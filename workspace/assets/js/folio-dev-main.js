(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*! Backbone.Mutators - v0.4.4
------------------------------
Build @ 2015-02-03
Documentation and Full License Available at:
http://asciidisco.github.com/Backbone.Mutators/index.html
git://github.com/asciidisco/Backbone.Mutators.git
Copyright (c) 2015 Sebastian Golasch <public@asciidisco.com>

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the

Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.*/
(function (root, factory, undef) {
    'use strict';

    if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory(require('underscore'), require('backbone'));
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['underscore', 'backbone'], function (_, Backbone) {
            // Check if we use the AMD branch of Back
            _ = _ === undef ? root._ : _;
            Backbone = Backbone === undef ? root.Backbone : Backbone;
            return (root.returnExportsGlobal = factory(_, Backbone, root));
        });
    } else {
        // Browser globals
        root.returnExportsGlobal = factory(root._, root.Backbone);
    }

// Usage:
//
// Note: This plugin is UMD compatible, you can use it in node, amd and vanilla js envs
//
// Vanilla JS:
// <script src="underscore.js"></script>
// <script src="backbone.js"></script>
// <script src="backbone.mutators.js"></script>
//
// Node:
// var _ = require('underscore');
// var Backbone = require('backbone');
// var Mutators = require('backbone.mutators');
//
//
// AMD:
// define(['underscore', 'backbone', 'backbone.mutators'], function (_, Backbone, Mutators) {
//    // insert sample from below
//    return User;
// });
//
// var User = Backbone.Model.extend({
//    mutators: {
//        fullname: function () {
//            return this.firstname + ' ' + this.lastname;
//        }
//    },
//
//    defaults: {
//        firstname: 'Sebastian',
//        lastname: 'Golasch'
//    }
// });
//
// var user = new User();
// user.get('fullname') // returns 'Sebastian Golasch'
// user.toJSON() // return '{firstname: 'Sebastian', lastname: 'Golasch', fullname: 'Sebastian Golasch'}'

}(this, function (_, Backbone, root, undef) {
    'use strict';

    // check if we use the amd branch of backbone and underscore
    Backbone = Backbone === undef ? root.Backbone : Backbone;
    _ = _ === undef ? root._ : _;

    // extend backbones model prototype with the mutator functionality
    var Mutator     = function () {},
        oldGet      = Backbone.Model.prototype.get,
        oldSet      = Backbone.Model.prototype.set,
        oldToJson   = Backbone.Model.prototype.toJSON;

    // This is necessary to ensure that Models declared without the mutators object do not throw and error
    Mutator.prototype.mutators = {};

    // override get functionality to fetch the mutator props
    Mutator.prototype.get = function (attr) {
        var isMutator = this.mutators !== undef;

        // check if we have a getter mutation
        if (isMutator === true && _.isFunction(this.mutators[attr]) === true) {
            return this.mutators[attr].call(this);
        }

        // check if we have a deeper nested getter mutation
        if (isMutator === true && _.isObject(this.mutators[attr]) === true && _.isFunction(this.mutators[attr].get) === true) {
            return this.mutators[attr].get.call(this);
        }

        return oldGet.call(this, attr);
    };

    // override set functionality to set the mutator props
    Mutator.prototype.set = function (key, value, options) {
        var isMutator = this.mutators !== undef,
            ret = null,
            attrs = null;

		ret = oldSet.call(this, key, value, options);

        // seamleassly stolen from backbone core
        // check if the setter action is triggered
        // using key <-> value or object
        if (_.isObject(key) || key === null) {
            attrs = key;
            options = value;
        } else {
            attrs = {};
            attrs[key] = value;
        }

        // check if we have a deeper nested setter mutation
        if (isMutator === true && _.isObject(this.mutators[key]) === true) {

            // check if we need to set a single value
            if (_.isFunction(this.mutators[key].set) === true) {
                ret = this.mutators[key].set.call(this, key, attrs[key], options, _.bind(oldSet, this));
            } else if(_.isFunction(this.mutators[key])){
                ret = this.mutators[key].call(this, key, attrs[key], options, _.bind(oldSet, this));
            }
        }

        if (isMutator === true && _.isObject(attrs)) {
            _.each(attrs, _.bind(function (attr, attrKey) {
                if (_.isObject(this.mutators[attrKey]) === true) {
                    // check if we need to set a single value

                    var meth = this.mutators[attrKey];
                    if(_.isFunction(meth.set)){
                        meth = meth.set;
                    }

                    if(_.isFunction(meth)){
                        if (options === undef || (_.isObject(options) === true && options.silent !== true && (options.mutators !== undef && options.mutators.silent !== true))) {
                            this.trigger('mutators:set:' + attrKey);
                        }
                        meth.call(this, attrKey, attr, options, _.bind(oldSet, this));
                    }

                }
            }, this));
        }

        return ret;
    };

    // override toJSON functionality to serialize mutator properties
    Mutator.prototype.toJSON = function (options) {
        // fetch ye olde values
        var attr = oldToJson.call(this),
            isSaving,
            isTransient;
        // iterate over all mutators (if there are some)
        _.each(this.mutators, _.bind(function (mutator, name) {
            // check if we have some getter mutations
            if (_.isObject(this.mutators[name]) === true && _.isFunction(this.mutators[name].get)) {
                isSaving = (this.isSaving) ? this.isSaving(options, mutator, name) : _.has(options || {}, 'emulateHTTP');
                isTransient = this.mutators[name].transient;
                if (!isSaving || !isTransient) {
                  attr[name] = _.bind(this.mutators[name].get, this)();
                }
            } else if (_.isFunction(this.mutators[name])) {
                attr[name] = _.bind(this.mutators[name], this)();
            }
        }, this));

        return attr;
    };

    // override get functionality to get HTML-escaped the mutator props
    Mutator.prototype.escape = function (attr){
        var val = this.get(attr);
        return _.escape(val == null ? '' : '' + val);
    };

    // extend the models prototype
    _.extend(Backbone.Model.prototype, Mutator.prototype);

    // make mutators globally available under the Backbone namespace
    Backbone.Mutators = Mutator;
    return Mutator;
}));

},{"backbone":5,"underscore":2}],2:[function(require,module,exports){
//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],3:[function(require,module,exports){
// Backbone.BabySitter
// -------------------
// v0.1.11
//
// Copyright (c)2016 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.babysitter

(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore'], function(Backbone, _) {
      return factory(Backbone, _);
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = require('backbone');
    var _ = require('underscore');
    module.exports = factory(Backbone, _);
  } else {
    factory(root.Backbone, root._);
  }

}(this, function(Backbone, _) {
  'use strict';

  var previousChildViewContainer = Backbone.ChildViewContainer;

  // BabySitter.ChildViewContainer
  // -----------------------------
  //
  // Provide a container to store, retrieve and
  // shut down child views.
  
  Backbone.ChildViewContainer = (function (Backbone, _) {
  
    // Container Constructor
    // ---------------------
  
    var Container = function(views){
      this._views = {};
      this._indexByModel = {};
      this._indexByCustom = {};
      this._updateLength();
  
      _.each(views, this.add, this);
    };
  
    // Container Methods
    // -----------------
  
    _.extend(Container.prototype, {
  
      // Add a view to this container. Stores the view
      // by `cid` and makes it searchable by the model
      // cid (and model itself). Optionally specify
      // a custom key to store an retrieve the view.
      add: function(view, customIndex){
        var viewCid = view.cid;
  
        // store the view
        this._views[viewCid] = view;
  
        // index it by model
        if (view.model){
          this._indexByModel[view.model.cid] = viewCid;
        }
  
        // index by custom
        if (customIndex){
          this._indexByCustom[customIndex] = viewCid;
        }
  
        this._updateLength();
        return this;
      },
  
      // Find a view by the model that was attached to
      // it. Uses the model's `cid` to find it.
      findByModel: function(model){
        return this.findByModelCid(model.cid);
      },
  
      // Find a view by the `cid` of the model that was attached to
      // it. Uses the model's `cid` to find the view `cid` and
      // retrieve the view using it.
      findByModelCid: function(modelCid){
        var viewCid = this._indexByModel[modelCid];
        return this.findByCid(viewCid);
      },
  
      // Find a view by a custom indexer.
      findByCustom: function(index){
        var viewCid = this._indexByCustom[index];
        return this.findByCid(viewCid);
      },
  
      // Find by index. This is not guaranteed to be a
      // stable index.
      findByIndex: function(index){
        return _.values(this._views)[index];
      },
  
      // retrieve a view by its `cid` directly
      findByCid: function(cid){
        return this._views[cid];
      },
  
      // Remove a view
      remove: function(view){
        var viewCid = view.cid;
  
        // delete model index
        if (view.model){
          delete this._indexByModel[view.model.cid];
        }
  
        // delete custom index
        _.any(this._indexByCustom, function(cid, key) {
          if (cid === viewCid) {
            delete this._indexByCustom[key];
            return true;
          }
        }, this);
  
        // remove the view from the container
        delete this._views[viewCid];
  
        // update the length
        this._updateLength();
        return this;
      },
  
      // Call a method on every view in the container,
      // passing parameters to the call method one at a
      // time, like `function.call`.
      call: function(method){
        this.apply(method, _.tail(arguments));
      },
  
      // Apply a method on every view in the container,
      // passing parameters to the call method one at a
      // time, like `function.apply`.
      apply: function(method, args){
        _.each(this._views, function(view){
          if (_.isFunction(view[method])){
            view[method].apply(view, args || []);
          }
        });
      },
  
      // Update the `.length` attribute on this container
      _updateLength: function(){
        this.length = _.size(this._views);
      }
    });
  
    // Borrowing this code from Backbone.Collection:
    // http://backbonejs.org/docs/backbone.html#section-106
    //
    // Mix in methods from Underscore, for iteration, and other
    // collection related features.
    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
      'last', 'without', 'isEmpty', 'pluck', 'reduce'];
  
    _.each(methods, function(method) {
      Container.prototype[method] = function() {
        var views = _.values(this._views);
        var args = [views].concat(_.toArray(arguments));
        return _[method].apply(_, args);
      };
    });
  
    // return the public API
    return Container;
  })(Backbone, _);
  

  Backbone.ChildViewContainer.VERSION = '0.1.11';

  Backbone.ChildViewContainer.noConflict = function () {
    Backbone.ChildViewContainer = previousChildViewContainer;
    return this;
  };

  return Backbone.ChildViewContainer;

}));

},{"backbone":5,"underscore":51}],4:[function(require,module,exports){
/**
 * Backbone.Native
 *
 * For all details and documentation:
 * http://github.com/inkling/backbone.native
 *
 * Copyright 2013 Inkling Systems, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The purpose of this library is to allow Backbone to work without needing to load jQuery or Zepto.
 * This file provides a basic jQuery-like implementation for Backbone, implementing the
 * minimum functionality for Backbone to function. We assume that Backbone applications using
 * this will not expect the standard jQuery API to work, and will instead use native JS functions.
 *
 * Keep in mind that due to the APIs in this, it will likely only work on recent browsers.
 *
 * Note:
 *  - Core Backbone only needs collections with single members, so that is all that has been
 *      supported in this library. It is expected that you will just use querySelectorAll instead.
 *      This will be most obvious if you make heavy use of 'view.$'.
 *  - Events delegated with selectors starting with '>' are not supported.
 *  - Due to 'currentTarget' being read-only on standard DOM events, we cannot make standard
 *      events behave identically to jQuery's events when delegation is used. The element matching
 *      the delegate selector is instead passed as the second argument to event handlers.
 *  - The '$.ajax' implementation is very simple and likely needs to be expanded to better support
 *      standard use-cases.
 *
 * Tested with Backbone v0.9.2 and 1.0.0.
 */
(function(){
    "use strict";

    // Regular expression to match an event name and/or a namespace.
    var namespaceRE = /^([^.]+)?(?:\.([^.]+))?$/;

    var matchesSelector = Element.prototype.matchesSelector || null;
    if (!matchesSelector){
        ['webkit', 'moz', 'o', 'ms'].forEach(function(prefix){
            var func = Element.prototype[prefix + 'MatchesSelector'];
            if (func) matchesSelector = func;
        });
    }

    // The element property to save the cache key on.
    var cacheKeyProp = 'backboneNativeKey' + Math.random();
    var id = 1;
    var handlers = {};
    var unusedKeys = [];

    /**
     * Get the event handlers for a given element, creating an empty set if one doesn't exist.
     *
     * To avoid constantly filling the handlers object with null values, we reuse old IDs that
     * have been created and then cleared.
     *
     * @param {Element} el The element to get handlers for.
     *
     * @return {Array} An array of handlers.
     */
    function handlersFor(el){
        if (!el[cacheKeyProp]){
            // Pick a new key, from the unused pool, or make a new one.
            el[cacheKeyProp] = unusedKeys.length === 0 ? ++id : unusedKeys.pop();
        }

        var cacheKey = el[cacheKeyProp];
        return handlers[cacheKey] || (handlers[cacheKey] = []);
    }

    /**
     * Clear the event handlers for a given element.
     *
     * @param {Element} el The element to clear.
     */
    function clearHandlers(el){
        var cacheKey = el[cacheKeyProp];
        if (handlers[cacheKey]){
            handlers[cacheKey] = null;
            el[cacheKeyProp] = null;
            unusedKeys.push(cacheKey);
        }
    }

    /**
     * Add event handlers to an element.
     *
     * @param {Element} parentElement The element to bind event handlers to.
     * @param {string} eventName The event to bind, e.g. 'click'.
     * @param {string} selector (Optional) The selector to match when an event propagates up.
     * @param {function(Event, Element)} callback The function to call when the event is fired.
     */
    function on(parentElement, eventName, selector, callback){
        // Adjust arguments if selector was not provided.
        if (typeof selector === 'function'){
            callback = selector;
            selector = null;
        }

        var parts = namespaceRE.exec(eventName);
        eventName = parts[1] || null;
        var namespace = parts[2] || null;

        if (!eventName) return;

        var handler = callback;
        var originalCallback = callback;
        if (selector){
            // Event delegation handler to match a selector for child element events.
            handler = function(event){
                for (var el = event.target; el && el !== parentElement; el = el.parentElement){
                    if (matchesSelector.call(el, selector)){
                        // jQuery does not include the second argument, but we have included it
                        // for simplicity because 'this' will likely be bound to the view inside
                        // the callback, and as noted above, we cannot override 'currentTarget'.
                        var result = originalCallback.call(el, event, el);
                        if (result === false){
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        return result;
                    }
                }
            };
        } else {
            // Standard event handler bound directly to the element.
            handler = function(event){
                var result = originalCallback.call(parentElement, event, parentElement);
                if (result === false){
                    event.stopPropagation();
                    event.preventDefault();
                }
                return result;
            };
        }

        parentElement.addEventListener(eventName, handler, false);

        // Save event handler metadata so that the handler can be unbound later.
        handlersFor(parentElement).push({
            eventName: eventName,
            callback: callback,
            handler: handler,
            namespace: namespace,
            selector: selector
        });
    }

    /**
     * Remove an event handler from an element.
     *
     * @param {Element} parentElement The element to unbind event handlers from.
     * @param {string} eventName (Optional) The event to unbind, e.g. 'click'.
     * @param {string} selector (Optional) The selector to unbind.
     * @param {function(Event, Element)} callback (Optional) The function to unbind.
     */
    function off(parentElement, eventName, selector, callback){
        if (typeof selector === 'function'){
            callback = selector;
            selector = null;
        }

        var parts = namespaceRE.exec(eventName || '');
        eventName = parts[1];
        var namespace = parts[2];
        var handlers = handlersFor(parentElement) || [];

        if (!eventName && !namespace && !selector && !callback){
            // Fastpath to remove all handlers.
            handlers.forEach(function(item){
                parentElement.removeEventListener(item.eventName, item.handler, false);
            });
            clearHandlers(parentElement);
        } else {
            var matchedHandlers = handlers.filter(function(item){
                return ((!namespace || item.namespace === namespace) &&
                    (!eventName || item.eventName === eventName) &&
                    (!callback || item.callback === callback) &&
                    (!selector || item.selector === selector));
            });

            matchedHandlers.forEach(function(item){
                parentElement.removeEventListener(item.eventName, item.handler, false);

                handlers.splice(handlers.indexOf(item), 1);
            });

            if (handlers.length === 0) clearHandlers(parentElement);
        }
    }

    /**
     * Construct a new jQuery-style element representation.
     *
     * @param {string|Element|Window} element There are several different possible values for this
     *      argument:
     *      - {string} A snippet of HTML, if it starts with a '<', or a selector to find.
     *      - {Element} An existing element to wrap.
     *      - {Window} The window object to wrap.
     * @param {Element} context The context to search within, if a selector was given.
     *      Defaults to document.
     */
    function $(element, context){
        context = context || document;

        // Call as a constructor if it was used as a function.
        if (!(this instanceof $)) return new $(element, context);

        if (!element){
            this.length = 0;
        } else if (typeof element === 'string'){
            if (/^\s*</.test(element)){
                // Parse arbitrary HTML into an element.
                var div = document.createElement('div');
                div.innerHTML = element;
                this[0] = div.firstChild;
                div.removeChild(div.firstChild);
                this.length = 1;
            } else {
                this[0] = context.querySelector(element);
                this.length = 1;
            }
        } else {
            // This handles both the 'Element' and 'Window' case, as both support
            // event binding via 'addEventListener'.
            this[0] = element;
            this.length = 1;
        }
    }

    $.prototype = {
        /**
         * The following methods are used by Backbone, but only in code-paths for IE 6/7 support.
         * Since none of this will work for old IE anyway, they are not implemented, and
         * instead left for documentation purposes.
         *
         * Used in Backbone.History.prototype.start.
         */
        hide: null,
        appendTo: null,

        /**
         * Find is not supported to encourage the use of querySelector(All) as an alternative.
         *
         * e.g.
         * Instead of 'this.$(sel)', use 'this.el.querySelectorAll(sel)'.
         *
         * Used in Backbone.View.prototype.$, but not actually called internally.
         */
        find: null,

        /**
         * Add attributes to the element.
         *
         * Used in Backbone.View.prototype.make.
         *
         * @param {Object} attributes A set of attributes to apply to the element.
         *
         * @return {$} This instance.
         */
        attr: function(attrs){
            Object.keys(attrs).forEach(function(attr){
                switch (attr){
                    case 'html':
                        this[0].innerHTML = attrs[attr];
                        break;
                    case 'text':
                        this[0].textContent = attrs[attr];
                        break;
                    case 'class':
                        this[0].className = attrs[attr];
                        break;
                    default:
                        this[0].setAttribute(attr, attrs[attr]);
                        break;
                }
            }, this);
            return this;
        },

        /**
         * Set the HTML content of the element. Backbone does not use the no-argument version
         * to read innerHTML, so that has not been implemented.
         *
         * Used in Backbone.View.prototype.make.
         *
         * @param {string} html The HTML to set as the element content.
         *
         * @return {$} This instance.
         */
        html: function(html){
            this[0].innerHTML = html;
            return this;
        },

        /**
         * Remove an element from the DOM and remove all event handlers bound to it and
         * its child elements.
         *
         * Used in Backbone.View.prototype.remove.
         *
         * @return {$} This instance.
         */
        remove: function(){
            var el = this[0];
            if (el.parentElement) el.parentElement.removeChild(el);

            // Unbind all event handlers on the element and children.
            (function removeChildEvents(element){
                off(element);

                for (var i = 0, len = element.childNodes.length; i < len; i++){
                    if (element.childNodes[i].nodeType !== Node.TEXT_NODE){
                        removeChildEvents(element.childNodes[i]);
                    }
                }
            })(el);

            return this;
        },

        /**
         * Bind an event handler to this element.
         *
         * @param {string} eventName The event to bind, e.g. 'click'.
         * @param {string} selector (Optional) The selector to match when an event propagates up.
         * @param {function(Event, Element)} callback The function to call when the event is fired.
         */
        on: function(eventName, selector, callback){
            on(this[0], eventName, selector, callback);
            return this;
        },

        /**
         * Unbind an event handler to this element.
         *
         * @param {string} eventName (Optional) The event to unbind, e.g. 'click'.
         * @param {string} selector (Optional) The selector to unbind.
         * @param {function(Event, Element)} callback (Optional) The function to unbind.
         */
        off: function(eventName, selector, callback){
            off(this[0], eventName, selector, callback);
            return this;
        },

        // Backbone v0.9.2 support.
        bind: function(eventName, callback){
            return this.on(eventName, callback);
        },
        unbind: function(eventName, callback){
            return this.off(eventName, callback);
        },
        delegate: function(selector, eventName, callback){
            return this.on(eventName, selector, callback);
        },
        undelegate: function(selector, eventName, callback){
            return this.off(eventName, selector, callback);
        }
    };

    /**
     * Send an AJAX request.
     *
     * @param {Object} options The options to use for the connection:
     *      - {string} url The URL to connect to.
     *      - {string} type The type of request, e.g. 'GET', or 'POST'.
     *      - {string} dataType The type of data expected, 'json'.
     *      - {string} contentType The content-type of the data.
     *      - {string|object} data The content to send.
     *      - {function(XMLHttpRequest)} beforeSend A callback to call before sending.
     *      - {boolean} processData True if 'data' should be converted
     *          to a query string from an object.
     *      - {function({string|object}, {string}, {XMLHttpRequest})} success The success callback.
     *      - {function({XMLHttpRequest})} error The error callback.
     */
    $.ajax = function(options){
        options = options || {};
        var type = options.type || 'GET';
        var url = options.url;
        var processData = options.processData === undefined ? true : !!options.processData;

        // Process the data for sending.
        var data = options.data;
        if (processData && typeof data === 'object'){
            var params = Object.keys(data).map(function(prop){
                return encodeURIComponent(prop) + '=' + encodeURIComponent(data[prop]);
            });
            data = params.join('&');
        }

        // Data for GET and HEAD goes in the URL.
        if (data && (type === 'GET' || type === 'HEAD')){
            url += (url.indexOf('?') === -1 ? '?' : '&') + data;
            data = undefined;
        }

        var xhr = new XMLHttpRequest();
        xhr.open(type, url, true);

        if (options.contentType) xhr.setRequestHeader('Content-Type', options.contentType);
        if (options.beforeSend) options.beforeSend(xhr);

        xhr.onload = function(){
            var error = false;
            var content = xhr.responseText;

            // Parse the JSON before calling success.
            if (options.dataType === 'json'){
                try {
                    content = JSON.parse(content);
                } catch (e){
                    error = true
                }
            }

            if (!error && (xhr.status >= 200 && xhr.status < 300)){
                // The last two arguments only apply to v0.9.2.
                if (options.success) options.success(content, xhr.statusText, xhr);
            } else {
                // This signature is inconsistent with v0.9.2, but is correct for 1.0.0.
                if (options.error) options.error(xhr);
            }
        }.bind(this);

        xhr.onerror = xhr.onabort = function(){
            if (options.error) options.error(xhr);
        };

        xhr.send(data);

        return xhr;
    };

    // Expose on/off for external use with having to instantiate a wrapper.
    $.on = on;
    $.off = off;

    if(typeof exports !== 'undefined') {
      return module.exports = $;
    }

    var root = this;
    var originalBackboneNative = root.Backbone ? root.Backbone.Native : null;
    var original$ = root.$;
    if (root.Backbone) root.Backbone.Native = $;
    root.$ = $;

    $.noConflict = function(deep){
        root.$ = original$;
        if (deep) root.Backbone.Native = originalBackboneNative;
        return $;
    };

    if (root.Backbone){
        if (root.Backbone.setDomLibrary){ // v0.9.2
            root.Backbone.setDomLibrary($);
        } else { // v1.0.0
            root.Backbone.$ = $;
        }
    }
}).call(this);

},{}],5:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

},{"underscore":51}],6:[function(require,module,exports){
/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20170427
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in window.self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_")) 
	|| document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = view.Element[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.setAttribute("class", this.toString());
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
		, index
	;
	do {
		token = tokens[i] + "";
		index = checkTokenAndGetIndex(this, token);
		while (index !== -1) {
			this.splice(index, 1);
			updated = true;
			index = checkTokenAndGetIndex(this, token);
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, force) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			force !== true && "remove"
		:
			force !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	if (force === true || force === false) {
		return force;
	} else {
		return !result;
	}
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		// adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
		// modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
		if (ex.number === undefined || ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(window.self));

}

// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
	"use strict";

	var testElement = document.createElement("_");

	testElement.classList.add("c1", "c2");

	// Polyfill for IE 10/11 and Firefox <26, where classList.add and
	// classList.remove exist but support only one argument at a time.
	if (!testElement.classList.contains("c2")) {
		var createMethod = function(method) {
			var original = DOMTokenList.prototype[method];

			DOMTokenList.prototype[method] = function(token) {
				var i, len = arguments.length;

				for (i = 0; i < len; i++) {
					token = arguments[i];
					original.call(this, token);
				}
			};
		};
		createMethod('add');
		createMethod('remove');
	}

	testElement.classList.toggle("c3", false);

	// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	// support the second argument.
	if (testElement.classList.contains("c3")) {
		var _toggle = DOMTokenList.prototype.toggle;

		DOMTokenList.prototype.toggle = function(token, force) {
			if (1 in arguments && !this.contains(token) === !force) {
				return force;
			} else {
				return _toggle.call(this, token);
			}
		};

	}

	testElement = null;
}());

}

},{}],7:[function(require,module,exports){
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":10}],8:[function(require,module,exports){
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":7,"./route":9}],9:[function(require,module,exports){
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":7}],10:[function(require,module,exports){
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],11:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":10,"simple-swizzle":39}],12:[function(require,module,exports){
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (!obj) {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-convert":8,"color-string":11}],13:[function(require,module,exports){
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":14}],14:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":37}],15:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":17,"./handlebars/exception":20,"./handlebars/no-conflict":30,"./handlebars/runtime":31,"./handlebars/safe-string":32,"./handlebars/utils":33}],17:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.12';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":18,"./exception":20,"./helpers":21,"./logger":29,"./utils":33}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":19}],19:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":33}],20:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],21:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":22,"./helpers/each":23,"./helpers/helper-missing":24,"./helpers/if":25,"./helpers/log":26,"./helpers/lookup":27,"./helpers/with":28}],22:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":33}],23:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":20,"../utils":33}],24:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":20}],25:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":33}],26:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],27:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],28:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":33}],29:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":33}],30:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":17,"./exception":20,"./utils":33}],32:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],33:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],34:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":16}],35:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":34}],36:[function(require,module,exports){
var MutationObserver = window.MutationObserver
  || window.WebKitMutationObserver
  || window.MozMutationObserver;

/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is goverened by a BSD-style
 * license that can be found in the LICENSE file.
 */

var WeakMap = window.WeakMap;

if (typeof WeakMap === 'undefined') {
  var defineProperty = Object.defineProperty;
  var counter = Date.now() % 1e9;

  WeakMap = function() {
    this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
  };

  WeakMap.prototype = {
    set: function(key, value) {
      var entry = key[this.name];
      if (entry && entry[0] === key)
        entry[1] = value;
      else
        defineProperty(key, this.name, {value: [key, value], writable: true});
      return this;
    },
    get: function(key) {
      var entry;
      return (entry = key[this.name]) && entry[0] === key ?
          entry[1] : undefined;
    },
    'delete': function(key) {
      var entry = key[this.name];
      if (!entry) return false;
      var hasValue = entry[0] === key;
      entry[0] = entry[1] = undefined;
      return hasValue;
    },
    has: function(key) {
      var entry = key[this.name];
      if (!entry) return false;
      return entry[0] === key;
    }
  };
}

var registrationsTable = new WeakMap();

// We use setImmediate or postMessage for our future callback.
var setImmediate = window.msSetImmediate;

// Use post message to emulate setImmediate.
if (!setImmediate) {
  var setImmediateQueue = [];
  var sentinel = String(Math.random());
  window.addEventListener('message', function(e) {
    if (e.data === sentinel) {
      var queue = setImmediateQueue;
      setImmediateQueue = [];
      queue.forEach(function(func) {
        func();
      });
    }
  });
  setImmediate = function(func) {
    setImmediateQueue.push(func);
    window.postMessage(sentinel, '*');
  };
}

// This is used to ensure that we never schedule 2 callas to setImmediate
var isScheduled = false;

// Keep track of observers that needs to be notified next time.
var scheduledObservers = [];

/**
 * Schedules |dispatchCallback| to be called in the future.
 * @param {MutationObserver} observer
 */
function scheduleCallback(observer) {
  scheduledObservers.push(observer);
  if (!isScheduled) {
    isScheduled = true;
    setImmediate(dispatchCallbacks);
  }
}

function wrapIfNeeded(node) {
  return window.ShadowDOMPolyfill &&
      window.ShadowDOMPolyfill.wrapIfNeeded(node) ||
      node;
}

function dispatchCallbacks() {
  // http://dom.spec.whatwg.org/#mutation-observers

  isScheduled = false; // Used to allow a new setImmediate call above.

  var observers = scheduledObservers;
  scheduledObservers = [];
  // Sort observers based on their creation UID (incremental).
  observers.sort(function(o1, o2) {
    return o1.uid_ - o2.uid_;
  });

  var anyNonEmpty = false;
  observers.forEach(function(observer) {

    // 2.1, 2.2
    var queue = observer.takeRecords();
    // 2.3. Remove all transient registered observers whose observer is mo.
    removeTransientObserversFor(observer);

    // 2.4
    if (queue.length) {
      observer.callback_(queue, observer);
      anyNonEmpty = true;
    }
  });

  // 3.
  if (anyNonEmpty)
    dispatchCallbacks();
}

function removeTransientObserversFor(observer) {
  observer.nodes_.forEach(function(node) {
    var registrations = registrationsTable.get(node);
    if (!registrations)
      return;
    registrations.forEach(function(registration) {
      if (registration.observer === observer)
        registration.removeTransientObservers();
    });
  });
}

/**
 * This function is used for the "For each registered observer observer (with
 * observer's options as options) in target's list of registered observers,
 * run these substeps:" and the "For each ancestor ancestor of target, and for
 * each registered observer observer (with options options) in ancestor's list
 * of registered observers, run these substeps:" part of the algorithms. The
 * |options.subtree| is checked to ensure that the callback is called
 * correctly.
 *
 * @param {Node} target
 * @param {function(MutationObserverInit):MutationRecord} callback
 */
function forEachAncestorAndObserverEnqueueRecord(target, callback) {
  for (var node = target; node; node = node.parentNode) {
    var registrations = registrationsTable.get(node);

    if (registrations) {
      for (var j = 0; j < registrations.length; j++) {
        var registration = registrations[j];
        var options = registration.options;

        // Only target ignores subtree.
        if (node !== target && !options.subtree)
          continue;

        var record = callback(options);
        if (record)
          registration.enqueue(record);
      }
    }
  }
}

var uidCounter = 0;

/**
 * The class that maps to the DOM MutationObserver interface.
 * @param {Function} callback.
 * @constructor
 */
function JsMutationObserver(callback) {
  this.callback_ = callback;
  this.nodes_ = [];
  this.records_ = [];
  this.uid_ = ++uidCounter;
}

JsMutationObserver.prototype = {
  observe: function(target, options) {
    target = wrapIfNeeded(target);

    // 1.1
    if (!options.childList && !options.attributes && !options.characterData ||

        // 1.2
        options.attributeOldValue && !options.attributes ||

        // 1.3
        options.attributeFilter && options.attributeFilter.length &&
            !options.attributes ||

        // 1.4
        options.characterDataOldValue && !options.characterData) {

      throw new SyntaxError();
    }

    var registrations = registrationsTable.get(target);
    if (!registrations)
      registrationsTable.set(target, registrations = []);

    // 2
    // If target's list of registered observers already includes a registered
    // observer associated with the context object, replace that registered
    // observer's options with options.
    var registration;
    for (var i = 0; i < registrations.length; i++) {
      if (registrations[i].observer === this) {
        registration = registrations[i];
        registration.removeListeners();
        registration.options = options;
        break;
      }
    }

    // 3.
    // Otherwise, add a new registered observer to target's list of registered
    // observers with the context object as the observer and options as the
    // options, and add target to context object's list of nodes on which it
    // is registered.
    if (!registration) {
      registration = new Registration(this, target, options);
      registrations.push(registration);
      this.nodes_.push(target);
    }

    registration.addListeners();
  },

  disconnect: function() {
    this.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      for (var i = 0; i < registrations.length; i++) {
        var registration = registrations[i];
        if (registration.observer === this) {
          registration.removeListeners();
          registrations.splice(i, 1);
          // Each node can only have one registered observer associated with
          // this observer.
          break;
        }
      }
    }, this);
    this.records_ = [];
  },

  takeRecords: function() {
    var copyOfRecords = this.records_;
    this.records_ = [];
    return copyOfRecords;
  }
};

/**
 * @param {string} type
 * @param {Node} target
 * @constructor
 */
function MutationRecord(type, target) {
  this.type = type;
  this.target = target;
  this.addedNodes = [];
  this.removedNodes = [];
  this.previousSibling = null;
  this.nextSibling = null;
  this.attributeName = null;
  this.attributeNamespace = null;
  this.oldValue = null;
}

function copyMutationRecord(original) {
  var record = new MutationRecord(original.type, original.target);
  record.addedNodes = original.addedNodes.slice();
  record.removedNodes = original.removedNodes.slice();
  record.previousSibling = original.previousSibling;
  record.nextSibling = original.nextSibling;
  record.attributeName = original.attributeName;
  record.attributeNamespace = original.attributeNamespace;
  record.oldValue = original.oldValue;
  return record;
};

// We keep track of the two (possibly one) records used in a single mutation.
var currentRecord, recordWithOldValue;

/**
 * Creates a record without |oldValue| and caches it as |currentRecord| for
 * later use.
 * @param {string} oldValue
 * @return {MutationRecord}
 */
function getRecord(type, target) {
  return currentRecord = new MutationRecord(type, target);
}

/**
 * Gets or creates a record with |oldValue| based in the |currentRecord|
 * @param {string} oldValue
 * @return {MutationRecord}
 */
function getRecordWithOldValue(oldValue) {
  if (recordWithOldValue)
    return recordWithOldValue;
  recordWithOldValue = copyMutationRecord(currentRecord);
  recordWithOldValue.oldValue = oldValue;
  return recordWithOldValue;
}

function clearRecords() {
  currentRecord = recordWithOldValue = undefined;
}

/**
 * @param {MutationRecord} record
 * @return {boolean} Whether the record represents a record from the current
 * mutation event.
 */
function recordRepresentsCurrentMutation(record) {
  return record === recordWithOldValue || record === currentRecord;
}

/**
 * Selects which record, if any, to replace the last record in the queue.
 * This returns |null| if no record should be replaced.
 *
 * @param {MutationRecord} lastRecord
 * @param {MutationRecord} newRecord
 * @param {MutationRecord}
 */
function selectRecord(lastRecord, newRecord) {
  if (lastRecord === newRecord)
    return lastRecord;

  // Check if the the record we are adding represents the same record. If
  // so, we keep the one with the oldValue in it.
  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
    return recordWithOldValue;

  return null;
}

/**
 * Class used to represent a registered observer.
 * @param {MutationObserver} observer
 * @param {Node} target
 * @param {MutationObserverInit} options
 * @constructor
 */
function Registration(observer, target, options) {
  this.observer = observer;
  this.target = target;
  this.options = options;
  this.transientObservedNodes = [];
}

Registration.prototype = {
  enqueue: function(record) {
    var records = this.observer.records_;
    var length = records.length;

    // There are cases where we replace the last record with the new record.
    // For example if the record represents the same mutation we need to use
    // the one with the oldValue. If we get same record (this can happen as we
    // walk up the tree) we ignore the new record.
    if (records.length > 0) {
      var lastRecord = records[length - 1];
      var recordToReplaceLast = selectRecord(lastRecord, record);
      if (recordToReplaceLast) {
        records[length - 1] = recordToReplaceLast;
        return;
      }
    } else {
      scheduleCallback(this.observer);
    }

    records[length] = record;
  },

  addListeners: function() {
    this.addListeners_(this.target);
  },

  addListeners_: function(node) {
    var options = this.options;
    if (options.attributes)
      node.addEventListener('DOMAttrModified', this, true);

    if (options.characterData)
      node.addEventListener('DOMCharacterDataModified', this, true);

    if (options.childList)
      node.addEventListener('DOMNodeInserted', this, true);

    if (options.childList || options.subtree)
      node.addEventListener('DOMNodeRemoved', this, true);
  },

  removeListeners: function() {
    this.removeListeners_(this.target);
  },

  removeListeners_: function(node) {
    var options = this.options;
    if (options.attributes)
      node.removeEventListener('DOMAttrModified', this, true);

    if (options.characterData)
      node.removeEventListener('DOMCharacterDataModified', this, true);

    if (options.childList)
      node.removeEventListener('DOMNodeInserted', this, true);

    if (options.childList || options.subtree)
      node.removeEventListener('DOMNodeRemoved', this, true);
  },

  /**
   * Adds a transient observer on node. The transient observer gets removed
   * next time we deliver the change records.
   * @param {Node} node
   */
  addTransientObserver: function(node) {
    // Don't add transient observers on the target itself. We already have all
    // the required listeners set up on the target.
    if (node === this.target)
      return;

    this.addListeners_(node);
    this.transientObservedNodes.push(node);
    var registrations = registrationsTable.get(node);
    if (!registrations)
      registrationsTable.set(node, registrations = []);

    // We know that registrations does not contain this because we already
    // checked if node === this.target.
    registrations.push(this);
  },

  removeTransientObservers: function() {
    var transientObservedNodes = this.transientObservedNodes;
    this.transientObservedNodes = [];

    transientObservedNodes.forEach(function(node) {
      // Transient observers are never added to the target.
      this.removeListeners_(node);

      var registrations = registrationsTable.get(node);
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i] === this) {
          registrations.splice(i, 1);
          // Each node can only have one registered observer associated with
          // this observer.
          break;
        }
      }
    }, this);
  },

  handleEvent: function(e) {
    // Stop propagation since we are managing the propagation manually.
    // This means that other mutation events on the page will not work
    // correctly but that is by design.
    e.stopImmediatePropagation();

    switch (e.type) {
      case 'DOMAttrModified':
        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes

        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;

        // 1.
        var record = new getRecord('attributes', target);
        record.attributeName = name;
        record.attributeNamespace = namespace;

        // 2.
        var oldValue = null;
        if (!(typeof MutationEvent !== 'undefined' && e.attrChange === MutationEvent.ADDITION))
          oldValue = e.prevValue;

        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          // 3.1, 4.2
          if (!options.attributes)
            return;

          // 3.2, 4.3
          if (options.attributeFilter && options.attributeFilter.length &&
              options.attributeFilter.indexOf(name) === -1 &&
              options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          // 3.3, 4.4
          if (options.attributeOldValue)
            return getRecordWithOldValue(oldValue);

          // 3.4, 4.5
          return record;
        });

        break;

      case 'DOMCharacterDataModified':
        // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata
        var target = e.target;

        // 1.
        var record = getRecord('characterData', target);

        // 2.
        var oldValue = e.prevValue;


        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          // 3.1, 4.2
          if (!options.characterData)
            return;

          // 3.2, 4.3
          if (options.characterDataOldValue)
            return getRecordWithOldValue(oldValue);

          // 3.3, 4.4
          return record;
        });

        break;

      case 'DOMNodeRemoved':
        this.addTransientObserver(e.target);
        // Fall through.
      case 'DOMNodeInserted':
        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist
        var target = e.relatedNode;
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === 'DOMNodeInserted') {
          addedNodes = [changedNode];
          removedNodes = [];
        } else {

          addedNodes = [];
          removedNodes = [changedNode];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;

        // 1.
        var record = getRecord('childList', target);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;

        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          // 2.1, 3.2
          if (!options.childList)
            return;

          // 2.2, 3.3
          return record;
        });

    }

    clearRecords();
  }
};

if (!MutationObserver) {
  MutationObserver = JsMutationObserver;
}

module.exports = MutationObserver;

},{}],37:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],38:[function(require,module,exports){
(function (process,global){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":37}],39:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":40}],40:[function(require,module,exports){
module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],41:[function(require,module,exports){
var makeString = require('./helper/makeString');

module.exports = function capitalize(str, lowercaseRest) {
  str = makeString(str);
  var remainingChars = !lowercaseRest ? str.slice(1) : str.slice(1).toLowerCase();

  return str.charAt(0).toUpperCase() + remainingChars;
};

},{"./helper/makeString":45}],42:[function(require,module,exports){
var trim = require('./trim');

module.exports = function dasherize(str) {
  return trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
};

},{"./trim":50}],43:[function(require,module,exports){
var escapeRegExp = require('./escapeRegExp');

module.exports = function defaultToWhiteSpace(characters) {
  if (characters == null)
    return '\\s';
  else if (characters.source)
    return characters.source;
  else
    return '[' + escapeRegExp(characters) + ']';
};

},{"./escapeRegExp":44}],44:[function(require,module,exports){
var makeString = require('./makeString');

module.exports = function escapeRegExp(str) {
  return makeString(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
};

},{"./makeString":45}],45:[function(require,module,exports){
/**
 * Ensure some object is a coerced to a string
 **/
module.exports = function makeString(object) {
  if (object == null) return '';
  return '' + object;
};

},{}],46:[function(require,module,exports){
module.exports = function strRepeat(str, qty){
  if (qty < 1) return '';
  var result = '';
  while (qty > 0) {
    if (qty & 1) result += str;
    qty >>= 1, str += str;
  }
  return result;
};

},{}],47:[function(require,module,exports){
var pad = require('./pad');

module.exports = function lpad(str, length, padStr) {
  return pad(str, length, padStr);
};

},{"./pad":48}],48:[function(require,module,exports){
var makeString = require('./helper/makeString');
var strRepeat = require('./helper/strRepeat');

module.exports = function pad(str, length, padStr, type) {
  str = makeString(str);
  length = ~~length;

  var padlen = 0;

  if (!padStr)
    padStr = ' ';
  else if (padStr.length > 1)
    padStr = padStr.charAt(0);

  switch (type) {
  case 'right':
    padlen = length - str.length;
    return str + strRepeat(padStr, padlen);
  case 'both':
    padlen = length - str.length;
    return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
  default: // 'left'
    padlen = length - str.length;
    return strRepeat(padStr, padlen) + str;
  }
};

},{"./helper/makeString":45,"./helper/strRepeat":46}],49:[function(require,module,exports){
var pad = require('./pad');

module.exports = function rpad(str, length, padStr) {
  return pad(str, length, padStr, 'right');
};

},{"./pad":48}],50:[function(require,module,exports){
var makeString = require('./helper/makeString');
var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
var nativeTrim = String.prototype.trim;

module.exports = function trim(str, characters) {
  str = makeString(str);
  if (!characters && nativeTrim) return nativeTrim.call(str);
  characters = defaultToWhiteSpace(characters);
  return str.replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
};

},{"./helper/defaultToWhiteSpace":43,"./helper/makeString":45}],51:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],52:[function(require,module,exports){
/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=
O(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};
function la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};
function qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}
ra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+
d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}
var za={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},
Ca=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());

},{}],53:[function(require,module,exports){
(function (GIT_REV,DEBUG,_){
"use strict";
/**
 * @module app/App
 */

"use strict";

console.info("Portfolio App started ".concat(GIT_REV)); // if (!DEBUG) {
// 	window.addEventListener("error", function(ev) {
// 		console.error("Uncaught Error", ev);
// 	});
// }

if (DEBUG) {
  require("Modernizr");
}

require("setimmediate");

require("es6-promise/auto");

require("classlist-polyfill");

require("raf-polyfill");

require("matches-polyfill");

require("fullscreen-polyfill");

require("math-sign-polyfill"); // require("path2d-polyfill");


require("mutation-observer");

require("backbone").$ = require("backbone.native");

require("backbone.babysitter");

require("Backbone.Mutators");

require("hammerjs"); // document.addEventListener('DOMContentLoaded', function(ev) {
// 	console.log("%s:[event %s]", ev.target, ev.type);
// });


window.addEventListener("load", function (ev) {
  console.log("%s:[event %s]", ev.target, ev.type); // process bootstrap data, let errors go up the stack

  try {
    require("app/model/helper/bootstrap")(window.bootstrap);
  } catch (err) {
    var el = document.querySelector(".app");
    el.classList.remove("app-initial");
    el.classList.add("app-error");
    throw new Error("bootstrap data error (" + err.message + ")", err.fileName, err.lineNumber);
  } finally {
    // detele global var
    delete window.bootstrap;
  }

  require("app/view/template/_helpers");
  /** @type {module:app/view/helper/createColorStyleSheet} */


  require("app/view/helper/createColorStyleSheet").call();
  /** @type {module:app/view/AppView} */


  var AppView = require("app/view/AppView"); // var startApp = AppView.getInstance.bind(AppView);

  /** @type {module:webfontloader} */


  var WebFont = require("webfontloader");

  var loadOpts = {
    async: false,
    groupName: "",
    classes: false,
    loading: function loading() {
      console.log("WebFont:%s:loading", this.groupName);
    },
    active: function active() {
      console.info("WebFont:%s:active", this.groupName);
    },
    inactive: function inactive() {
      console.warn("WebFont:%s:inactive", this.groupName);
    },
    fontactive: function fontactive(familyName, variantFvd) {
      console.info("WebFont:%s:fontactive '%s' (%s)", this.groupName, familyName, variantFvd);
    },
    fontinactive: function fontinactive(familyName, variantFvd) {
      console.warn("WebFont:%s:fontinactive '%s' (%s)", this.groupName, familyName, variantFvd);
    } // fontloading: function(familyName, variantDesc) {
    // 	console.log("WebFont::fontloading", familyName, JSON.stringify(variantDesc, null, " "));
    // },

  };
  WebFont.load(_.defaults({
    async: false,
    groupName: "required",
    custom: {
      families: ["FranklinGothicFS:n4,n6", // "FranklinGothicFS:i4,i6"
      "FolioFigures:n4"],
      testStrings: {
        "FolioFigures": "hms"
      }
    },
    active: function active() {
      return AppView.getInstance();
    },
    inactive: function inactive() {
      return AppView.getInstance();
    }
  }, loadOpts));
  WebFont.load(_.defaults({}, loadOpts)); // requestAnimationFrame(function(tstamp) {
  // 	AppView.getInstance();
  // });
});

if (DEBUG) {// /** @type {module:underscore} */
  // var _ = require("underscore");
  // var isFF = /Firefox/.test(window.navigator.userAgent);
  // var isIOS = /iPad|iPhone/.test(window.navigator.userAgent);

  /*
  if (/Firefox/.test(window.navigator.userAgent)) {
  	console.prefix = "# ";
  	var shift = [].shift;
  	var logWrapFn = function() {
  		if (typeof arguments[1] == "string") arguments[1] = console.prefix + arguments[1];
  		return shift.apply(arguments).apply(console, arguments);
  	};
  	console.group = _.wrap(console.group, logWrapFn);
  	console.log = _.wrap(console.log, logWrapFn);
  	console.info = _.wrap(console.info, logWrapFn);
  	console.warn = _.wrap(console.warn, logWrapFn);
  	console.error = _.wrap(console.error, logWrapFn);
  }
  */

  /*
  var saveLogs = function() {
  	var logWrapFn = function(name, fn, msg) {
  		document.documentElement.appendChild(
  			document.createComment("[" + name + "] " + msg));
  	};
  	console.group = _.wrap(console.group, _.partial(logWrapFn, "group"));
  	console.log = _.wrap(console.log, _.partial(logWrapFn, "log"));
  	console.info = _.wrap(console.info, _.partial(logWrapFn, "info"));
  	console.warn = _.wrap(console.warn, _.partial(logWrapFn, "warn"));
  	console.error = _.wrap(console.error, _.partial(logWrapFn, "error"));
  };
  */
  // handle error events on some platforms and production

  /*
  if (isIOS) {
  	// saveLogs();
  	window.addEventListener("error", function() {
  		var args = Array.prototype.slice.apply(arguments),
  			el = document.createElement("div"),
  			html = "";
  		_.extend(el.style, {
  			fontfamily: "monospace",
  			display: "block",
  			position: "absolute",
  			zIndex: "999",
  			backgroundColor: "white",
  			color: "black",
  			width: "calc(100% - 3em)",
  			bottom: "0",
  			margin: "1em 1.5em",
  			padding: "1em 1.5em",
  			outline: "0.5em solid red",
  			outlineOffset: "0.5em",
  			boxSizing: "border-box",
  			overflow: "hidden",
  		});
  		html += "<pre><b>location:<b> " + window.location + "</pre>";
  		html += "<pre><b>event:<b> " + JSON.stringify(args.shift(), null, " ") + "</pre>";
  		if (args.length) html += "<pre><b>rest:<b> " + JSON.stringify(args, null, " ") + "</pre>";
  		el.innerHTML = html;
  		document.body.appendChild(el);
  	});
  }*/
}

}).call(this,'',true,require("underscore"))

},{"Backbone.Mutators":1,"Modernizr":"Modernizr","app/model/helper/bootstrap":67,"app/view/AppView":74,"app/view/helper/createColorStyleSheet":96,"app/view/template/_helpers":123,"backbone":5,"backbone.babysitter":3,"backbone.native":4,"classlist-polyfill":6,"es6-promise/auto":13,"fullscreen-polyfill":"fullscreen-polyfill","hammerjs":15,"matches-polyfill":"matches-polyfill","math-sign-polyfill":"math-sign-polyfill","mutation-observer":36,"raf-polyfill":"raf-polyfill","setimmediate":38,"underscore":51,"webfontloader":52}],54:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/control/Controller
 */

/** @type {module:backbone} */

var Backbone = require("backbone"); // /** @type {module:app/model/collection/TypeCollection} */
// var types = require("app/model/collection/TypeCollection");
// /** @type {module:app/model/collection/KeywordCollection} */
// var keywords = require("app/model/collection/KeywordCollection");

/** @type {module:app/model/collection/ArticleCollection} */


var articles = require("app/model/collection/ArticleCollection");
/** @type {module:app/model/collection/BundleCollection} */


var bundles = require("app/model/collection/BundleCollection");
/* --------------------------- *
/* Static private
/* --------------------------- */

/**
/* @constructor
/* @type {module:app/control/Controller}
/*/


var Controller = Backbone.Router.extend({
  // /** @override */
  // routes: {},

  /** @override */
  initialize: function initialize(options) {
    if (DEBUG) {
      this._routeNames = [];

      this.route = function (route, name, callback) {
        this._routeNames.push(_.isString(name) ? name : '');

        return Backbone.Router.prototype.route.apply(this, arguments);
      };

      this.on("route", function (routeName, args) {
        console.log("controller:[route] %s [%s]", routeName, args.join());
      });
    }
    /*
     * Prefixed article regexp: /^article(?:\/([^\/]+))\/?$/
     * Single bundle regexp: /^bundles(?:\/([^\/]+)(?:\/(\d+))?)?\/?$/
     */


    this.route(/(.*)/, "notfound", this.toNotFound);
    this.route(/^([a-z][a-z0-9\-]*)\/?$/, "article-item", this.toArticleItem);
    this.route(/^(?:bundles)?\/?$/, "root", this.toRoot); // this.route(/^bundles\/?$/,
    // 	"bundle-list", this.toBundleList);
    // this.route(/^bundles\/([^\/]+)\/?$/,
    // 	"bundle-item", this.toBundleItem);
    // this.route(/^bundles\/([^\/]+)\/(\d+)\/?$/,
    // 	"media-item", this.toMediaItem);
    // this.route(/^bundles(?:\/([^\/]+)(?:\/(\d+))?)?\/?$/,

    this.route(/^bundles\/([^\/]+)(?:\/(\d+)?)?\/?$/, "media-item", this.toMediaItem);

    if (DEBUG) {
      console.log("%s::initialize routes: %o", "controller", this._routeNames);
    }
  },

  /* ---------------------------
  /* JS to URL: public command methods
  /* --------------------------- */
  selectMedia: function selectMedia(media) {
    this._goToLocation(media.get("bundle"), media);
  },
  selectBundle: function selectBundle(bundle) {
    if (bundle.attr("@no-desc")) {
      this._goToLocation(bundle, bundle.get("media").at(0));
    } else {
      this._goToLocation(bundle);
    }
  },
  deselectMedia: function deselectMedia() {
    this._goToLocation(bundles.selected);
  },
  deselectBundle: function deselectBundle() {
    this._goToLocation();
  },
  selectArticle: function selectArticle(article) {
    this.navigate(article.get("handle"), {
      trigger: true
    });
  },
  deselectArticle: function deselectArticle() {
    this.navigate("", {
      trigger: true
    });
  },

  /* ---------------------------
  /* JS to URL: private helpers
  /* --------------------------- */

  /** Update location when navigation happens internally */

  /*_updateLocation: function() {
  	var bundle, media;
  	bundle = bundles.selected;
  	if (bundle) {
  		media = bundle.get("media").selected;
  	}
  	this.navigate(this._getLocation(bundle, media), {
  		trigger: false
  	});
  },*/
  _getLocation: function _getLocation(bundle, media) {
    var mediaIndex,
        location = [];

    if (bundle) {
      location.push("bundles");
      location.push(bundle.get("handle"));

      if (media) {
        mediaIndex = bundle.get("media").indexOf(media);

        if (mediaIndex >= 0) {
          location.push(mediaIndex);
        }
      }
    } // location.push("");


    return location.join("/");
  },
  _goToLocation: function _goToLocation(bundle, media) {
    this.navigate(this._getLocation(bundle, media), {
      trigger: true
    });
  },

  /* --------------------------- *
   * URL to JS: router handlers
   * --------------------------- */
  toRoot: function toRoot() {
    this.trigger("change:before");

    if (bundles.selected) {
      // bundles.selected.get("media").deselect();
      bundles.deselect();
    } // keywords.deselect();


    articles.deselect();
    this.trigger("change:after");
  },
  toNotFound: function toNotFound(slug) {
    console.info("route:[*:%s]", slug);
  },
  // toBundleList: function() {
  // 	this.navigate("", {
  // 		trigger: true,
  // 		replace: true
  // 	});
  // },
  toBundleItem: function toBundleItem(bundleHandle) {
    var bundle = bundles.findWhere({
      handle: bundleHandle
    });

    if (!bundle) {
      throw new Error("Cannot find bundle with handle \"" + bundleHandle + "\""); // } else if (bundle.attr("@no-desc")) {
      // this._changeSelection(bundle, bundle.get("media").at(0));
      // this.navigate(this._getLocation(bundle, bundle.get("media").at(0)), { trigger: true, replace: false });
    } else {
      this._changeSelection(bundle);
    }
  },
  toMediaItem: function toMediaItem(bundleHandle, mediaIndex) {
    var bundle, media; // if (bundleHandle) {

    bundle = bundles.findWhere({
      handle: bundleHandle
    });

    if (!bundle) {
      throw new Error("No bundle with handle \"" + bundleHandle + "\" found");
    }

    media = bundle.get("media").at(mediaIndex ? mediaIndex : 0);

    if (!media) {
      throw new Error("No media at index " + mediaIndex + " in bundle with handle \"" + bundleHandle + "\" found");
    } // }
    // }


    this._changeSelection(bundle, media);
  },
  toArticleItem: function toArticleItem(articleHandle) {
    var article = articles.findWhere({
      handle: articleHandle
    });

    if (!article) {
      throw new Error("Cannot find article with handle \"" + articleHandle + "\"");
    }

    this.trigger("change:before", article);
    bundles.deselect();
    articles.select(article);
    this.trigger("change:after", article);
  },

  /* -------------------------------
  /* URL to JS: private helpers
  /* ------------------------------- */

  /*
  /* NOTE: Selection order
  /* - Apply media selection to *incoming bundle*, as not to trigger
  /*	unneccesary events on an outgoing bundle. Outgoing bundle media selection
  /*	remains untouched.
  /* - Apply media selection *before* selecting the incoming bundle. Views
  /*	normally listen to the selected bundle only, so if the bundle is changing,
  /*	they will not be listening to media selection changes yet.
  /*/
  _changeSelection: function _changeSelection(bundle, media) {
    var lastBundle, lastMedia;
    if (bundle === void 0) bundle = null;
    if (media === void 0) media = null; // if (bundle !== null && media === null && bundle.attr("@no-desc")) {
    // 	media = bundle.get("media").at(0);
    // 	this._goToLocation(bundle, media);
    // 	return;
    // }

    lastBundle = bundles.selected;
    lastMedia = lastBundle ? lastBundle.get("media").selected : null;
    console.log("controller::_changeSelection bundle:[%s -> %s] media:[%s -> %s]", lastBundle ? lastBundle.cid : lastBundle, bundle ? bundle.cid : bundle, lastMedia ? lastMedia.cid : lastMedia, media ? media.cid : media);

    if (!articles.selected && lastBundle === bundle && lastMedia === media) {
      return;
    }

    this.trigger("change:before", bundle, media);
    bundle && bundle.get("media").select(media);
    bundles.select(bundle);
    articles.deselect();
    this.trigger("change:after", bundle, media);
  }
});
module.exports = new Controller();

}).call(this,true,require("underscore"))

},{"app/model/collection/ArticleCollection":63,"app/model/collection/BundleCollection":64,"backbone":5,"underscore":51}],55:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/control/Globals
 */

module.exports = function () {
  // reusable vars
  var o, s, so; // global hash

  var g = {}; // SASS <--> JS shared hash

  var sass = require("../../../sass/variables.json"); // JUNK FIRST: Some app-wide defaults
  // - - - - - - - - - - - - - - - - -


  g.VPAN_DRAG = 0.95; // as factor of pointer delta

  g.HPAN_OUT_DRAG = 0.4; // factor

  g.VPAN_OUT_DRAG = 0.1; // factor

  g.PAN_THRESHOLD = 15; // px

  g.COLLAPSE_THRESHOLD = 75; // px

  g.COLLAPSE_OFFSET = parseInt(sass.temp["collapse_offset"]); // g.CLICK_EVENT = "click"; //window.hasOwnProperty("onpointerup") ? "pointerup" : "mouseup";

  g.VIDEO_CROP_PX = parseInt(sass["video_crop_px"]); // breakpoints
  // - - - - - - - - - - - - - - - - -

  g.BREAKPOINTS = {};

  for (s in sass.breakpoints) {
    o = sass.breakpoints[s];
    /*if (Array.isArray(o)) {
    	g.BREAKPOINTS[s] = Object.defineProperties({}, {
    		"matches": {
    			get: _.partial(_.some, o.map(window.matchMedia), _.property("matches"))
    		},
    		"media": {
    			value: o.join(", ")
    		},
    		"queries": {
    			value: o.map(window.matchMedia)
    		},
    	});
    } else {
    	g.BREAKPOINTS[s] = window.matchMedia(o);
    }*/

    o = Array.isArray(o) ? o.join(", ") : o;
    o = o.replace(/[\'\"]/g, "");
    o = window.matchMedia(o);
    o.className = s;
    g.BREAKPOINTS[s] = o;
  }

  if (DEBUG) {
    console.groupCollapsed("Breakpoints");

    for (s in g.BREAKPOINTS) {
      console.log("%s: %o", s, g.BREAKPOINTS[s].media);
    }

    console.groupEnd();
  } // base colors, dimensions
  // - - - - - - - - - - - - - - - - -


  g.DEFAULT_COLORS = _.clone(sass.default_colors); // g.HORIZONTAL_STEP = parseFloat(sass.units["hu_px"]);
  // g.VERTICAL_STEP = parseFloat(sass.units["vu_px"]);
  // paths, networking
  // - - - - - - - - - - - - - - - - -
  // var toAbsoluteURL = (function() {
  // 	var a = null;
  // 	return function(url) {
  // 		a = a || document.createElement('a');
  // 		a.href = url;
  // 		return a.href;
  // 	};
  // })();
  // g.APP_ROOT = toAbsoluteURL(window.approot);
  // g.MEDIA_DIR = toAbsoluteURL(window.mediadir);

  g.APP_ROOT = window.approot;
  g.MEDIA_DIR = window.mediadir;
  delete window.approot;
  delete window.mediadir; // hardcoded font data
  // - - - - - - - - - - - - - - - - -

  g.FONT_METRICS = {
    "FranklinGothicFS": {
      "unitsPerEm": 1000,
      "ascent": 827,
      "descent": -173
    },
    "ITCFranklinGothicStd": {
      "unitsPerEm": 1000,
      "ascent": 686,
      "descent": -314
    },
    "FolioFigures": {
      "unitsPerEm": 1024,
      "ascent": 939,
      "descent": -256
    }
  };
  g.PAUSE_CHAR = String.fromCharCode(0x23F8);
  g.PLAY_CHAR = String.fromCharCode(0x23F5);
  g.STOP_CHAR = String.fromCharCode(0x23F9); // translate common template

  if (sass.transform_type == "3d") {
    g.TRANSLATE_TEMPLATE = function (x, y) {
      return "translate3d(" + x + "px, " + y + "px, 0px)";
    };
  } else {
    g.TRANSLATE_TEMPLATE = function (x, y) {
      return "translate(" + x + "px, " + y + "px)";
    };
  }

  g.TRANSLATE_TEMPLATE = function (x, y) {
    return "translate(" + x + "px, " + y + "px)"; // return "translate3d(" + x + "px, " + y + "px ,0px)";
  }; // timing, easing
  // - - - - - - - - - - - - - - - - -


  var ease = g.TRANSITION_EASE = sass.transitions["ease"];
  var duration = g.TRANSITION_DURATION = parseFloat(sass.transitions["duration_ms"]);
  var delayInterval = g.TRANSITION_DELAY_INTERVAL = parseFloat(sass.transitions["delay_interval_ms"]);
  var minDelay = g.TRANSITION_MIN_DELAY = parseFloat(sass.transitions["min_delay_ms"]);
  var delay = g.TRANSITION_DELAY = g.TRANSITION_DURATION + g.TRANSITION_DELAY_INTERVAL; // css transitions
  // - - - - - - - - - - - - - - - - -

  o = {}; // match tx() in _transitions.scss
  // - - - - - - - - - - - - - - - - -

  o.tx = function tx(durationCount, delayCount, easeVal) {
    _.isNumber(durationCount) || (durationCount = 1);
    _.isNumber(delayCount) || (delayCount = -1);
    _.isString(easeVal) || (easeVal = ease);
    var o = {};

    if (delayCount < 0) {
      o.duration = duration * durationCount + delayInterval * (durationCount - 1);
      o.delay = 0;
    } else {
      o.duration = duration * durationCount + delayInterval * (durationCount - 1) - minDelay;
      o.delay = delay * delayCount - minDelay;
    }

    o.easeing = easeVal;
    return 0;
  }; // transition presets
  // TODO: get rid of this
  // - - - - - - - - - - - - - - - - -


  o.NONE = {
    delay: 0,
    duration: 0,
    easing: "step-start"
  };
  o.NOW = {
    delay: 0,
    duration: duration,
    easing: ease
  };
  o.UNSET = _.defaults({
    cssText: ""
  }, o.NONE);

  var txAligned = _.defaults({
    duration: duration - minDelay
  }, o.NOW);

  o.FIRST = _.defaults({
    delay: delay * 0.0 + minDelay
  }, txAligned);
  o.BETWEEN = _.defaults({
    delay: delay * 1.0 + minDelay
  }, txAligned);
  o.LAST = _.defaults({
    delay: delay * 2.0 + minDelay
  }, txAligned);
  o.AFTER = _.defaults({
    delay: delay * 2.0 + minDelay
  }, txAligned);
  o.BETWEEN_EARLY = _.defaults({
    delay: delay * 1.0 + minDelay - 60
  }, txAligned);
  o.BETWEEN_LATE = _.defaults({
    delay: delay * 1.0 + minDelay + 60
  }, txAligned);
  o.FIRST_LATE = _.defaults({
    delay: delay * 0.5 + minDelay
  }, txAligned);
  o.LAST_EARLY = _.defaults({
    delay: delay * 1.5 + minDelay
  }, txAligned); // o.FIRST_LATE = 		_.defaults({delay: txDelay*0.0 + txMinDelay*2}, txAligned);
  // o.LAST_EARLY = 		_.defaults({delay: txDelay*2.0 + txMinDelay*0}, txAligned);
  // o.AFTER = 			_.defaults({delay: txDelay*2.0 + txMinDelay}, txAligned);

  console.groupCollapsed("Transitions");

  for (s in o) {
    if (!_.isFunction(o[s])) {
      so = o[s];
      so.name = s;
      so.className = "tx-" + s.replace("_", "-").toLowerCase();

      if (!so.hasOwnProperty("cssText")) {
        so.cssText = so.duration / 1000 + "s " + so.easing + " " + so.delay / 1000 + "s";
      }

      console.log("%s: %s", so.name, so.cssText);
    }
  }

  console.groupEnd();
  g.transitions = o;
  return g;
}();

}).call(this,true,require("underscore"))

},{"../../../sass/variables.json":154,"underscore":51}],56:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/DebugToolbar
 */

/** @type {module:cookies-js} */

var Cookies = require("cookies-js");
/** @type {module:modernizr} */


var Modernizr = require("Modernizr");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals"); // /** @type {module:app/control/Controller} */
// var controller = require("app/control/Controller");

/** @type {module:app/view/base/View} */


var View = require("app/view/base/View");
/** @type {Function} */


var viewTemplate = require("./template/DebugToolbar.hbs");
/** @type {Function} */


var gridTemplate = require("./template/DebugToolbar.SVGGrid.hbs");
/** @type {Function} */


var sizeTemplate = _.template("<%= w %> \xD7 <%= h %>"); // var appStateSymbols = { withBundle: "b", withMedia: "m", collapsed: "c"};
// var appStateKeys = Object.keys(appStateSymbols);


module.exports = View.extend({
  /** @override */
  cidPrefix: "debugToolbar",

  /** @override */
  tagName: "div",

  /** @override */
  className: "toolbar",

  /** @override */
  template: viewTemplate,

  /** @override */
  properties: {
    grid: {
      get: function get() {
        return this._grid || (this._grid = this.createGridElement());
      }
    }
  },
  initialize: function initialize(options) {
    Cookies.defaults = {
      expires: new Date(0x7fffffff * 1e3),
      domain: String(window.location).match(/^https?\:\/\/([^\/:?#]+)(?:[\/:?#]|$)/i)[1]
    };
    this.el.innerHTML = this.template({
      tests: Modernizr,
      navigator: window.navigator
    });
    /* toggle's target: container
    /* - - - - - - - - - - - - - - - - */

    var container = document.getElementById("container"); //.querySelector("#container");

    /* create/attach svg grid element
    /* - - - - - - - - - - - - - - - - */

    container.insertBefore(this.createGridElement(), container.firstElementChild);
    /* info elements
    /* - - - - - - - - - - - - - - - - */

    this.backendEl = this.el.querySelector("#edit-backend a");
    this.mediaInfoEl = this.el.querySelector("#media-info span");
    this.appStateEl = this.el.querySelector("#app-state");
    /* toggle visibility
    /* - - - - - - - - - - - - - - - - */

    this.initializeClassToggle("show-links", this.el.querySelector("#links-toggle"), this.el, function (key, value) {
      this.el.classList.toggle("not-" + key, !value);
    });
    this.initializeClassToggle("show-tests", this.el.querySelector("#toggle-tests a"), this.el);
    this.initializeClassToggle("hide-passed", this.el.querySelector("#toggle-passed"), this.el);
    /* toggle container classes
    /* - - - - - - - - - - - - - - - - */

    this.initializeClassToggle("debug-state", this.el.querySelector("#toggle-state a"), container);
    this.initializeClassToggle("debug-blocks-nav", this.el.querySelector("#toggle-blocks-nav a"), container);
    this.initializeClassToggle("debug-blocks-content", this.el.querySelector("#toggle-blocks-content a"), container);
    this.initializeClassToggle("debug-mdown", this.el.querySelector("#toggle-mdown a"), container);
    this.initializeClassToggle("debug-tx", this.el.querySelector("#toggle-tx a"), container, function (key, value) {
      this.el.classList.toggle("show-tx", value);
      this.el.classList.toggle("not-show-tx", !value);
    });
    this.initializeClassToggle("debug-graph", this.el.querySelector("#toggle-graph a"), container);
    this.initializeClassToggle("debug-logs", this.el.querySelector("#toggle-logs a"), container);
    this.initializeClassToggle("debug-grid-bg", this.el.querySelector("#toggle-grid-bg a"), document.body);
    this.initializeViewportInfo(); // this.initializeLayoutSelect();

    this.listenTo(this.model, "change", this._onModelChange);

    this._onModelChange();
  },
  initializeViewportInfo: function initializeViewportInfo() {
    var viewportInfoEl = this.el.querySelector("#viewport-info span");

    var callback = function callback() {
      viewportInfoEl.textContent = sizeTemplate({
        w: window.innerWidth,
        h: window.innerHeight
      });
    };

    callback.call();
    window.addEventListener("resize", _.debounce(callback, 100, false, false));
  },
  initializeToggle: function initializeToggle(key, toggleEl, callback) {
    if (!toggleEl) return;
    var ctx = this;
    var toggleValue = Cookies.get(key) === "true";
    callback.call(ctx, key, toggleValue);
    toggleEl.addEventListener("click", function (ev) {
      if (ev.defaultPrevented) return;else ev.preventDefault();
      toggleValue = !toggleValue;
      Cookies.set(key, toggleValue ? "true" : "");
      callback.call(ctx, key, toggleValue);
    }, false);
  },
  initializeClassToggle: function initializeClassToggle(key, toggleEl, targetEl, callback) {
    var hasCallback = _.isFunction(callback);

    this.initializeToggle(key, toggleEl, function (key, toggleValue) {
      targetEl.classList.toggle(key, toggleValue);
      toggleEl.classList.toggle("toggle-enabled", toggleValue);
      toggleEl.classList.toggle("color-reverse", toggleValue);
      hasCallback && callback.apply(this, arguments);
    });
  },
  _onModelChange: function _onModelChange() {
    // console.log("%s::_onModelChange changedAttributes: %o", this.cid, this.model.changedAttributes());
    var i,
        ii,
        prop,
        el,
        els = this.appStateEl.children;

    for (i = 0, ii = els.length; i < ii; i++) {
      el = els[i];
      prop = el.getAttribute("data-prop");
      el.classList.toggle("has-value", this.model.get(prop));
      el.classList.toggle("has-changed", this.model.hasChanged(prop));
      el.classList.toggle("color-reverse", this.model.hasChanged(prop));
    } // NOTE: Always but rewrite CMS href.
    // Only collapsed may have changed, but not worth all the logic


    var attrVal = Globals.APP_ROOT + "symphony/";

    switch (this.model.get("routeName")) {
      case "article-item":
        attrVal += "publish/articles/edit/" + this.model.get("article").id;
        break;

      case "bundle-item":
        attrVal += "publish/bundles/edit/" + this.model.get("bundle").id;
        break;

      case "media-item":
        attrVal += "publish/media/edit/" + this.model.get("media").id;
        break;

      case "root":
        attrVal += "publish/bundles";
        break;
    }

    this.backendEl.setAttribute("href", attrVal);

    if (this.model.hasChanged("routeName")) {
      document.body.setAttribute("last-route", this.model.previous("routeName"));
      document.body.setAttribute("current-route", this.model.get("routeName"));
    }

    if (this.model.hasChanged("media")) {
      if (this.model.has("media")) {
        this.mediaInfoEl.textContent = sizeTemplate(this.model.get("media").get("source").toJSON());
        this.mediaInfoEl.style.display = "";
      } else {
        this.mediaInfoEl.textContent = "";
        this.mediaInfoEl.style.display = "none";
      }
    }
  },
  createGridElement: function createGridElement() {
    var el = document.createElement("div");
    el.id = "grid-wrapper";
    el.innerHTML = gridTemplate();
    return el;
  }
});
module.exports.prototype._logFlags = "";

}).call(this,require("underscore"))

},{"./template/DebugToolbar.SVGGrid.hbs":57,"./template/DebugToolbar.hbs":58,"Modernizr":"Modernizr","app/control/Globals":55,"app/view/base/View":82,"cookies-js":"cookies-js","underscore":51}],57:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<svg id=\"debug-grid\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" preserveAspectRatio=\"xMaxYMid slice\" viewport-fill=\"hsl(0,0%,100%)\" viewport-fill-opacity=\"1\" style=\"fill:none;stroke:none;stroke-width:1px;fill:none;fill-rule:evenodd;\">\n<defs>\n	<pattern id=\"pat-baseline-12px\" class=\"baseline base12\" x=\"0\" y=\"0\" width=\"20\" height=\"12\" patternUnits=\"userSpaceOnUse\">\n		<line x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\" stroke-opacity=\"1.0\"/>\n		<line x1=\"0\" x2=\"100%\" y1=\"3\" y2=\"3\" stroke-opacity=\"0.125\"/>\n		<line x1=\"0\" x2=\"100%\" y1=\"6\" y2=\"6\" stroke-opacity=\"0.375\"/>\n		<line x1=\"0\" x2=\"100%\" y1=\"9\" y2=\"9\" stroke-opacity=\"0.125\"/>\n	</pattern>\n\n	<pattern id=\"pat-baseline-24px\" class=\"baseline base12\" x=\"0\" y=\"0\" width=\"20\" height=\"24\" patternUnits=\"userSpaceOnUse\">\n		<line x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\" stroke-opacity=\"1.0\"/>\n	</pattern>\n\n	<pattern id=\"pat-baseline-10px\" class=\"baseline base10\" x=\"0\" y=\"0\" width=\"20\" height=\"10\" patternUnits=\"userSpaceOnUse\">\n		<line x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\" stroke-opacity=\"1.00\"/>\n		<line x1=\"0\" x2=\"100%\" y1=\"5\" y2=\"5\" stroke-opacity=\"0.75\"/>\n	</pattern>\n	<pattern id=\"pat-baseline-20px\" class=\"baseline base10\" x=\"0\" y=\"0\" width=\"20\" height=\"20\" patternUnits=\"userSpaceOnUse\">\n		<line x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\" stroke-opacity=\"1.0\"/>\n	</pattern>\n	<pattern id=\"pat-cols-220px\" x=\"0\" y=\"0\" width=\"220\" height=\"36\" patternUnits=\"userSpaceOnUse\">\n		<rect transform=\"translate(0,0)\" x=\"0\" y=\"0\" width=\"20\" height=\"100%\" fill=\"hsl(336,50%,40%)\" fill-opacity=\"0.1\"/>\n		<rect transform=\"translate(200,0)\" x=\"0\" y=\"0\" width=\"20\" height=\"100%\" fill=\"hsl(336,50%,40%)\" fill-opacity=\"0.1\"/>\n		<line transform=\"translate(20 0)\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\" stroke=\"hsl(336,50%,60%)\" stroke-opacity=\"0.2\"/>\n		<line transform=\"translate(200 0)\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\" stroke=\"hsl(336,50%,40%)\" stroke-opacity=\"0.2\"/>\n\n		<line transform=\"translate(140 0)\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\" stroke=\"hsl(336,50%,40%)\" stroke-opacity=\"0.3\"/>\n		<line transform=\"translate(80 0)\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\" stroke=\"hsl(336,50%,40%)\" stroke-opacity=\"0.3\"/>\n\n		<line transform=\"translate(0 0)\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\" stroke=\"hsl(236,50%,40%)\" stroke-opacity=\"0.4\" stroke-width=\"1\"/>\n		<line transform=\"translate(220 0)\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\" stroke=\"hsl(236,50%,40%)\" stroke-opacity=\"0.4\" stroke-width=\"1\"/>\n	</pattern>\n</defs>\n<g id=\"debug-grid-body\" transform=\"translate(0 0.5)\">\n	<rect id=\"baseline\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n	<g id=\"debug-grid-container\">\n		<g id=\"debug-grid-content\">\n			<rect id=\"baseline-content\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n			<line id=\"gct0\" class=\"hguide\" x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\"/>\n			<line id=\"gct1\" class=\"hguide\" x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\"/>\n		</g>\n		<line id=\"gnv0\" class=\"hguide\" x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\"/>\n		<line id=\"gnv1\" class=\"hguide\" x1=\"0\" x2=\"100%\" y1=\"0\" y2=\"0\"/>\n	</g>\n\n	<g id=\"abs-cols\">\n		<rect id=\"columns\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\"/>\n	</g>\n\n	<g id=\"rel-cols\">\n		<line id=\"le\" class=\"vguide edge\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\"/>\n		<line id=\"re\" class=\"vguide edge\" x1=\"100%\" x2=\"100%\" y1=\"0\" y2=\"100%\"/>\n\n		<line id=\"gl0\" class=\"vguide margin\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\"/>\n		<line id=\"gl1\" class=\"vguide gutter\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\"/>\n\n		<line id=\"gr0\" class=\"vguide margin\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\"/>\n		<line id=\"gr1\" class=\"vguide gutter\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\"/>\n\n		<line id=\"gm\" class=\"vguide\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"100%\"/>\n	</g>\n</g>\n</svg>\n";
},"useData":true});

},{"hbsfy/runtime":35}],58:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../view/template/svg/CogSymbol.hbs');
HandlebarsCompiler.registerPartial('../../view/template/svg/CogSymbol.hbs', partial$0);
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "	<dd id=\"select-layout\">\n		<select size=1>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.layouts : depth0),{"name":"each","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "		</select>\n	</dd>\n";
},"2":function(container,depth0,helpers,partials,data) {
    var alias1=container.lambda, alias2=container.escapeExpression;

  return "			<option value=\""
    + alias2(alias1(depth0, depth0))
    + "\">"
    + alias2(alias1(depth0, depth0))
    + "</option>\n";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

  return "		<li class=\""
    + ((stack1 = helpers["if"].call(alias1,depth0,{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.program(7, data, 0),"data":data})) != null ? stack1 : "")
    + "\">"
    + container.escapeExpression(((helper = (helper = helpers.key || (data && data.key)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"key","hash":{},"data":data}) : helper)))
    + "</li>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "passed";
},"7":function(container,depth0,helpers,partials,data) {
    return "failed";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.escapeExpression;

  return "<dl class=\"debug-links color-bg\">\n	<dt id=\"links-toggle\">\n"
    + ((stack1 = container.invokePartial(partials["../../view/template/svg/CogSymbol.hbs"],depth0,{"name":"../../view/template/svg/CogSymbol.hbs","data":data,"indent":"\t\t","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "	</dt>\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.layouts : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "	<dd id=\"edit-backend\">\n		<a href=\""
    + alias2((helpers.global || (depth0 && depth0.global) || helpers.helperMissing).call(alias1,"APP_ROOT",{"name":"global","hash":{},"data":data}))
    + "symphony/\" class=\"color-fg color-bg\" target=\"_blank\">CMS</a>\n	</dd>\n	<dd id=\"toggle-tests\">\n		<a href=\"#toggle-tests\" class=\"color-fg color-bg\">Tests</a>\n	</dd>\n	<dd id=\"toggle-state\">\n		<a href=\"#toggle-state\" class=\"color-fg color-bg\">Route</a>\n	</dd>\n	<dd id=\"toggle-blocks-nav\">\n		<a href=\"#toggle-blocks-nav\" class=\"color-fg color-bg\">Nav</a>\n	</dd>\n	<dd id=\"toggle-blocks-content\">\n		<a href=\"#toggle-blocks-content\" class=\"color-fg color-bg\">Content</a>\n	</dd>\n	<dd id=\"toggle-mdown\">\n		<a href=\"#toggle-mdown\" class=\"color-fg color-bg\">Markdown</a>\n	</dd>\n	<dd id=\"toggle-tx\">\n		<a href=\"#toggle-tx\" class=\"color-fg color-bg\">TX/FX</a>\n	</dd>\n	<dd id=\"toggle-grid-bg\">\n		<a href=\"#toggle-grid-bg\" class=\"color-fg color-bg\">Grid</a>\n	</dd>\n	<dd id=\"toggle-graph\">\n		<a href=\"#toggle-graph\" class=\"color-fg color-bg\">Graph</a>\n	</dd>\n	<dd id=\"toggle-logs\">\n		<a href=\"#toggle-logs\" class=\"color-fg color-bg\">Logs</a>\n	</dd>\n	<dd id=\"media-info\">\n		<span></span>\n	</dd>\n	<dd id=\"viewport-info\">\n		<span></span>\n	</dd>\n	<dd id=\"app-state\">\n		<span class=\"color-fg color-bg\" data-prop=\"collapsed\">c</span><span class=\"color-fg color-bg\" data-prop=\"withBundle\">b</span><span class=\"color-fg color-bg\" data-prop=\"withMedia\">m</span><span class=\"color-fg color-bg\" data-prop=\"withArticle\">a</span>\n	</dd>\n</dl>\n<div id=\"test-results\">\n	<h6>Tests <a id=\"toggle-passed\" href=\"#toggle-passed\">Passed</a></h6>\n	<p>"
    + alias2(container.lambda(((stack1 = (depth0 != null ? depth0.navigator : depth0)) != null ? stack1.userAgent : stack1), depth0))
    + "</p>\n	<ul>\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.tests : depth0),{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "	</ul>\n</div>\n";
},"usePartial":true,"useData":true});

},{"../../view/template/svg/CogSymbol.hbs":124,"hbsfy/runtime":35}],59:[function(require,module,exports){
"use strict";
/**
 * @module app/model/BaseItem
 * @requires module:backbone
 */

/** @type {module:backbone} */

var BaseModel = require("backbone").Model; // /** @type {module:app/model/BaseModel} */
// var BaseModel = require("app/model/BaseModel");


module.exports = BaseModel.extend({
  defaults: {
    collapsed: false,
    routeName: "initial",
    article: null,
    bundle: null,
    media: null,
    fromRouteName: "",
    withArticle: false,
    withBundle: false,
    withMedia: false
  },
  getters: ["collapsed", "routeName", "article", "bundle", "media", "fromRouteName", "withArticle", "withBundle", "withMedia"],
  // mutators: {
  // 	routeName: {
  // 		set: function(key, value, opts, set) {
  // 			// Set fromRoute to avoid losing current "changing" state
  // 			this._previousAttributes["fromRouteName"] = this.attributes["fromRouteName"];
  // 			this.changed["fromRouteName"] = this.attributes["fromRouteName"] = this.previous("routeName");
  // 			// set("fromRouteName", this.previous("routeName"), {
  // 			// 	silent: true
  // 			// });
  // 		}
  // 	}
  // },
  initialize: function initialize() {
    // this.listenTo(this, {
    // 	"change:routeName": function() {
    // 		this.set("fromRouteName", this.previous("routeName"));
    // 	},
    // 	"change:article": function(val) {
    // 		console.log("%s:[change] %o", this.cid, arguments);
    // 		this.set("withArticle", (typeof val === 'object'));
    // 	},
    // 	"change:bundle": function(val) {
    // 		console.log("%s:[change] %o", this.cid, arguments);
    // 		this.set("withBundle", (typeof val === 'object'));
    // 	},
    // 	"change:media": function(val) {
    // 		console.log("%s:[change] %o", this.cid, arguments);
    // 		this.set("withMedia", (typeof val === 'object'));
    // 	},
    // });
    // this.set({
    // 	fromRouteName: "",
    // 		withArticle: false,
    // 		withBundle: false,
    // 		withMedia: false
    // });
    var opts = {
      silent: false
    };
    this.listenTo(this, "change", function (attrs) {
      // var opts = { silent: false };
      if (this.hasChanged("routeName")) {
        this.set("fromRouteName", this.previous("routeName"), opts);
      }

      if (this.hasChanged("article")) {
        this.set("withArticle", this.has("article"), opts);
      }

      if (this.hasChanged("bundle")) {
        this.set("withBundle", this.has("bundle"), opts);
      }

      if (this.hasChanged("media")) {
        this.set("withMedia", this.has("media"), opts);
      }
    });
    this.listenTo(this, "change:routeName", function (val) {
      console.log("%s:[change:routeName] %o", this.cid, val); // this.set("fromRouteName", this.previous("routeName"));
    });
    this.listenTo(this, "change:article", function (val) {
      console.log("%s:[change:article] %o", this.cid, val); // this.set("withArticle", _.isObject(val));
    });
    this.listenTo(this, "change:bundle", function (val) {
      console.log("%s:[change:bundle] %o", this.cid, val); // this.set("withBundle", _.isObject(val));
    });
    this.listenTo(this, "change:media", function (val) {
      console.log("%s:[change:media] %o", this.cid, val); // this.set("withMedia", _.isObject(val));
    });
  },
  hasAnyPrevious: function hasAnyPrevious(attr) {
    return this.previous(attr) != null;
  },
  hasAnyChanged: function hasAnyChanged(attr) {
    return this.hasChanged(attr) && this.has(attr) != this.hasAnyPrevious(attr);
  } // constructor: function() {
  // 	Object.keys(this.defaults).forEach(function(getterName) {
  // 		Object.defineProperty(this, getterName, {
  // 			enumerable: true,
  // 			get: function() {
  // 				return this.get(getterName);
  // 			}
  // 		});
  // 	});
  // 	BaseModel.apply(this, arguments);
  // }

});

},{"backbone":5}],60:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/model/BaseItem
 * @requires module:backbone
 */

/** @type {module:app/model/BaseModel} */

var BaseModel = require("app/model/BaseModel"); // /** @type {module:app/control/Globals} */
// var Globals = require("app/control/Globals");
// /** @type {module:app/utils/strings/stripTags} */
// var stripTags = require("utils/strings/stripTags");
// /** @type {module:app/model/parseSymAttrs} */
//var parseSymAttrs = require("app/model/parseSymAttrs");


var parseSymAttrs = function parseSymAttrs(s) {
  return s.replace(/(\,|\;)/g, function (m) {
    return m == "," ? ";" : ",";
  });
};

var toAttrsHash = function toAttrsHash(obj, attr) {
  if (_.isString(attr)) {
    var idx = attr.indexOf(":");

    if (idx > 0) {
      obj[attr.substring(0, idx)] = parseSymAttrs(attr.substring(idx + 1));
    } else {
      obj[attr] = attr; // to match HTML5<>XHTML valueless attributes
    }
  } // else ignore non-string values


  return obj;
};
/**
 * @constructor
 * @type {module:app/model/BaseItem}
 */


module.exports = BaseModel.extend({
  _domPrefix: "_",

  /** @type {Object} */
  defaults: {
    // attrs: function() { return {}; },
    get attrs() {
      return {};
    }

  },
  getters: ["domid"],
  mutators: {
    domid: function domid() {
      if (!this.hasOwnProperty("_domId")) this._domId = this._domPrefix + this.id;
      return this._domId;
    },
    attrs: {
      set: function set(key, value, options, _set) {
        if (Array.isArray(value)) {
          value = value.reduce(toAttrsHash, {});
        }

        if (!_.isObject(value)) {
          console.error("%s::attrs value not an object or string array", this.cid, value);
          value = {};
        }

        _set(key, value, options);
      }
    }
  },
  attr: function attr(_attr) {
    return this.attrs()[_attr];
  },
  attrs: function attrs() {
    return this.get("attrs");
  },
  toString: function toString() {
    return this.get("domid");
  },
  getDistanceToSelected: function getDistanceToSelected() {
    if (this.collection && this.collection.selectedIndex > 0) {
      return this.collection.indexOf(this) - this.collection.selectedIndex;
    }

    return -1;
  },
  getIndex: function getIndex() {
    if (this.collection) {
      return this.collection.indexOf(this);
    }

    return -1;
  }
});

}).call(this,require("underscore"))

},{"app/model/BaseModel":61,"underscore":51}],61:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/model/BaseModel
 * @requires module:backbone
 */

/** @type {module:backbone} */

var Backbone = require("backbone");

var BaseModelProto = {// constructor: function() {
  // 	if (this.properties) {
  // 		Object.defineProperties(this, this.properties);
  // 	}
  // 	Backbone.Model.apply(this, arguments);
  // }
};
var BaseModel = {
  extend: function extend(proto, obj) {
    var constr, propName; //, propDef;

    for (propName in proto) {
      if (proto.hasOwnProperty(propName) && _.isObject(proto[propName])) {
        //(Object.getPrototypeOf(proto[propName]) === Object.prototype)) {
        proto[propName] = _.defaults(proto[propName], this.prototype[propName]); // console.log("BaseModel::extend '%s:%s' is Object\n%s", proto._domPrefix, propName, JSON.stringify(proto[propName]));
      }
    } // if (_.isObject(proto.properties)) {
    // 	if (Array.isArray(proto.getters)) {
    // 		proto.properties = _.omit(proto.properties, proto.getters);
    // 	}
    // }
    // if (proto.properties && this.prototype.properties) {
    // 	_.defaults(proto.properties, this.prototype.properties);
    // }


    constr = Backbone.Model.extend.apply(this, arguments);

    if (Array.isArray(constr.prototype.getters)) {
      constr.prototype.getters.forEach(function (getterName) {
        Object.defineProperty(constr.prototype, getterName, {
          enumerable: true,
          get: function get() {
            return this.get(getterName);
          }
        });
      });
    } // if (Array.isArray(constr.prototype.properties)) {
    // }
    // if (_.isObject(proto.properties)) {
    // 	for (propName in proto.properties) {
    // 		if (proto.properties.hasOwnProperty(propName)) {
    // 			propDef = proto.properties[propName];
    // 			if (_.isFunction(propDef)) {
    // 				proto.properties[propName] = {
    // 					enumerable: true, get: propDef
    // 				};
    // 			} else if (_.isObject(propDef)){
    // 				propDef.enumerable = true;
    // 			} else {
    // 				delete proto.properties[propName];
    // 			}
    // 		}
    // 	}
    // 	Object.defineProperties(proto, proto.properties);
    // 	delete proto.properties;
    // }


    return constr;
  }
};
/**
 * @constructor
 * @type {module:app/model/BaseModel}
 */

module.exports = Backbone.Model.extend.call(Backbone.Model, BaseModelProto, BaseModel); // module.exports = Model.extend(BaseModelProto, BaseModel);

}).call(this,require("underscore"))

},{"backbone":5,"underscore":51}],62:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/model/SelectableCollection
 */

/** @type {module:backbone} */

var Backbone = require("backbone");
/**
 * @constructor
 * @type {module:app/model/SelectableCollection}
 */


var SelectableCollection = Backbone.Collection.extend({
  initialize: function initialize(models, options) {
    options = _.defaults({}, options, {
      initialSelection: "none",
      silentInitial: true
    });
    this.initialSelection = options.initialSelection;
    this.initialOptions = {
      silent: options.silentInitial
    };
  },
  reset: function reset(models, options) {
    this.deselect(this.initialOptions);
    Backbone.Collection.prototype.reset.apply(this, arguments);

    if (this.initialSelection === "first" && this.length) {
      this.select(this.at(0), this.initialOptions);
    }
  },
  select: function select(newModel, options) {
    if (newModel === void 0) {
      newModel = null;
    }

    if (this.selected === newModel) {
      return;
    }

    var triggerEvents = !(options && options.silent);
    var oldModel = this.selected;
    this.lastSelected = this.selected;
    this.lastSelectedIndex = this.selectedIndex;
    this.selected = newModel;
    this.selectedIndex = this.indexOf(newModel);

    if (oldModel) {
      if (_.isFunction(oldModel.deselect)) {
        oldModel.deselect(options);
      } else if (triggerEvents) {
        oldModel.selected = void 0;
        oldModel.trigger("deselected", newModel, oldModel);
      }

      if (triggerEvents) this.trigger("deselect:one", oldModel);
    } else {
      if (triggerEvents) this.trigger("deselect:none", null);
    }

    if (newModel) {
      if (_.isFunction(newModel.select)) {
        newModel.select(options);
      } else if (triggerEvents) {
        newModel.selected = true;
        newModel.trigger("selected", newModel, oldModel);
      }

      if (triggerEvents) this.trigger("select:one", newModel);
    } else {
      if (triggerEvents) this.trigger("select:none", null);
    }
  },
  deselect: function deselect(options) {
    this.select(null, options);
  },
  selectAt: function selectAt(index, options) {
    if (0 > index || index >= this.length) {
      new RangeError("index is out of bounds");
    }

    this.select(this.at(index), options);
  },
  distance: function distance(a, b) {
    var aIdx, bIdx;
    if (!a) return NaN;
    aIdx = this.indexOf(a);
    if (aIdx == -1) return NaN;

    if (arguments.length == 1) {
      bIdx = this.selectedIndex;
    } else {
      if (!b) return NaN;
      bIdx = this.indexOf(b);
      if (bIdx == -1) return NaN;
    }

    return Math.abs(bIdx - aIdx);
  },

  /* TODO: MOVE INTO MIXIN */

  /** @return boolean	/*/
  hasFollowing: function hasFollowing(model) {
    model || (model = this.selected);
    return this.indexOf(model) < this.length - 1;
  },

  /** @return next model	*/
  following: function following(model) {
    model || (model = this.selected);
    return this.hasFollowing(model) ? this.at(this.indexOf(model) + 1) : null;
  },

  /** @return next model or the beginning if at the end */
  followingOrFirst: function followingOrFirst(model) {
    model || (model = this.selected);
    return this.at((this.indexOf(model) + 1) % this.length);
  },

  /** @return boolean	/*/
  hasPreceding: function hasPreceding(model) {
    model || (model = this.selected);
    return this.indexOf(model) > 0;
  },

  /** @return the previous model */
  preceding: function preceding(model) {
    model || (model = this.selected);
    return this.hasPreceding(model) ? this.at(this.indexOf(model) - 1) : null;
  },

  /** @return the previous model or the end if at the beginning */
  precedingOrLast: function precedingOrLast(model) {
    model || (model = this.selected);
    var index = this.indexOf(model) - 1;
    return this.at(index > -1 ? index : this.length - 1);
  }
});
module.exports = SelectableCollection;

}).call(this,require("underscore"))

},{"backbone":5,"underscore":51}],63:[function(require,module,exports){
"use strict";
/**
 * @module app/model/collection/ArticleCollection
 */

/** @type {module:app/model/SelectableCollection} */

var SelectableCollection = require("app/model/SelectableCollection");
/** @type {module:app/model/item/ArticleItem} */


var ArticleItem = require("app/model/item/ArticleItem");
/**
 * @constructor
 * @type {module:app/model/collection/ArticleCollection}
 */


var ArticleCollection = SelectableCollection.extend({
  /** @type {Backbone.Model} */
  model: ArticleItem
});
module.exports = new ArticleCollection();

},{"app/model/SelectableCollection":62,"app/model/item/ArticleItem":68}],64:[function(require,module,exports){
"use strict";
/**
 * @module app/model/collection/BundleCollection
 */

/** @type {module:app/model/SelectableCollection} */

var SelectableCollection = require("app/model/SelectableCollection");
/** @type {module:app/model/item/BundleItem} */


var BundleItem = require("app/model/item/BundleItem");
/**
 * @constructor
 * @type {module:app/model/collection/BundleCollection}
 */


var BundleCollection = SelectableCollection.extend({
  /** @type {Backbone.Model} */
  model: BundleItem,

  /** @type {Function} */
  comparator: function comparator(oa, ob) {
    var a = oa.get("completed");
    var b = ob.get("completed");

    if (a > b) {
      return -1;
    } else if (a < b) {
      return 1;
    } else {
      return 0;
    }
  },

  /** @type {String} */
  url: "/json/bundles/"
});
module.exports = new BundleCollection();

},{"app/model/SelectableCollection":62,"app/model/item/BundleItem":69}],65:[function(require,module,exports){
"use strict";
/**
 * @module app/model/collection/KeywordCollection
 * @requires module:backbone
 */

/** @type {module:app/model/SelectableCollection} */

var SelectableCollection = require("app/model/SelectableCollection");
/** @type {module:app/model/item/KeywordItem} */


var KeywordItem = require("app/model/item/KeywordItem");
/**
 * @constructor
 * @type {module:app/model/collection/KeywordCollection}
 */


var KeywordCollection = SelectableCollection.extend({
  /** @type {Backbone.Model} */
  model: KeywordItem
});
module.exports = new KeywordCollection();

},{"app/model/SelectableCollection":62,"app/model/item/KeywordItem":70}],66:[function(require,module,exports){
"use strict";
/**
 * @module app/model/collection/TypeCollection
 * @requires module:backbone
 */

/** @type {module:backbone} */

var Backbone = require("backbone");
/** @type {module:app/model/item/TypeItem} */


var TypeItem = require("app/model/item/TypeItem");
/**
 * @constructor
 * @type {module:app/model/collection/TypeCollection}
 */


var TypeCollection = Backbone.Collection.extend({
  /** @type {Backbone.Model} */
  model: TypeItem
});
module.exports = new TypeCollection();

},{"app/model/item/TypeItem":73,"backbone":5}],67:[function(require,module,exports){
(function (_){
"use strict";

module.exports = function (bootstrap) {
  /** @type {module:app/control/Globals} */
  var Globals = require("app/control/Globals"); // Globals.GA_TAGS = bootstrap["ga-tags"];
  // Globals.PARAMS = bootstrap["params"];
  // Globals.APP_ROOT = bootstrap["params"]["root"];
  // Globals.MEDIA_DIR = bootstrap["params"]["uploads"];


  Globals.APP_NAME = bootstrap["params"]["website-name"];
  /** @type {module:app/model/collection/TypeCollection} */

  var typeList = require("app/model/collection/TypeCollection");
  /** @type {module:app/model/collection/KeywordCollection} */


  var keywordList = require("app/model/collection/KeywordCollection");
  /** @type {module:app/model/collection/BundleCollection} */


  var bundleList = require("app/model/collection/BundleCollection");
  /** @type {module:app/model/collection/ArticleCollection} */


  var articleList = require("app/model/collection/ArticleCollection"); // Fix-ups to bootstrap data.


  var articles = bootstrap["articles-all"];
  var types = bootstrap["types-all"];
  var keywords = bootstrap["keywords-all"];
  var bundles = bootstrap["bundles-all"];
  var media = bootstrap["media-all"]; // Attach media to their bundles

  var mediaByBundle = _.groupBy(media, "bId"); // Fill-in back-references:
  // Create Keyword.bundleIds from existing Bundle.keywordIds,
  // then Bundle.typeIds from unique Keyword.typeId
  // _.each(bundles, function (bo, bi, ba) {


  bundles.forEach(function (bo, bi, ba) {
    bo.tIds = [];
    bo.media = mediaByBundle[bo.id]; // _.each(keywords, function (ko, ki, ka) {

    keywords.forEach(function (ko, ki, ka) {
      if (bi === 0) {
        ko.bIds = [];
      } // if (_.contains(bo.kIds, ko.id)) {


      if (bo.kIds.indexOf(ko.id) != -1) {
        ko.bIds.push(bo.id); // if (!_.contains(bo.tIds, ko.tId)) {

        if (bo.tIds.indexOf(ko.tId) == -1) {
          bo.tIds.push(ko.tId);
        }
      }
    });
  }); // Fill collection singletons

  articleList.reset(articles);
  typeList.reset(types);
  keywordList.reset(keywords);
  bundleList.reset(bundles); // bootstrap["params"] = bootstrap["articles-all"] = bootstrap["types-all"] = bootstrap["keywords-all"] = bootstrap["bundles-all"] = bootstrap["media-all"] = null;
};

}).call(this,require("underscore"))

},{"app/control/Globals":55,"app/model/collection/ArticleCollection":63,"app/model/collection/BundleCollection":64,"app/model/collection/KeywordCollection":65,"app/model/collection/TypeCollection":66,"underscore":51}],68:[function(require,module,exports){
"use strict";
/**
 * @module app/model/item/ArticleItem
 */
// /** @type {module:backbone} */
// var Backbone = require("backbone");

/** @type {module:app/model/item/SourceItem} */

var BaseItem = require("app/model/BaseItem");
/**
 * @constructor
 * @type {module:app/model/item/ArticleItem}
 */


module.exports = BaseItem.extend({
  _domPrefix: "a",

  /** @type {Object} */
  defaults: {
    name: "",
    handle: "",
    text: ""
  }
});

},{"app/model/BaseItem":60}],69:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/model/item/BundleItem
 * @requires module:backbone
 */
// /** @type {module:backbone} */
// var Backbone = require("backbone");/** @type {Function} */

var Color = require("color");
/** @type {module:app/model/item/SourceItem} */


var BaseItem = require("app/model/BaseItem");
/** @type {module:app/model/item/MediaItem} */


var MediaItem = require("app/model/item/MediaItem");
/** @type {module:app/model/SelectableCollection} */


var SelectableCollection = require("app/model/SelectableCollection");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:app/utils/strings/stripTags} */


var stripTags = require("utils/strings/stripTags"); // /** @type {module:app/utils/strings/parseTaglist} */
// var parseSymAttrs = require("app/model/parseSymAttrs");
// /** @type {module:app/model/collection/KeywordCollection} */
// var keywords = require("app/model/collection/KeywordCollection");
// Globals.DEFAULT_COLORS["color"];
// Globals.DEFAULT_COLORS["background-color"];


var attrsDefault = _.defaults({
  "has-colors": "defaults"
}, Globals.DEFAULT_COLORS);
/** @private */


var MediaCollection = SelectableCollection.extend({
  model: MediaItem,
  comparator: "o"
});
/**
 * @constructor
 * @type {module:app/model/item/BundleItem}
 */

module.exports = BaseItem.extend({
  _domPrefix: "b",

  /** @type {Object|Function} */
  // defaults: function() {
  // 	return {
  // 		name: "",
  // 		handle: "",
  // 		desc: "",
  // 		completed: 0,
  // 		kIds: [],
  // 	};
  // },
  defaults: {
    name: "",
    handle: "",
    desc: "",
    completed: 0,

    get kIds() {
      return [];
    }

  },
  getters: ["name", "media"],
  mutators: {
    text: function text() {
      return stripTags(this.get("desc"));
    },
    // kIds: {
    // 	set: function (key, value, options, set) {
    // 		if (Array.isArray(value)) {
    // 			set("keywords", value.map(function(id) {
    // 				var obj = keywords.get(id);
    // 				return obj;
    // 			}, this), options;
    // 		}
    // 		set(key, value, options);
    // 	},
    // },
    media: {
      transient: true,
      set: function set(key, value, options, _set) {
        if (Array.isArray(value)) {
          value.forEach(function (o) {
            o.bundle = this;
          }, this);
          value = new MediaCollection(value);
        }

        _set(key, value, options);
      }
    }
  },
  initialize: function initialize(attrs, options) {
    this.colors = {
      fgColor: new Color(this.attr("color")),
      bgColor: new Color(this.attr("background-color")),
      lnColor: new Color(this.attr("link-color"))
    };
    this.colors.hasDarkBg = this.colors.fgColor.luminosity() > this.colors.bgColor.luminosity();
  },
  attrs: function attrs() {
    return this._attrs || (this._attrs = _.defaults({}, this.get("attrs"), attrsDefault));
  }
});

}).call(this,require("underscore"))

},{"app/control/Globals":55,"app/model/BaseItem":60,"app/model/SelectableCollection":62,"app/model/item/MediaItem":71,"color":12,"underscore":51,"utils/strings/stripTags":152}],70:[function(require,module,exports){
"use strict";
/**
 * @module app/model/item/KeywordItem
 * @requires module:app/model/BaseItem
 */

/** @type {module:app/model/BaseItem} */

var BaseItem = require("app/model/BaseItem"); // /** @type {module:app/model/collection/TypeCollection} */
// var types = require("app/model/collection/TypeCollection");

/**
 * @constructor
 * @type {module:app/model/item/KeywordItem}
 */


module.exports = BaseItem.extend({
  _domPrefix: "k",

  /** @type {Object} */
  defaults: {
    name: "",
    handle: "",
    tId: -1
  } // mutators: {
  // 	tId: {
  // 		set: function (key, value, options, set) {
  // 			var type = types.get(value);
  // 			if (type) {
  // 				type.get("keywords").push(this);
  // 				set("type", type, options);
  // 			}
  // 			set(key, value, options);
  // 		}
  // 	},
  // }

});

},{"app/model/BaseItem":60}],71:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/model/item/MediaItem
 * @requires module:backbone
 */
// /** @type {module:backbone} */
// var Backbone = require("backbone");/** @type {Function} */

var Color = require("color");
/** @type {module:app/model/item/SourceItem} */


var BaseItem = require("app/model/BaseItem");
/** @type {module:app/model/item/SourceItem} */


var SourceItem = require("app/model/item/SourceItem");
/** @type {module:app/model/SelectableCollection} */


var SelectableCollection = require("app/model/SelectableCollection");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:app/utils/strings/stripTags} */


var stripTags = require("utils/strings/stripTags"); // /** @type {module:app/model/parseSymAttrs} */
// var parseSymAttrs = require("app/model/parseSymAttrs");
// console.log(Globals.PARAMS);


var urlTemplates = {
  "original": _.template(Globals.MEDIA_DIR + "/<%= src %>"),
  "constrain-width": _.template(Globals.APP_ROOT + "image/1/<%= width %>/0/uploads/<%= src %>"),
  "constrain-height": _.template(Globals.APP_ROOT + "image/1/0/<%= height %>/uploads/<%= src %>"),
  "debug-bandwidth": _.template(Globals.MEDIA_DIR.replace(/(https?\:\/\/[^\/]+)/, "$1/slow/<%= kbps %>") + "/<%= src %>")
};
/**
 * @constructor
 * @type {module:app/model/item/MediaItem.SourceCollection}
 */

var SourceCollection = SelectableCollection.extend({
  model: SourceItem
});
/**
 * @constructor
 * @type {module:app/model/item/MediaItem}
 */

module.exports = BaseItem.extend({
  _domPrefix: "m",

  /** @type {Object} */
  defaults: {
    name: "<p><em>Untitled</em></p>",
    sub: "",
    o: 0,
    bId: -1,
    srcIdx: 0,

    get srcset() {
      return [];
    },

    get sources() {
      return new SourceCollection();
    }

  },
  getters: ["name", "bundle", "source", "sources"],
  mutators: {
    // desc: function() {
    // 	return this.get("name");
    // },
    handle: function handle() {
      return this.get("src");
    },
    text: function text() {
      if (!this.hasOwnProperty("_text")) this._text = _.unescape(stripTags(this.get("name")));
      return this._text;
    },
    attrs: {
      set: function set(key, value, opts, _set) {
        this._attrs = null;
        BaseItem.prototype.mutators.attrs.set.apply(this, arguments);

        this._updateSources();
      }
    },
    srcset: {
      set: function set(key, value, opts, _set2) {
        _set2(key, value, opts);

        this.get("sources").reset(value, opts);

        this._updateSources();
      }
    },
    source: {
      transient: true,
      get: function get() {
        return this.get("sources").at(this.get("srcIdx"));
      }
    }
  },
  initialize: function initialize() {
    this._updateColors();

    this.listenTo(this, "change:attrs change:bundle", function () {
      this._attrs = null;
    });
  },
  attrs: function attrs() {
    return this._attrs || (this._attrs = _.defaults({}, this.get("bundle").attrs(), this.get("attrs")));
  },
  _updateColors: function _updateColors() {
    this.colors = {
      fgColor: new Color(this.attr("color")),
      bgColor: new Color(this.attr("background-color"))
    };
    this.colors.hasDarkBg = this.colors.fgColor.luminosity() > this.colors.bgColor.luminosity();
  },
  _updateSources: function _updateSources() {
    var srcObj = {
      kbps: this.attr("@debug-bandwidth")
    };
    var srcTpl = urlTemplates[srcObj.kbps ? "debug-bandwidth" : "original"];
    this.get("sources").forEach(function (item) {
      srcObj.src = item.get("src");
      item.set("original", srcTpl(srcObj));
    });
  } // _updateSourcesArr: function() {
  // 	var srcset = this.get("srcset");
  // 	if (Array.isArray(srcset)) {
  // 		var srcObj = { kbps: this.attr("@debug-bandwidth") };
  // 		var srcTpl = Globals.MEDIA_SRC_TPL[srcObj.kbps? "debug-bandwidth" : "original"];
  // 		srcset.forEach(function(o) {
  // 			srcObj.src = o.src;
  // 			o.original = srcTpl(srcObj);
  // 		}, this);
  // 	}
  // 	this.get("sources").reset(srcset);
  // },

});

}).call(this,require("underscore"))

},{"app/control/Globals":55,"app/model/BaseItem":60,"app/model/SelectableCollection":62,"app/model/item/SourceItem":72,"color":12,"underscore":51,"utils/strings/stripTags":152}],72:[function(require,module,exports){
(function (DEBUG){
"use strict";
/**
 * @module app/model/item/SourceItem
 * @requires module:backbone
 */
// /** @type {module:backbone} */
// var Backbone = require("backbone");
// /** @type {module:app/control/Globals} */
// var Globals = require("app/control/Globals");

/** @type {module:app/model/item/SourceItem} */

var BaseItem = require("app/model/BaseItem");
/** @type {String} */


var noCacheSuffix = "?" + Date.now();
/**
 * @constructor
 * @type {module:app/model/item/SourceItem}
 */
// module.exports = Backbone.Model.extend({

module.exports = BaseItem.extend({
  /** @type {Object} */
  defaults: {
    src: null,
    mime: null,
    w: null,
    h: null
  },
  getters: ["src", "original"],
  mutators: {
    src: {
      set: function set(key, value, options, _set) {
        if (DEBUG) {
          value += noCacheSuffix;
        }

        _set(key, value, options);
      }
    } // original: { 
    // 	transient: true,
    // 	get: function (key, value, options, set) {
    // 		return this.attributes.original || (this.attributes.original = this._composeOriginalSrc());
    // 	},
    // },
    // media: {
    // 	transient: true,
    // 	get: function () {
    // 		var retval;
    // 		if (this._noRecusion) {
    // 			console.log("%s::media returning null", this.cid);
    // 			retval = null;//this.id;
    // 		} else {
    // 			console.log("%s::media returning Object", this.cid);
    // 			this._noRecusion = true;
    // 			retval = this.attributes.media;
    // 			this._noRecusion = false;
    // 		}
    // 		return retval;
    // 	},
    // 	set: function (key, value, options, set) {
    // 		if (value instanceof BaseItem) {
    // 			set(key, value, options);
    // 		}
    // 	},
    // },

  } // initialize: function() {
  // 	if (DEBUG) {
  // 		var cb = function() {
  // 			// console.log("@debug-bandwidth:", JSON.stringify(this.get("media").attr("@debug-bandwidth")));
  // 			console.log("media:", JSON.stringify(this.toJSON()));
  // 			// if ((this.get("media") instanceof BaseItem) && this.get("media").attr("@debug-bandwidth")) {
  // 			// 	console.log("original", this.get("original"));
  // 			// 	console.log("media:", JSON.stringify(this.get("media").toJSON()));
  // 			// }
  // 		}.bind(this);
  // 		window.requestAnimationFrame(cb);
  // 	}
  // },
  // 
  // _composeOriginalSrc: function() {
  // 	var values = { src: this.get("src") };
  // 	if (this.has("media") && (values.kbps = this.get("media").attr("@debug-bandwidth"))) {
  // 	// if (this.has("media") && this.get("media").attrs().hasOwnProperty("@debug-bandwidth")) {
  // 	// 	values.kbps = this.get("media").attrs()["@debug-bandwidth"];
  // 		return Globals.MEDIA_SRC_TPL["debug-bandwidth"](values);
  // 	}
  // 	return Globals.MEDIA_SRC_TPL["original"](values);
  // },

});

}).call(this,true)

},{"app/model/BaseItem":60}],73:[function(require,module,exports){
"use strict";
/**
 * @module app/model/item/TypeItem
 */
// /** @type {module:backbone} */
// var Backbone = require("backbone");

/** @type {module:app/model/item/SourceItem} */

var BaseItem = require("app/model/BaseItem");
/**
 * @constructor
 * @type {module:app/model/item/TypeItem}
 */


module.exports = BaseItem.extend({
  _domPrefix: "t",

  /** @type {Object} */
  defaults: {
    name: "",
    handle: "" // get kIds() { return []; },
    // get keywords() { return []; },

  }
});

},{"app/model/BaseItem":60}],74:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/view/AppView
 */

/** @type {module:backbone} */

var Backbone = require("backbone");
/** @type {module:app/utils/debug/traceArgs} */


var stripTags = require("utils/strings/stripTags");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:app/control/Controller} */


var controller = require("app/control/Controller");
/** @type {module:app/model/AppState} */


var AppState = require("app/model/AppState");
/** @type {module:app/model/collection/BundleCollection} */


var bundles = require("app/model/collection/BundleCollection");
/** @type {module:app/model/collection/ArticleCollection} */


var articles = require("app/model/collection/ArticleCollection");
/** @type {module:app/view/base/View} */


var View = require("app/view/base/View");
/** @type {module:app/view/NavigationView} */


var NavigationView = require("app/view/NavigationView");
/** @type {module:app/view/ContentView} */


var ContentView = require("app/view/ContentView");
/** @type {module:app/view/base/TouchManager} */


var TouchManager = require("app/view/base/TouchManager"); // /** @type {module:hammerjs} */
// const Hammer = require("hammerjs");
// /** @type {module:utils/touch/SmoothPanRecognizer} */
// const Pan = require("utils/touch/SmoothPanRecognizer");
// /** @type {module:hammerjs.Tap} */
// const Tap = Hammer.Tap;
// /** @type {module:utils/debug/traceElement} */
// const traceElement = require("utils/debug/traceElement");
//
// const vpanLogFn = _.debounce(console.log.bind(console), 100, false);
// const hpanLogFn = _.debounce(console.log.bind(console), 100, false);

/**
 * @constructor
 * @type {module:app/view/AppView}
 */


module.exports = View.extend({
  /** @override */
  cidPrefix: "app",

  /** @override */
  el: "html",
  // /** @override */
  className: "app",
  // without-bundle without-media without-article",

  /** @override */
  model: AppState,

  /** @override */
  events: {
    "visibilitychange": function visibilitychange(ev) {
      console.log("%s:[%s]", this.cid, ev.type);
    },
    "fullscreenchange": function fullscreenchange(ev) {
      console.log("%s:[%s] fullscreen: %o", this.cid, ev.type, document.fullscreenElement !== null, document.fullscreen);
    },
    "dragstart": function dragstart(ev) {
      if (ev.target.nodeName == "IMG" || ev.target.nodeName == "A") {
        ev.defaultPrevented || ev.preventDefault();
      }
    } // "touchmove body": function(ev) {
    // 	ev.defaultPrevented || ev.preventDefault();
    // },

  },
  properties: {
    container: {
      get: function get() {
        return this._container || (this._container = document.getElementById("container")); // (this._container = document.body);
      }
    },
    navigation: {
      get: function get() {
        return this._navigation || (this._navigation = document.getElementById("navigation"));
      }
    },
    content: {
      get: function get() {
        return this._content || (this._content = document.getElementById("content"));
      }
    }
  },

  /** @override */
  initialize: function initialize(options) {
    var _this = this;

    /* elements */
    // this.routeEl = this.el;
    // this.stateEl = this.el
    this.breakpointEl = this.el;
    /* init HammerJS handlers */

    var vtouch, htouch, touchEl; // var vpan, hpan, tap;
    // this._vpanEnableFn = function(mc, ev) {
    // 	var retval = !this._hasOverflowY(this.container);
    // 	vpanLogFn("%s::_vpanEnableFn -> %o\n%o", this.cid, retval, arguments);
    // 	return retval;
    // }.bind(this);
    //
    // this._hpanEnableFn = function(mc, ev) {
    // 	var retval = this.model.get("withBundle") && this.model.get("collapsed");
    // 	hpanLogFn("%s::_hpanEnableFn -> %o\n%o", this.cid, retval, arguments);
    // 	return !!retval;
    // }.bind(this);

    touchEl = this.content; // touchEl = document.body;

    vtouch = htouch = TouchManager.init(touchEl); // vtouch.get("vpan").set({ enable: this._vpanEnableFn });
    // htouch.get("hpan").set({ enable: this._hpanEnableFn });
    // 		vtouch.set({
    // 			enable: function() {
    // 				console.log("app1::hammerjs enable", arguments);
    // 				return true;
    // 			}
    // 		});
    // hpan = vpan;
    // this.el.style.touchAction = "none"; //"pan-x pan-y";
    // tap = new Hammer.Tap();
    // hpan = new Pan({
    // 	event: "hpan",
    // 	direction: Hammer.DIRECTION_HORIZONTAL
    // });
    // hpan.set({
    // 	enable: this._hpanEnableFn
    // });
    // vpan = new Pan({
    // 	event: "vpan",
    // 	direction: Hammer.DIRECTION_VERTICAL
    // });
    // vpan.set({
    // 	enable: this._vpanEnableFn
    // });
    // hpan.requireFailure(vpan);
    // vpan.requireFailure(hpan);
    // vtouch.add([]);
    // htouch = vtouch = new Hammer.Manager(this.content);
    // htouch.add([tap, hpan, vpan]);
    // htouch.add([hpan, vpan]);
    // htouch.set({ touchAction: "pan-x pan-y" });
    // vpan = new Hammer(this.navigation, {
    // 	recognizers: [
    // 		[Pan, {
    // 			event: 'vpan',
    // 			touchAction: "pan-y",
    // 			direction: Hammer.DIRECTION_VERTICAL,
    // 			enable: vpanEnableFn
    // 		}],
    // 	]
    // });
    // hpan = new Hammer(this.content, {
    // 	recognizers: [
    // 		[Pan, {
    // 			event: 'hpan',
    // 			touchAction: "pan-x",
    // 			direction: Hammer.DIRECTION_HORIZONTAL,
    // 			enable: hpanEnableFn
    // 		}],
    // 		[Tap]
    // 	]
    // });
    // hpan.get("hpan").requireFailure(vpan.get("vpan"));
    // this._afterRender = this._afterRender.bind(this);

    this._onResize = this._onResize.bind(this);
    /* render on resize, onorientationchange, visibilitychange */
    // window.addEventListener("orientationchange", this._onResize, false);
    // window.addEventListener("resize", _.debounce(this._onResize.bind(this), 30, false), false);

    window.addEventListener("resize", this._onResize, false); // var h = function(ev) { console.log(ev.type, ev) };
    // window.addEventListener("scroll", h, false);
    // window.addEventListener("wheel", h, false);

    /* TODO: replace resize w/ mediaquery listeners. Caveat: some components
    (vg. Carousel) require update on resize */
    // this._onBreakpointChange = this._onBreakpointChange.bind(this);
    // Object.keys(Globals.BREAKPOINTS).forEach(function(s) {
    // 	Globals.BREAKPOINTS[s].addListeners(this._onBreakpointChange);
    // }, this);

    /* initialize controller/model listeners BEFORE views register their own */

    this.listenTo(controller, "route", this._onRoute); // this.listenTo(controller, "change:after", this._afterControllerChanged);

    this.listenTo(this.model, "change", this._onModelChange);
    /* FIXME */

    /* initialize views */

    this.navigationView = new NavigationView({
      el: this.navigation,
      model: this.model,
      vpan: vtouch,
      hpan: htouch
    });
    this.contentView = new ContentView({
      el: this.content,
      model: this.model,
      vpan: vtouch,
      hpan: htouch
    });
    /* TouchEvents fixups
     * ------------------------------- */
    // var traceTouchEvent = (msg, traceObj) => {
    // 	if (msg.hasOwnProperty("type")) {
    // 		msg = msg.type + " : " +
    // 			(msg.defaultPrevented ? "prevented" : "not prevented");
    // 	}
    // 	var sy, sh, ch;
    // 	sy = this.el.scrollTop;
    // 	sh = this.el.scrollHeight - 1;
    // 	ch = this.el.clientHeight;
    // 	console.log("%s:[%s] " +
    // 		"sy:[1>%o>=%s = %o] " +
    // 		"sh:[%o<=%o = %o] " +
    // 		"nav:[css:%o val:%o]",
    // 		this.cid, msg,
    // 		sy, sh - ch, (1 <= sy <= (sh - ch)),
    // 		sh, ch, (sh <= ch),
    // 		this.navigationView.el.style.height,
    // 		this.navigationView.el.scrollHeight,
    // 		traceObj || ""
    // 	);
    // };
    // var scrolltouch = new Hammer.Manager(this.el);
    // scrolltouch.add(new Hammer.Pan({ direction: Hammer.DIRECTION_VERTICAL, threshold: 0 }));
    // scrolltouch.on("panmove", function(ev) {
    //
    // 	// var sy, sh, ch;
    // 	// sy = this.el.scrollTop;
    // 	// sh = this.el.scrollHeight - 1;
    // 	// ch = this.el.clientHeight;
    // 	//
    // 	// if ((1 > sy) && (ev.direction | Hammer.DIRECTION_DOWN)) {
    // 	// 	ev.preventDefault();
    // 	// 	console.log("%s:[panmove] %s", this.cid, "prevent at top");
    // 	// } else
    // 	// if ((sy > (sh - ch)) && (ev.direction | Hammer.DIRECTION_UP)) {
    // 	// 	ev.preventDefault();
    // 	// 	console.log("%s:[panmove] %s", this.cid, "prevent at bottom");
    // 	// }
    // 	if ((this.el.scrollHeight - 1) <= this.el.clientHeight) {
    // 		ev.srcEvent.preventDefault();
    // 	}
    // 	// traceTouchEvent(ev);
    // }.bind(this));

    var touchOpts = {
      capture: false,
      passive: false
    };

    var onTouchStart = function onTouchStart(ev) {
      _this.el.addEventListener("touchmove", onTouchMove, touchOpts);

      _this.el.addEventListener("touchend", onTouchEnd, touchOpts);

      _this.el.addEventListener("touchcancel", onTouchEnd, touchOpts);
    };

    var onTouchMove = function onTouchMove(ev) {
      if (!ev.defaultPrevented && _this.el.scrollHeight - 1 <= _this.el.clientHeight) {
        ev.preventDefault();
      } //traceTouchEvent(ev);

    };

    var onTouchEnd = function onTouchEnd(ev) {
      _this.el.removeEventListener("touchmove", onTouchMove, touchOpts);

      _this.el.removeEventListener("touchend", onTouchEnd, touchOpts);

      _this.el.removeEventListener("touchcancel", onTouchEnd, touchOpts);
    };

    this.el.addEventListener("touchstart", onTouchStart);

    var onMeasured = function onMeasured(view) {
      _this.setImmediate(function () {
        _this.requestAnimationFrame(function () {
          if (_this.el.scrollHeight - 1 <= _this.el.clientHeight) {
            _this.el.style.overflowY = "hidden";
          } else {
            _this.el.style.overflowY = "";
          }

          _this.el.scrollTop = 1; //traceTouchEvent("view:collapsed:measured");
        });
      });
    };

    this.listenTo(this.navigationView, "view:collapsed:measured", onMeasured);
    /* Google Analytics
     * ------------------------------- */

    if (window.ga && window.GA_ID) {
      controller.once("route", function () {
        window.ga("create", window.GA_ID, "auto"); // if localhost or dummy ID, disable analytics

        if (/(?:(localhost|\.local))$/.test(location.hostname) || window.GA_ID == "UA-9123564-8") {
          window.ga("set", "sendHitTask", null);
        }

        console.warn("GA enabled tag '%s'", window.GA_ID);
      }).on("route", function (name) {
        var page = Backbone.history.getFragment(); // Add a slash if neccesary

        if (page.charAt(0) !== '/') {
          page = '/' + page;
        } // page.replace(/^(?!\/)/, "/");


        window.ga("set", "page", page);
        window.ga("send", "pageview");
        console.warn("GA page set to '%s'", page);
      });
    } else {
      console.warn("GA not enabled (LIB: %s, GA_ENABLED: %s, GA_ID: %s)", !!window.ga, window.GA_ENABLED, window.GA_ID);
    }
    /* Startup listener, added last */


    this.listenToOnce(controller, "route", this._appStart);
    /* start router, which will request appropiate state */

    Backbone.history.start({
      pushState: false,
      hashChange: true
    });
  },

  /* -------------------------------
  /* _appStart
  /* ------------------------------- */
  _appStart: function _appStart(name, args) {
    console.info("%s::_appStart(%s, %s)", this.cid, name, args.join());
    this.skipTransitions = true;
    this.el.classList.add("skip-transitions");
    this.requestRender(View.MODEL_INVALID | View.SIZE_INVALID).requestChildrenRender(View.MODEL_INVALID | View.SIZE_INVALID).listenToOnce(this, "view:render:after", function (view, flags) {
      // this.setImmediate(function() {
      this.requestAnimationFrame(function () {
        console.log("%s::_appStart[view:render:after][raf]", this.cid);
        this.skipTransitions = false;
        this.el.classList.remove("skip-transitions");
        this.el.classList.remove("app-initial");
      });
    });
  },

  /* --------------------------- *
  /* route changed
  /* --------------------------- */
  _onRoute: function _onRoute(name, args) {
    console.info("%s::_onRoute %o -> %o", this.cid, this.model.get("routeName"), name); // var o = _.defaults({ routeName: name }, AppState.prototype.defaults);

    var o = {
      routeName: name,
      bundle: null,
      media: null,
      article: null
    };

    switch (name) {
      case "media-item":
        o.bundle = bundles.selected; // o.withBundle = true;

        o.media = o.bundle.media.selected; // o.withMedia = true;

        o.collapsed = true;
        break;

      case "bundle-item":
        o.bundle = bundles.selected; // o.withBundle = true;

        o.collapsed = true;
        break;

      case "article-item":
        o.article = articles.selected; // o.withArticle = true;

        o.collapsed = true;
        break;

      case "bundle-list":
      case "notfound":
      case "root":
      default:
        o.collapsed = false;
        break;
    } // console.log("%s::_onRoute args: %o", this.cid, name, args);


    this.model.set(o);
  },

  /* --------------------------- *
  /* model changed
  /* --------------------------- */
  _onModelChange: function _onModelChange() {
    if (DEBUG) {
      console.groupCollapsed(this.cid + "::_onModelChange");
      console.groupCollapsed("changes");
      Object.keys(this.model.changedAttributes()).forEach(function (key) {
        console.info("%s::_onModelChange %s: %s -> %s", this.cid, key, this.model.previous(key), this.model.get(key));
      }, this);
      ["Article", "Bundle", "Media"].forEach(function (name) {
        var key = name.toLowerCase();
        console[this.hasChanged("with" + name) == this.hasAnyChanged(key) ? "log" : "warn"].call(console, "%s::_onModelChange with%s: %o with%sChanged: %o", this.cid, name, this.has(key), name, this.hasAnyChanged(key));
      }, this.model);
      console.groupEnd();
      this.once("view:render:after", function (view, flags) {
        console.info("%s::_onModelChange [view:render:after]", view.cid);
        console.groupEnd();
      });
    }

    this.requestRender(View.MODEL_INVALID); // this.requestChildrenRender(View.MODEL_INVALID);
  },

  /* -------------------------------
  /* resize
  /* ------------------------------- */
  _onResize: function _onResize(ev) {
    console.group(this.cid + "::_onResize [event]");
    this.skipTransitions = true;
    this.el.classList.add("skip-transitions");
    this.requestRender(View.SIZE_INVALID) // .whenRendered().then(function(view) {
    .once("view:render:after", function (view, flags) {
      // this.requestChildrenRender(View.SIZE_INVALID, true);
      // this.setImmediate(function() {
      this.requestAnimationFrame(function () {
        console.info("%s::_onResize [view:render:after][raf]", view.cid);
        view.skipTransitions = false;
        view.el.classList.remove("skip-transitions");
        this.el.scrollTop = 1;
        console.groupEnd();
      });
    });
    if (document.fullscreenElement === null) this.renderNow();
  },

  /* -------------------------------
  /* render
  /* ------------------------------- */
  renderFrame: function renderFrame(tstamp, flags) {
    console.log("%s::renderFrame [%s]", this.cid, View.flagsToString(flags));
    /* model: set route & model id classes */

    if (flags & View.MODEL_INVALID) {
      this.renderModelChange(flags);
    }
    /* size: check breakpoints and set classes*/


    if (flags & View.SIZE_INVALID) {
      _.each(Globals.BREAKPOINTS, function (o, s) {
        this.toggle(s, o.matches);
      }, this.breakpointEl.classList);
    }
    /* request children render:  always render now */


    this.requestChildrenRender(flags, true);
    /* request children render:  set 'now' flag if size is invalid */
    // this.requestChildrenRender(flags, flags & View.SIZE_INVALID);
    // if ((this.el.scrollHeight - 1) <= this.el.clientHeight) {
    // 	this.el.scrollTop = 1;
    // 	this.el.style.overflowY = "hidden";
    // } else {
    // 	this.el.style.overflowY = "";
    // }
    // this.navigationView.whenRendered().then(function(view) {
    // 	this.requestAnimationFrame(function() {
    // 		console.log("%s::renderFrame [raf] css:%o val:%o",
    // 			this.cid,
    // 			this.navigationView.el.style.height,
    // 			this.navigationView.el.scrollHeight,
    // 			this.el.scrollTop,
    // 			this.el.scrollHeight - 1,
    // 			this.el.clientHeight,
    // 			(this.el.scrollHeight - 1) <= this.el.clientHeight,
    // 			this.el.style.overflowY
    // 		);
    // 	});
    // }.bind(this));
  },

  /* -------------------------------
  /* body classes etc
  /* ------------------------------- */
  renderModelChange: function renderModelChange() {
    var cls = this.el.classList;
    var prevAttr = null;
    var docTitle = [];
    var hasDarkBg = false;
    docTitle.push(Globals.APP_NAME);

    if (this.model.get("bundle")) {
      docTitle.push(stripTags(this.model.get("bundle").get("name")));

      if (this.model.get("media")) {
        docTitle.push(stripTags(this.model.get("media").get("name")));
      }
    } else if (this.model.get("article")) {
      docTitle.push(stripTags(this.model.get("article").get("name")));
    }

    document.title = _.unescape(docTitle.join(" / "));
    /* Set route class */

    if (this.model.hasChanged("routeName")) {
      prevAttr = this.model.previous("fromRouteName");

      if (prevAttr) {
        cls.remove("from-route-" + prevAttr);
      }

      cls.add("from-route-" + this.model.get("fromRouteName"));
      prevAttr = this.model.previous("routeName");

      if (prevAttr) {
        cls.remove("route-" + prevAttr); // this.el.setAttribute("from-route", prevAttr);
      } // this.el.setAttribute("to-route", this.model.get("routeName"));


      cls.add("route-" + this.model.get("routeName"));
    }
    /* Set model id classes for color styles */


    ["article", "bundle", "media"].forEach(function (prop) {
      var item = this.model.get(prop);

      if (this.model.hasChanged(prop)) {
        prevAttr = this.model.previous(prop);

        if (prevAttr) {
          cls.remove(prevAttr.get("domid"));
        }

        if (item) {
          cls.add(item.get("domid"));
        }
      }

      cls.toggle("with-" + prop, !!item);
      cls.toggle("without-" + prop, !item);
      hasDarkBg |= item && item.colors && item.colors.hasDarkBg;
    }.bind(this));
    /* flag dark background */

    cls.toggle("color-dark", hasDarkBg);
  }
}, {
  getInstance: function getInstance() {
    if (!(window.app instanceof this)) {
      window.app = new this({
        model: new AppState()
      });
    }

    return window.app;
  }
});

if (DEBUG) {
  module.exports = function (AppView) {
    /** @type {module:app/debug/DebugToolbar} */
    var DebugToolbar = require("app/debug/DebugToolbar");

    return AppView.extend({
      initialize: function initialize() {
        var retval;
        var view = new DebugToolbar({
          id: "debug-toolbar",
          model: this.model
        });
        document.body.appendChild(view.render().el);
        retval = AppView.prototype.initialize.apply(this, arguments);
        this._logFlags["view.trace"] = true;
        this.navigationView._logFlags["view.trace"] = true;
        return retval;
      }
    });
  }(module.exports);
}

}).call(this,true,require("underscore"))

},{"app/control/Controller":54,"app/control/Globals":55,"app/debug/DebugToolbar":56,"app/model/AppState":59,"app/model/collection/ArticleCollection":63,"app/model/collection/BundleCollection":64,"app/view/ContentView":75,"app/view/NavigationView":76,"app/view/base/TouchManager":81,"app/view/base/View":82,"backbone":5,"underscore":51,"utils/strings/stripTags":152}],75:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/ContentView
 */

/** @type {module:app/control/Globals} */

var Globals = require("app/control/Globals");
/** @type {module:utils/TransformHelper} */


var TransformHelper = require("utils/TransformHelper"); // /** @type {module:app/view/base/TouchManager} */
// var TouchManager = require("app/view/base/TouchManager");

/** @type {module:app/control/Controller} */


var controller = require("app/control/Controller");
/** @type {module:app/model/collection/BundleCollection} */


var bundles = require("app/model/collection/BundleCollection");
/** @type {module:app/model/collection/ArticleCollection} */


var articles = require("app/model/collection/ArticleCollection"); // /** @type {module:app/model/collection/BundleItem} */
// var BundleItem = require("app/model/item/BundleItem");

/** @type {module:app/view/base/View} */


var View = require("app/view/base/View");
/** @type {module:app/view/component/ArticleView} */


var ArticleView = require("app/view/component/ArticleView");
/** @type {module:app/view/component/CollectionStack} */


var CollectionStack = require("app/view/component/CollectionStack");
/** @type {module:app/view/component/CollectionStack} */


var SelectableListView = require("app/view/component/SelectableListView");
/** @type {module:app/view/render/DotNavigationRenderer} */


var DotNavigationRenderer = require("app/view/render/DotNavigationRenderer");
/** @type {module:app/view/component/Carousel} */


var Carousel = require("app/view/component/Carousel");
/** @type {module:app/view/render/CarouselRenderer} */


var CarouselRenderer = require("app/view/render/CarouselRenderer");
/** @type {module:app/view/render/ImageRenderer} */


var ImageRenderer = require("app/view/render/ImageRenderer");
/** @type {module:app/view/render/VideoRenderer} */


var VideoRenderer = require("app/view/render/VideoRenderer");
/** @type {module:app/view/render/SequenceRenderer} */


var SequenceRenderer = require("app/view/render/SequenceRenderer"); // /** @type {module:app/view/component/CanvasProgressMeter} */
// var ProgressMeter = require("app/view/component/CanvasProgressMeter");

/** @type {Function} */


var carouselEmptyTemplate = require("./template/Carousel.EmptyRenderer.Bundle.hbs");
/** @type {Function} */


var mediaStackTemplate = require("./template/CollectionStack.Media.hbs"); // var transitionEnd = View.prefixedEvent("transitionend");


var transformProp = View.prefixedProperty("transform");
var transitionProp = View.prefixedProperty("transition");
var tx = Globals.transitions; // var clickEvent = window.hasOwnProperty("onpointerup") ? "pointerup" : "mouseup",

/**
 * @constructor
 * @type {module:app/view/ContentView}
 */

module.exports = View.extend({
  /** @override */
  cidPrefix: "contentView",

  /** @override */
  className: "container-expanded",

  /** @override */
  events: {
    "transitionend .adding-child": "_onAddedTransitionEnd",
    "transitionend .removing-child": "_onRemovedTransitionEnd" // "transitionend": "_onTransitionEnd",

  },

  /** @override */
  initialize: function initialize(options) {
    _.bindAll(this, "_onVPanStart", "_onVPanMove", "_onVPanFinal", "_onCollapsedEvent");

    this.transforms = new TransformHelper(); // this.touch = options.touch || new Error("no touch"); //TouchManager.getInstance();

    this.vpan = options.vpan || new Error("no vpan");
    this.hpan = options.hpan || new Error("no hpan");
    this.listenTo(this.model, "change", this._onModelChange); // disconnect children before last change
    // this.listenTo(bundles, "deselect:one", this._onDeselectOneBundle);

    this.skipTransitions = true;
    this.itemViews = []; // this.progressWrapper = this.createProgressWrapper(),
    // this.el.appendChild(this.progressWrapper.el);
  },

  /* --------------------------- *
  /* Render
  /* --------------------------- */
  renderFrame: function renderFrame(tstamp, flags) {
    // values
    var collapsed = this.model.get("collapsed");
    var collapsedChanged = flags & View.MODEL_INVALID && this.model.hasChanged("collapsed");
    var childrenChanged = flags & View.MODEL_INVALID && (this.model.hasChanged("bundle") || this.model.hasChanged("article")); // flags

    var sizeChanged = !!(flags & View.SIZE_INVALID);
    var transformsChanged = !!(flags & (View.MODEL_INVALID | View.SIZE_INVALID | View.LAYOUT_INVALID));
    transformsChanged = transformsChanged || this._transformsChanged || this.skipTransitions; // debug
    // - - - - - - - - - - - - - - - - -
    // if (flags & View.MODEL_INVALID) {
    // 	console.group(this.cid + "::renderFrame model changed:");
    // 	Object.keys(this.model.changed).forEach(function(key) {
    // 		console.log("\t%s: %s -> %s", key, this.model._previousAttributes[key], this.model.changed[key]);
    // 	}, this);
    // 	console.groupEnd();
    // }
    // model:children
    // - - - - - - - - - - - - - - - - -

    if (childrenChanged) {
      this.removeChildren();

      if (bundles.selected) {
        this.createChildren(bundles.selected);
      } else if (articles.selected) {
        this.createChildren(articles.selected);
      }
    } // model:collapsed
    // - - - - - - - - - - - - - - - - -


    if (collapsedChanged) {
      this.el.classList.toggle("container-collapsed", collapsed);
      this.el.classList.toggle("container-expanded", !collapsed);
    } // size
    // - - - - - - - - - - - - - - - - -


    if (sizeChanged) {
      this.transforms.clearAllCaptures();
    } // transforms
    // - - - - - - - - - - - - - - - - -


    if (transformsChanged) {
      this.el.classList.remove("container-changing");

      if (this.skipTransitions) {
        this.transforms.stopAllTransitions();
        this.el.classList.remove("container-changed");

        if (!childrenChanged) {
          // this.transforms.clearAllOffsets();
          if (collapsedChanged) {
            this._setChildrenEnabled(collapsed);
          }
        }
      } else {
        if (!childrenChanged) {
          if (collapsedChanged) {
            var afterTransitionsFn;
            this.el.classList.add("container-changed"); // this.transforms.clearAllOffsets();

            if (collapsed) {
              // container-collapsed, enable last
              afterTransitionsFn = function afterTransitionsFn() {
                this._setChildrenEnabled(true);

                this.el.classList.remove("container-changed");
              };

              this.transforms.runAllTransitions(tx.LAST);
            } else {
              // container-expanded, disable first
              afterTransitionsFn = function afterTransitionsFn() {
                this.el.classList.remove("container-changed");
              };

              this._setChildrenEnabled(false);

              this.transforms.runAllTransitions(tx.FIRST);
            }

            afterTransitionsFn = afterTransitionsFn.bind(this);
            this.transforms.whenAllTransitionsEnd().then(afterTransitionsFn, afterTransitionsFn);
          } else {
            this.transforms.items.forEach(function (o) {
              if (o.hasOffset) {
                o.runTransition(tx.NOW); // o.clearOffset();
              }
            });
          }
        }
      }

      if (!childrenChanged) {
        this.transforms.clearAllOffsets();
      }

      this.transforms.validate();
    }

    if (sizeChanged) {
      this.itemViews.forEach(function (view) {
        view.skipTransitions = this.skipTransitions;
        view.requestRender(View.SIZE_INVALID).renderNow();
      }, this);
      /*Promise.all(this.itemViews.map(function(view) {
      		view.skipTransitions = this.skipTransitions;
      		return view.requestRender(View.SIZE_INVALID).whenRendered();
      	}, this))
      	.then(
      		function(views) {
      			var nh = this.el.offsetParent.offsetHeight - this.el.offsetTop;
      			// var oh = views.reduce(function(h, view) {
      			// 	return Math.max(h, view.el.offsetHeight);
      			// }, nh);
      			// oh++;
      			// console.log("%s:[whenRendered] [result: %s %s] %o", this.cid,
      			// 	nh, oh, this.el.parent, views);
      			this.el.style.minHeight = nh + "px";
      			return views;
      		}.bind(this),
      		function(reason) {
      			console.warn("%s:[whenRendered] [rejected] %o", this.cid, reason);
      			return reason;
      		}.bind(this)
      	);*/
    }

    this.skipTransitions = this._transformsChanged = false;
  },
  _setChildrenEnabled: function _setChildrenEnabled(enabled) {
    // if (enabled) {
    // 	this.el.removeEventListener("click", this._onCollapsedClick, false);
    // } else {
    // 	this.el.addEventListener("click", this._onCollapsedClick, false);
    // }
    this.itemViews.forEach(function (view) {
      view.setEnabled(enabled);
    });
  },

  /* -------------------------------
  /* Collapse UI gestures/events
  /* ------------------------------- */
  _onCollapsedEvent: function _onCollapsedEvent(ev) {
    console.log("%s:[%s -> _onCollapsedEvent] target: %s", this.cid, ev.type, ev.target);

    if (!ev.defaultPrevented && this.model.has("bundle") && !this.model.get("collapsed") && !this.enabled) {
      // this.setImmediate(function() {
      // if (ev.type == "click") ev.stopPropagation();
      ev.preventDefault();
      this.setImmediate(function () {
        // if (ev.type == "click") ev.stopPropagation();
        this.model.set("collapsed", true);
      }); // });
    }
  },

  /* --------------------------- *
  /* model changed
  /* --------------------------- */
  _onModelChange: function _onModelChange() {
    if (this.model.hasAnyChanged("bundle")) {
      if (this.model.has("bundle")) {
        this.vpan.on("vpanstart", this._onVPanStart);
      } else {
        this.vpan.off("vpanstart", this._onVPanStart);
      }
    }
    /*
    if (this.model.hasChanged("withBundle") ||
    	this.model.hasChanged("collapsed")) {
    	if (this.model.get("withBundle") &&
    		!this.model.get("collapsed")) {
    		this.hpan.on("hpanleft hpanright", this._onCollapsedEvent);
    		this.el.addEventListener(View.CLICK_EVENT, this._onCollapsedEvent, false);
    	} else {
    		this.hpan.off("hpanleft hpanright", this._onCollapsedEvent);
    		this.el.removeEventListener(View.CLICK_EVENT, this._onCollapsedEvent, false);
    	}
    }
    */


    this.requestRender(View.MODEL_INVALID);
  },

  /* -------------------------------
  /* Vertical touch/move (_onVPan*)
  /* ------------------------------- */
  _collapsedOffsetY: Globals.COLLAPSE_OFFSET,
  _onVPanStart: function _onVPanStart(ev) {
    this.vpan.on("vpanmove", this._onVPanMove);
    this.vpan.on("vpanend vpancancel", this._onVPanFinal);
    this.transforms.stopAllTransitions(); // this.transforms.clearAllOffsets();
    // this.transforms.validate();

    this.transforms.clearAllCaptures();
    this.el.classList.add("container-changing");

    this._onVPanMove(ev);
  },
  _onVPanMove: function _onVPanMove(ev) {
    var collapsed = this.model.get("collapsed");
    var delta = ev.deltaY; //ev.thresholdDeltaY;

    var maxDelta = this._collapsedOffsetY; // + Math.abs(ev.thresholdOffsetY);
    // check if direction is aligned with collapsed/expand

    var isValidDir = collapsed ? delta > 0 : delta < 0;
    var moveFactor = collapsed ? Globals.VPAN_DRAG : 1 - Globals.VPAN_DRAG;
    delta = Math.abs(delta); // remove sign

    delta *= moveFactor;
    maxDelta *= moveFactor;

    if (isValidDir) {
      if (delta > maxDelta) {
        // overshooting
        delta = (delta - maxDelta) * Globals.VPAN_OUT_DRAG + maxDelta;
      } else {// no overshooting
        // delta = delta;
      }
    } else {
      delta = -delta * Globals.VPAN_OUT_DRAG; // delta is opposite
    }

    delta *= collapsed ? 1 : -1; // reapply sign

    this.transforms.offsetAll(0, delta);
    this.transforms.validate();
  },
  _onVPanFinal: function _onVPanFinal(ev) {
    this.vpan.off("vpanmove", this._onVPanMove);
    this.vpan.off("vpanend vpancancel", this._onVPanFinal); // FIXME: model.collapsed may have already changed, _onVPanMove would run with wrong values:
    // model.collapsed is changed in a setImmediate callback from NavigationView.

    this._onVPanMove(ev);

    this.setImmediate(function () {
      this._transformsChanged = true;
      this.requestRender();
    });
  },
  // willCollapsedChange: function(ev) {
  // 	var collapsed = this.model.get("collapsed");
  // 	return ev.type == "vpanend"? collapsed?
  // 		ev.thresholdDeltaY > Globals.COLLAPSE_THRESHOLD :
  // 		ev.thresholdDeltaY < -Globals.COLLAPSE_THRESHOLD :
  // 		false;
  // },

  /* -------------------------------
  /* create/remove children on bundle selection
  /* ------------------------------- */

  /** Create children on bundle select */
  createChildren: function createChildren(model) {
    var view;

    if (model.__proto__.constructor === bundles.model) {
      // will be attached to dom in this order
      view = this.createMediaCaptionStack(model);
      this.itemViews.push(view);
      this.transforms.add(view.el);
      view = this.createMediaCarousel(model);
      this.itemViews.push(view);
      this.transforms.add(view.el);
      view = this.createMediaDotNavigation(model);
      this.itemViews.push(view);
    } else if (model.__proto__.constructor === articles.model) {
      view = this.createArticleView(model);
      this.itemViews.push(view);
    }

    this.itemViews.forEach(function (view) {
      if (!this.skipTransitions) {
        view.el.classList.add("adding-child");
        view.el.style.opacity = 0;
      }

      this.el.appendChild(view.el);
      view.render();
    }, this);

    if (!this.skipTransitions) {
      this.requestAnimationFrame(function () {
        console.log("%s::createChildren::[callback:requestAnimationFrame]", this.cid);
        this.itemViews.forEach(function (view) {
          if (!this.skipTransitions) {
            view.el.style[transitionProp] = "opacity " + tx.LAST.cssText;
          }

          view.el.style.removeProperty("opacity");
        }, this);
      });
    }
  },
  removeChildren: function removeChildren() {
    this.itemViews.forEach(function (view, i, arr) {
      this.transforms.remove(view.el);

      if (this.skipTransitions) {
        view.remove();
      } else {
        var s = window.getComputedStyle(view.el);

        if (s.opacity == "0" || s.visibility == "hidden") {
          console.log("%s::removeChildren [view:%s] removed immediately (invisible)", this.cid, view.cid);
          view.remove();
        } else {
          view.el.classList.add("removing-child");
          if (s[transformProp]) view.el.style[transformProp] = s[transformProp];
          view.el.style[transitionProp] = "opacity " + tx.FIRST.cssText;
          view.el.style.opacity = 0;
        }
      }

      arr[i] = null;
    }, this);
    this.itemViews.length = 0;
  },
  _onAddedTransitionEnd: function _onAddedTransitionEnd(ev) {
    if (ev.target.cid && this.childViews.hasOwnProperty(ev.target.cid)) {
      console.log("%s::_onAddedTransitionEnd [view:%s] [prop:%s] [ev:%s]", this.cid, ev.target.cid, ev.propertyName, ev.type);
      var view = this.childViews[ev.target.cid];
      view.el.classList.remove("adding-child");
      view.el.style.removeProperty(transitionProp);
    }
  },
  _onRemovedTransitionEnd: function _onRemovedTransitionEnd(ev) {
    if (ev.target.cid && this.childViews.hasOwnProperty(ev.target.cid)) {
      console.log("%s::_onRemovedTransitionEnd [view:%s] [prop:%s] [ev:%s]", this.cid, ev.target.cid, ev.propertyName, ev.type);
      var view = this.childViews[ev.target.cid];
      view.el.classList.remove("removing-child");
      view.remove();
    }
  },
  // purgeChildren: function() {
  // 	var i, el, els = this.el.querySelectorAll(".removing-child");
  // 	for (i = 0; i < els.length; i++) {
  // 		el = els.item(i);
  // 		if (el.parentElement === this.el) {
  // 			try {
  // 				console.error("%s::purgeChildren", this.cid, el.getAttribute("data-cid"));
  // 				View.findByElement(el).remove();
  // 			} catch (err) {
  // 				console.error("s::purgeChildren", this.cid, "orphaned element", err);
  // 				this.el.removeChild(el);
  // 			}
  // 		}
  // 	}
  // },

  /* -------------------------------
  /* Components
  /* ------------------------------- */

  /**
   * media-carousel
   */
  createMediaCarousel: function createMediaCarousel(bundle) {
    // Create carousel
    var EmptyRenderer = CarouselRenderer.extend({
      className: "carousel-item empty-item",
      model: bundle,
      template: carouselEmptyTemplate
    });

    var rendererFunction = function rendererFunction(item, index, arr) {
      if (index === -1) {
        return EmptyRenderer;
      }

      switch (item.attr("@renderer")) {
        case "video":
          return VideoRenderer;

        case "sequence":
          return SequenceRenderer;

        case "image":
          return ImageRenderer;

        default:
          return ImageRenderer;
      }
    };

    var view = new Carousel({
      className: "media-carousel " + bundle.get("domid"),
      collection: bundle.get("media"),
      rendererFunction: rendererFunction,
      requireSelection: !!bundle.attr("@no-desc"),
      // direction: Carousel.DIRECTION_HORIZONTAL,
      touch: this.hpan
    });
    controller.listenTo(view, {
      "view:select:one": function viewSelectOne(model) {
        console.log("%s:[view:select:one] %s", view.cid, model.cid);
        controller.selectMedia(model);
      },
      "view:select:none": controller.deselectMedia // "view:removed": controller.stopListening

    });
    view.listenTo(bundle, "deselected", function () {
      this.stopListening(this.collection);
      controller.stopListening(this);
    });
    return view;
  },

  /**
   * media-caption-stack
   */
  createMediaCaptionStack: function createMediaCaptionStack(bundle) {
    var view = new CollectionStack({
      className: "media-caption-stack",
      collection: bundle.get("media"),
      template: mediaStackTemplate
    });
    view.listenTo(bundle, "deselected", function () {
      this.stopListening(this.collection);
    });
    return view;
  },

  /**
   * media-dotnav
   */
  createMediaDotNavigation: function createMediaDotNavigation(bundle) {
    var view = new SelectableListView({
      className: "media-dotnav dots-fontface color-fg05",
      collection: bundle.get("media"),
      renderer: DotNavigationRenderer
    });
    controller.listenTo(view, {
      "view:select:one": controller.selectMedia,
      "view:select:none": controller.deselectMedia // "view:removed": controller.stopListening

    });
    view.listenTo(bundle, "deselected", function () {
      this.stopListening(this.collection);
      controller.stopListening(this);
    });
    return view;
  },

  /**
   * @param el {module:app/model/item/ArticleView}
   * @return {module:app/view/base/View}
   */
  createArticleView: function createArticleView(article) {
    var view = new ArticleView({
      model: article
    });
    return view;
  } // createProgressWrapper: function() {
  // 	// var view = new ProgressMeter({
  // 	// 	id: "media-progress-wrapper",
  // 	// 	// className: "color-bg color-fg05",
  // 	// 	useOpaque: false,
  // 	// 	labelFn: function() { return "0%"; }
  // 	// });
  // 	// this.el.appendChild(this.progressWrapper.el);
  // 	// return view;
  // 	return null;
  // },

});

}).call(this,require("underscore"))

},{"./template/Carousel.EmptyRenderer.Bundle.hbs":120,"./template/CollectionStack.Media.hbs":121,"app/control/Controller":54,"app/control/Globals":55,"app/model/collection/ArticleCollection":63,"app/model/collection/BundleCollection":64,"app/view/base/View":82,"app/view/component/ArticleView":86,"app/view/component/Carousel":88,"app/view/component/CollectionStack":90,"app/view/component/SelectableListView":95,"app/view/render/CarouselRenderer":105,"app/view/render/DotNavigationRenderer":110,"app/view/render/ImageRenderer":112,"app/view/render/SequenceRenderer":117,"app/view/render/VideoRenderer":119,"underscore":51,"utils/TransformHelper":127}],76:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/NavigationView
 */

/** @type {module:hammerjs} */

var Hammer = require("hammerjs");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:utils/TransformHelper} */


var TransformHelper = require("utils/TransformHelper"); // /** @type {module:app/view/base/TouchManager} */
// var TouchManager = require("app/view/base/TouchManager");

/** @type {module:app/control/Controller} */


var controller = require("app/control/Controller");
/** @type {module:app/model/collection/TypeCollection} */


var types = require("app/model/collection/TypeCollection");
/** @type {module:app/model/collection/KeywordCollection} */


var keywords = require("app/model/collection/KeywordCollection");
/** @type {module:app/model/collection/BundleCollection} */


var bundles = require("app/model/collection/BundleCollection");
/** @type {module:app/model/collection/ArticleCollection} */


var articles = require("app/model/collection/ArticleCollection");
/** @type {module:app/view/base/View} */


var View = require("app/view/base/View");
/** @type {module:app/view/component/FilterableListView} */


var FilterableListView = require("app/view/component/FilterableListView");
/** @type {module:app/view/component/GroupingListView} */


var GroupingListView = require("app/view/component/GroupingListView"); // /** @type {module:app/view/component/CollectionPager} */
// var CollectionPager = require("app/view/component/CollectionPager");

/** @type {module:app/view/component/GraphView} */


var GraphView = require("app/view/component/GraphView");
/** @type {module:app/view/component/ArticleButton} */


var ArticleButton = require("app/view/component/ArticleButton"); // /** @type {module:utils/prefixedProperty} */
// var prefixedProperty = require("utils/prefixedProperty");
// var traceElement = require("utils/debug/traceElement");


var tx = Globals.transitions;

var txNow = _.clone(tx.NOW);

txNow.easing = "ease"; // var hTx = _.clone(collapsed ? tx.LAST : tx.FIRST);
// hTx.easing = "ease";

/**
 * @constructor
 * @type {module:app/view/NavigationView}
 */

module.exports = View.extend({
  // /** @override */
  // tagName: "div",

  /** @override */
  cidPrefix: "navigationView",

  /** @override */
  className: "navigation container-expanded",

  /** @override */
  initialize: function initialize(options) {
    _.bindAll(this, "_onVPanStart", "_onVPanMove", "_onVPanFinal");

    _.bindAll(this, "_onHPanStart", "_onHPanMove", "_onHPanFinal");

    _.bindAll(this, "_onNavigationClick"); // _.bindAll(this, "_whenTransitionsEnd", "_whenTransitionsAbort");
    // _.bindAll(this, "_whenListsRendered");
    // this._metrics = {
    // 	minHeight: 0
    // };


    this.itemViews = [];
    this.transforms = new TransformHelper(); // this.touch = options.touch || new Error("no touch"); //TouchManager.getInstance();

    this.vpan = options.vpan || new Error("no vpan");
    this.hpan = options.hpan || new Error("no hpan");
    this.listenTo(this.model, "change", this._onModelChange);
    this.listenTo(keywords, "select:one select:none", this._onKeywordSelect); // this.listenTo(this.model, "withBundle:change", this._onwithBundleChange);

    this.vpanGroup = this.el.querySelector("#vpan-group"); // this.el.style.touchAction = "none";
    // this.el.style.webkitUserSelect = "none";
    // this.el.style.webkitUserDrag = "none";

    this.keywordList = this.createKeywordList();
    this.bundleList = this.createBundleList();
    this.itemViews.push(this.keywordList);
    this.itemViews.push(this.bundleList);
    this.graph = this.createGraphView(this.bundleList, this.keywordList, this.vpanGroup);
    this.sitename = this.createSitenameButton();
    this.about = this.createAboutButton();
    /* NOTE: .list-group .label moves horizontally (cf. sass/layouts/*.scss) */

    this.hGroupings = this.keywordList.el.querySelectorAll(".list-group .label");
    this.transforms.add(this.vpanGroup, this.bundleList.wrapper, this.keywordList.wrapper, this.bundleList.el, this.keywordList.el, this.hGroupings, this.sitename.wrapper, this.about.wrapper, this.sitename.el, this.about.el, this.graph.el); // this.itemViews.push(this.graph);
    // this.listenTo(this.graph, {
    // 	"canvas:update": this._onGraphUpdate,
    // 	"canvas:redraw": this._onGraphRedraw,
    // });

    /*this.listenTo(this.graph, "view:render:before", function(view, flags) {
    	var vmax;
    	if (!view.el.style.height) {
    		// if (flags & (View.SIZE_INVALID | View.MODEL_INVALID)) {
    		// if ((this.bundleList.renderFlags | View.SIZE_INVALID) ||
    		// 	(this.keywordList.renderFlags | View.SIZE_INVALID)) {
    		// }
    		vmax = Math.max(
    			this.bundleList._metrics.height,
    			this.keywordList._metrics.height
    		);
    		if (_.isNumber(vmax)) {
    			view.el.style.height = vmax + "px";
    			console.log("%s:[view:render:before][once]:%s [%s] heights:[%i, %i] (max %i)",
    				this.cid, view.cid, View.flagsToString(flags),
    				this.bundleList._metrics.height,
    				this.keywordList._metrics.height,
    				vmax);
    		}
    	}
    });*/
    // this.listenTo(this.bundleList, "view:render:after", function(view, flags) {
    // 	console.info("%s:[view:render:after %s]", this.cid, view.cid, View.flagsToString(flags & View.SIZE_INVALID));
    // 		if (flags & View.SIZE_INVALID) {
    // 			// console.info("%s:[%s view:render:after] bundleList height", this.cid, view.cid, this.bundleList.el.style.height);
    // 			// this.graph.el.style.height = this.bundleList.el.style.height;
    // 			this.graph.el.style.opacity = this.bundleList.collapsed? 0 : 1;
    // 			this.graph.requestRender(View.SIZE_INVALID).renderNow();
    // 	// 	}
    // });
    // this.listenTo(this.bundleList, "view:render:after", this._onListResize);
    // this.listenTo(this.keywordList, "view:render:after", this._onListResize);
  },

  /* --------------------------- *
  /* Render
  /* --------------------------- */
  renderFrame: function renderFrame(tstamp, flags) {
    if (flags & View.MODEL_INVALID) {
      if (this.model.hasChanged("collapsed")) {
        this.el.classList.toggle("container-collapsed", this.model.get("collapsed"));
        this.el.classList.toggle("container-expanded", !this.model.get("collapsed"));
      }

      if (this.model.hasChanged("collapsed") || this.model.hasChanged("withBundle")) {
        this.el.classList.add("container-changing");
      }

      if (this.model.hasChanged("routeName")) {
        this.bundleList.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
        this.keywordList.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
      }
    } // transforms
    // - - - - - - - - - - - - - - - - -


    if (this.skipTransitions || flags & View.ALL_INVALID) {
      // (flags & (View.MODEL_INVALID | View.SIZE_INVALID | View.LAYOUT_INVALID))) {
      // if (transformsChanged) {
      if (this.skipTransitions) {
        this.transforms.stopAllTransitions();
        this.transforms.validate();
        this.transforms.clearAllOffsets();
      } else {
        this.renderTransitions(flags);
      }

      this.transforms.validate(); // console.log("%s::renderFrame %o", this.cid,
      // 	this.transforms.items.map(function(o) {
      // 		return traceElement(o.el) + ":" +
      // 			(o.hasTransition ? o.transition.name : "-");
      // 	}));
    } // if (this.model.hasChanged("collapsed") && this.model.get("collapsed")) {
    // 	this.el.style.height = "";
    // 	// this.el.style.minHeight = hval + "px";
    // 	this.graph.el.style.height = "";
    // }
    // promise handlers
    // - - - - - - - - - - - - - - - - -


    var measureRenderedLists = function (result) {
      // var hval = result.reduce(function(a, o) {
      // 	return Math.max(a, o.metrics.height);
      // }, 0);
      var hval = Math.max(this.bundleList.metrics.height, this.keywordList.metrics.height);

      if (this.model.get("collapsed")) {
        this.el.style.height = ""; // this.el.style.minHeight = hval + "px";

        this.graph.el.style.height = "";
      } else {
        this.el.style.height = hval + "px"; // this.el.style.minHeight = "";

        this.graph.el.style.height = hval + "px";
      } // this.el.style.height = this.model.get("collapsed") ? "" : "100%";
      // this.vpanGroup.style.height = hval;


      this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
      console.log("%s:[whenListsRenderedDone] height set to %s", this.cid, this.model.get("collapsed") ? hval + "px" : "[not set]", result);
      this.trigger("view:collapsed:measured", this);
      return result;
    }.bind(this);

    var toggleGraph = function (result) {
      this.graph.enabled = !this.model.get("collapsed");
      this.graph.valueTo("a2b", 0, 0);

      if (!this.model.get("collapsed")) {
        this.graph.valueTo("a2b", 1, Globals.TRANSITION_DURATION);
      }

      return result;
    }.bind(this);

    var whenCollapsedChangeDone = function (result) {
      console.log("%s:[whenCollapsedChangeDone][flags: %s]", this.cid, View.flagsToString(flags), result);
      this.el.classList.remove("container-changing");
      this.trigger("view:collapsed:end", this);
      return result;
    }.bind(this); // promises
    // - - - - - - - - - - - - - - - - -


    var p; // p = Promise.all([
    // 		this.bundleList.whenRendered(),
    // 		this.keywordList.whenRendered(),
    // 		this.bundleList.whenCollapseChangeEnds(),
    // 		this.keywordList.whenCollapseChangeEnds(),
    // 		this.transforms.whenAllTransitionsEnd(),
    // 	]);

    p = Promise.all([this.bundleList.whenCollapseChangeEnds(), this.keywordList.whenCollapseChangeEnds()]).then(measureRenderedLists);

    if (flags & View.MODEL_INVALID && this.model.hasChanged("collapsed")) {
      p = p.then(toggleGraph);
    }

    p.then(this.transforms.whenAllTransitionsEnd()).then(whenCollapsedChangeDone).catch(function (reason) {
      console.warn("%s::renderFrame promise rejected", this.cid);
    }.bind(this));
    /*
    var whenListsRendered = Promise.all([
    	this.bundleList.whenRendered(),
    	this.keywordList.whenRendered()
    ]);
    	var whenTransformsEnd = this.transforms.promise();
    	whenListsRendered.then(
    	whenListsRenderedDone,
    	function(reason) {
    		console.warn("%s:[whenListsRendered] failed: %o", this.cid, reason);
    		return reason;
    	}.bind(this)
    );
    	Promise.all([
    	whenListsRendered,
    	whenTransformsEnd
    ])
    	.then(
    		function(result) {
    			console.log("%s:[whenListsRendered+whenTransformsEnd] [%s]", this.cid, View.flagsToString(flags), result);
    			this.el.classList.remove("container-changing");
    			this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
    		}.bind(this),
    		function(reason) {
    			console.warn("%s:[whenListsRendered+whenTransformsEnd] [%s]", this.cid, View.flagsToString(flags), reason);
    			this.el.classList.remove("container-changing");
    			this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
    		}.bind(this)
    	);*/
    // trace result handlers
    // - - - - - - - - - - - - - - - - -

    /*if (this.model.hasChanged("collapsed")) {
    	var msgBase = this.model.get("collapsed") ? "collaps" : "expand";
    	Promise.all([
    		Promise.all([
    				this.bundleList.whenRendered(),
    				this.keywordList.whenRendered()
    			])
    			.then(
    				function() {
    					console.log("nav-tx:%sing", msgBase, arguments);
    				}),
    		this.transforms.promise()
    	])
    		.catch(
    			function() {
    				console.warn("nav-tx:%sed [rejected]", msgBase, arguments);
    			})
    		.finally(
    			function() {
    				console.log("nav-tx:%sed", msgBase, arguments);
    			}
    		);
    }*/
    // graph
    // - - - - - - - - - - - - - - - - -
    // if ((flags & (View.SIZE_INVALID | ~View.MODEL_INVALID))
    // 	/* collapsed has not changed, no bundle selected */
    // 	&& !this.model.hasChanged("collapsed")
    // 	&& !this.model.get("withBundle")) {
    // 	this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
    // 	if (!this.skipTransitions) {
    // 		this.graph.renderNow();
    // 	}
    // }
    // else
    // if ((flags & View.SIZE_INVALID) && !this.model.get("collapsed")) {
    // 	/* NavigationView has resized while uncollapsed,
    // 	but model is unchanged */
    // 	this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
    // }
    // children loop
    // - - - - - - - - - - - - - - - - -

    this.itemViews.forEach(function (view) {
      // view.skipTransitions = view.skipTransitions || this.skipTransitions;
      if (this.skipTransitions) {
        view.skipTransitions = true;
      }

      if (flags & View.SIZE_INVALID) {
        view.requestRender(View.SIZE_INVALID);
      } // if (!view.skipTransitions) {


      view.renderNow(); // }
    }, this);
    this.requestAnimationFrame(function () {
      this.skipTransitions = false;
    });
  },

  /*_whenListsRendered: function(result) {
  	var hval;
  	if (this.model.get("collapsed")) {
  		this.el.style.height = "";
  		// this.graph.el.style.height = "100%";
  	} else {
  		// hval = result.reduce(function(a, o) {
  		// 	return Math.max(a, o.metrics.height);
  		// }, 0);
  		hval = Math.max(
  			this.bundleList.metrics.height,
  			this.keywordList.metrics.height);
  		this.el.style.height = hval + "px";
  		// this.graph.el.style.height = hval + "px";
  	}
  	this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID).renderNow();
  	console.log("%s:[_whenListsRendered] height set to %opx", this.cid, hval ? hval : "[empty]", arguments);
  	return result
  },
  	_whenTransitionsEnd: function(result) {
  	console.info("%s::_whenTransitionsEnd", this.cid);
  	this.el.classList.remove("container-changing");
  	// if (!Globals.BREAKPOINTS["medium-wide"].matches)
  	// 	return;
  	// if (!this.model.get("collapsed")) {
  	// 	this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID); //.renderNow();
  	// }
  	return result;
  },
  	_whenTransitionsAbort: function(reason) {
  	console.warn("%s::_whenTransitionsAbort %o", this.cid, reason);
  	this.el.classList.remove("container-changing");
  	// if (!Globals.BREAKPOINTS["medium-wide"].matches)
  	// 	return;
  	// if (!this.model.get("collapsed")) {
  	// 	this.graph.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID); //.renderNow();
  	// }
  	return result;
  },*/

  /* -------------------------------
  /* renderTransitions
  /* ------------------------------- */
  renderTransitions: function renderTransitions(flags) {
    var modelChanged = flags & View.MODEL_INVALID;
    var fromRoute = this.model.get("fromRouteName");
    var toRoute = this.model.get("routeName");
    var routeChanged = modelChanged && this.model.hasChanged("routeName");
    /* bundle */

    var withBundle = this.model.has("bundle");
    var withBundleChanged = modelChanged && this.model.hasAnyChanged("bundle");
    var bundleChanged = modelChanged && this.model.hasChanged("bundle");
    /* media */

    var withMedia = this.model.has("media");
    var withMediaChanged = modelChanged && this.model.hasAnyChanged("media"); //var mediaChanged = modelChanged && this.model.hasChanged("media");

    /* article */
    // var withArticle = this.model.has("article");

    var withArticleChanged = modelChanged && this.model.hasAnyChanged("article"); //var articleChanged = modelChanged && this.model.hasChanged("article");

    /* collapsed */

    var collapsed = this.model.get("collapsed");
    var collapsedChanged = modelChanged && this.model.hasChanged("collapsed");
    var tf;
    /* this.vpanGroup */

    tf = this.transforms.get(this.vpanGroup);

    if (tf && tf.hasOffset) {
      tf.runTransition(collapsedChanged ? tx.BETWEEN : tx.NOW);
      tf.clearOffset();
    }
    /* this.bundleList.el */
    // tf = this.transforms.get(this.bundleList.el);
    // if (tf.hasOffset) {
    // 	tf.runTransition(collapsedChanged ? tx.BETWEEN : tx.NOW);
    // 	tf.clearOffset();
    // }

    /* this.keywordList.el */
    // tf = this.transforms.get(this.keywordList.el);
    // if (tf.hasOffset) {
    // 	tf.runTransition(collapsedChanged ? tx.BETWEEN : tx.NOW);
    // 	tf.clearOffset();
    // }

    /* this.graph.el */
    // tf = this.transforms.get(this.graph.el);
    // if (tf && tf.hasOffset) {
    // 	tf.runTransition(collapsedChanged ? tx.BETWEEN : tx.NOW);
    // 	tf.clearOffset();
    // }

    /*
     * NOTE:
     * Vertical:
     *		site-name-wrapper,
     *		article-list-wrapper
     * Horizontal:
     *		site-name,
     *		article-buttons,
     *		keywordList.wrapper,
     *		bundleList.wrapper,
     *		hGroupings
     */


    if (Globals.BREAKPOINTS["medium-wide"].matches) {
      /* HORIZONTAL: keywordList.wrapper */
      tf = this.transforms.get(this.keywordList.wrapper);

      if (collapsedChanged && !withArticleChanged) {
        // if (collapsedChanged) {
        if (withBundleChanged) {
          if (withMediaChanged) tf.runTransition(withBundle ? tx.LAST : tx.FIRST);
        } else {
          if (withMedia) tf.runTransition(collapsed ? tx.LAST : tx.FIRST);
        }
      } else {
        if (!withBundleChanged && withMediaChanged) tf.runTransition(bundleChanged ? tx.BETWEEN : txNow); //tx.NOW);
      }

      if (tf.hasOffset) tf.clearOffset();
      /* HORIZONTAL: the rest */

      if (collapsedChanged ^ withArticleChanged) {
        this.transforms.runTransition(collapsed ? tx.LAST : tx.FIRST, this.sitename.el, this.about.el, this.bundleList.wrapper); // if (fromRoute != 'article-item' && toRoute != 'media-item') {

        this.transforms.runTransition(collapsed ? tx.LAST : tx.FIRST, this.hGroupings); // }
      }
      /* VERTICAL */


      if (routeChanged && (fromRoute == 'root' || toRoute == 'root')) {
        this.transforms.runTransition(tx.BETWEEN, this.sitename.wrapper, this.about.wrapper);
      }
      /* this.hGroupings */
      // if (collapsedChanged ^ withArticleChanged) {
      // 	// if (collapsedChanged && !withArticleChanged) {
      // 	this.transforms.runTransition(collapsed ? tx.LAST : tx.FIRST, this.hGroupings);
      // }
      // if (collapsedChanged) {
      // 	if (!withArticleChanged) {
      // 		// if (fromRoute == 'root' || toRoute == 'root') {
      // 		this.transforms.runTransition(collapsed ? tx.LAST : tx.FIRST, this.bundleList.wrapper);
      // 	}
      // } else {
      // 	if (withArticleChanged && withBundleChanged) {
      // 		this.transforms.runTransition(withArticle ? tx.BETWEEN : tx.LAST, this.bundleList.wrapper);
      // 	}
      // }

    } else if (Globals.BREAKPOINTS["small-stretch"].matches) {
      // if (collapsedChanged ) {
      if (collapsedChanged ^ withArticleChanged) {
        this.transforms.runTransition(collapsed ? tx.FIRST : tx.LAST, this.sitename.el, this.about.el);
      }
    } else {
      if (withBundleChanged) {
        this.transforms.runTransition(tx.BETWEEN, this.sitename.el, this.about.el);
      }
    } // this.transforms.clearOffset(
    // 	// this.bundleList.el,
    // 	// this.keywordList.el,
    // 	this.bundleList.wrapper);

  },

  /* --------------------------- *
  /* own model changed
  /* --------------------------- */
  _onModelChange: function _onModelChange() {
    // 	this.setImmediate(this.commitModel);
    // },
    //
    // commitModel: function() {
    // this.requestRender(View.MODEL_INVALID | View.LAYOUT_INVALID);
    this.requestRender(View.MODEL_INVALID); // keywords.deselect();

    if (this.model.hasChanged("collapsed")) {
      if (this.model.get("collapsed")) {
        // clear keyword selection
        keywords.deselect();
      } // else {}


      this.keywordList.collapsed = this.model.get("collapsed");
      this.bundleList.collapsed = this.model.get("collapsed");
    }

    if (this.model.hasChanged("bundle")) {
      this.bundleList.selectedItem = this.model.get("bundle");
      this.keywordList.refreshFilter(); // if (!this.model.get("collapsed") && this.graph) {
      // 	this.listenToOnce(this.keywordList, "view:render:after", function(view, flags) {
      // 		console.log("%s::_onBundleSelect -> %s:[view:render:after] flags:%s", this.cid, view.cid, View.flagsToString(flags));
      // 		this.graph.valueTo( "a2b", 0,  0);
      // 		// this.graph.renderNow();
      // 		this.graph.valueTo( "a2b", 1,  Globals.TRANSITION_DURATION);
      // 	});
      // }
      // keywords.deselect();
      // this.graph && this.graph.requestRender(View.SIZE_INVALID);
    } // var clickEv = "click";//View.CLICK_EVENT


    if (this.model.hasChanged("withBundle")) {
      // this.keywordList.refreshFilter()
      if (this.model.get("withBundle")) {
        this.el.addEventListener(View.CLICK_EVENT, this._onNavigationClick);
        this.vpan.on("vpanstart", this._onVPanStart);
        this.hpan.on("hpanstart", this._onHPanStart); // this.hpan.on("tap", this._onTap);
      } else {
        this.el.removeEventListener(View.CLICK_EVENT, this._onNavigationClick);
        this.vpan.off("vpanstart", this._onVPanStart);
        this.hpan.off("hpanstart", this._onHPanStart);
        keywords.deselect(); // this.hpan.off("tap", this._onTap);
      } // this.graph.valueTo()

    }
  },
  // _onwithBundleChange: function(withBundle) {
  // 	if (withBundle) {
  // 		this.listenTo(this.model, "collapsed:change", function(collapsed){
  //
  // 		});
  // 	} else {
  // 		this.stopListening(this.model, "collapsed:change", function(collapsed){
  //
  // 		});
  // 	}
  // },

  /* --------------------------- *
  /* keyword collection changed
  /* --------------------------- */
  _onKeywordSelect: function _onKeywordSelect(keyword) {
    // use collection listener to avoid redundant refreshFilter calls
    if (!this.model.get("collapsed") && this.graph) {
      this.listenToOnce(this.bundleList, "view:render:after", function (view, flags) {
        // console.log("%s::_onKeywordSelect -> %s:[view:render:after] flags:%s", this.cid, view.cid, View.flagsToString(flags));
        this.graph.valueTo("b2a", 0, 0);
        this.graph.valueTo("b2a", 1, Globals.TRANSITION_DURATION);
      });
    }

    this.bundleList.refreshFilter();
  },

  /* --------------------------- *
  /* UI Events: bundleList keywordList buttons
  /* --------------------------- */
  _onNavigationClick: function _onNavigationClick(ev) {
    console.log("%s::_onNavigationClick [%s] defaultPrevented:%s", this.cid, ev.type, ev.defaultPrevented);
    if (ev.defaultPrevented) return; // if (ev.target !== this.graph.el && ev.target !== this.el) return;

    ev.preventDefault();

    if (this.model.has("bundle")) {
      // this.transforms.offset(0, 1, this.graph.el);
      // this.transforms.validate();
      // this._setCollapsed(!this.model.get("collapsed"));
      // this.setImmediate(function() {
      this.model.set("collapsed", !this.model.get("collapsed")); // });
    }
  },
  _setCollapsed: function _setCollapsed(value) {
    if (value !== this.model.get("collapsed")) {
      // this.transforms.offset(0, 1, this.graph.el);
      // this.transforms.validate();
      this.setImmediate(function () {
        // console.log("%s::_setCollapsed -> %s (setImmediate)", this.cid, value);
        this.model.set("collapsed", value);
      });
    }
  },

  /* -------------------------------
  /* Horizontal touch/move (HammerJS)
  /* ------------------------------- */
  _onHPanStart: function _onHPanStart(ev) {
    this.transforms.get(this.keywordList.wrapper).stopTransition().clearOffset().validate(); // if (this.model.get("layoutName") != "left-layout"
    // 	&& this.model.get("layoutName") != "default-layout") {
    // 	return;
    // }

    if (Globals.BREAKPOINTS["medium-wide"].matches && this.model.get("bundle").get("media").selectedIndex <= 0 && this.model.get("collapsed")) {
      this.transforms.get(this.keywordList.wrapper).clearCapture();

      this._onHPanMove(ev);

      this.hpan.on("hpanmove", this._onHPanMove);
      this.hpan.on("hpanend hpancancel", this._onHPanFinal);
    }
  },
  _onHPanMove: function _onHPanMove(ev) {
    // var HPAN_DRAG = 1;
    // var HPAN_DRAG = 0.75;
    var HPAN_DRAG = 720 / 920;
    var delta = ev.deltaX; //ev.thresholdDeltaX;
    // var mediaItems = this.model.get("bundle").get("media");

    if (this.model.has("media")) {
      delta *= ev.offsetDirection & Hammer.DIRECTION_LEFT ? 0.0 : HPAN_DRAG;
    } else {
      delta *= ev.offsetDirection & Hammer.DIRECTION_LEFT ? HPAN_DRAG : Globals.HPAN_OUT_DRAG;
    }

    this.transforms.offset(delta, null, this.keywordList.wrapper);
    this.transforms.validate();
  },
  _onHPanFinal: function _onHPanFinal(ev) {
    this.hpan.off("hpanmove", this._onHPanMove);
    this.hpan.off("hpanend hpancancel", this._onHPanFinal);
    /* NOTE: if there is no model change, set tx here. Otherwise just wait for render */

    var kTf = this.transforms.get(this.keywordList.wrapper);

    if (!(this._renderFlags & View.MODEL_INVALID) && kTf.hasOffset) {
      if (kTf.offsetX != 0) {
        kTf.runTransition(tx.NOW);
      }

      kTf.clearOffset().validate();
    }
  },

  /* -------------------------------
  /* Vertical touch/move (_onVPan*)
  /* ------------------------------- */
  _collapsedOffsetY: Globals.COLLAPSE_OFFSET,
  _onVPanStart: function _onVPanStart(ev) {
    this.vpan.on("vpanmove", this._onVPanMove);
    this.vpan.on("vpanend vpancancel", this._onVPanFinal);
    this.transforms.stopTransition(this.vpanGroup);
    this.transforms.clearCapture(this.vpanGroup); // this.transforms.stopTransition(this.bundleList.el, this.keywordList.el); //, this.graph.el);
    // // this.transforms.clearOffset(this.bundleList.el, this.keywordList.el);
    // // this.transforms.validate();
    // this.transforms.clearCapture(this.bundleList.el, this.keywordList.el); //, this.graph.el);
    //
    // if (!this.model.get("collapsed")) {
    // 	this.transforms.stopTransition(this.graph.el);
    // 	this.transforms.clearCapture(this.graph.el);
    // }
    // // this.el.classList.add("container-changing");
    // this._onVPanMove(ev);
  },
  _onVPanMove: function _onVPanMove(ev) {
    var delta = this._computeVPanDelta(ev.deltaY); //ev.thresholdDeltaY);


    this.transforms.offset(0, delta, this.vpanGroup); // this.transforms.offset(0, delta,
    // 	this.bundleList.el, this.keywordList.el);
    // if (!this.model.get("collapsed")) {
    // 	this.transforms.offset(0, delta, this.graph.el);
    // }

    this.transforms.validate();
  },
  _onVPanFinal: function _onVPanFinal(ev) {
    this.vpan.off("vpanmove", this._onVPanMove);
    this.vpan.off("vpanend vpancancel", this._onVPanFinal); // this._onVPanMove(ev);
    // this.transforms.validate();

    this.setImmediate(function () {
      // this.transforms.clearOffset(this.bundleList.el, this.keywordList.el, this.graph.el);
      if (this.willCollapsedChange(ev)) {
        // this._setCollapsed(!this.model.get("collapsed"));
        this.model.set("collapsed", !this.model.get("collapsed"));
      }

      this.requestRender(View.LAYOUT_INVALID); //.renderNow();
    });
  },
  willCollapsedChange: function willCollapsedChange(ev) {
    return ev.type == "vpanend" ? this.model.get("collapsed") ? ev.deltaY > Globals.COLLAPSE_THRESHOLD : ev.deltaY < -Globals.COLLAPSE_THRESHOLD : false;
  },
  _computeVPanDelta: function _computeVPanDelta(delta) {
    var collapsed = this.model.get("collapsed");
    var maxDelta = this._collapsedOffsetY; // + Math.abs(ev.thresholdOffsetY);
    // check if direction is aligned with collapsed/expand

    var isValidDir = collapsed ? delta > 0 : delta < 0;
    var moveFactor = collapsed ? 1 - Globals.VPAN_DRAG : Globals.VPAN_DRAG;
    delta = Math.abs(delta); // remove sign

    delta *= moveFactor;
    maxDelta *= moveFactor;

    if (isValidDir) {
      if (delta > maxDelta) {
        // overshooting
        delta = (delta - maxDelta) * Globals.VPAN_OUT_DRAG + maxDelta;
      } else {// no overshooting
        // delta = delta;
      }
    } else {
      delta = -delta * Globals.VPAN_OUT_DRAG; // delta is opposite
    }

    delta *= collapsed ? 0.5 : -1; // reapply sign

    return delta;
  },

  /* -------------------------------
  /* Create children components
  /* ------------------------------- */
  // -------------------------------
  // #site-name
  // -------------------------------
  createSitenameButton: function createSitenameButton() {
    var view = new View({
      el: "#site-name",
      events: {
        "click a": function clickA(domev) {
          domev.defaultPrevented || domev.preventDefault();
          this.trigger("view:click");
        }
      }
    });
    view.wrapper = view.el.parentElement;
    this.listenTo(view, "view:click", this._onSitenameClick);
    return view;
  },
  _onSitenameClick: function _onSitenameClick() {
    switch (this.model.get("routeName")) {
      case "media-item":
      case "bundle-item":
        // if (this.model.get("collapsed")) {
        // 	this._setCollapsed(false);
        // } else {
        controller.deselectBundle(); // }

        break;

      case "article-item":
        controller.deselectArticle();
        break;
    }
  },
  // -------------------------------
  // .article-button
  // -------------------------------
  createArticleButton: function createArticleButton(articleItem) {
    var view = new ArticleButton({
      el: ".article-button[data-handle='about']",
      model: articleItem
    }).render();
    view.wrapper = view.el.parentElement;
    this.listenTo(view, "view:click", this._onArticleClick);
    return view;
  },
  _onArticleClick: function _onArticleClick(item) {
    switch (this.model.get("routeName")) {
      case "article-item":
        controller.deselectArticle();
        break;

      case "root":
      default:
        controller.selectArticle(item);
        break;
    }
  },
  createAboutButton: function createAboutButton() {
    return this.createArticleButton(articles.findWhere({
      handle: "about"
    }));
  },
  // -------------------------------
  // #bundle-list
  // -------------------------------

  /**
   * @param el {HTMLElement}
   * @return {module:app/base/view/component/FilterableListView}
   */
  createBundleList: function createBundleList(el) {
    var view = new FilterableListView({
      el: "#bundle-list",
      collection: bundles,
      collapsed: false,
      filterFn: function filterFn(bundle, index, arr) {
        return keywords.selected ? bundle.get("kIds").indexOf(keywords.selected.id) !== -1 : false;
      }
    });
    view.wrapper = view.el.parentElement;
    this.listenTo(view, "view:select:one view:select:none", function (bundle) {
      this.setImmediate(function () {
        controller.selectBundle(bundle);
      });
    });
    this.listenTo(view, "view:select:same", this._onBundleListSame);
    return view;
  },
  _onBundleListSame: function _onBundleListSame(bundle) {
    // this.transforms.offset(0, 1, this.graph.el);
    // this.transforms.validate();
    // this.setImmediate(function() {
    this.model.set("collapsed", !this.model.get("collapsed")); // });
  },
  // -------------------------------
  // #keyword-list
  // -------------------------------

  /**
   * @param el {HTMLElement}
   * @return {module:app/base/view/component/GroupingListView}
   */
  createKeywordList: function createKeywordList(el) {
    var view = new GroupingListView({
      el: "#keyword-list",
      collection: keywords,
      collapsed: false,
      filterFn: function filterFn(item, idx, arr) {
        return bundles.selected ? bundles.selected.get("kIds").indexOf(item.id) !== -1 : false;
      },
      groupingFn: function groupingFn(item, idx, arr) {
        return types.get(item.get("tId"));
      }
    });
    view.wrapper = view.el.parentElement;
    view.listenTo(keywords, "select:one select:none", function (item) {
      view.selectedItem = item;
    });
    this.listenTo(view, "view:select:one view:select:none", this._onKeywordListChange);
    return view;
  },
  _onKeywordListChange: function _onKeywordListChange(keyword) {
    if (!this.model.get("collapsed")) {
      keywords.select(keyword);
    }
  },
  // -------------------------------
  // #nav-graph
  // -------------------------------

  /**
   * @param listA {module:app/base/view/component/FilterableListView}
   * @param listB {module:app/base/view/component/FilterableListView}
   * @param parentEl {HTMLElement}
   * @return {module:app/base/view/component/GraphView}
   */
  createGraphView: function createGraphView(listA, listB, parentEl) {
    var view = new GraphView({
      id: "nav-graph",
      listA: listA,
      listB: listB,
      model: this.model,
      useOpaque: false
    });
    parentEl || (parentEl = this.el);
    parentEl.insertBefore(view.el, parentEl.firstElementChild);
    return view;
  }
  /* -------------------------------
  /* Horizontal touch/move (MutationObserver)
  /* ------------------------------- */

  /*
  _beginTransformObserve: function() {
  	if (!(Globals.BREAKPOINTS["medium-wide"].matches && this.model.get("bundle").get("media").selectedIndex <= 0 && this.model.get("collapsed"))) {
  		return;
  	}
  	var target = document.querySelector(".carousel > .empty-item");
  	if (target === null) {
  		return;
  	}
  	if (!this._transformObserver) {
  		this._transformObserver = new MutationObserver(this._onTransformMutation);
  	}
  	this._transformObserver.observe(target, { attributes: true, attributeFilter: ["style"] });
  	this.hpan.on("hpanend hpancancel", this._endTransformObserve);
  	this.transforms.get(this.keywordList.wrapper)
  		.stopTransition()
  		.clearOffset()
  		.clearCapture()
  		.validate();
  },
  	_endTransformObserve: function() {
  	this._transformObserver.disconnect();
  	this.hpan.off("hpanend hpancancel", this._endTransformObserve);
  	this.transforms.get(this.keywordList.wrapper)
  		.clearOffset()
  		.runTransition(tx.NOW)
  		.validate();
  },
  	_onTransformMutation: function(mutations) {
  	var tView, tMetrics, tCss, dTxObj, pos;
  		// this.keywordList.wrapper.style[prefixedProperty("transform")];
  	// transform = mutations[0].target.style.getPropertyValue(prefixedProperty("transform"));
  		tView = View.findByElement(mutations[0].target);
  	if (tView) {
  		tMetrics = tView.metrics;
  		dTxObj = this.transforms.get(this.keywordList.wrapper);
  		console.log("%s::_onTransformMutation [withMedia: %s] target: (%f\+%f) %f wrapper: (%f) %f", this.cid,
  			this.model.has("media"),
  			tMetrics.translateX, tMetrics.width, tMetrics.translateX + tMetrics.width,
  			dTxObj.capturedX, tMetrics.translateX - dTxObj.capturedX,
  			tMetrics
  		);
  			this.transforms.offset(tMetrics.translateX - dTxObj.capturedX, void 0, this.keywordList.wrapper);
  		this.transforms.validate();
  	}
  },
  */

});

}).call(this,require("underscore"))

},{"app/control/Controller":54,"app/control/Globals":55,"app/model/collection/ArticleCollection":63,"app/model/collection/BundleCollection":64,"app/model/collection/KeywordCollection":65,"app/model/collection/TypeCollection":66,"app/view/base/View":82,"app/view/component/ArticleButton":85,"app/view/component/FilterableListView":91,"app/view/component/GraphView":92,"app/view/component/GroupingListView":93,"hammerjs":15,"underscore":51,"utils/TransformHelper":127}],77:[function(require,module,exports){
"use strict";

var PriorityQueue = function PriorityQueue(offset) {
  this._offset = offset | 0;
  this._items = [];
  this._priorities = [];
  this._numItems = 0;
};

PriorityQueue.prototype = Object.create({
  enqueue: function enqueue(item, priority) {
    var i = this._items.length;
    this._items[i] = item;
    this._priorities[i] = {
      priority: priority | 0,
      index: i
    };
    this._numItems++; // console.log("FrameQueue::RequestQueue::enqueue() [numItems:%i] ID:%i", this._numItems, this._offset + i);

    return this._offset + i;
  },
  contains: function contains(index) {
    index -= this.offset;
    return 0 <= index && index < this._items.length;
  },
  skip: function skip(index) {
    var i, item;
    i = index - this._offset;

    if (0 > i || i >= this._items.length) {
      // 	console.warn("FrameQueue::RequestQueue::skip(id:%i) out of range (%i-%i)", index, this._offset, this._offset + (this._numItems - 1));
      return void 0;
    }

    item = this._items[i];

    if (item !== null) {
      // if (item = this._items[i]) {
      this._items[i] = null;
      this._numItems--;
    }

    return item;
  },
  indexes: function indexes() {
    var items = this._priorities.concat();

    items.sort(function (a, b) {
      if (a.priority > b.priority) return 1;
      if (a.priority < b.priority) return -1;
      return 0;
    });
    items.forEach(function (o, i, a) {
      a[i] = o.index;
    }, this);
    return items;
  },
  items: function items() {
    var items = this._priorities.concat();

    items.sort(function (a, b) {
      if (a.priority > b.priority) return 1;
      if (a.priority < b.priority) return -1;
      return 0;
    });
    items.forEach(function (o, i, a) {
      a[i] = this._items[o.index];
    }, this);
    return items;
  },
  _empty: function _empty(offset) {
    this._offset = offset;
    this._items.length = 0;
    this._priorities.length = 0;
    this._numItems = 0;
  }
}, {
  offset: {
    get: function get() {
      return this._offset;
    }
  },
  length: {
    get: function get() {
      return this._items.length;
    }
  },
  numItems: {
    get: function get() {
      return this._numItems;
    }
  }
});

var CallbackQueue = function CallbackQueue(requestFn, cancelFn) {
  this._nextQueue = new PriorityQueue(0);
  this._currQueue = null; // this._pending = false;

  this._running = false;
  this._runId = -1;
  this._requestFn = requestFn;
  this._cancelFn = cancelFn;
  this._runQueue = this._runQueue.bind(this);
};

CallbackQueue.prototype = Object.create({
  /**
   * @param tstamp {int}
   */
  _runQueue: function _runQueue() {
    if (this._running) throw new Error("wtf!!!");
    this._currQueue = this._nextQueue;
    this._nextQueue = new PriorityQueue(this._currQueue.offset + this._currQueue.length);
    this._runId = -1;
    this._running = true;
    var i, item;

    var indexes = this._currQueue.indexes();

    var items = this._currQueue._items;

    for (i = 0; i < indexes.length; i++) {
      item = items[indexes[i]];

      if (item !== null) {
        item.apply(null, arguments);
      }
    } // var self = this;
    // this._currQueue.indexes().forEach(function(index) {
    // 	var fn = self._currQueue._items[index];
    // 	if (fn !== null) {
    // 		fn.apply(null, arguments);
    // 	}
    // });


    this._running = false;
    this._currQueue = null;

    if (this._nextQueue.numItems > 0) {
      this._runId = this._requestFn.call(null, this._runQueue); // this._runId = this._requestFn(this._runQueue);
    }
  },

  /**
   * @param fn {Function}
   * @param priority {int}
   * @return {int}
   */
  request: function request(fn, priority) {
    // if (!this._running && !this._pending) {
    // 	this._pending = true;
    // 	console.warn("FrameQueue::request setImmediate: pending");
    // 	setImmediate(function() {
    // 		this._pending = false;
    // 		if (this._nextQueue.numItems > 0) {
    // 			this._runId = window.requestAnimationFrame(_runQueue);
    // 			console.warn("FrameQueue::request setImmediate: raf:%i for %i items", this._runId, this._nextQueue.numItems);
    // 		} else {
    // 			console.warn("FrameQueue::request setImmediate: no items");
    // 		}
    // 	});
    // }
    if (!this._running && this._runId === -1) {
      this._runId = this._requestFn.call(null, this._runQueue); // this._runId = this._requestFn(this._runQueue);
    }

    return this._nextQueue.enqueue(fn, priority);
  },

  /**
   * @param id {int}
   * @return {Function?}
   */
  cancel: function cancel(id) {
    var fn;

    if (this._running) {
      fn = this._currQueue.skip(id) || this._nextQueue.skip(id);
    } else {
      fn = this._nextQueue.skip(id);

      if (this._runId !== -1 && this._nextQueue.numItems === 0) {
        this._cancelFn.call(null, this._runId); // this._cancelFn(this._runId);


        this._runId = -1;
      }
    }

    return fn;
  }
}, {
  running: {
    get: function get() {
      return this._running;
    }
  }
});
module.exports = CallbackQueue;

},{}],78:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/* global Path2D */

/**
 * @module app/view/component/progress/CanvasView
 */
// /** @type {module:color} */
// var Color = require("color");

/** @type {module:app/view/base/View} */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var View = require("app/view/base/View");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:app/view/base/Interpolator} */


var Interpolator = require("app/view/base/Interpolator");
/** @type {module:utils/css/getBoxEdgeStyles} */


var getBoxEdgeStyles = require("utils/css/getBoxEdgeStyles");

var MIN_CANVAS_RATIO = 1; // /Firefox/.test(window.navigator.userAgent)? 2 : 1;

/**
 * @constructor
 * @type {module:app/view/component/progress/CanvasView}
 */

var CanvasView = View.extend({
  /** @type {string} */
  cidPrefix: "canvasView",

  /** @type {string} */
  tagName: "canvas",

  /** @type {string} */
  className: "canvas-view",
  properties: {
    paused: {
      get: function get() {
        return this._paused;
      },
      set: function set(paused) {
        paused = !!paused;

        if (this._interpolator.paused !== paused) {
          this._interpolator.paused = paused;

          if (!paused) {
            this.requestRender();
          }
        }
      }
    },
    context: {
      get: function get() {
        return this._ctx;
      }
    },
    interpolator: {
      get: function get() {
        return this._interpolator;
      }
    },
    canvasRatio: {
      get: function get() {
        return this._canvasRatio;
      }
    }
  },

  /** @type {Object} */
  defaults: {
    values: {
      value: 0
    },
    maxValues: {
      value: 1
    },
    paused: false,
    useOpaque: false
  },

  /* --------------------------- *
   * children/layout
   * --------------------------- */

  /** @override */
  initialize: function initialize(options) {
    // TODO: cleanup this options mess
    options = _.defaults(options || {}, this.defaults);
    options.values = _.defaults(options.values || {}, this.defaults.values);
    options.maxValues = _.defaults(options.maxValues || {}, this.defaults.maxValues);
    this._interpolator = new Interpolator(options.values, options.maxValues);
    this._interpolator.paused = options.paused;
    this._useOpaque = options.useOpaque;
    this._options = _.pick(options, "color", "backgroundColor"); // opaque background
    // --------------------------------

    var ctxOpts = {}; // if (this._useOpaque) {
    // 	this._opaqueProp = Modernizr.prefixed("opaque", this.el, false);
    // 	if (this._opaqueProp) {
    // 		this.el[this._opaqueProp] = true;
    // 	} else {
    // 		ctxOpts.alpha = true;
    // 	}
    // 	this.el.classList.add("color-bg");
    // }
    // canvas' context init
    // --------------------------------

    this._ctx = this.el.getContext("2d", ctxOpts); // adjust canvas size to pixel ratio
    // upscale the canvas if the two ratios don't match
    // --------------------------------

    var ratio = MIN_CANVAS_RATIO;
    var ctxRatio = this._ctx.webkitBackingStorePixelRatio || 1;

    if (window.devicePixelRatio !== ctxRatio) {
      // ratio = Math.max(window.devicePixelRatio / ctxRatio, MIN_CANVAS_RATIO);
      ratio = window.devicePixelRatio / ctxRatio;
      ratio = Math.max(ratio, MIN_CANVAS_RATIO);
    }

    this._canvasRatio = ratio; // console.log("%s::init canvasRatio: %f", this.cid, this._canvasRatio);

    this.listenTo(this, "view:attached", function () {
      // this.invalidateSize();
      // this.renderNow();
      this.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID).renderNow();
    });
  },
  // _computeCanvasRatio: function() {
  // 	var ratio = MIN_CANVAS_RATIO;
  // 	var ctxRatio = this._ctx.webkitBackingStorePixelRatio || 1;
  // 	if (window.devicePixelRatio !== ctxRatio) {
  // 		// ratio = Math.max(window.devicePixelRatio / ctxRatio, MIN_CANVAS_RATIO);
  // 		ratio = window.devicePixelRatio / ctxRatio;
  // 		ratio = Math.max(ratio, MIN_CANVAS_RATIO);
  // 	}
  // 	this._canvasRatio = ratio;
  // },
  _updateCanvas: function _updateCanvas() {
    // adjust canvas size to pixel ratio
    // upscale the canvas if the two ratios don't match
    // --------------------------------
    var s = getComputedStyle(this.el); // this._canvasWidth = this.el.offsetWidth;
    // this._canvasHeight = this.el.offsetHeight;

    this._canvasWidth = this.el.scrollWidth;
    this._canvasHeight = this.el.scrollHeight;

    if (s.boxSizing === "border-box") {
      var m = getBoxEdgeStyles(s);
      this._canvasWidth -= m.paddingLeft + m.paddingRight + m.borderLeftWidth + m.borderRightWidth;
      this._canvasHeight -= m.paddingTop + m.paddingBottom + m.borderTopWidth + m.borderBottomWidth;
    }

    this._canvasWidth *= this._canvasRatio;
    this._canvasHeight *= this._canvasRatio;
    this.measureCanvas(this._canvasWidth, this._canvasHeight, s);
    this.el.width = this._canvasWidth;
    this.el.height = this._canvasHeight; // this.el.style.height = h + "px";
    // this.el.style.width = w + "px";
    // colors
    // --------------------------------

    this._color = this._options.color || s.color || Globals.DEFAULT_COLORS["color"];
    this._backgroundColor = this._options.backgroundColor || s.backgroundColor || Globals.DEFAULT_COLORS["background-color"]; // mozOpaque
    // --------------------------------

    if (this._useOpaque && this._opaqueProp) {
      // this.el.style.backgroundColor = this._backgroundColor;
      this.el[this._opaqueProp] = true;
    } // fontSize
    // --------------------------------


    this._fontSize = parseFloat(s.fontSize) * this._canvasRatio;
    this._fontFamily = s.fontFamily; // prepare canvas context
    // --------------------------------

    this._ctx.restore();

    this._ctx.font = [s.fontWeight, s.fontStyle, this._fontSize + "px/1", s.fontFamily].join(" ");
    this._ctx.textAlign = "left";
    this._ctx.lineCap = "butt";
    this._ctx.lineJoin = "miter";
    this._ctx.strokeStyle = this._color;
    this._ctx.fillStyle = this._color;
    this.updateCanvas(this._ctx, s);

    this._ctx.save(); // console.group(this.cid+"::_updateCanvas");
    // console.log("ratio:    %f (min: %f, device: %f, context: %s)", this._canvasRatio, MIN_CANVAS_RATIO, window.devicePixelRatio, this._ctx.webkitBackingStorePixelRatio || "(webkit-only)");
    // console.log("colors:   fg: %s bg: %s", this._color, this._backgroundColor);
    // console.log("style:    %s, %s, padding: %s (%s)", s.width, s.height, s.padding, s.boxSizing);
    // console.log("box:      %f x %f px", m.width, m.height);
    // console.log("measured: %f x %f px", w, h);
    // console.log("canvas:   %f x %f px", this._canvasWidth, this._canvasHeight);
    // console.groupEnd();

  },
  measureCanvas: function measureCanvas(w, h, s) {
    /* abstract */
  },
  updateCanvas: function updateCanvas(ctx, s) {
    /* abstract */
  },
  _getFontMetrics: function _getFontMetrics(str) {
    var key,
        idx,
        mObj,
        mIdx = str.length;

    for (key in Globals.FONT_METRICS) {
      idx = str.indexOf(key);

      if (idx !== -1 && idx < mIdx) {
        mIdx = idx;
        mObj = Globals.FONT_METRICS[key];
      }
    }

    return mObj || {
      "unitsPerEm": 1024,
      "ascent": 939,
      "descent": -256
    };
  },
  _clearCanvas: function _clearCanvas() {
    if (arguments.length == 4) {
      this._clearCanvasRect.apply(this, arguments);
    } else {
      this._ctx.save();

      this._ctx.setTransform(1, 0, 0, 1, 0, 0);

      this._clearCanvasRect(0, 0, this.el.width, this.el.height);

      this._ctx.restore();
    }
  },
  _clearCanvasRect: function _clearCanvasRect(x, y, w, h) {
    this._ctx.clearRect(x, y, w, h);

    if (this._useOpaque) {
      this._ctx.save();

      this._ctx.fillStyle = this._backgroundColor;

      this._ctx.fillRect(x, y, w, h);

      this._ctx.restore();
    }
  },
  _setStyle: function _setStyle(s) {
    CanvasView.setStyle(this._ctx, s);
  },

  /* --------------------------- *
   * render
   * --------------------------- */

  /** @override */
  render: function render() {
    if (this.attached) {
      return this.renderNow();
    }

    return this;
  },

  /** @override */
  renderFrame: function renderFrame(tstamp, flags) {
    if (!this.attached) {
      return flags;
    }

    if (flags & View.SIZE_INVALID) {
      this._updateCanvas();
    }

    if (this._interpolator.valuesChanged) {
      flags |= View.LAYOUT_INVALID;

      this._interpolator.interpolate(tstamp);
    }

    if (flags & (View.LAYOUT_INVALID | View.SIZE_INVALID)) {
      this.redraw(this._ctx, this._interpolator, flags);

      if (this._interpolator.valuesChanged) {
        this.requestRender();
      }
    }
  },
  // setEnabled: function(enabled) {
  // 	View.prototype.setEnabled.apply(this, arguments);
  // 	if (this.attached) {
  // 		console.info("[%s] %s::setEnabled", this.parentView.cid, this.cid, this.enabled);
  // 		// if (this._enabled && this._interpolator.valuesChanged) {
  // 		// this.requestRender();
  // 		// this.requestRender(CanvasView.LAYOUT_INVALID);
  // 		// }
  // 	}
  // },

  /* --------------------------- *
  /* public
  /* --------------------------- */
  getTargetValue: function getTargetValue(key) {
    return this._interpolator.getTargetValue(key);
  },
  getRenderedValue: function getRenderedValue(key) {
    return this._interpolator.getRenderedValue(key);
  },
  valueTo: function valueTo(key, value, duration) {
    this._interpolator.valueTo(key, value, duration);

    this.requestRender(View.MODEL_INVALID | View.LAYOUT_INVALID);
  },
  // updateValue: function(key) {
  // 	return this._interpolator.updateValue(key || this.defaultKey);
  // },

  /* --------------------------- *
  /* redraw
  /* --------------------------- */
  redraw: function redraw(ctx, interp, flags) {}
}, {
  setStyle: function setStyle(ctx, s) {
    if (_typeof(s) != "object") return;

    for (var p in s) {
      switch (_typeof(ctx[p])) {
        case "undefined":
          break;

        case "function":
          if (Array.isArray(s[p])) ctx[p].apply(ctx, s[p]);else ctx[p].call(ctx, s[p]);
          break;

        default:
          ctx[p] = s[p];
      }
    }
  }
});

if (DEBUG) {
  CanvasView.prototype._logFlags = "";
}

module.exports = CanvasView;

}).call(this,true,require("underscore"))

},{"app/control/Globals":55,"app/view/base/Interpolator":79,"app/view/base/View":82,"underscore":51,"utils/css/getBoxEdgeStyles":139}],79:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/base/Interpolator
 */

/** @type {module:utils/ease/fn/linear} */

var linear = require("utils/ease/fn/linear");
/**
 * @constructor
 * @type {module:app/view/base/Interpolator}
 */


var Interpolator = function Interpolator(values, maxValues, easeValues) {
  this._tstamp = 0; // gets thrown away by first interpolate() but avoid null access errors

  this._renderableKeys = [];
  this._renderedKeys = [];
  this._paused = false;
  this._pausedChanging = false; //this._pausedKeys = [];

  this._maxValues = _.isObject(maxValues) ? _.extend({}, maxValues) : {};
  this._easeFn = _.isObject(easeValues) ? _.extend({}, easeValues) : {};
  this._valueData = {}; // var key, val, maxVal, easeFn;

  for (var key in values) {
    _.isNumber(this._maxValues[key]) || (this._maxValues[key] = null);
    _.isFunction(this._easeFn[key]) || (this._easeFn[key] = linear); // create value object and store it

    this._valueData[key] = this._initValue(values[key], 0, this._maxValues[key]); // add to next render list

    this._renderableKeys.push(key);
  }
};

Interpolator.prototype = Object.create({
  /* --------------------------- *
  /* public interface
  /* --------------------------- */
  isAtTarget: function isAtTarget(key) {
    return this._renderableKeys.indexOf(key) === -1;
  },
  getCurrentValue: function getCurrentValue(key) {
    return this._valueData[key]._renderedValue || this._valueData[key]._value;
  },
  getTargetValue: function getTargetValue(key) {
    return this._valueData[key]._value;
  },
  getStartValue: function getStartValue(key) {
    return this._valueData[key]._startValue;
  },
  getRenderedValue: function getRenderedValue(key) {
    return this._valueData[key]._renderedValue;
  },
  getOption: function getOption(key, opt) {
    if (opt === "max") return this._maxValues[key];
    if (opt === "ease") return this._easeFn[key];
  },
  valueTo: function valueTo(key, value, duration, ease) {
    var changed,
        dataObj = this._valueData[key];

    if (_.isFunction(ease)) {
      this._easeFn[key] = ease;
    } // console.log("%s::valueTo [%s]", "[interpolator]", key, value);


    if (Array.isArray(dataObj)) {
      changed = value.reduce(function (prevChanged, itemValue, i) {
        if (dataObj[i]) {
          dataObj[i] = this._initNumber(itemValue, duration, this._maxValues[key]);
          return true;
        }

        return this._setValue(dataObj[i], itemValue, duration) || prevChanged;
      }.bind(this), changed);
    } else {
      changed = this._setValue(dataObj, value, duration);
    }

    if (changed) {
      this._renderableKeys.indexOf(key) !== -1 || this._renderableKeys.push(key);
    }

    return this;
  },
  updateValue: function updateValue(key) {
    // Call _interpolateKey only if needed. _interpolateKey() returns false
    // once interpolation is done, in which case remove key from _renderableKeys.
    var kIndex = this._renderableKeys.indexOf(key);

    if (kIndex !== -1 && !this._interpolateKey(key)) {
      this._renderableKeys.splice(kIndex, 1);
    }

    return this;
  },

  /* --------------------------- *
  /* private: valueData
  /* --------------------------- */
  _initValue: function _initValue(value, duration, maxVal) {
    if (Array.isArray(value)) {
      return value.map(function (val) {
        return this._initNumber(val, duration, maxVal);
      }, this);
    }

    return this._initNumber(value, duration, maxVal);
  },
  _initNumber: function _initNumber(value, duration, maxVal) {
    var o = {};
    o._value = value;
    o._startValue = value;
    o._valueDelta = 0;
    o._duration = duration || 0;
    o._startTime = NaN;
    o._elapsedTime = NaN;
    o._lastRenderedValue = null;
    o._renderedValue = o._startValue;
    o._maxVal = maxVal; // if (maxVal !== void 0) o._maxVal = maxVal;
    // o._maxVal = this._maxValues[key];
    // o._maxVal = this._maxVal;// FIXME

    return o;
  },
  _setValue: function _setValue(o, value, duration) {
    if (o._value !== value) {
      o._startValue = o._value;
      o._valueDelta = value - o._value;
      o._value = value;
      o._duration = duration || 0;
      o._startTime = NaN;
      o._elapsedTime = NaN; // o._lastRenderedValue = o._renderedValue;
      // o._renderedValue = o._startValue;

      return true;
    }

    return false;
  },

  /* --------------------------- *
  /* private: interpolate
  /* --------------------------- */
  _tstamp: 0,

  /** @override */
  interpolate: function interpolate(tstamp) {
    this._tstamp = tstamp;

    if (this.valuesChanged) {
      if (this._pausedChanging) {
        this._renderableKeys.forEach(function (key) {
          var o = this._valueData[key];

          if (!isNaN(o._elapsedTime)) {
            o._startTime = tstamp - o._elapsedTime;
          }
        }, this);

        this._pausedChanging = false;
      }

      var changedKeys = this._renderableKeys;
      this._renderableKeys = changedKeys.filter(function (key) {
        return this._interpolateValue(tstamp, this._valueData[key], this._easeFn[key]);
      }, this);
      this._renderedKeys = changedKeys;
    }

    return this;
  },
  _interpolateKey: function _interpolateKey(key) {
    return this._interpolateValue(this._tstamp, this._valueData[key], this._easeFn[key]);
  },
  _interpolateValue: function _interpolateValue(tstamp, o, fn) {
    if (Array.isArray(o)) {
      return o.reduce(function (changed, item, index, arr) {
        return this._interpolateNumber(tstamp, item, fn) || changed;
      }.bind(this), false);
    }

    return this._interpolateNumber(tstamp, o, fn);
  },
  _interpolateNumber: function _interpolateNumber(tstamp, o, fn) {
    if (isNaN(o._startTime)) {
      o._startTime = tstamp;
    }

    o._lastRenderedValue = o._renderedValue;
    var elapsed = Math.max(0, tstamp - o._startTime);

    if (elapsed < o._duration) {
      if (o._maxVal && o._valueDelta < 0) {
        // upper-bound values
        o._renderedValue = fn(elapsed, o._startValue, o._valueDelta + o._maxVal, o._duration) - o._maxVal;
      } else {
        // unbound values
        o._renderedValue = fn(elapsed, o._startValue, o._valueDelta, o._duration);
      }

      o._elapsedTime = elapsed;
      return true;
    }

    o._renderedValue = o._value;
    o._elapsedTime = NaN;
    o._startTime = NaN;
    return false;
  }
}, {
  /**
   * @type {boolean}
   */
  paused: {
    get: function get() {
      return this._paused;
    },
    set: function set(value) {
      value = !!value; // Convert to boolean

      if (this._paused !== value) {
        this._paused = value;
        this._pausedChanging = true;
      }
    }
  },

  /**
   * @type {boolean} Has any value been changed by valueTo() since last interpolate()
   */
  valuesChanged: {
    get: function get() {
      return !this._paused && this._renderableKeys.length > 0;
    }
  },

  /**
   * @type {array} Keys that are not yet at target value
   */
  renderableKeys: {
    get: function get() {
      return this._renderableKeys;
    }
  },

  /**
   * @type {array} Keys that have been rendered in the last interpolate()
   */
  renderedKeys: {
    get: function get() {
      return this._renderedKeys;
    }
  },

  /**
   * @type {array} All keys
   */
  keys: {
    get: function get() {
      return Object.keys(this._valueData);
    }
  }
});
module.exports = Interpolator;

}).call(this,require("underscore"))

},{"underscore":51,"utils/ease/fn/linear":142}],80:[function(require,module,exports){
(function (DEBUG){
"use strict";
/** @type {module:utils/prefixedEvent} */

var prefixedEvent = require("utils/prefixedEvent");

var eventMap = {
  "transitionend": prefixedEvent("transitionend"),
  "fullscreenchange": prefixedEvent("fullscreenchange", document),
  "fullscreenerror": prefixedEvent("fullscreenerror", document),
  "visibilitychange": prefixedEvent("visibilitychange", document, "hidden")
};
var eventNum = 0;

for (var eventName in eventMap) {
  if (eventName === eventMap[eventName]) {
    delete eventMap[eventName];
  } else {
    Object.defineProperty(eventMap, eventName, {
      value: eventMap[eventName],
      enumerable: true
    });
    Object.defineProperty(eventMap, eventNum, {
      value: eventName,
      enumerable: false
    });
    eventNum++;
  }
}

Object.defineProperty(eventMap, "length", {
  value: eventNum
});

if (DEBUG) {
  console.log("prefixes enabled for %i events", eventMap.length, Object.keys(eventMap));
}

module.exports = eventMap; // module.exports = eventNum > 0? eventMap : null;

}).call(this,true)

},{"utils/prefixedEvent":145}],81:[function(require,module,exports){
(function (DEBUG){
"use strict";
/**
 * @module app/view/base/TouchManager
 */

/** @type {module:app/control/Globals} */

var Globals = require("app/control/Globals");
/** @type {module:hammerjs} */


var Hammer = require("hammerjs"); // /** @type {module:hammerjs.Tap} */
// const Tap = Hammer.Tap;

/** @type {module:utils/touch/SmoothPanRecognizer} */


var Pan = require("utils/touch/SmoothPanRecognizer");
/** @type {module:hammerjs.Pan} */
// const Pan = Hammer.Pan;

/* -------------------------------
/* Static private
/* ------------------------------- */

/**
 * @param el HTMLElement
 * @return {Hammer.Manager}
 */


function createInstance(el) {
  var manager = new Hammer.Manager(el); // manager.set({ domevents: true });
  // let tap = new Hammer.Tap({
  // 	threshold: Globals.PAN_THRESHOLD - 1
  // });
  // manager.add(tap);

  var hpan = new Pan({
    event: "hpan",
    direction: Hammer.DIRECTION_HORIZONTAL,
    threshold: Globals.PAN_THRESHOLD // touchAction: "pan-y",

  });
  manager.add(hpan); // let vpan = new Pan({
  // 	event: "vpan",
  // 	direction: Hammer.DIRECTION_VERTICAL,
  // 	// threshold: Globals.PAN_THRESHOLD,
  // 	// touchAction: "pan-x",
  // });
  // manager.add(vpan);
  // vpan.requireFailure(hpan);

  return manager;
}
/* -------------------------------
 * hammerjs fixup handlers
 * ------------------------------- */

/* eslint-disable no-unused-vars */


var PANEND_THRES_MS = 300; // millisecs

var PANEND_THRES_PX = 25; // pixels

var UP_EVENT = window.hasOwnProperty("onpointerup") ? "pointerup" : "mouseup";
var touchHandlers = {};
var captureHandlers = {};
var bubblingHandlers = {};
/*https://gist.githubusercontent.com/jtangelder/361052976f044200ea17/raw/f54c2cef78d59da3f38286fad683471e1c976072/PreventGhostClick.js*/

var lastTimeStamp = NaN;
var panSessionOpened = false;

var saveTimeStamp = function saveTimeStamp(hev) {
  panSessionOpened = !hev.isFinal;

  if (hev.isFinal) {
    lastTimeStamp = hev.srcEvent.timeStamp;
  }

  if (DEBUG) {
    logPanEvent(hev);
  }
}; // let preventSrcEvent = function(hev) {
// 	//console.log(hev.type, "preventDefault");
// 	hev.srcEvent.preventDefault();
// };
// let preventWhilePanning = function(domev) {
// 	panSessionOpened && domev.preventDefault();
// };
// let preventWhileNotPanning = function(domev) {
// 	!panSessionOpened && domev.preventDefault();
// };


var stopEventAfterPan = function stopEventAfterPan(domev) {
  if (domev.timeStamp - lastTimeStamp < PANEND_THRES_MS) {
    // domev.defaultPrevented ||
    domev.preventDefault();
    domev.stopPropagation();
  }

  if (DEBUG) {
    logEvent(domev, (domev.timeStamp - lastTimeStamp).toFixed(3));
  }

  lastTimeStamp = NaN;
};

touchHandlers["hpanstart hpanend hpancancel"] = saveTimeStamp; // touchHandlers["vpanstart vpanend vpancancel"] = saveTimeStamp;
// touchHandlers["hpanmove hpanend hpancancel"] = preventSrcEvent;
// touchHandlers["vpanmove vpanend vpancancel"] = preventSrcEvent;

captureHandlers["click"] = stopEventAfterPan; // bubblingHandlers["click"] = stopEventAfterPan;
// touchHandlers[[
// 	"vpanstart", "vpanend", "vpancancel", "vpanmove",
// 	"hpanstart", "hpanend", "hpancancel", "hpanmove"
// ].join(" ")] = logHammerEvent;

/* -------------------------------
/* DOM event handlers
/* ------------------------------- */
// captureHandlers[UP_EVENT] = preventWhilePanning;
// captureHandlers["touchmove"] = captureHandlers["mousemove"] = logDOMEvent;

if (DEBUG) {
  var logPanEvent = function logPanEvent(hev) {
    logEvent(hev.srcEvent, "[".concat(hev.type, "]"));
  };

  var logEvent = function logEvent(domev, msg) {
    var msgs = [];
    if (domev.defaultPrevented) msgs.push("prevented");
    if (msg) msgs.push(msg);
    msgs.push("".concat(panSessionOpened ? "panning" : "pan ended", " ").concat((domev.timeStamp - lastTimeStamp).toFixed(3)));
    console.log("TouchManager %s [%s]", domev.timeStamp.toFixed(3), domev.type, msgs.join(", "));
  };
}
/* eslint-enable no-unsused-vars */
// -------------------------------
//
// -------------------------------


function addHandlers() {
  var eventName;
  var el = instance.element;

  for (eventName in touchHandlers) {
    if (touchHandlers.hasOwnProperty(eventName)) instance.on(eventName, touchHandlers[eventName]);
  }

  for (eventName in captureHandlers) {
    if (captureHandlers.hasOwnProperty(eventName)) el.addEventListener(eventName, captureHandlers[eventName], true);
  }

  for (eventName in bubblingHandlers) {
    if (bubblingHandlers.hasOwnProperty(eventName)) el.addEventListener(eventName, bubblingHandlers[eventName], false);
  } // document.addEventListener("touchmove", preventWhileNotPanning, false);

}

function removeHandlers() {
  var eventName;
  var el = instance.element;

  for (eventName in captureHandlers) {
    if (captureHandlers.hasOwnProperty(eventName)) el.removeEventListener(eventName, captureHandlers[eventName], true);
  }

  for (eventName in bubblingHandlers) {
    if (captureHandlers.hasOwnProperty(eventName)) el.removeEventListener(eventName, bubblingHandlers[eventName], true);
  } // document.removeEventListener("touchmove", preventWhileNotPanning, false);

}
/** @type {Hammer.Manager} */


var instance = null;
/* -------------------------------
/* Static public
/* ------------------------------- */

var TouchManager = {
  init: function init(target) {
    if (instance === null) {
      instance = createInstance(target);
      addHandlers();
    } else if (instance.element !== target) {
      console.warn("TouchManager already initialized with another element");
    }

    return instance;
  },
  destroy: function destroy() {
    if (instance !== null) {
      removeHandlers();
      instance.destroy();
      instance = null;
    } else {
      console.warn("no instance to destroy");
    }
  },
  getInstance: function getInstance() {
    if (instance === null) {
      console.error("TouchManager has not been initialized");
    }

    return instance;
  }
};
module.exports = TouchManager;
/*
// alt syntax
function createInstance(el) {
	return new Hammer(el, {
		recognizers: [
			[Tap],
			[Pan, {
				event: 'hpan',
				direction: Hammer.DIRECTION_HORIZONTAL,
				threshold: Globals.THRESHOLD
			}],
			[Pan, {
				event: 'vpan',
				direction: Hammer.DIRECTION_VERTICAL,
				threshold: Globals.THRESHOLD
			}, ['hpan']]
		]
	});
}
*/

}).call(this,true)

},{"app/control/Globals":55,"hammerjs":15,"utils/touch/SmoothPanRecognizer":153}],82:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/* global HTMLElement, MutationObserver */

/**
 * @module app/view/base/View
 */

/** @type {module:setimmediate} */

require("setimmediate");
/** @type {module:backbone} */


var Backbone = require("backbone");
/* -------------------------------
/* MutationObserver
/* ------------------------------- */


var _cidSeed = 1;
var _viewsByCid = {};

function addChildViews(el) {
  var view,
      els = el.querySelectorAll("*[data-cid]");

  for (var i = 0, ii = els.length; i < ii; i++) {
    view = View.findByElement(els.item(i));

    if (view) {
      if (!view.attached) {
        // console.log("View::[attached (parent)] %s", view.cid);
        view._elementAttached(); // } else {
        // 	console.warn("View::[attached (parent)] %s (ignored)", view.cid);

      }
    }
  }
}

function removeChildViews(el) {
  var view,
      els = el.querySelectorAll("*[data-cid]");

  for (var i = 0, ii = els.length; i < ii; i++) {
    view = View.findByElement(els.item(i));

    if (view) {
      if (view.attached) {
        console.log("View::[detached (parent)] %s", view.cid);

        view._elementDetached();
      } else {
        console.warn("View::[detached (parent)] %s (ignored)", view.cid);
      }
    }
  }
}

var observer = new MutationObserver(function (mm) {
  // console.log("View::mutations %s", JSON.stringify(mm, null, " "));
  var i, ii, m;
  var j, jj, e;
  var view;

  for (i = 0, ii = mm.length; i < ii; i++) {
    m = mm[i];

    if (m.type == "childList") {
      for (j = 0, jj = m.addedNodes.length; j < jj; j++) {
        e = m.addedNodes.item(j);
        view = View.findByElement(e);

        if (view) {
          if (!view.attached) {
            // console.log("View::[attached (childList)] %s", view.cid);
            view._elementAttached(); // } else {
            // 	console.warn("View::[attached (childList)] %s (ignored)", view.cid);

          }
        }

        if (e instanceof HTMLElement) addChildViews(e);
      }

      for (j = 0, jj = m.removedNodes.length; j < jj; j++) {
        e = m.removedNodes.item(j); // console.log("View::[detached (childList)] %s", e.cid);

        view = View.findByElement(e);

        if (view) {
          if (view.attached) {
            console.log("View::[detached (childList)] %s", view.cid, view.attached);

            view._elementDetached();
          } else {
            console.warn("View::[detached (childList)] %s (ignored)", view.cid, view.attached);
          }
        }

        if (e instanceof HTMLElement) removeChildViews(e);
      }
    } else if (m.type == "attributes") {
      view = View.findByElement(m.target);

      if (view) {
        if (!view.attached) {
          // console.log("View::[attached (attribute)] %s", view.cid);
          view._elementAttached(); // } else {
          // 	console.warn("View::[attached (attribute)] %s (ignored)", view.cid);

        }
      } // else {
      // 	console.warn("View::[attributes] target has no cid (%s='%s')", m.attributeName, m.target.getAttribute(m.attributeName), m);
      // }

    }
  }
});
observer.observe(document.body, {
  attributes: true,
  childList: true,
  subtree: true,
  attributeFilter: ["data-cid"]
});
/* -------------------------------
/* static private
/* ------------------------------- */

var _now = window.performance ? window.performance.now.bind(window.performance) : Date.now.bind(Date); // var _now = window.performance?
// 	function() { return window.performance.now(); }:
// 	function() { return Date.now(); };
// /** @type {module:app/view/base/renderQueue} */
// var renderQueue = require("app/view/base/renderQueue");
//

/** @type {module:app/view/base/CallbackQueue} */


var renderQueue = function (CallbackQueue) {
  return new CallbackQueue(function (callback) {
    return window.requestAnimationFrame(callback);
  }, function (id) {
    return window.cancelAnimationFrame(id);
  });
}(require("app/view/base/CallbackQueue"));
/** @type {module:app/view/base/CallbackQueue} */


var modelQueue = function (CallbackQueue) {
  return new CallbackQueue(function (callback) {
    return window.setImmediate(function () {
      callback.call(null, _now());
    });
  }, function (id) {
    return window.clearImmediate(id);
  });
}(require("app/view/base/CallbackQueue"));
/** @type {module:app/view/base/PrefixedEvents} */


var PrefixedEvents = require("app/view/base/PrefixedEvents");

var applyEventPrefixes = function applyEventPrefixes(events) {
  var selector, unprefixed;

  for (selector in events) {
    unprefixed = selector.match(/^\w+/i)[0];

    if (PrefixedEvents.hasOwnProperty(unprefixed)) {
      events[selector.replace(unprefixed, PrefixedEvents[unprefixed])] = events[selector]; // console.log("applyEventPrefixes", unprefixed, prefixedEvents[unprefixed]);

      delete events[selector];
    }
  }

  return events;
};

var getViewDepth = function getViewDepth(view) {
  if (!view) {
    return null;
  }

  if (!view.attached) {
    return NaN;
  }

  if (view.parentView === null) {
    return 0;
  }

  return view.parentView.viewDepth + 1;
};

function logAttachInfo(view, name, level) {
  if (["log", "info", "warn", "error"].indexOf(level) != -1) {
    level = "log";
  }

  console[level].call(console, "%s::%s [parent:%s %s %s depth:%s]", view.cid, name, view.parentView && view.parentView.cid, view.attached ? "attached" : "detached", view._viewPhase, view.viewDepth);
}
/* -------------------------------
/* static public
/* ------------------------------- */


var View = {
  /** @const */
  NONE_INVALID: 0,

  /** @const */
  ALL_INVALID: ~0 >>> 1,

  /** @const */
  CHILDREN_INVALID: 1,

  /** @const */
  MODEL_INVALID: 2,

  /** @const */
  STYLES_INVALID: 4,

  /** @const */
  SIZE_INVALID: 8,

  /** @const */
  LAYOUT_INVALID: 16,

  /** @const */
  CLICK_EVENT: "click",
  //window.hasOwnProperty("onpointerup") ? "pointerup" : "mouseup",

  /** @type {module:app/view/base/ViewError} */
  ViewError: require("app/view/base/ViewError"),

  /** @type {module:utils/prefixedProperty} */
  prefixedProperty: require("utils/prefixedProperty"),

  /** @type {module:utils/prefixedStyleName} */
  prefixedStyleName: require("utils/prefixedStyleName"),

  /** @type {module:utils/prefixedEvent} */
  prefixedEvent: require("utils/prefixedEvent"),

  /** @type {module:app/view/promise/whenViewIsAttached} */
  whenViewIsAttached: require("app/view/promise/whenViewIsAttached"),

  /** @type {module:app/view/promise/whenViewIsRendered} */
  whenViewIsRendered: require("app/view/promise/whenViewIsRendered"),

  /**
  /* @param el {HTMLElement}
  /* @return {module:app/view/base/View}
  /*/
  findByElement: function findByElement(el) {
    if (_viewsByCid[el.cid]) {
      return _viewsByCid[el.cid];
    }

    return null;
  },

  /**
  /* @param el {HTMLElement}
  /* @return {module:app/view/base/View}
  /*/
  findByDescendant: function findByDescendant(el) {
    do {
      if (_viewsByCid[el.cid]) {
        return _viewsByCid[el.cid];
      }
    } while (el = el.parentElement || el.parentNode);

    return null;
  },

  /** @override */
  extend: function extend(proto, obj) {
    if (PrefixedEvents.length && proto.events) {
      if (_.isFunction(proto.events)) {
        proto.events = _.wrap(proto.events, function (fn) {
          return applyEventPrefixes(fn.apply(this));
        });
      } else if (_.isObject(proto.events)) {
        proto.events = applyEventPrefixes(proto.events);
      }
    }

    if (proto.properties && this.prototype.properties) {
      _.defaults(proto.properties, this.prototype.properties);
    }

    return Backbone.View.extend.apply(this, arguments);
  },
  _flagsToStrings: ["-"],
  flagsToString: function flagsToString(flags) {
    var s = View._flagsToStrings[flags | 0];

    if (!s) {
      s = [];
      if (flags & View.CHILDREN_INVALID) s.push("children");
      if (flags & View.MODEL_INVALID) s.push("model");
      if (flags & View.STYLES_INVALID) s.push("styles");
      if (flags & View.SIZE_INVALID) s.push("size");
      if (flags & View.LAYOUT_INVALID) s.push("layout");
      View._flagsToStrings[flags] = s = s.join(" ");
    }

    return s; // return (flags | 0).toString(2);
  }
};
Object.defineProperty(View, "instances", {
  value: _viewsByCid,
  enumerable: true
});
/* -------------------------------
/* prototype
/* ------------------------------- */
// module.exports = Backbone.View.extend({

var ViewProto = {
  /** @type {string} */
  cidPrefix: "view",

  /** @type {Boolean} */
  _attached: false,

  /** @type {HTMLElement|null} */
  _parentView: null,

  /** @type {int|null} */
  _viewDepth: null,

  /** @type {string} initializing > initialized > disposing > disposed */
  _viewPhase: "initializing",

  /** @type {int} */
  _renderQueueId: -1,

  /** @type {int} */
  _renderFlags: 0,

  /** @type {Boolean} */
  _enabled: null,

  /** @type {object} */
  properties: {
    cid: {
      get: function get() {
        return this._cid || (this._cid = this.cidPrefix + _cidSeed++);
      },
      set: function set(value) {// ignored
      }
    },
    attached: {
      get: function get() {
        return this._attached;
      }
    },
    parentView: {
      get: function get() {
        return this._parentView;
      }
    },
    viewDepth: {
      get: function get() {
        return this._getViewDepth();
      }
    },
    invalidated: {
      get: function get() {
        return this._renderQueueId !== -1;
      }
    },
    enabled: {
      get: function get() {
        return this._enabled;
      },
      set: function set(enabled) {
        this.setEnabled(enabled);
      }
    },
    renderFlags: {
      get: function get() {
        return this._renderFlags;
      }
    }
  },
  $: Backbone.$,

  /**
   * @constructor
   * @type {module:app/view/base/View}
   */
  constructor: function constructor(options) {
    this.transform = {};
    this.childViews = {};
    this._applyRender = this._applyRender.bind(this);

    if (this.properties) {
      // Object.defineProperties(this, getPrototypeChainValue(this, "properties", Backbone.View));
      Object.defineProperties(this, this.properties);
    }

    if (options && options.className && this.className) {
      options.className += " " + _.result(this, "className");
    }

    if (options && options.parentView) {
      this._setParentView(options.parentView, true);
    }

    Backbone.View.apply(this, arguments); // console.log("%s::initialize viewPhase:[%s => initialized]", this.cid, this._viewPhase);

    this._viewPhase = "initialized";

    if (this.parentView !== null) {
      this.trigger("view:parentChange", this.parentView, null);
    }

    if (this.attached) {
      this.trigger("view:attached", this);
    }
  },

  /* -------------------------------
  /* remove
  /* ------------------------------- */

  /** @override */
  remove: function remove() {
    if (this._viewPhase == "disposing") {
      logAttachInfo(this, "remove", "warn");
    } else {} // logAttachInfo(this, "remove", "log");
    // before removal


    this._viewPhase = "disposing";

    this._cancelRender(); // call Backbone impl
    // Backbone.View.prototype.remove.apply(this, arguments);
    // NOTE: from Backbone impl


    this.$el.remove(); // from Backbone impl

    this._attached = false;
    this.trigger("view:removed", this); // remove parent/child references

    this._setParentView(null); // NOTE: from Backbone impl. No more events after this


    this.stopListening(); // check for invalidations that may have been triggered by "view:removed"

    if (this.invalidated) {
      console.warn("%s::remove invalidated after remove()", this.cid);

      this._cancelRender();
    } // // check for children still here
    // var ccids = Object.keys(this.childViews);
    // if (ccids.length) {
    // 	console.warn("%s::remove %i children not removed [%s]", this.cid, ccids.length, ccids.join(", "), this.childViews);
    // }
    // // remove childViews
    // for (var cid in this.childViews) {
    // 	this.childViews[cid].remove();
    // }
    // clear reference in view map


    delete _viewsByCid[this.cid]; // delete this.el.cid;
    // update phase

    this._viewPhase = "disposed";
    return this;
  },

  /* -------------------------------
  /* _elementAttached _elementDetached
  /* ------------------------------- */
  _elementAttached: function _elementAttached() {
    // this._addToParentView();
    this._attached = true;
    this._viewDepth = null;
    this.setEnabled(true);

    this._setParentView(View.findByDescendant(this.el.parentElement)); // if (this.parentView) {
    // 	console.log("[attach] [%i] %s > %s::_elementAttached", this.viewDepth, this.parentView.cid, this.cid);
    // } else {
    // 	console.log("[attach] [%i] %s::_elementAttached", this.viewDepth, this.cid);
    // }
    // if (this._viewPhase == "initializing") {
    // 	// this.trigger("view:attached", this);
    // } else


    if (this._viewPhase == "initialized") {
      this.trigger("view:attached", this);
    } else if (this._viewPhase == "replacing") {
      this._viewPhase = "initialized";
      this.trigger("view:replaced", this);
    }
  },
  _elementDetached: function _elementDetached() {
    if (!this.attached || this._viewPhase == "disposing" || this._viewPhase == "disposed") {
      logAttachInfo(this, "_elementDetached", "error"); // } else {
      // 	logAttachInfo(this, "_elementDetached", "log");
    }

    this._attached = false;
    this._viewDepth = null;
    this.setEnabled(false);

    if (this._viewPhase != "disposing" || this._viewPhase == "disposed") {
      this.remove();
    }
  },

  /* -------------------------------
  /* parentView
  /* ------------------------------- */
  _setParentView: function _setParentView(newParent, silent) {
    if (newParent === void 0) {
      console.warn("$s::_setParentView invalid value '%s'", this.cid, newParent);
      newParent = null;
    }

    var oldParent = this._parentView;
    this._parentView = newParent; // force update of _viewDepth

    this._viewDepth = null; //getViewDepth(this);
    // skip the rest if arg is the same

    if (newParent === oldParent) {
      return;
    }

    if (oldParent !== null) {
      if (this.cid in oldParent.childViews) {
        delete oldParent.childViews[this.cid];
      }
    }

    if (newParent !== null) {
      newParent.childViews[this.cid] = this;
    }

    if (!silent) this.trigger("view:parentChange", this, newParent, oldParent);
  },
  whenAttached: function whenAttached() {
    return View.whenViewIsAttached(this);
  },
  _getViewDepth: function _getViewDepth() {
    if (this._viewDepth === null) {
      this._viewDepth = getViewDepth(this);
    }

    return this._viewDepth;
  },

  /* -------------------------------
  /* Backbone.View overrides
  /* ------------------------------- */

  /** @override */
  setElement: function setElement(element, delegate) {
    // setElement always initializes this.el, so check it to be non-null before calling super
    if (this.el) {
      if (this.el !== element && this.el.parentElement) {
        // Element is being replaced
        if (this.attached) {
          // Since old element is attached to document tree, _elementAttached will be
          // triggered by replaceChild: set _viewPhase = "replacing" to flag this
          // change and trigger 'view:replaced' instead of 'view:added'.
          this._viewPhase = "replacing";
        }

        this.el.parentElement.replaceChild(element, this.el);
      }

      Backbone.View.prototype.setElement.apply(this, arguments); // Merge classes specified by this view with the ones already in the element,
      // as backbone will not:

      if (this.className) {
        _.result(this, "className").split(" ").forEach(function (item) {
          this.el.classList.add(item);
        }, this);
      }
    } else {
      Backbone.View.prototype.setElement.apply(this, arguments);
    }

    if (this.el === void 0) {
      throw new Error("Backbone view has no element");
    }

    _viewsByCid[this.cid] = this;
    this.el.cid = this.cid;
    this.el.setAttribute("data-cid", this.cid);

    if (this.model) {
      this.el.setAttribute("data-mcid", this.model.cid);
    }

    return this;
  },

  /* ---------------------------
  /* event helpers
  /* --------------------------- */
  addListeners: function addListeners(target, events, handler, useCapture) {
    if (!_.isObject(useCapture)) useCapture = !!useCapture;

    if (typeof events === "string") {
      events = events.split(" ");
    }

    for (var i = 0; i < events.length; i++) {
      target.addEventListener(events[i], handler, useCapture);
    }

    return this;
  },
  removeListeners: function removeListeners(target, events, handler, useCapture) {
    if (!_.isObject(useCapture)) useCapture = !!useCapture;

    if (typeof events === "string") {
      events = events.split(" ");
    }

    for (var i = 0; i < events.length; i++) {
      target.removeEventListener(events[i], handler, useCapture);
    }

    return this;
  },
  listenToElement: function listenToElement(target, events, handler) {
    target = Backbone.$(target);

    if (typeof events === "string") {
      events = events.split(" ");
    }

    for (var i = 0; i < events.length; i++) {
      this.listenTo(target, events[i], handler);
    }
  },
  stopListeningToElement: function stopListeningToElement(target, events, handler) {
    target = Backbone.$(target);

    if (typeof events === "string") {
      events = events.split(" ");
    }

    for (var i = 0; i < events.length; i++) {
      this.stopListening(target, events[i], handler);
    }
  },
  // listenToElementOnce: function(target, event, handler, useCapture) {
  // 	this.listenToOnce(this.$(target), event, handler);
  // },
  // stopListenToElement: function(target, event, handler, useCapture) {
  // 	this.stopListening(Backbone.$(target), event, handler);
  // },
  listenToElementOnce: function listenToElementOnce(target, event, handler, useCapture) {
    if (!_.isObject(useCapture)) useCapture = !!useCapture;

    var _cleanup, wrapper, ctx;

    ctx = this;

    _cleanup = function cleanup() {
      ctx.off("view:remove", _cleanup);
      target.removeEventListener(event, wrapper, useCapture);
    };

    wrapper = function wrapper(ev) {
      _cleanup();

      handler.call(ctx, ev);
    };

    ctx.on("view:remove", _cleanup);
    target.addEventListener(event, wrapper, useCapture);
    return this;
  },

  /* -------------------------------
  /* requestAnimationFrame
  /* ------------------------------- */
  requestAnimationFrame: function requestAnimationFrame(callback, priority, ctx) {
    return renderQueue.request(callback.bind(ctx || this), priority);
  },
  cancelAnimationFrame: function cancelAnimationFrame(id) {
    return renderQueue.cancel(id);
  },
  setImmediate: function setImmediate(callback, priority, ctx) {
    return modelQueue.request(callback.bind(ctx || this), priority);
  },
  clearImmediate: function clearImmediate(id) {
    return modelQueue.cancel(id); // return window.clearImmediate(id);
  },

  /* -------------------------------
  /* deferred render: private methods
  /* ------------------------------- */
  _traceRenderStatus: function _traceRenderStatus() {
    return [this._renderQueueId != -1 ? "async id:" + this._renderQueueId : "sync", View.flagsToString(this._renderFlags), this.attached ? "attached" : "detached", (this.skipTransitions ? "skip" : "run") + "-tx"].join(", ");
  },

  /** @private */
  _applyRender: function _applyRender(tstamp) {
    if (DEBUG) {
      if (this._logFlags["view.render"]) {
        console.log("%s::_applyRender [%s]", this.cid, this._traceRenderStatus(), this._logFlags["view.trace"] ? this._logRenderCallers.join("\n") : "");
      }

      this._logRenderCallers.length = 0;
    }

    var flags = this._renderFlags;
    this.trigger("view:render:before", this, flags);
    this._renderFlags = 0;
    this._renderQueueId = -1;
    this._renderFlags |= this.renderFrame(tstamp, flags);
    this.trigger("view:render:after", this, flags);

    if (this._renderFlags != 0) {
      console.warn("%s::_applyRender [returned] phase: %s flags: %s (%s)", this.cid, this._viewPhase, View.flagsToString(this._renderFlags), this._renderFlags);
    }
  },
  _cancelRender: function _cancelRender() {
    if (this._renderQueueId != -1) {
      var cancelId, cancelFn;
      cancelId = this._renderQueueId;
      this._renderQueueId = -1;
      cancelFn = renderQueue.cancel(cancelId);

      if (cancelFn === void 0) {
        console.warn("%s::_cancelRender [id:%i] not found", this.cid, cancelId);
      } else if (cancelFn === null) {
        console.warn("%s::_cancelRender [id:%i] already cancelled", this.cid, cancelId); // } else {
        // 	if (this._logFlags["view.render"] && !renderQueue.running)
        // 		console.log("%s::_cancelRender ID:%i cancelled", this.cid, cancelId);
      }
    }
  },
  _requestRender: function _requestRender() {
    if (renderQueue.running) {
      this._cancelRender(); // if (DEBUG) {
      // 	if (this._logFlags["view.render"]) {
      // 		console.info("%s::_requestRender rescheduled [%s (%s)]", this.cid, View.flagsToString(this._renderFlags), this._renderFlags);
      // 	}
      // }

    }

    if (this._renderQueueId == -1) {
      this._renderQueueId = renderQueue.request(this._applyRender, isNaN(this.viewDepth) ? Number.MAX_VALUE : this.viewDepth);
    }

    if (DEBUG) {
      if (this._logFlags["view.trace"]) {
        // if (this._logFlags["view.trace"]) {
        // 	console.groupCollapsed(this.cid + "::_requestRender [" + this._traceRenderStatus() + "] trace");
        // 	console.trace();
        // 	console.groupEnd();
        // } else {
        console.log("%s::_requestRender %s [%s]", this.cid, renderQueue.running ? "rescheduled " : "", this._traceRenderStatus()); // }
      }
    }
  },

  /* -------------------------------
  /* render: public / abstract methods
  /* ------------------------------- */
  invalidate: function invalidate(flags) {
    if (flags !== void 0) {
      /*if (DEBUG) {
      	if (this._logFlags["view.render"]) {
      		if (this._renderFlags > 0) {
      			console.log("%s::invalidate [%s (%s)] + [%s (%s)]", this.cid, View.flagsToString(this._renderFlags), this._renderFlags, View.flagsToString(flags), flags);
      		} else {
      			console.log("%s::invalidate [%s (%s)]", this.cid, View.flagsToString(flags), flags);
      		}
      	}
      }*/
      this._renderFlags |= flags;
    }

    return this;
  },
  requestRender: function requestRender(flags) {
    // if (DEBUG) {
    // 	if (this._logFlags["view.trace"]) {
    // 		var fnPath = [];
    // 		var fn = arguments.callee.caller;
    // 		while (fn) {
    // 			if (fnPath.length > 5) break;
    // 			fnPath.push(fn.name);
    // 			fn = fn.caller;
    // 		}
    // 		// this._logRenderCallers.push(fnPath.join("\n\t->"));
    // 		this._logRenderCallers.push(fnPath.join(" -> "));
    // 	}
    // }
    // if (flags !== void 0) {
    // 	this._renderFlags |= flags;
    // }
    this.invalidate(flags);

    this._requestRender();

    return this;
  },

  /** @abstract */
  renderFrame: function renderFrame(tstamp, flags) {
    // subclasses should override this method
    return View.NONE_INVALID;
  },
  renderNow: function renderNow(alwaysRun) {
    if (this._renderQueueId != -1) {
      this._cancelRender();

      alwaysRun = true;
    } // if (alwaysRun === true) {


    if (alwaysRun) {
      this._applyRender(_now());
    }

    return this;
  },
  whenRendered: function whenRendered() {
    return View.whenViewIsRendered(this);
  },

  /* -------------------------------
  /* render bitwise flags
  /* - check: this._renderFlags & flags
  /* - add: this._renderFlags |= flags
  /* - remove: this._renderFlags &= ~flags
  /* ------------------------------- */

  /* helpers ------------------ */
  requestChildrenRender: function requestChildrenRender(flags, now, force) {
    var ccid, view;

    for (ccid in this.childViews) {
      view = this.childViews[ccid];
      view.skipTransitions = view.skipTransitions || this.skipTransitions;
      view.requestRender(flags);

      if (now) {
        view.renderNow(force);
      }
    }

    return this;
  },
  render: function render() {
    return this.renderNow(true);
  },

  /* -------------------------------
  /* common abstract
  /* ------------------------------- */

  /**
  /* @param {Boolean}
  /*/
  setEnabled: function setEnabled(enable) {
    if (this._enabled == enable) return;
    this._enabled = !!enable;

    if (this._enabled) {
      this.delegateEvents();
    } else {
      this.undelegateEvents();
    }
  }
}; //, View);

if (DEBUG) {
  ViewProto._logFlags = ["view.render"].join(" ");

  ViewProto.constructor = function (fn) {
    return function () {
      var retval;
      this._logRenderCallers = [];
      this._logFlags = this._logFlags.split(" ").reduce(function (r, o) {
        r[o] = true;
        return r;
      }, {});
      retval = fn.apply(this, arguments); // console.log("------ %s %o", this.cid, this._logFlags);

      return retval;
    };
  }(ViewProto.constructor);
}

module.exports = Backbone.View.extend(ViewProto, View);

}).call(this,true,require("underscore"))

},{"app/view/base/CallbackQueue":77,"app/view/base/PrefixedEvents":80,"app/view/base/ViewError":83,"app/view/promise/whenViewIsAttached":103,"app/view/promise/whenViewIsRendered":104,"backbone":5,"setimmediate":38,"underscore":51,"utils/prefixedEvent":145,"utils/prefixedProperty":146,"utils/prefixedStyleName":147}],83:[function(require,module,exports){
"use strict";

function ViewError(view, err) {
  this.view = view;
  this.err = err;
  this.message = err.message;
}

ViewError.prototype = Object.create(Error.prototype);
ViewError.prototype.constructor = ViewError;
ViewError.prototype.name = "ViewError";
module.exports = ViewError;

},{}],84:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function";

  return "<a href=\""
    + alias3((helpers.global || (depth0 && depth0.global) || alias2).call(alias1,"APP_ROOT",{"name":"global","hash":{},"data":data}))
    + "#"
    + alias3(((helper = (helper = helpers.handle || (depth0 != null ? depth0.handle : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"handle","hash":{},"data":data}) : helper)))
    + "\">"
    + ((stack1 = ((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</a>\n";
},"useData":true});

},{"hbsfy/runtime":35}],85:[function(require,module,exports){
"use strict";
/**
/* @module app/view/component/ArticleView
/*/

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View");
/** @type {Function} */


var viewTemplate = require("./ArticleButton.hbs");
/**
/* @constructor
/* @type {module:app/view/component/ArticleButton}
/*/


var ArticleButton = View.extend({
  /** @type {string} */
  cidPrefix: "articleButton",

  /** @override */
  tagName: "h2",

  /** @override */
  className: "article-button",

  /** @type {Function} */
  template: viewTemplate,
  events: {
    "click a": function clickA(domev) {
      domev.defaultPrevented || domev.preventDefault();
      this.trigger("view:click", this.model);
    }
  },
  // /** @override */
  // initialize: function(options) {},

  /* --------------------------- *
  /* Render
  /* --------------------------- */
  renderFrame: function renderFrame(tstamp, flags) {
    this.el.innerHTML = this.template(this.model.toJSON());
  }
});
module.exports = ArticleButton;

},{"./ArticleButton.hbs":84,"app/view/base/View":82}],86:[function(require,module,exports){
"use strict";
/**
/* @module app/view/component/ArticleView
/*/

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View"); // /** @type {module:utils/net/toAbsoluteURL} */
// var toAbsoluteURL = require("utils/net/toAbsoluteURL");
//
// /** @type {string} */
// var ABS_APP_ROOT = toAbsoluteURL(require("app/control/Globals").APP_ROOT);

/**
/* @constructor
/* @type {module:app/view/component/ArticleView}
/*/


var ArticleView = View.extend({
  /** @type {string} */
  cidPrefix: "articleView",

  /** @override */
  tagName: "article",

  /** @override */
  className: "article-view mdown",

  /** @override */
  initialize: function initialize(options) {},

  /* --------------------------- *
  /* Render
  /* --------------------------- */
  renderFrame: function renderFrame(tstamp, flags) {
    this.el.innerHTML = this.model.get("text"); // FIXME: now done in xslt
    // this.el.querySelectorAll("a[href]").forEach(function(el) {
    // 	var url = toAbsoluteURL(el.getAttribute("href"));
    // 	if (url.indexOf(ABS_APP_ROOT) !== 0) {
    // 		el.setAttribute("target", "_blank");
    // 	}
    // });
  }
});
module.exports = ArticleView;

},{"app/view/base/View":82}],87:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/view/component/progress/CanvasProgressMeter
 */

/** @type {module:app/view/base/CanvasView} */

var CanvasView = require("app/view/base/CanvasView");

var PI2 = Math.PI * 2;
/* NOTE: avoid negative rotations */

var BASE_ROTATION = 1 - 0.25; // of PI2 (-90 degrees)

var GAP_ARC = PI2 / 48;
/** @type {module:utils/ease/fn/easeInQuad} */

var easeIn = require("utils/ease/fn/easeInQuad");
/** @type {module:utils/ease/fn/easeOutQuad} */


var easeOut = require("utils/ease/fn/easeOutQuad");

var LOOP_OFFSET = 1.833333;
var STEP_MS = 400; // tween time base

var ARC_DEFAULTS = {
  "amount": {
    lineWidth: 0.75,
    radiusOffset: 0
  },
  "available": {
    lineWidth: 0.75,
    // lineDash: [1.3, 0.7],
    inverse: "not-available"
  },
  "not-available": {
    lineWidth: 0.8,
    lineDash: [0.3, 0.7],
    lineDashOffset: 0
  },
  "indeterminate": {
    lineWidth: 2.0,
    //0.8,
    lineDash: [0.3, 1.7],
    // lineDash: [0.6, 1.4],
    lineDashOffset: 0
  }
};
/**
 * @constructor
 * @type {module:app/view/component/progress/CanvasProgressMeter}
 */

module.exports = CanvasView.extend({
  /** @type {string} */
  cidPrefix: "canvasProgressMeter",

  /** @type {string} */
  className: "progress-meter canvas-progress-meter",
  defaultKey: "amount",
  defaults: {
    values: {
      amount: 0,
      available: 0,
      _loop: 0,
      _stalled_arc: 0,
      _stalled_loop: 0
    },
    maxValues: {
      amount: 1,
      available: 1,
      _stalled_loop: 1
    },
    useOpaque: true,
    labelFn: function labelFn(value, max) {
      return value / max * 100 | 0;
    }
  },
  properties: {
    stalled: {
      get: function get() {
        return false; //this._stalled;
      },
      set: function set(value) {// this._setStalled(value)
      }
    }
  },
  _setStalled: function _setStalled(value) {
    if (this._stalled !== value) {
      this._stalled = value;
      this.requestRender(CanvasView.MODEL_INVALID | CanvasView.LAYOUT_INVALID);
    }
  },

  /* --------------------------- *
  /* children/layout
  /* --------------------------- */

  /** @override */
  initialize: function initialize(options) {
    // TODO: cleanup options mess in CanvasView
    CanvasView.prototype.initialize.apply(this, arguments); // options = _.defaults(options, this.defaults);

    this._labelFn = options.labelFn;
    this._stalled = !!options.stalled;
    this._valueStyles = {};
    this._canvasSize = null;
    this._canvasOrigin = null;
  },
  _needsLoop: false,

  /** @override */
  valueTo: function valueTo(key, value, duration) {
    if (key === "amount" && value < this.interpolator.getCurrentValue("amount")) {
      this._needsLoop = true;
    }

    CanvasView.prototype.valueTo.apply(this, arguments);
  },

  /* --------------------------- *
  /* private
  /* --------------------------- */

  /** @override */
  measureCanvas: function measureCanvas(w, h, s) {
    // make canvas square
    this._canvasHeight = this._canvasWidth = Math.min(w, h);
  },

  /** @override */
  updateCanvas: function updateCanvas() {
    // CanvasView.prototype._updateCanvas.apply(this, arguments);
    // size, lines, gaps, dashes (this._valueStyles, GAP_ARC, this._arcRadius)
    // --------------------------------
    // var arcName, s, arcDefault;
    // var mapLineDash = function(n) {
    // 	return n * this.radius * GAP_ARC;
    // };
    // var sumFn = function(s, n) {
    // 	return s + n;
    // };
    // this._canvasSize = Math.min(this._canvasWidth, this._canvasHeight);
    var s; // this._maxDashArc = 0

    for (var styleName in ARC_DEFAULTS) {
      s = _.defaults({}, ARC_DEFAULTS[styleName]);
      s.lineWidth *= this._canvasRatio;
      s.radius = (this._canvasWidth - s.lineWidth) / 2;

      if (s.radiusOffset) {
        s.radius += s.radiusOffset * this._canvasRatio;
      }

      if (_.isArray(s.lineDash)) {
        s.lineDash = s.lineDash.map(function (val, i, arr) {
          return val * this.radius * GAP_ARC;
        }, s);
        s.lineDashLength = s.lineDash.reduce(function (res, val, i, arr) {
          return res + val;
        }, 0);
        s.lineDashArc = s.lineDash[0] * GAP_ARC; // this._maxDashArc = Math.max(this._maxDashArc, s.lineDashArc);
      } else {
        s.lineDashArc = 0;
      }

      this._valueStyles[styleName] = s;
    } // baselineShift
    // --------------------------------
    // NOTE: Center baseline: use ascent data to center to x-height, or sort-of.
    // with ascent/descent values (0.7, -0.3), x-height is 0.4


    var mObj = this._getFontMetrics(this._fontFamily);

    this._baselineShift = mObj ? (mObj.ascent + mObj.descent) / mObj.unitsPerEm : 0.7; // default value

    this._baselineShift *= this._fontSize * 0.5; // apply to font-size, halve it

    this._baselineShift = Math.round(this._baselineShift); // save canvas context
    // --------------------------------
    // reset matrix and translate 0,0 to center

    this._ctx.restore();

    this._ctx.setTransform(1, 0, 0, 1, this._canvasWidth / 2, this._canvasHeight / 2);

    this._ctx.save();
  },

  /** @override */
  redraw: function redraw(ctx, intrp, flags) {
    this._clearCanvas(-this._canvasWidth / 2, -this._canvasHeight / 2, this._canvasWidth, this._canvasHeight);

    var s, // reused style objects
    valData, // reused for interpolated data
    arcVal; // reused arc values
    // amount label
    // --------------------------------

    valData = intrp._valueData["amount"];
    this.drawLabel(this._labelFn(valData._renderedValue, valData._maxVal)); // indeterminate
    // --------------------------------

    /*
    var indVal;
    if (this.stalled) {
    	// _ind loop indefinitely while indeterminate: restart if at end
    	if (intrp.isAtTarget("_ind")) {
    		// if (intrp.renderedKeys && (intrp.renderedKeys.indexOf("_ind") === -1)) {
    		intrp.valueTo("_ind", 0, 0);
    		intrp.valueTo("_ind", 1, 1000);
    		intrp.updateValue("_ind");
    	}
    	indVal = intrp.getCurrentValue("_ind");
    	//indVal = intrp._valueData["_ind"]._renderedValue || 0;
    		// draw spinning arc
    	// --------------------------------
    	// s = this._valueStyles["amount"];
    	// ctx.save();
    	// ctx.rotate(PI2 * (BASE_ROTATION + (indVal))); // + GAP_ARC);
    	// lastEndArc = this.drawArc(1,
    	// 	GAP_ARC,
    	// 	PI2 - GAP_ARC,
    	// 	0, s);
    	// ctx.restore();
    	// return;
    		// lineDashOffset animation
    	// --------------------------------
    	s = this._valueStyles["indeterminate"];
    	s.lineDashOffset = s.lineDashLength * ((1 - indVal) % 3) * 3;
    	this._valueStyles["available"].inverse = "indeterminate";
    		// console.log("%s::redraw indVal:%o s.lineDashOffset:%o s.lineDash:%o", this.cid, indVal, s.lineDashOffset, s.lineDash[0]);
    		// draw spinning wheel
    	// --------------------------------
    	// ctx.save();
    	// ctx.rotate((PI2 / WHEEL_NUM) * indVal); // + GAP_ARC);
    	// this.drawWheel(this._valueStyles["amount"], 2 / 5, 3 / 5);
    	// ctx.restore();
    	} else {
    	if (!intrp.isAtTarget("_ind")) {
    		// if (intrp.renderedKeys && (intrp.renderedKeys.indexOf("_ind") !== -1)) {
    		intrp.valueTo("_ind", 0, 0);
    		intrp.updateValue("_ind");
    	}
    	// lineDashOffset animation
    	// --------------------------------
    	this._valueStyles["available"].inverse = "not-available";
    }*/
    // save ctx before drawing arcs

    ctx.save(); // loop (amount)
    // --------------------------------

    var loopVal;
    /*
    NOTE: If value "amount" has changed (with valueTo()) but no yet
    interpolated, and its last rendered value is less, then its been reset
    (a reload, a loop, etc): we trigger a 'loop' of the whole arc.
    */
    // if ((intrp.renderedKeys.indexOf("amount") !== -1) && (valData._lastRenderedValue > valData._renderedValue)) {

    if (this._needsLoop) {
      this._needsLoop = false; // trigger loop

      intrp.valueTo("_loop", 1, 0);
      intrp.valueTo("_loop", 0, 750);
      intrp.updateValue("_loop");
    } // loopVal = intrp._valueData["_loop"]._renderedValue || 0;


    loopVal = intrp.getCurrentValue("_loop");
    ctx.rotate(PI2 * (BASE_ROTATION + (1 - loopVal))); // + GAP_ARC);
    // amount arc
    // --------------------------------
    // var amountGapArc = GAP_ARC;

    var lastEndArc = 0;
    s = this._valueStyles["amount"];
    arcVal = loopVal + valData._renderedValue / valData._maxVal;

    if (arcVal > 0) {
      lastEndArc = this.drawArc(arcVal, GAP_ARC, PI2 - GAP_ARC, lastEndArc, s);
      this.drawEndCap(lastEndArc, s);
      lastEndArc = lastEndArc + GAP_ARC * 2;
    } // available arc
    // --------------------------------


    s = this._valueStyles["available"];
    valData = intrp._valueData["available"];
    var stepsNum = valData.length || 1;
    var stepBaseArc = PI2 / stepsNum;
    var stepAdjustArc = stepBaseArc % GAP_ARC;
    var stepGapArc = GAP_ARC + (stepAdjustArc - s.lineDashArc) / 2;

    if (Array.isArray(valData)) {
      for (var i = 0; i < stepsNum; i++) {
        arcVal = valData[i]._renderedValue / (valData[i]._maxVal / stepsNum);
        this.drawArc(arcVal, i * stepBaseArc + stepGapArc, (i + 1) * stepBaseArc - stepGapArc, lastEndArc, s);
      }
    } else {
      arcVal = valData._renderedValue / valData._maxVal;
      this.drawArc(arcVal, stepGapArc, PI2 - stepGapArc, lastEndArc, s);
    } // restore ctx after drawing arcs
    // keep rotation transform
    //ctx.restore();


    if (this._stalled) {
      if (intrp.getTargetValue('_stalled_arc') === 0) {
        intrp.valueTo('_stalled_arc', 1, 1 * STEP_MS, easeIn).updateValue('_stalled_arc');
      }
    } else {
      if (intrp.getTargetValue('_stalled_arc') === 1) {
        intrp.valueTo('_stalled_arc', 0, 1 * STEP_MS, easeOut).updateValue('_stalled_arc');
      }
    }

    var a = intrp.getRenderedValue("_stalled_arc"); // while arc is > 0, loop indefinitely while spinning and restart
    // if at end. Otherwise let interp exhaust arc duration

    if (a > 0) {
      if (!intrp.paused && intrp.isAtTarget('_stalled_loop')) {
        intrp.valueTo('_stalled_loop', 0, 0).valueTo('_stalled_loop', 1, 2 * STEP_MS).updateValue('_stalled_loop');
      }
    }

    var l = intrp.getRenderedValue("_stalled_loop"); // always render while arc is > 0

    if (a > 0) {
      // arc span bounce
      var b = (l < 0.5 ? l % 0.5 : 0.5 - l % 0.5) * 2; // bounce + main arc span

      var aa = a * b * 0.25 + a * 0.125 + .0001; // rotation loop

      var ll = l + LOOP_OFFSET;
      ctx.save();
      ctx.lineWidth = 10 * this._canvasRatio;
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeColor = 'red';
      ctx.beginPath();
      ctx.arc(0, 0, this._canvasWidth / 2, (1 - aa + ll) * PI2, (aa + ll) * PI2, false);
      ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  },
  drawArc: function drawArc(value, startArc, endArc, prevArc, style) {
    var valArc, valStartArc, valEndArc, invStyle, invStartArc, invEndArc;
    prevArc || (prevArc = 0);
    valArc = endArc - startArc;
    valEndArc = startArc + valArc * value;
    valStartArc = Math.max(startArc, prevArc);

    if (valEndArc > valStartArc) {
      this._ctx.save();

      this.applyValueStyle(style);

      this._ctx.beginPath();

      this._ctx.arc(0, 0, style.radius, valEndArc, valStartArc, true);

      this._ctx.stroke();

      this._ctx.restore();
    } // if there's valueStyle, draw rest of span, minus prevArc overlap too


    if (style.inverse !== void 0) {
      invStyle = this._valueStyles[style.inverse];
      invEndArc = valEndArc + valArc * (1 - value);
      invStartArc = Math.max(valEndArc, prevArc);

      if (invEndArc > invStartArc) {
        this._ctx.save();

        this.applyValueStyle(invStyle);

        this._ctx.beginPath();

        this._ctx.arc(0, 0, invStyle.radius, invEndArc, invStartArc, true);

        this._ctx.stroke();

        this._ctx.restore();
      }
    }

    return valEndArc;
  },
  applyValueStyle: function applyValueStyle(s) {
    this._ctx.lineWidth = s.lineWidth;

    if (_.isArray(s.lineDash)) {
      this._ctx.setLineDash(s.lineDash);
    }

    if (_.isNumber(s.lineDashOffset)) {
      this._ctx.lineDashOffset = s.lineDashOffset;
    }
  },
  drawNotch: function drawNotch(arcPos, length, s) {
    var ex, ey, ec1, ec2;
    ex = Math.cos(arcPos);
    ey = Math.sin(arcPos);
    ec1 = s.radius;
    ec2 = s.radius - length;

    this._ctx.save();

    this.applyValueStyle(s);
    this._ctx.lineCap = "square";

    this._ctx.beginPath();

    this._ctx.moveTo(ec1 * ex, ec1 * ey);

    this._ctx.lineTo(ec2 * ex, ec2 * ey);

    this._ctx.stroke();

    this._ctx.restore();
  },
  drawEndCap: function drawEndCap(arcPos, s) {
    var radius = s.radius;

    this._ctx.save();

    this._ctx.lineWidth = s.lineWidth;

    this._ctx.rotate(arcPos - GAP_ARC * 2); // 1.5);


    this._ctx.beginPath();

    this._ctx.arc(0, 0, radius, GAP_ARC * 0.5, GAP_ARC * 2, false);

    this._ctx.lineTo(radius - GAP_ARC * radius, 0);

    this._ctx.closePath();

    this._ctx.fill();

    this._ctx.stroke();

    this._ctx.restore();
  },
  drawLabel: function drawLabel(s) {
    if (this._labelText !== s) {
      this._labelText = s;
      this._labelWidth = this._ctx.measureText(s).width;
    }

    this._ctx.fillText(s, this._labelWidth * -0.5, this._baselineShift, this._labelWidth);
  }
});

if (DEBUG) {
  module.exports.prototype._logFlags = "";
}

}).call(this,true,require("underscore"))

},{"app/view/base/CanvasView":78,"underscore":51,"utils/ease/fn/easeInQuad":140,"utils/ease/fn/easeOutQuad":141}],88:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/view/component/Carousel
 */

/** @type {module:backbone.babysitter} */

var Container = require("backbone.babysitter");
/** @type {module:hammerjs} */


var Hammer = require("hammerjs");
/** @type {module:utils/touch/SmoothPanRecognizer} */


var Pan = require("utils/touch/SmoothPanRecognizer");
/** @type {module:hammerjs.Tap} */


var Tap = Hammer.Tap;
/** @type {module:app/control/Globals} */

var Globals = require("app/control/Globals");
/** @type {module:app/view/base/View} */


var View = require("app/view/base/View"); // /** @type {module:app/view/base/DeferredView} */
// var View = require("app/view/base/DeferredView");

/** @type {module:app/view/render/CarouselRenderer} */


var CarouselRenderer = require("app/view/render/CarouselRenderer");
/** @type {module:utils/prefixedProperty} */


var prefixedProperty = require("utils/prefixedProperty");
/** @type {module:utils/prefixedStyleName} */


var prefixedStyleName = require("utils/prefixedStyleName");

var transformStyleName = prefixedStyleName("transform");
var transformProperty = prefixedProperty("transform");
var translateTemplate = Globals.TRANSLATE_TEMPLATE; // var cssToPx = function(cssVal, el) {
// 	return parseInt(cssVal);
// };
// var defaultRendererFunction = (function() {
// 	var defaultRenderer = CarouselRenderer.extend({ className: "carousel-item default-renderer"}),
// 		emptyRenderer = CarouselRenderer.extend({ className: "carousel-item empty-renderer"});
// 	return function(item, index, arr) {
// 		return (index === -1)? emptyRenderer: defaultRenderer;
// 	};
// })();

/** @const */

var MAX_SELECT_THRESHOLD = 20; // /** @const */
// var CHILDREN_INVALID = View.CHILDREN_INVALID,
// 	STYLES_INVALID = View.STYLES_INVALID,
// 	MODEL_INVALID = View.MODEL_INVALID,
// 	SIZE_INVALID = View.SIZE_INVALID,
// 	LAYOUT_INVALID = View.LAYOUT_INVALID;

var VERTICAL = Hammer.DIRECTION_VERTICAL,
    HORIZONTAL = Hammer.DIRECTION_HORIZONTAL; // x: ["x", "y"],
// y: ["y", "x"],
// offsetLeft: ["offsetLeft", "offsetTop"],
// offsetTop: ["offsetTop", "offsetLeft"],
// offsetWidth: ["offsetWidth", "offsetHeight"],
// offsetHeight: ["offsetHeight", "offsetWidth"],
// width: ["width","height"],
// height: ["height","width"],
// marginLeft: ["marginLeft","marginTop"],
// marginRight: ["marginRight","marginBottom"],

/*
var HORIZONTAL_PROPS = {
	pos: "x",
	size: "width",
	offsetPos: "offsetLeft",
	offsetSize: "offsetWidth",
	marginBefore: "marginLeft",
	marginAfter: "marginRight",
};
var VERTICAL_PROPS = {
	pos: "y",
	size: "height",
	offsetPos: "offsetTop",
	offsetSize: "offsetHeight",
	marginBefore: "marginTop",
	marginAfter: "marginBottom",
};
*/
// var DIRECTION_NONE = 1;
// var DIRECTION_LEFT = 2;
// var DIRECTION_RIGHT = 4;
// var DIRECTION_UP = 8;
// var DIRECTION_DOWN = 16;

var dirToStr = function dirToStr(dir) {
  if (dir === Hammer.DIRECTION_NONE) return 'NONE';
  if (dir === Hammer.DIRECTION_LEFT) return 'LEFT';
  if (dir === Hammer.DIRECTION_RIGHT) return 'RIGHT';
  if (dir === Hammer.DIRECTION_UP) return 'UP';
  if (dir === Hammer.DIRECTION_DOWN) return 'DOWN';
  if (dir === Hammer.DIRECTION_HORIZONTAL) return 'HOR'; //IZONTAL';

  if (dir === Hammer.DIRECTION_VERTICAL) return 'VER'; //TICAL';

  if (dir === Hammer.DIRECTION_ALL) return 'ALL';
  return 'UNREC'; //OGNIZED';
};

var isValidTouchManager = function isValidTouchManager(touch, direction) {
  // var retval;
  try {
    return touch.get("hpan").options.direction == direction;
  } catch (err) {
    return false;
  } // return retval;

}; // /** @type {int} In pixels */
// var panThreshold: 15;


var createTouchManager = function createTouchManager(el, dir, thres) {
  var touch = new Hammer.Manager(el);
  var pan = new Pan({
    event: "hpan",
    threshold: Globals.THRESHOLD,
    direction: Hammer.DIRECTION_HORIZONTAL
  });
  var tap = new Tap({
    threshold: Globals.THRESHOLD - 1,
    interval: 50,
    time: 200
  });
  tap.recognizeWith(pan);
  touch.add([pan, tap]);
  return touch;
};

var Carousel = {
  /** const */
  ANIMATED: false,

  /** const */
  IMMEDIATE: true,

  /** copy of Hammer.DIRECTION_VERTICAL */
  DIRECTION_VERTICAL: VERTICAL,

  /** copy of Hammer.DIRECTION_HORIZONTAL */
  DIRECTION_HORIZONTAL: HORIZONTAL,

  /** @type {Object} */
  defaults: {
    /** @type {boolean} */
    selectOnScrollEnd: false,

    /** @type {boolean} */
    requireSelection: false,

    /** @type {int} */
    direction: HORIZONTAL,

    /** @type {int} In pixels */
    selectThreshold: 20,

    /** @type {Function} */
    rendererFunction: function () {
      var defaultRenderer = CarouselRenderer.extend({
        className: "carousel-item default-renderer"
      }),
          emptyRenderer = CarouselRenderer.extend({
        className: "carousel-item empty-renderer"
      });
      return function (item, index, arr) {
        return index === -1 ? emptyRenderer : defaultRenderer;
      };
    }()
  }
};
Carousel.validOptions = _.keys(Carousel.defaults);
/**
/* @constructor
/* @type {module:app/view/component/Carousel}
/*/

var CarouselProto = {
  /** @override */
  cidPrefix: "carousel",

  /** @override */
  tagName: "div",

  /** @override */
  className: "carousel skip-transitions",

  /* --------------------------- *
  /* properties
  /* --------------------------- */
  properties: {
    scrolling: {
      get: function get() {
        return this._scrolling;
      }
    },
    selectedItem: {
      get: function get() {
        return this._selectedView.model;
      },
      set: function set(value) {
        if (value) this._onSelectOne(value);else this._onSelectNone();
      }
    }
  },
  events: {
    // "mousedown": "_onMouseDown", "mouseup": "_onMouseUp",
    "transitionend .carousel-item.selected": "_onScrollTransitionEnd",
    "click .carousel-item:not(.selected)": "_onClick"
  },

  /** @override */
  initialize: function initialize(options) {
    _.bindAll(this, "_onPointerEvent", "_onClick");

    this.itemViews = new Container();
    this.metrics = {};

    _.extend(this, _.defaults(_.pick(options, Carousel.validOptions), Carousel.defaults)); // this.childGap = 0; //this.dirProp(20, 18);


    this._precedingDir = (Hammer.DIRECTION_LEFT | Hammer.DIRECTION_UP) & this.direction;
    this._followingDir = (Hammer.DIRECTION_RIGHT | Hammer.DIRECTION_DOWN) & this.direction; // use supplied touch mgr or create private

    if (isValidTouchManager(options.touch, this.direction)) {
      this.touch = options.touch;
    } else {
      console.warn("%s::initialize creating Hammer instance", this.cid);
      this.touch = createTouchManager(this.el, this.direction); // this.on("view:removed", this.touch.destroy, this.touch);

      this.listenTo(this, "view:removed", function () {
        this.touch.destroy();
      });
    }
    /* create children and props */


    this.setEnabled(true);
    this.skipTransitions = true;
    this._renderFlags = View.CHILDREN_INVALID; // this.invalidateChildren();

    this.listenTo(this, "view:attached", function () {
      this.skipTransitions = true; // this.invalidateSize();
      // this.renderNow();
      // this.requestRender();

      this.requestRender(View.SIZE_INVALID | View.LAYOUT_INVALID);
    });
    /* collection listeners */

    this.listenTo(this.collection, {
      "reset": this._onReset,
      "select:one": this._onSelectOne,
      "select:none": this._onSelectNone,
      "deselect:one": this._onDeselectAny,
      "deselect:none": this._onDeselectAny
    });
  },

  /* --------------------------- *
  /* Hammer init
  /* --------------------------- */
  // validateTouchManager: function(touch, direction) {
  // 	try {
  // 		return touch.get("pan").options.direction === direction);
  // 	} catch (err) {
  // 		return false;
  // 	}
  // },
  // initializeHammer: function(options) {
  // 	// direction from opts/defaults
  // 	if (options.direction === VERTICAL) {
  // 		this.direction = VERTICAL;
  // 	} // do nothing: the default is horizontal
  //
  // 	// validate hammer instance or create local
  // 	if ((touch = options.touch) && (pan = touch.get("pan"))) {
  // 		// Override direction only if specific
  // 		if (pan.options.direction !== Hammer.DIRECTION_ALL) {
  // 			this.direction = pan.options.direction;
  // 		}
  // 		this.panThreshold = pan.options.threshold;
  // 	} else {
  // 		console.warn("%s::initializeHammer using private Hammer instance", this.cid);
  // 		touch = createHammerInstance(this.el, this.panThreshold, this.direction);
  // 		this.on("view:removed", touch.destroy, touch);
  // 	}
  // 	this.touch = touch;
  // },
  remove: function remove() {
    // this._scrollPendingAction && this._scrollPendingAction(true);
    // if (this._enabled) {
    // 	this.touch.off("tap", this._onTap);
    // 	this.touch.off("hpanstart hpanmove hpanend hpancancel", this._onPan);
    // }
    this._togglePointerEvents(false);

    this.removeChildren();
    View.prototype.remove.apply(this, arguments);
    return this;
  },

  /* --------------------------- *
  /* helper functions
  /* --------------------------- */
  dirProp: function dirProp(hProp, vProp) {
    return this.direction & HORIZONTAL ? hProp : vProp;
  },

  /* --------------------------- *
  /* Render
  /* --------------------------- */
  // render: function() {
  // 	if (this.attached) {
  // 		this.skipTransitions = true;
  // 		// this.invalidateSize();
  // 		this.renderNow(true);
  // 	}
  // },
  // /** @override */
  // render: function () {
  // 	if (!this.attached) {
  // 		if (!this._renderPending) {
  // 			this._renderPending = true;
  // 			this.listenTo(this, "view:attached", this.render);
  // 		}
  // 	} else {
  // 		if (this._renderPending) {
  // 			this._renderPending = false;
  // 			this.stopListening(this, "view:attached", this.render);
  // 		}
  // 		this._delta = 0;
  // 		this.skipTransitions = true;
  // 		this.invalidateSize();
  // 		// this.invalidateLayout();
  // 		this.renderNow();
  // 	}
  // 	return this;
  // },
  // render: function () {
  // 	this.measureLater();
  // 	this.scrollBy(0, Carousel.IMMEDIATE);
  //
  // 	if (this.el.parentElement) {
  // 		this.renderNow();
  // 	}
  // 	return this;
  // },

  /** @override */
  renderFrame: function renderFrame(tstamp, flags) {
    if (flags & View.CHILDREN_INVALID) {
      this._createChildren(); // clear this flag now: render may be deferred until attached


      flags &= ~View.CHILDREN_INVALID;
    }

    if (this.attached) {
      if (flags & View.SIZE_INVALID) {
        this._measure();
      }

      if (flags & (View.LAYOUT_INVALID | View.SIZE_INVALID)) {
        this._scrollBy(this._delta, this.skipTransitions);
      }
    } else if (flags) {
      this.listenToOnce(this, "view:attached", function () {
        this.requestRender(flags);
      });
    }
  },

  /* --------------------------- *
  /* enabled
  /* --------------------------- */
  // /** @override */
  // _enabled: undefined,

  /** @override */
  setEnabled: function setEnabled(enabled) {
    if (this._enabled !== enabled) {
      this._enabled = enabled; // toggle events immediately

      this._togglePointerEvents(enabled); // dom manipulation on render (_renderEnabled)
      // this._renderFlags |= View.STYLES_INVALID;
      // this.requestRender();


      this.setImmediate(this._renderEnabled); // this._renderEnabled();
    }
  },
  _renderEnabled: function _renderEnabled() {
    this.el.classList.toggle("disabled", !this.enabled);
    this.itemViews.each(function (view) {
      view.setEnabled(this.enabled);
    }, this);
  },

  /* --------------------------- *
  /* Create children
  /* --------------------------- */
  _createChildren: function _createChildren() {
    // var sIndex;
    var buffer, renderer, view, viewOpts;
    this.removeChildren();

    if (this.collection.length) {
      viewOpts = {
        // viewDepth: this.viewDepth + 1,
        // parentView: this,
        enabled: this.enabled
      };
      buffer = document.createDocumentFragment(); // buffer = this.el;

      if (!this.requireSelection) {
        renderer = this.rendererFunction(null, -1, this.collection);
        view = new renderer(viewOpts);
        this.itemViews.add(view);
        buffer.appendChild(view.el);
        this.emptyView = view;
      }

      this.collection.each(function (item, index, arr) {
        viewOpts.model = item;
        renderer = this.rendererFunction(item, index, arr);
        view = new renderer(viewOpts);
        this.itemViews.add(view);
        buffer.appendChild(view.el);
      }, this); // if (!this.requireSelection) {
      // 	buffer = this.appendItemView(buffer, this.model, -1, this.collection);
      // 	this.emptyView = this.itemViews.first();
      // }
      // buffer = this.collection.reduce(this.appendItemView, buffer, this);

      this.adjustToSelection();

      this._selectedView.el.classList.add("selected");

      this.el.appendChild(buffer);
    }
  },
  // appendItemView: function (parentEl, model, index, arr) {
  // 	var renderer = this.rendererFunction(model, index, arr);
  // 	var view = new renderer({
  // 		model: model,
  // 		parentView: this,
  // 		enabled: this.enabled
  // 	});
  // 	this.itemViews.add(view);
  // 	parentEl.appendChild(view.el);
  // 	return parentEl;
  // },
  // createItemView: function (renderer, opts) {
  // 	var view = new renderer(opts);
  // 	this.itemViews.add(view);
  // 	return view;
  // },
  removeChildren: function removeChildren() {
    this.itemViews.each(this.removeItemView, this);
    this.emptyView = void 0;
  },
  removeItemView: function removeItemView(view) {
    this.itemViews.remove(view);
    view.remove();
    return view;
  },

  /* --------------------------- *
  /* measure
  /* --------------------------- */
  _measure: function _measure() {
    var m, mm;
    var pos = 0,
        posInner = 0;
    var maxAcross = 0,
        maxOuter = 0;
    var maxOuterView, maxAcrossView;
    maxOuterView = maxAcrossView = this.emptyView || this.itemViews.first(); // chidren metrics

    this.itemViews.each(function (view) {
      view.render();
    });
    this.itemViews.each(function (view) {
      m = this.measureItemView(view);
      m.pos = pos;
      pos += m.outer; // + this.childGap;

      m.posInner = posInner;
      posInner += m.inner; //+ this.childGap;

      if (view !== this.emptyView) {
        if (m.across > maxAcross) {
          maxAcross = m.across;
          maxAcrossView = view;
        }

        if (m.outer > maxOuter) {
          maxOuter = m.outer;
          maxOuterView = view;
        }
      }
    }, this); // measure self + max child metrics

    mm = this.metrics[this.cid] || (this.metrics[this.cid] = {});
    mm.outer = this.el[this.dirProp("offsetWidth", "offsetHeight")];
    mm.before = maxOuterView.el[this.dirProp("offsetLeft", "offsetTop")];
    mm.inner = maxOuterView.el[this.dirProp("offsetWidth", "offsetHeight")];
    mm.after = mm.outer - (mm.inner + mm.before);
    mm.across = maxAcross; // m = this.metrics[maxOuterView.cid];
    // mm.inner = m.inner;
    // tap area

    this._tapAcrossBefore = maxAcrossView.el[this.dirProp("offsetTop", "offsetLeft")];
    this._tapAcrossAfter = this._tapAcrossBefore + maxAcross;
    this._tapBefore = mm.before + this._tapGrow;
    this._tapAfter = mm.before + mm.inner - this._tapGrow;
    this.selectThreshold = Math.min(MAX_SELECT_THRESHOLD, mm.outer * 0.1);
  },
  measureItemView: function measureItemView(view) {
    var m, viewEl; // var s, sizeEl;

    viewEl = view.el;
    m = this.metrics[view.cid] || (this.metrics[view.cid] = {});
    m.outer = viewEl[this.dirProp("offsetWidth", "offsetHeight")];
    m.across = viewEl[this.dirProp("offsetHeight", "offsetWidth")];

    if (view.metrics) {
      m.before = view.metrics[this.dirProp("marginLeft", "marginTop")];
      m.outer += m.before;
      m.outer += view.metrics[this.dirProp("marginRight", "marginBottom")];
      m.inner = view.metrics.content[this.dirProp("width", "height")];
      m.before += view.metrics.content[this.dirProp("x", "y")];
      m.after = m.outer - (m.inner + m.before); // var marginBefore = view.metrics[this.dirProp("marginLeft","marginTop")];
      // var marginAfter = view.metrics[this.dirProp("marginRight","marginBottom")];
      // var pos = view.metrics.content[this.dirProp("x","y")];
      //
      // m.inner = view.metrics.content[this.dirProp("width","height")];
      // m.before = marginBefore + pos;
      // m.outer += marginBefore + marginAfter;
      // m.after = m.outer - (m.inner + m.before);
    } else {
      // throw new Error("renderer has no metrics");
      console.warn("%s::measureItemView view '%s' has no metrics", this.cid, view.cid);
      m.inner = m.outer;
      m.after = m.before = 0;
    }

    return m;
  },

  /* --------------------------- *
  /* scrolling property
  /* --------------------------- */
  _delta: 0,
  _scrolling: false,
  _setScrolling: function _setScrolling(scrolling) {
    // console.warn("_setScrolling current/requested", this._scrolling, scrolling);
    if (this._scrolling != scrolling) {
      this._scrolling = scrolling;
      this.el.classList.toggle("scrolling", scrolling);
      this.trigger(scrolling ? "view:scrollstart" : "view:scrollend");
    }
  },

  /* --------------------------- *
  /* Scroll/layout
  /* --------------------------- */
  scrollBy: function scrollBy(delta, skipTransitions) {
    this._delta = delta || 0;
    this.skipTransitions = !!skipTransitions; // this.invalidateLayout();

    this.requestRender(View.LAYOUT_INVALID);
  },
  _scrollBy: function _scrollBy(delta, skipTransitions) {
    var sMetrics, metrics, pos;
    sMetrics = this.metrics[(this._scrollCandidateView || this._selectedView).cid];
    this.itemViews.each(function (view) {
      metrics = this.metrics[view.cid];
      pos = Math.floor(this._getScrollOffset(delta, metrics, sMetrics));
      view.metrics.translateX = this.direction & HORIZONTAL ? pos : 0;
      view.metrics.translateY = this.direction & HORIZONTAL ? 0 : pos;
      view.metrics._transform = translateTemplate(view.metrics.translateX, view.metrics.translateY);
      view.el.style[transformProperty] = view.metrics._transform; // view.el.style[transformProperty] = (this.direction & HORIZONTAL)?
      // 	"translate3d(" + pos + "px,0,0)":
      // 	"translate3d(0," + pos + "px,0)";
    }, this);
    this.el.classList.toggle("skip-transitions", skipTransitions);
    this.selectFromView();
  },
  _getScrollOffset: function _getScrollOffset(delta, mCurr, mSel) {
    var pos,
        offset = 0;
    pos = mCurr.pos - mSel.pos + delta;

    if (pos < 0) {
      if (Math.abs(pos) < mSel.outer) {
        offset += -mCurr.after / mSel.outer * pos;
      } else {
        offset += mCurr.after;
      }
    } else if (0 <= pos) {
      if (Math.abs(pos) < mSel.outer) {
        offset -= mCurr.before / mSel.outer * pos;
      } else {
        offset -= mCurr.before;
      }
    }

    return pos + offset;
  },
  _onScrollTransitionEnd: function _onScrollTransitionEnd(ev) {
    if (ev.propertyName === transformStyleName && this.scrolling) {
      console.log("%s::_onScrollTransitionEnd selected: %s", this.cid, ev.target.cid);

      this._setScrolling(false);
    }
  },

  /* --------------------------- *
  /* toggle touch events
  /* --------------------------- */
  _togglePointerEvents: function _togglePointerEvents(enable) {
    // console.log("%s::_togglePointerEvents", this.cid, enable);
    if (this._pointerEventsEnabled == enable) return;
    this._pointerEventsEnabled = enable;

    if (enable) {
      this.touch.on("hpanstart hpanmove hpanend hpancancel", this._onPointerEvent);
      this.el.addEventListener(View.CLICK_EVENT, this._onClick, true);
    } else {
      this.touch.off("hpanstart hpanmove hpanend hpancancel", this._onPointerEvent);
      this.el.removeEventListener(View.CLICK_EVENT, this._onClick, true);
    }
  },
  _onPointerEvent: function _onPointerEvent(ev) {
    // NOTE: https://github.com/hammerjs/hammer.js/pull/1118
    if (ev.srcEvent.type === 'pointercancel') return;
    console.log("%s:[%s (%s)]:_onPointerEvent offs:%s [%s|%s==%s] [%s]", this.cid, ev.type, ev.srcEvent.type, dirToStr(ev.offsetDirection), dirToStr(ev.direction), dirToStr(this.direction), dirToStr(ev.direction | this.direction), ev.srcEvent.defaultPrevented ? "prevented" : "-"); // if (ev.direction & this.direction) {

    switch (ev.type) {
      // case View.CLICK_EVENT:
      // 	return this._onClick(ev);
      // case "tap":
      // 	return this._onTap(ev);
      case "hpanstart":
        return this._onPanStart(ev);

      case "hpanmove":
        return this._onPanMove(ev);

      case "hpanend":
        return this._onPanFinal(ev);

      case "hpancancel":
        return this._onPanFinal(ev);
    } // }

  },

  /* --------------------------- *
  /* touch event: pan
  /* --------------------------- */
  getViewAtPanDir: function getViewAtPanDir(dir) {
    // return (dir & this._precedingDir) ? this._precedingView : this._followingView;
    return dir & this._followingDir ? this._precedingView : this._followingView;
  },
  // _panCapturedOffset: 0,

  /** @param {Object} ev */
  _onPanStart: function _onPanStart(ev) {
    this.selectFromView();
    this.el.classList.add("panning");

    this._setScrolling(true);
  },

  /** @param {Object} ev */
  _onPanMove: function _onPanMove(ev) {
    // var delta = (this.direction & HORIZONTAL) ? ev.thresholdDeltaX : ev.thresholdDeltaY;
    var delta = this.direction & HORIZONTAL ? ev.deltaX : ev.deltaY;
    var view = this.getViewAtPanDir(ev.offsetDirection);
    var cView = this._panCandidateView;

    if (cView !== view) {
      cView && cView.el.classList.remove("candidate");
      view && view.el.classList.add("candidate");
      this._panCandidateView = view;
    }

    if (cView === void 0) {
      delta *= Globals.HPAN_OUT_DRAG;
    }

    if (this._renderRafId !== -1) {
      this.scrollBy(delta, Carousel.IMMEDIATE);
      this.renderNow();
    } else {
      this._scrollBy(delta, Carousel.IMMEDIATE);
    }
  },

  /** @param {Object} ev */
  _onPanFinal: function _onPanFinal(ev) {
    var scrollCandidate; // NOTE: this delta is used for determining selection, NOT for layout
    // var delta = (this.direction & HORIZONTAL) ? ev.thresholdDeltaX : ev.thresholdDeltaY;

    var delta = this.direction & HORIZONTAL ? ev.deltaX : ev.deltaY;

    if (ev.type == "hpanend" &&
    /* pan direction (current event) and offsetDirection (whole gesture) must match */
    ev.direction ^ ev.offsetDirection ^ this.direction // && (ev.direction & ev.offsetDirection & this.direction)

    /* gesture must overshoot selectThreshold */
    && Math.abs(delta) > this.selectThreshold) {
      /* choose next scroll target */
      scrollCandidate = this.getViewAtPanDir(ev.offsetDirection);
    }

    this._scrollCandidateView = scrollCandidate || void 0;

    if (this._panCandidateView && this._panCandidateView !== scrollCandidate) {
      this._panCandidateView.el.classList.remove("candidate");
    }

    this._panCandidateView = void 0;
    this.el.classList.remove("panning");
    console.log("%s:[%s]:_onPanFinal thres:(%s>%s) dir:(e:%s o:%s c:%s)=%s\n", this.cid, ev.type, Math.abs(delta), this.selectThreshold, dirToStr(ev.direction), dirToStr(ev.offsetDirection), dirToStr(this.direction), dirToStr(ev.direction ^ ev.offsetDirection ^ this.direction), scrollCandidate ? scrollCandidate.cid + ":" + scrollCandidate.model.cid : "none"); // console.log("%s::_onPanFinal", this.cid, ev);

    this.scrollBy(0, Carousel.ANIMATED);
    this.selectFromView(); // if (this._renderRafId !== -1) {
    // 	this.scrollBy(0, Carousel.ANIMATED);
    // 	this.renderNow();
    // } else {
    // 	this._scrollBy(0, Carousel.ANIMATED);
    // }
  },

  /* --------------------------- *
  /* touch event: tap
  /* --------------------------- */

  /** @type {int} In pixels */
  _tapGrow: 10,
  getViewAtTapPos: function getViewAtTapPos(posAlong, posAcross) {
    if (this._tapAcrossBefore < posAcross && posAcross < this._tapAcrossAfter) {
      if (posAlong < this._tapBefore) {
        return this._precedingView;
      } else if (posAlong > this._tapAfter) {
        return this._followingView;
      }
    }

    return void 0;
  },
  _onClick: function _onClick(ev) {
    console.log("%s::_onClick [%s]", this.cid, ev.type, ev.defaultPrevented ? "prevented" : "not-prevented");

    this._onTap(ev);
  },
  _onTap: function _onTap(ev) {
    if (ev.defaultPrevented) return;
    var tapCandidate;
    var targetView = View.findByDescendant(ev.target); // console.log("%s::_onTap %o", this.cid, targetView.cid, ev.target);
    // if (!this.itemViews.contains(targetView)) {
    // 	return;
    // }

    do {
      if (this._selectedView === targetView) {
        tapCandidate = null;
        break;
      } else if (this === targetView.parentView) {
        tapCandidate = targetView;
        break;
      } else if (this === targetView) {
        var bounds, tapX, tapY;
        bounds = this.el.getBoundingClientRect();
        tapX = (ev.type === "tap" ? ev.center.x : ev.clientX) - bounds.left;
        tapY = (ev.type === "tap" ? ev.center.y : ev.clientY) - bounds.top;
        tapCandidate = this.getViewAtTapPos(this.dirProp(tapX, tapY), this.dirProp(tapY, tapX));
        break;
      }
    } while (targetView = targetView.parentView);

    if (tapCandidate) {
      ev.preventDefault(); // ev.stopPropagation();
      // this._scrollCandidateView = tapCandidate;
      // this._setScrolling(true);
      // this.scrollBy(0, Carousel.ANIMATED);
      // this._scrollCandidateView.el.classList.add("candidate");
      // this.selectFromView();
      //// NOT using internalSelection
      // this.triggerSelectionEvents(tapCandidate, false);
      // using internalSelection

      this._scrollCandidateView = tapCandidate;

      this._setScrolling(true);

      this.scrollBy(0, Carousel.ANIMATED);
      this.triggerSelectionEvents(tapCandidate, true); // this.renderNow();
    }
  },

  /* --------------------------- *
  /* Private
  /* --------------------------- */
  triggerSelectionEvents: function triggerSelectionEvents(view, internal) {
    if (view === void 0 || this._internalSelection) {
      return;
    }

    this._internalSelection = !!internal;

    if (view === this.emptyView) {
      this.trigger("view:select:none");
    } else {
      this.trigger("view:select:one", view.model);
    }

    this._internalSelection = false;
  },
  selectFromView: function selectFromView() {
    if (this._scrollCandidateView) {
      this.triggerSelectionEvents(this._scrollCandidateView, true);
    } // if (this._scrollCandidateView === (void 0)) {
    // 	return;
    // }
    // var view = this._scrollCandidateView;
    // this.triggerSelectionEvents(view, true);

  },
  adjustToSelection: function adjustToSelection() {
    var m,
        i = this.collection.selectedIndex; // assume -1 < index < this.collection.length

    if (this.requireSelection) {
      i == -1 && i++; // if selection is null (index -1), set _selectedView to first item (index 0)

      this._selectedView = (m = this.collection.at(i)) && this.itemViews.findByModel(m);
      this._precedingView = (m = this.collection.at(i - 1)) && this.itemViews.findByModel(m);
      this._followingView = (m = this.collection.at(i + 1)) && this.itemViews.findByModel(m);
    } else {
      this._selectedView = (m = this.collection.at(i)) ? this.itemViews.findByModel(m) : this.emptyView;
      this._precedingView = m && ((m = this.collection.at(i - 1)) ? this.itemViews.findByModel(m) : this.emptyView);
      this._followingView = (m = this.collection.at(i + 1)) && this.itemViews.findByModel(m);
    }
  },

  /* --------------------------- *
  /* Model listeners
  /* --------------------------- */

  /** @private */
  _onSelectOne: function _onSelectOne(model) {
    if (model === this._selectedView.model) {
      // console.info("INTERNAL");
      return;
    }

    this._onSelectAny(model);
  },

  /** @private */
  _onSelectNone: function _onSelectNone() {
    if ((this.requireSelection ? this.itemViews.first() : this.emptyView) === this._selectedView) {
      // console.info("INTERNAL");
      return;
    }

    this._onSelectAny();
  },

  /** @private */
  _onSelectAny: function _onSelectAny(model) {
    this._selectedView.el.classList.remove("selected");

    this.adjustToSelection();

    this._selectedView.el.classList.add("selected");

    if (this._scrollCandidateView) {
      this._scrollCandidateView.el.classList.remove("candidate");

      this._scrollCandidateView = void 0;
    }

    if (!this._internalSelection) {
      this._setScrolling(true);

      this.scrollBy(0, Carousel.ANIMATED);
    }
  },
  // _onDeselectAny: function (model) {},

  /** @private */
  _onReset: function _onReset() {
    // this._createChildren();
    // this.invalidateChildren();
    this.requestRender(View.CHILDREN_INVALID | View.MODEL_INVALID);
  }
  /* --------------------------- *
  /* TEMP
  /* --------------------------- */
  // _scrollBy2: function (delta, skipTransitions) {
  // 	var metrics, pos;
  // 	var sMetrics = this.metrics[(this._scrollCandidateView || this._selectedView).cid];
  // 	var cMetrics = this.metrics[(this._panCandidateView || this._selectedView).cid];
  //
  // 	this.itemViews.each(function (view) {
  // 		metrics = this.metrics[view.cid];
  // 		pos = Math.floor(this._getScrollOffset(delta, metrics, sMetrics, cMetrics));
  // 		view.el.style[transformProperty] = (this.direction & HORIZONTAL)?
  // 				"translate3d(" + pos + "px,0,0)" : "translate3d(0," + pos + "px,0)";
  // 				// "translate(" + pos + "px,0)" : "translate(0," + pos + "px)";
  // 				// "translateX(" + pos + "px)" : "translateY(" + pos + "px)";
  // 	}, this);
  // 	this.el.classList.toggle("skip-transitions", skipTransitions);
  // 	this.selectFromView();
  // },
  // _getScrollOffset2: function (delta, mCurr, mSel, mCan) {
  // 	var offset = 0;
  // 	var posInner = mCurr.posInner - mSel.posInner + delta;
  //
  // 	if (posInner < -mSel.inner) {
  // 		offset = -(mCurr.before);
  // 	} else if (posInner > mSel.inner) {
  // 		offset = (mSel.after);
  // 	} else {
  // 		if (posInner < 0) {
  // 			offset = (mCurr.before) / (mCurr.inner) * posInner;
  // 		} else {
  // 			offset = (mSel.after) / (mCan.inner) * posInner;
  // 		}
  // 	}
  // 	return posInner + offset;
  // },
  // captureSelectedOffset: function() {
  // 	var val, view, cssval, m, mm;
  //
  // 	val = 0;
  // 	view = this._scrollCandidateView || this._selectedView;
  // 	cssval = getComputedStyle(view.el)[transformProperty];
  //
  // 	mm = cssval.match(/(matrix|matrix3d)\(([^\)]+)\)/);
  // 	if (mm) {
  // 		m = mm[2].split(",");
  // 		if (this.direction & HORIZONTAL) {
  // 			val = m[mm[1]=="matrix"? 4 : 12];
  // 		} else {
  // 			val = m[mm[1]=="matrix"? 5 : 13];
  // 		}
  // 		val = parseFloat(val);
  // 	}
  //
  // 	console.log("%s::captureSelectedOffset", this.cid, cssval, val, cssval.match(/matrix\((?:\d\,){3}(\d)\,(\d)|matrix3d\((?:\d\,){11}(\d)\,(\d)/));
  //
  // 	return val;
  // },
  // _onScrollEnd: function(exec) {
  // 	this._scrollEndCancellable = (void 0);
  // 	// this.el.classList.remove("disabled-changing");
  // 	if (exec) {
  // 		this._setScrolling(false);
  // 		// this.el.classList.remove("scrolling");
  // 		// this.trigger("view:scrollend");
  // 		console.log("%s::_onScrollEnd", this.cid);
  // 	}
  // },
  // _onMouseDown: function(ev) {
  // 	if (this._scrolling) {
  // 		this._panCapturedOffset = this.captureSelectedOffset();
  // 		console.log("%s::events[mousedown] scrolling interrupted (pos %f)", this.cid, this._panCapturedOffset);
  // 	}
  // },
  // _onMouseUp:function(ev) {
  // 	this._panCapturedOffset = 0;
  // },

};

if (DEBUG) {
  CarouselProto._logFlags = "";
}

module.exports = Carousel = View.extend(CarouselProto, Carousel);

}).call(this,true,require("underscore"))

},{"app/control/Globals":55,"app/view/base/View":82,"app/view/render/CarouselRenderer":105,"backbone.babysitter":3,"hammerjs":15,"underscore":51,"utils/prefixedProperty":146,"utils/prefixedStyleName":147,"utils/touch/SmoothPanRecognizer":153}],89:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper;

  return container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"id","hash":{},"data":data}) : helper)));
},"useData":true});

},{"hbsfy/runtime":35}],90:[function(require,module,exports){
"use strict";
/**
 * @module app/view/component/CollectionStack
 */

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View");
/** @type {string} */


var viewTemplate = require("./CollectionStack.hbs");
/**
 * @constructor
 * @type {module:app/component/CollectionStack}
 */


module.exports = View.extend({
  /** @override */
  cidPrefix: "stack",

  /** @override */
  tagName: "div",

  /** @override */
  className: "stack",

  /** @override */
  template: viewTemplate,
  events: {
    "transitionend": function transitionend(ev) {
      // console.log("%s::transitionend [invalid: %s] [transition: %s]", this.cid, this._contentInvalid, (this._skipTransitions? "skip": "run"), ev.target.id, ev.target.className);
      this._renderContent();
    }
  },
  initialize: function initialize(options) {
    this._enabled = true;
    this._skipTransitions = true;
    this._contentInvalid = true;
    options.template && (this.template = options.template);
    this.content = document.createElement("div");
    this.content.className = "stack-item";
    this.el.appendChild(this.content);
    this.listenTo(this.collection, "select:one select:none", this._onSelectChange);
  },
  setEnabled: function setEnabled(enabled) {
    if (this._enabled !== enabled) {
      this._enabled = enabled;
      this.el.classList.toggle("disabled", !this._enabled);
    }
  },
  _onSelectChange: function _onSelectChange(item) {
    if (this._renderedItem === this.collection.selected) {
      throw new Error("change event received but item is identical");
    }

    this._renderedItem = this.collection.selected;
    this._contentInvalid = true;
    this.render();
  },

  /* --------------------------- *
  /* render
  /* --------------------------- */
  render: function render() {
    if (this._skipTransitions) {
      // execute even if content has not changed to apply styles immediately
      this._skipTransitions = false;
      this.el.classList.add("skip-transitions");
      this.setImmediate(function () {
        this.el.classList.remove("skip-transitions");
      }); // render changed content immediately

      if (this._contentInvalid) {
        this._renderContent();
      }
    } else {
      // else remove 'current' class and render on transitionend
      if (this._contentInvalid) {
        this.content.classList.remove("current"); // this.content.className = "stack-item";
      }
    }

    return this;
  },
  _renderContent: function _renderContent() {
    if (this._contentInvalid) {
      this._contentInvalid = false;
      var item = this.collection.selected;
      this.content.innerHTML = item ? this.template(item.toJSON()) : "";
      this.content.classList.add("current"); // this.content.className = "stack-item current";
    }
  }
});

},{"./CollectionStack.hbs":89,"app/view/base/View":82}],91:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
/* @module app/view/component/FilterableListView
/*/

/** @type {module:backbone.babysitter} */

var Container = require("backbone.babysitter");
/** @type {module:app/view/base/View} */


var View = require("app/view/base/View");
/** @type {module:app/view/component/ClickableRenderer} */


var ClickableRenderer = require("app/view/render/ClickableRenderer");
/** @type {module:utils/prefixedProperty} */


var prefixedProperty = require("utils/prefixedProperty");
/** @type {module:utils/css/getBoxEdgeStyles} */


var getBoxEdgeStyles = require("utils/css/getBoxEdgeStyles");
/** @type {module:utils/array/difference} */


var diff = require("utils/array/difference");
/** @type {module:utils/promise/resolveAll} */


var resolveAll = require("utils/promise/resolveAll");
/** @type {module:utils/promise/rejectAll} */


var rejectAll = require("utils/promise/rejectAll"); // var resolveAll = function(pp, result) {
// 	if (pp.length != 0) {
// 		pp.forEach(function(p, i, a) {
// 			p.resolve(result);
// 			a[i] = null;
// 		});
// 		pp.length = 0;
// 	}
// 	return pp;
// };
// var rejectAll = function(pp, reason) {
// 	if (pp.length != 0) {
// 		pp.forEach(function(p, i, a) {
// 			p.reject(reason);
// 			a[i] = null;
// 		});
// 		pp.length = 0;
// 	}
// 	return pp;
// };

/** @type {module:app/control/Globals.TRANSLATE_TEMPLATE} */


var translateCssValue = require("app/control/Globals").TRANSLATE_TEMPLATE;
/** @const */


var transformProp = prefixedProperty("transform");
/**
/* @constructor
/* @type {module:app/view/component/FilterableListView}
/*/

var FilterableListView = View.extend({
  /** @type {string} */
  cidPrefix: "filterableList",

  /** @override */
  tagName: "ul",

  /** @override */
  className: "list selectable filterable",

  /** @override */
  defaults: {
    collapsed: true,
    filterFn: function filterFn() {
      return true;
    },
    renderer: ClickableRenderer.extend({
      /** @override */
      cidPrefix: "listItem",

      /** @override */
      className: "list-item list-node"
    })
  },

  /** @override */
  properties: {
    collapsed: {
      get: function get() {
        return this._collapsed;
      },
      set: function set(value) {
        this._setCollapsed(value);
      }
    },
    selectedItem: {
      get: function get() {
        return this._selectedItem;
      },
      set: function set(value) {
        this._setSelection(value);
      }
    },
    filteredItems: {
      get: function get() {
        return this._filteredItems;
      }
    },
    metrics: {
      get: function get() {
        return this._metrics;
      }
    }
  },

  /** @override */
  events: {
    "transitionend .list-node": function transitionendListNode(ev) {
      // if (!ev.target.classList.contains("list-node")) {}
      if (ev.propertyName == transformProp && ev.target.parentElement === this.el) {
        this._changedPosNum--; // console.log("%s:[%s (%s)] [%s]", this.cid, ev.type, ev.target.className, ev.propertyName, this._changedPosNum, ev);
      }

      if (!this._collapsedChanging) {
        return;
      }

      if (this._changedPosNum == 0) {
        // if ((ev.propertyName == transformProp) ||
        // 	(ev.propertyName == "visibility")) {
        console.log("%s:[%s .list-item] [%s] collapsed-changing end (resolving %s promises)", this.cid, ev.type, ev.propertyName, this._collapsePromises.length);
        this._collapsedChanging = false;
        this.el.classList.remove("collapsed-changing");
        resolveAll(this._collapsePromises, this);
      }
    }
  },

  /** @override */
  initialize: function initialize(options) {
    this._filteredItems = [];
    this._filteredIncoming = [];
    this._filteredOutgoing = [];
    this._metrics = {};
    this._itemMetrics = [];
    this._collapsePromises = [];
    this.itemViews = new Container();

    _.defaults(options, this.defaults);

    this.renderer = options.renderer;
    this._filterFn = options.filterFn; // this.computeFilter();
    // this.collection.each(this.createItemView, this);

    this.collection.each(this.createItemView, this);

    this._setSelection(this.collection.selected);

    this._setCollapsed(options.collapsed);

    this.refreshFilter(); // this.skipTransitions = true;
    // this.renderNow();
    // this.listenTo(this.collection, "select:one select:none", this._setSelection);

    this.listenTo(this.collection, "reset", function () {
      this._allItems = null;
      throw new Error("not implemented");
    }); // will trigger on return if this.el is already attached
    // this.skipTransitions = true;
    // this.el.classList.add("skip-transitions");
    // this.requestRender(View.ALL_INVALID);

    console.log("%s::initialize attached: %o", this.cid, this.attached);
    this.once("view:attached", function (view) {
      console.log("%s::initialize -> [view:attached] attached: %o", view.cid, view.attached); // view.requestRender(View.ALL_INVALID).renderNow();

      view.skipTransitions = true;
      view.el.classList.add("skip-transitions");
      view.setImmediate(function () {
        // this.skipTransitions = true;
        view.renderNow();
      });
    });
  },

  /**
   * Get an array with a collection contens
   * @private
   */
  _getAllItems: function _getAllItems() {
    return this._allItems || (this._allItems = this.collection.slice());
  },

  /* --------------------------- *
  /* Transition promises
  /* --------------------------- */
  _whenCollapseChangeEnds: function _whenCollapseChangeEnds() {
    if (this._collapsedChanged) {
      var view = this;
      return new Promise(function (resolve, reject) {
        view.on("view:render:after", resolve);
      });
    } else {
      return Promise.resolve(this);
    }
  },
  whenCollapseChangeEnds: function whenCollapseChangeEnds() {
    var d, p, pp;

    if (this._collapsedChanging || this._collapsedChanged) {
      d = {};
      p = new Promise(function (resolve, reject) {
        d.resolve = resolve;
        d.reject = reject;
      });
      pp = this._collapsePromises;
      pp.push(d);
    } else {
      p = Promise.resolve(this);
    }

    return p;
  },

  /* --------------------------- *
  /* Render
  /* --------------------------- */

  /** @override */
  renderFrame: function renderFrame(tstamp, flags) {
    // if (DEBUG) {
    // 	var changed = [];
    // 	this._collapsedChanged && changed.push("collapsed");
    // 	this._selectionChanged && changed.push("selection");
    // 	this._filterChanged && changed.push("filter");
    // 	console.log("%s::renderFrame [%s]", this.cid, changed.join(" "));
    // }
    // collapsed transition flag
    if (this._collapsedChanging) {
      console.warn("%s::renderFrame collapsed tx interrupted", this.cid);
      this._collapsedChanging = false;
      this.el.classList.remove("collapsed-changing");
      rejectAll(this._collapsePromises, this);
    }

    if (this.skipTransitions) {
      this.el.classList.add("skip-transitions"); // this.requestAnimationFrame(function() {

      this.setImmediate(function () {
        this.skipTransitions = false;
        this.el.classList.remove("skip-transitions");
      });
    }

    if (this._collapsedChanged) {
      this._collapsedChanged = false;
      flags |= View.SIZE_INVALID;
      this.el.classList.toggle("collapsed", this._collapsed);

      if (this.skipTransitions) {
        this._collapsedChanging = false; // resolveAll(this._collapsePromises, this.el);

        this.once("view:render:after", function (view) {
          this._changedPosNum = 0;
          resolveAll(view._collapsePromises, view);
        });
      } else {
        this._collapsedChanging = true;
        this.el.classList.add("collapsed-changing"); // this will be resolved on transitionend
      }

      console.log("%s:[collapse changed] %s promises", this.cid, this._collapsePromises.length, this._collapsedChanging ? "resolving now" : "resolving on transitionend");
    }

    if (this._selectionChanged) {
      this._selectionChanged = false;
      flags |= View.LAYOUT_INVALID;
      this.renderSelection(this.collection.selected, this.collection.lastSelected);
    }

    if (this._filterChanged) {
      this._filterChanged = false;
      flags |= View.LAYOUT_INVALID;
      var lastFilteredItems = this.filteredItems; // this._printStats(lastFilteredItems);

      this.computeFilter();
      this.applyFilter();

      if (DEBUG) {
        this._printStats(lastFilteredItems);
      }
    }

    if (flags & View.SIZE_INVALID) {
      this.measure(); // NOTE: measures children
    }

    if (flags & (View.LAYOUT_INVALID | View.SIZE_INVALID)) {
      this.renderLayout();
    }
  },
  measure: function measure() {
    // var i, ii, el, els, m, mm;
    // els = this.el.children;
    // ii = els.length;
    // mm = this._itemMetrics;
    // for (i = 0; i < ii; i++) {
    // 	mm[i] = _.pick(els[i], "offsetTop", "offsetHeight");
    // }
    this._metrics = getBoxEdgeStyles(this.el, this._metrics); // var itemEl, itemView, baseline = 0;
    // if (itemEl = this.el.querySelector(".list-item:not(.excluded) .label")) {
    // 	// itemView = this.itemViews.findByCid(itemEl.cid);
    // 	var elA = itemEl, elB = itemEl.parentElement;
    // 	var yA = elA.offsetTop,
    // 		hA = elA.offsetHeight,
    // 		yB = elB.offsetTop,
    // 		hB = elB.offsetHeight;
    // 	baseline = ((yA + hA) - (yB + hB));
    // 	console.log("%s::measure fontSize: %spx (%s+%s)-(%s+%s)=%s", this.cid, this._metrics.fontSize,
    // 		yA, hA, yB, hB, baseline
    // 	);
    // }

    this.itemViews.forEach(function (view) {
      if (!view._metrics) view._metrics = {}; // view._metrics.baseline = this._metrics.fontSize - baseline;

      view._metrics.offsetTop = view.el.offsetTop;
      view._metrics.offsetHeight = view.el.offsetHeight;
      view._metrics.offsetLeft = view.el.offsetLeft;
      view._metrics.offsetWidth = view.el.offsetWidth;

      if (!this._collapsed && view.label) {
        view._metrics.textLeft = view.label.offsetLeft;
        view._metrics.textWidth = view.label.offsetWidth;
      } else {
        view._metrics.textLeft = view._metrics.offsetLeft;
        view._metrics.textWidth = view._metrics.offsetWidth;
      }
    }, this); // this._metrics.baseline = this._metrics.fontSize - baseline;
  },
  renderLayout: function renderLayout() {
    var posX, posY, lastX, lastY;
    posX = this._metrics.paddingLeft;
    posY = this._metrics.paddingTop;
    this._changedPosNum = 0; // use HTMLElement.children to keep layout order

    for (var i = 0, ii = this.el.children.length; i < ii; i++) {
      var view = this.itemViews.findByCid(this.el.children[i].cid);
      lastX = view.transform.tx;
      lastY = view.transform.ty;

      if ((this.collection.selected && !view.model.selected || view.el.classList.contains("excluded")) && this._collapsed) {
        view.transform.tx = posX;
        view.transform.ty = posY;
      } else {
        if (view._metrics.offsetHeight == 0) {
          posY -= view._metrics.offsetTop;
        }

        view.transform.tx = posX;
        view.transform.ty = posY;
        posY += view._metrics.offsetHeight + view._metrics.offsetTop;
      }

      view.el.style[transformProp] = translateCssValue(view.transform.tx, view.transform.ty);

      if (view.transform.tx != lastX || view.transform.ty != lastY) {
        this._changedPosNum++;
      }
    } // posY += this._metrics.paddingBottom;


    this._metrics.height = Math.max(0, posY + this._metrics.paddingBottom);
    this.el.style.height = this._metrics.height + "px"; // this.el.style.height = (posY > 0) ? posY + "px" : "";
  },

  /* --------------------------- *
  /* Child views
  /* --------------------------- */

  /** @private */
  createItemView: function createItemView(item, index) {
    var view = new this.renderer({
      model: item,
      el: this.el.querySelector(".list-item[data-id=\"" + item.id + "\"]")
    }); // item.set("excluded", false, { silent: true });
    // view.listenTo(item, "change:excluded", function(item, newVal) {
    // 	// console.log(arguments);
    // 	if (this.el.classList.contains("excluded") !== newVal) {
    // 		console.warn("%s:[change:excluded] m:%o css: %o", this.cid, newVal, this.el.classList.contains("excluded"));
    // 	}
    // 	// this.el.classList.toggle("excluded", excluded);
    // });

    this.listenTo(view, "renderer:click", this._onRendererClick);
    this.itemViews.add(view);
    return view;
  },

  /** @private */
  _onRendererClick: function _onRendererClick(item, ev) {
    if (this._collapsedChanging || this._collapsed && item.get("excluded")) {
      return;
    }

    if (this.collection.selected !== item) {
      this.trigger("view:select:one", item);
    } else {
      if (ev.altKey) {
        this.trigger("view:select:none");
      } else {
        this.trigger("view:select:same", item);
      } // this.trigger("view:select:none");

    }
  },

  /* --------------------------- *
  /* Collapsed
  /* --------------------------- */

  /** @private */
  _collapsed: undefined,

  /**
   * @param {Boolean}
   */
  _setCollapsed: function _setCollapsed(collapsed) {
    if (collapsed !== this._collapsed) {
      this._collapsed = collapsed;
      this._collapsedChanged = true;
      this.requestRender();
    }
  },

  /* --------------------------- *
  /* Selection
  /* --------------------------- */

  /** @private */
  _selectedItem: undefined,

  /** @param {Backbone.Model|null} */
  _setSelection: function _setSelection(item) {
    if (item !== this._selectedItem) {
      this._selectedItem = item;
      this._selectionChanged = true;
      this.requestRender(View.MODEL_INVALID);
    }
  },

  /** @private */
  renderSelection: function renderSelection(newItem, oldItem) {
    var view;

    if (oldItem) {
      view = this.itemViews.findByModel(oldItem);
      view.el.classList.remove("selected"); // view.label.classList.remove("color-fg");
      // view.label.classList.remove("color-reverse");
    }

    if (newItem) {
      view = this.itemViews.findByModel(newItem);
      view.el.classList.add("selected"); // view.label.classList.add("color-fg");
      // view.label.classList.add("color-reverse");
    }

    this.el.classList.toggle("has-selected", this.selectedItem !== null);
  },

  /* --------------------------- *
  /* Filter
  /* --------------------------- */
  refreshFilter: function refreshFilter() {
    if (this._filterFn) {
      this._filterChanged = true;
      this.requestRender(View.MODEL_INVALID);
    }
  },

  /* --------------------------- *
  /* Filter impl 2
  /* --------------------------- */
  computeFilter: function computeFilter() {
    var newItems, oldItems;
    var hasNew, hasOld;
    this._filteredIncoming.length = 0;
    this._filteredOutgoing.length = 0;
    newItems = this._filterFn ? this.collection.filter(this._filterFn, this) : this._getAllItems();
    oldItems = this._filteredItems;
    hasNew = !!(newItems && newItems.length);
    hasOld = !!(oldItems && oldItems.length); // NOTE: diff third arg is destination array

    if (hasNew) {
      // incoming exclusions
      diff(hasOld ? oldItems : this._getAllItems(), newItems, this._filteredIncoming); // this._filteredIncoming.forEach(function(item) {
      // 	item.set("excluded", true);
      // });
    }

    if (hasOld) {
      // outgoing exclusions
      diff(hasNew ? newItems : this._getAllItems(), oldItems, this._filteredOutgoing); // this._filteredOutgoing.forEach(function(item) {
      // 	item.set("excluded", false);
      // });
    } // console.log("%s::renderFilterFn", this.cid, newItems);


    this._filteredItems = newItems;
  },
  applyFilter: function applyFilter() {
    // this.itemViews.forEach(function(view) {
    // 	view.el.classList.toggle("excluded", view.model.get("excluded"));
    // });
    this._filteredIncoming.forEach(function (item) {
      this.itemViews.findByModel(item).el.classList.add("excluded");
      item.set("excluded", true);
    }, this);

    this._filteredOutgoing.forEach(function (item) {
      this.itemViews.findByModel(item).el.classList.remove("excluded");
      item.set("excluded", false);
    }, this);

    this.el.classList.toggle("has-excluded", this.filteredItems.length > 0);
  }
  /* --------------------------- *
  /* Filter impl 1
  /* --------------------------- */

  /*
  computeFilter_1: function() {
  	var items = this._filterFn ? this.collection.filter(this._filterFn, this) : this._getAllItems();
  	this.renderFilters(items, this._filteredItems);
  	this._filteredItems = items;
  },
  	renderFilters: function(newItems, oldItems) {
  	var hasNew = !!(newItems && newItems.length);
  	var hasOld = !!(oldItems && oldItems.length);
  	var inExcl = [];
  	var outExcl = [];
  		// console.log("%s::renderFilterFn", this.cid, newItems);
  	// NOTE: diff third arg is destination array
  	if (hasNew) {
  		diff((hasOld ? oldItems : this._getAllItems()), newItems, inExcl)
  		// .forEach(function(item) {
  		// 	this.itemViews.findByModel(item).el.classList.add("excluded");
  		// 	item.set("excluded", true);
  		// }, this);
  	}
  	if (hasOld) {
  		diff((hasNew ? newItems : this._getAllItems()), oldItems, outExcl)
  		// .forEach(function(item) {
  		// 	this.itemViews.findByModel(item).el.classList.remove("excluded");
  		// 	item.set("excluded", false);
  		// }, this);
  	}
  	this._filteredIncoming = inExcl;
  	this._filteredOutgoing = outExcl;
  	// this.el.classList.toggle("has-excluded", hasNew);
  	// this.applyFilter();
  },
  */
  // computeFiltered: function() {
  // 	this._filterResult = this.collection.map(this._filterFn, this);
  // },
  //
  // renderFiltered: function() {
  // 	this.collection.forEach(function(item, index) {
  // 		this.itemViews.findByModel(item).el.classList.toggle("excluded", !this._filterResult[index]);
  // 	}, this);
  // },

});

if (DEBUG) {
  FilterableListView.prototype._logFlags = ["view.render"].join(" ");

  FilterableListView.prototype._printStats = function (lastFilteredItems) {
    if (this._logFlags["view.trace"]) console.log("%s::renderFrame %s filtered:%o(=%o)/%o (changed:%o, in:%o, out:%o)", this.cid, this.filteredItems.length > 0 ? "has" : "has not", this.filteredItems.length, lastFilteredItems ? this.filteredItems.length + this._filteredIncoming.length - this._filteredOutgoing.length : this.filteredItems.length, this.collection.length, this._filteredIncoming.length + this._filteredOutgoing.length, this._filteredIncoming.length, this._filteredOutgoing.length);
  };
}

module.exports = FilterableListView;

}).call(this,true,require("underscore"))

},{"app/control/Globals":55,"app/view/base/View":82,"app/view/render/ClickableRenderer":106,"backbone.babysitter":3,"underscore":51,"utils/array/difference":129,"utils/css/getBoxEdgeStyles":139,"utils/prefixedProperty":146,"utils/promise/rejectAll":149,"utils/promise/resolveAll":150}],92:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/view/component/GraphView
 */

/** @type {Function} */

var Color = require("color");
/** @type {module:app/view/base/CanvasView} */


var CanvasView = require("app/view/base/CanvasView");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:utils/canvas/calcArcHConnector} */


var calcArcHConnector = require("utils/canvas/calcArcHConnector");
/** @type {module:utils/canvas/CanvasHelper} */


var CanvasHelper = require("utils/canvas/CanvasHelper");
/** @type {module:utils/geom/inflateRect} */


var inflateRect = require("utils/geom/inflateRect"); // /** @type {module:utils/dom/getAbsoluteClientRect} */
// var getAbsoluteClientRect = require("utils/dom/getAbsoluteClientRect");
// var BEZIER_CIRCLE = 0.551915024494;
// var MIN_CANVAS_RATIO = 2;
// var PI2 = Math.PI * 2;


var styleBase = {
  lineCap: "butt",
  // round, butt, square
  lineWidth: 0.75,
  lineDashOffset: 0,
  setLineDash: [[]] // radiusBase: 2,
  // /* factored to rem unit */ //6,
  // radiusIncrement: 0.21, //3, //0.25,
  // /* uses lineWidth multiplier */
  // outlineWidth: 3,
  // /* uses lineWidth multiplier */
  // arrowSize: 0.3,

};
var paramsBase = {
  radiusBase: 1.25,

  /* factored to rem unit */
  //6,
  radiusIncrement: 0.21,
  //3, //0.25,

  /* uses lineWidth multiplier */
  outlineWidth: 3,

  /* factored to rem unit */
  arrowSize: 0.4 //0.3,

}; // var overlayStyleBase = {
// 	globalAlpha: 0.75,
// 	globalCompositeOperation: "destination-out",
// 	lineWidth: 4,
// 	lineJoin: "round",
// 	textBaseline: "top",
// 	textAlign: "left",
// };

if (DEBUG) {
  /* eslint-disable no-unused-vars */
  var _dStyles = {
    defaults: {
      globalAlpha: 0.66,
      lineWidth: 0,
      fillStyle: "transparent",
      strokeStyle: "transparent",
      lineDashOffset: 0,
      setLineDash: [[]]
    }
  };
  /* Stroke */

  ["red", "salmon", "sienna", "green", "yellowgreen", "olive", "blue", "lightskyblue", "midnightblue", "grey", "silver"].forEach(function (colorName) {
    var rgbaValue = Color(colorName).alpha(0.75).string();
    _dStyles[colorName] = _.defaults({
      lineWidth: 0.75,
      strokeStyle: rgbaValue
    }, _dStyles["defaults"]);
    _dStyles[colorName + "_dashed"] = _.defaults({
      setLineDash: [[4, 2]],
      strokeStyle: rgbaValue
    }, _dStyles["defaults"]);
    _dStyles[colorName + "_thick"] = _.defaults({
      lineWidth: 5,
      strokeStyle: rgbaValue
    }, _dStyles["defaults"]);
    _dStyles[colorName + "_fill"] = _.defaults({
      fillStyle: rgbaValue
    }, _dStyles["defaults"]);
  });
  /* eslint-enable no-unused-vars */
}

var getRectDirX = function getRectDirX(r1, r2) {
  if (r1.right < r2.left) {
    return 1;
  }

  if (r2.right < r1.left) {
    return -1;
  }

  return 0;
};
/**
 * @constructor
 * @type {module:app/view/component/GraphView}
 */


var GraphView = CanvasView.extend({
  /** @type {string} */
  cidPrefix: "graph",

  /** @override */
  tagName: "canvas",

  /** @override */
  className: "graph",
  defaultKey: "a2b",
  defaults: {
    values: {
      a2b: 0,
      b2a: 0
    },
    maxValues: {
      a2b: 1,
      b2a: 1
    } // useOpaque: true,
    // labelFn: function(value, max) {
    // 	return ((value / max) * 100) | 0;
    // },

  },

  /** @override */
  initialize: function initialize(options) {
    CanvasView.prototype.initialize.apply(this, arguments);
    this._listA = options.listA;
    this._listB = options.listB;
    this._a2b = {
      srcView: options.listA,
      destView: options.listB,
      s: _.defaults({
        lineWidth: 0.7 //1.25
        // radiusIncrement: 0.25,

      }, styleBase, paramsBase),
      p: _.defaults({}, paramsBase),
      strokeStyleFn: function strokeStyleFn(fg, bg, ln) {
        return Color(ln).mix(bg, 0.1).hex();
      }
    };
    this._b2a = {
      srcView: options.listB,
      destView: options.listA,
      s: _.defaults({
        lineWidth: 0.7 // arrowSize: 0.25,
        // radiusIncrement: 0,
        // outlineWidth: 0,

      }, styleBase, paramsBase),
      p: _.defaults({}, paramsBase),
      strokeStyleFn: function strokeStyleFn(fg, bg, ln) {
        return Color(fg).mix(bg, 0.4).hex();
      }
    }; // this.listenTo(this._a2b.srcView.collection, "view:select:one view:select:none", function(item) {
    // 	this._a2b.connectorsOut = this._a2b.connectors;
    // 	this._a2b.connectors = null;
    // });
    //
    // this.listenTo(this._b2a.srcView.collection, "view:select:one view:select:none", function(item) {
    // 	this._b2a.connectorsOut = this._b2a.connectors;
    // 	this._b2a.connectors = null;
    // });
    // this.listenTo(this, "view:render:before", this._beforeViewRender);
    // this._traceScroll = _.debounce(this.__raceScroll, 100, false);
    // var viewportChanged = function(ev) {
    // 	console.log("%s:[%s]", this.cid, ev.type);
    //
    // 	// this._traceScroll(ev.type);
    // 	// this._labelOverlays = null;
    // 	this.invalidate(CanvasView.LAYOUT_INVALID | CanvasView.SIZE_INVALID);
    // 	// this.requestRender(CanvasView.LAYOUT_INVALID | CanvasView.SIZE_INVALID);
    // 	// this.requestRender().renderNow();
    // }.bind(this);
    // viewportChanged = _.debounce(viewportChanged, 60, false);
    // window.addEventListener("scroll",
    // 		_.debounce(viewportChanged, 100, false), false);
    // window.addEventListener("wheel",
    // 	_.debounce(viewportChanged, 100, false), false);
    // window.addEventListener("scroll", viewportChanged, false);
    // window.addEventListener("wheel", viewportChanged, false);
    // window.addEventListener("resize", viewportChanged, false);
    // window.addEventListener("orientationchange", viewportChanged, false);
    // this._addListListeners(this._a2b);
    // this._addListListeners(this._b2a);
  },

  /** @override */
  measureCanvas: function measureCanvas(w, h, s) {
    console.log("%s::measureCanvas style:%o scroll:%o offset:%o client:%o arg:%o", this.cid, s.height, this.el.offsetHeight, this.el.scrollHeight, this.el.clientHeight, h);
  },

  /** @override */
  updateCanvas: function updateCanvas() {
    this._updateMetrics();

    this._updateStyles();
  },

  /* --------------------------- *
  /* styles
  /* --------------------------- */
  _updateStyles: function _updateStyles() {
    var b, bgColor, lnColor;

    if (this.model.has("bundle")) {
      b = this.model.get("bundle");
      lnColor = Color(b.colors.lnColor); //.clone();

      bgColor = Color(b.colors.bgColor); //.clone();
    } else {
      bgColor = Color(Globals.DEFAULT_COLORS["background-color"]);
      lnColor = Color(Globals.DEFAULT_COLORS["link-color"]);
    }

    this._a2b.s.strokeStyle = this._a2b.s.fillStyle = this._a2b.strokeStyleFn(this._color, bgColor, lnColor);
    this._b2a.s.strokeStyle = this._b2a.s.fillStyle = this._b2a.strokeStyleFn(this._color, bgColor, lnColor);

    if (DEBUG) {
      this._debugBlocks = this.el.matches(".debug-blocks ." + this.className);
      this._debugGraph = this.el.matches(".debug-graph ." + this.className);
    }
  },
  _setStyle: function _setStyle(s) {
    if (typeof s == "string") {
      s = this._styleData[s];
    }

    CanvasView.setStyle(this._ctx, s);
  },

  /* --------------------------- *
  /* metrics
  /* --------------------------- */
  _updateMetrics: function _updateMetrics() {
    var bounds;
    this._rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
    bounds = this.el.getBoundingClientRect(); // bounds = getAbsoluteClientRect(this.el);

    this._ctx.setTransform(this._canvasRatio, 0, 0, this._canvasRatio, -(bounds.left + window.pageXOffset) * this._canvasRatio - 0.5, -(bounds.top + window.pageYOffset) * this._canvasRatio - 0.5);

    var i, ii, els;
    var srcRect, destRect;
    var srcMin, destMin;
    srcRect = this._a2b.srcView.el.getBoundingClientRect();
    destRect = this._a2b.destView.el.getBoundingClientRect();
    this._a2b.qx = getRectDirX(srcRect, destRect);
    els = this._listA.el.querySelectorAll(".label");
    srcMin = srcRect.left + window.pageXOffset;

    for (i = 0, ii = els.length; i < ii; i++) {
      srcMin = Math.max(srcMin, els[i].getBoundingClientRect().right + window.pageXOffset);
    }

    this._a2b.xMin = srcMin;
    els = this._listB.el.querySelectorAll(".label");
    destMin = destRect.left + window.pageXOffset;

    for (i = 0, ii = els.length; i < ii; i++) {
      destMin = Math.min(destMin, els[i].getBoundingClientRect().left + window.pageXOffset);
    }

    this._a2b.destMinX = destMin;
    this._b2a.qx = -this._a2b.qx;
    this._b2a.xMin = this._a2b.destMinX;
    this._b2a.destMinX = this._a2b.xMin; // var s = getComputedStyle(document.documentElement);
    // this._rootFontSize = parseFloat(s.fontSize); // * this._canvasRatio;
    // console.log("%s::_updateMetrics _rootFontSize: %s %o", this.cid, this._rootFontSize, s);
    // var c = Math.abs(sData.xMin - dData.xMin) / 6;
    // sMin = sData.xMin + c * qx;
    // dMin = dData.xMin - c * qx;
    // this._a2b.targets = this._measureListItems(listView);
    // this._b2a.targets = this._measureListItems(listView);
    // // connector minimum branch x2
    // listView = this._listB;
    // for (i = 0, ii = listView.groups.length; i < ii; i++) {
    // 	itemView = listView.itemViews.findByModel(listView.groups[i]);
    // 	itemRect = (itemView.label || itemView.el).getBoundingClientRect();
    // 	this._b2a.xMin = Math.min(this._b2a.xMin, itemRect.left);
    // 	// if (itemView._metrics) this._b2a.rect.left + itemView.transform.tx + itemView._metrics.textLeft;
    // }
  },

  /* --------------------------- *
  /* redraw
  /* --------------------------- */
  redraw: function redraw(ctx, interp, flags) {
    this._clearCanvas(0, 0, this._canvasWidth, this._canvasHeight);

    ctx.save();

    this._redraw_fromElements(ctx, interp, flags); // this._redraw_fromViews(ctx, interp);


    ctx.restore();
  },
  _redraw_fromElements: function _redraw_fromElements(ctx, interp, flags) {
    // b2a: keyword to bundles, right to left
    // a2b: bundle to keywords, left to right
    if (flags & (CanvasView.SIZE_INVALID | CanvasView.MODEL_INVALID)) {
      console.log("%s::redraw [valuesChanged: %s] [flags: %s]", this.cid, interp.valuesChanged, CanvasView.flagsToString(flags));
      this._a2b.connectorsOut = this._a2b.connectors;
      this._b2a.connectorsOut = this._b2a.connectors;
      this._b2a.connectors = this._computeConnectors(this._b2a);
      this._a2b.connectors = this._computeConnectors(this._a2b);
      this._labelOverlays = this._computeLabelOverlays(this._listB);
    }
    /* line dash value interpolation */


    var b2aVal, a2bVal;
    b2aVal = interp.getRenderedValue("b2a") / interp.getOption("b2a", "max"); //_valueData["b2a"]._maxVal;
    // b2aVal = interp._valueData["b2a"]._renderedValue / interp._valueData["b2a"]._maxVal;

    a2bVal = interp.getRenderedValue("a2b") / interp.getOption("a2b", "max"); //interp._valueData["a2b"]._maxVal;
    // a2bVal = interp._valueData["a2b"]._renderedValue / interp._valueData["a2b"]._maxVal;

    /* draw */

    this._drawConnectors(this._b2a.connectors, this._b2a.s, b2aVal, 1);

    this._drawConnectors(this._b2a.connectorsOut, this._b2a.s, 1 - b2aVal, 1);

    this._drawConnectors(this._a2b.connectors, this._a2b.s, a2bVal, 2); // this._drawConnectors(this._a2b.connectorsOut, this._a2b.s, 1 - a2bVal, 2);


    this._drawLabelOverlays(this._labelOverlays);
  },

  /* --------------------------- *
   * label overlays
   * --------------------------- */
  _computeLabelOverlays: function _computeLabelOverlays(list) {
    var data = {
      rects: []
    };
    var els = list.el.querySelectorAll(".list-group .label span");
    var i, ii, r;

    for (i = 0, ii = els.length; i < ii; i++) {
      // r = inflateRect(els[i].getBoundingClientRect(), 0, 0);
      r = _.clone(els[i].getBoundingClientRect());
      r.top += window.pageYOffset; // - 0.5;

      r.left += window.pageXOffset; // - 0.5;
      // r.innerText = els[i].innerText;

      data.rects[i] = r;
    } // data.cssStyle = getComputedStyle(els[0]);
    // data.boxStyle = getBoxEdgeStyles(overlayData.cssStyle);
    // data.ctxStyle = {
    // 	font: [s.fontWeight, s.fontStyle, s.fontSize + "/" + s.lineHeight, s.fontFamily].join(" ")
    // };


    return data;
  },
  _drawLabelOverlays: function _drawLabelOverlays(data) {
    this._ctx.save(); // CanvasView.setStyle(this._ctx, s);


    this._ctx.globalAlpha = 0.85;
    this._ctx.globalCompositeOperation = "destination-out"; // this._ctx.canvas.style.letterSpacing = overlayData.cssStyle.letterSpacing;

    data.rects.forEach(function (r) {
      // this._ctx.clearRect(r.left, r.top, r.width, r.height);
      this._ctx.fillRect(r.left, r.top, r.width, r.height); // this._ctx.strokeText(r.innerText, r.left, r.top);

    }, this);

    this._ctx.restore();

    if (DEBUG) {
      if (this._debugGraph || this._debugBlocks) {
        data.rects.forEach(function (r) {
          r = inflateRect(r, 0, 0);
          CanvasHelper.drawRect(this._ctx, _dStyles["silver_dashed"], r.left, r.top, r.width, r.height);
        }, this);
      }
    }
  },

  /* --------------------------- *
   * connectors
   * --------------------------- */
  _computeConnectors: function _computeConnectors(d) {
    var sMin = d.xMin;
    var dMin = d.destMinX;
    var qx = d.qx;
    var rBase, rInc;
    rBase = this._roundTo(d.s.radiusBase * this._rootFontSize, 0.5);
    rInc = this._roundTo(d.s.radiusIncrement * this._rootFontSize, 0.5); // var root = {};

    var i,
        p,
        ddNum,
        connectors = [];
    var x1, y1, tx;
    var sView, ddView, ddItems;

    if (d.srcView.collection.selected && d.destView.filteredItems) {
      sView = d.srcView.itemViews.findByModel(d.srcView.collection.selected);
      var rect = sView.label.getBoundingClientRect();
      x1 = rect.left;
      y1 = rect.top + rect.height / 2;
      if (qx > 0) x1 += rect.width;
      x1 += window.pageXOffset;
      y1 += window.pageYOffset; // if (!sView._metrics) return;
      // x1 = d.rect.left + sView.transform.tx
      // 	+ sView._metrics.textLeft;
      // y1 = d.rect.top + sView.transform.ty
      // 	+ sView._metrics.offsetHeight / 2;
      // if (qx > 0) x1 += sView._metrics.textWidth;

      ddItems = d.destView.filteredItems;
      ddNum = d.destView.filteredItems.length;

      for (i = 0; i < ddNum; i++) {
        p = {};
        ddView = d.destView.itemViews.findByModel(ddItems[i]);
        rect = ddView.label.getBoundingClientRect();
        p.x2 = rect.left;
        p.y2 = rect.top + rect.height / 2;
        if (qx < 0) p.x2 += rect.width;
        p.x2 += window.pageXOffset;
        p.y2 += window.pageYOffset; // p.x2 = d.destRect.left + ddView.transform.tx
        // 	+ ddView._metrics.textLeft;
        // p.y2 = d.destRect.top + ddView.transform.ty
        // 	+ ddView._metrics.offsetHeight / 2;
        // if (qx < 0) p.x2 += ddView._metrics.textWidth;

        p.x1 = x1;
        p.y1 = y1;
        p.qx = qx;
        connectors[i] = p;
      }

      connectors.sort(function (a, b) {
        return a.y2 - b.y2;
      }); // ssEl's number of items above in the Y axis

      var si = 0; // Node first arc (r0) max radius (cx0)
      // They are centered to the label, so halve it

      var rMax0 = ddNum * rInc * 0.5; // cy1 offset from y1

      var a; // First pass, calc first radius (r0, at the source of the connector),
      // and the amount of dest connectors vertically closer to the source (di)

      for (i = 0; i < ddNum; i++) {
        p = connectors[i];
        a = (i - (ddNum - 1) / 2) * rInc;
        p.cy1 = p.y1 + a;
        p.cy2 = p.y2;
        p.r0 = Math.abs(a);
        p.cx0 = p.x1 + (rMax0 - p.r0) * qx; // If src (cy1) is above dest (y2), decrease index diff (di)

        p.di = p.cy1 - p.y2 > 0 ? i : ddNum - (i + 1);
        si = Math.max(si, p.di); // p.dx = x1 - p.x2;
        // p.dy = y1 - p.y2;
      } // Calc max radius that fits sMin to dMin:
      // from space btw sMin to dMin, remove first arc and max arc increase,
      // then halve (there's two arcs left)


      var rBaseMax = (Math.abs(dMin - sMin) - (rMax0 + si * rInc)) / 2; // Ensure 0 > rBase > rBaseMax

      rBase = Math.max(0, Math.min(rBase, rBaseMax)); // console.log("%s::_computeConnectors 1rem = %spx rBase:%s rBaseMax:%s", this.cid, this._rootFontSize, rBase, rBaseMax);

      for (i = 0; i < ddNum; i++) {
        p = connectors[i];
        p.r1 = p.di * rInc + rBase;
        p.r2 = rBase; // p.r1 = p.di * rInc + rBase;
        // p.r2 = (si - p.di) * rInc + rBase;

        p.cx1 = sMin + rMax0 * qx;
        p.cx2 = dMin - (si - p.di) * rInc * qx; //
        // p.cx1 = sMin + (rMax0 * qx);
        // p.cx2 = dMin;

        tx = calcArcHConnector(p.cx1, p.cy1, p.r1, p.cx2, p.cy2, p.r2, 0.9);

        if (tx) {
          p.tx1 = tx[0];
          p.tx2 = tx[1];
        } else {
          p.tx1 = p.cx1;
          p.tx2 = p.cx2;
        }

        p.length = Math.abs(p.x1 - p.x2) + Math.abs(p.cy1 - p.cy2); // Find out longest node connection for setLineDash
        // root.maxLength = Math.max(root.maxLength, p.length);
      }

      connectors.sort(function (a, b) {
        return a.di - b.di;
      } // Sort by index distance to from source point
      // a.r0 - b.r0 // Sort by first arc (centered)
      // (a.r1 + a.r2) - (b.r1 + b.r2)
      // a.tx2 - b.tx2
      );
      connectors.si = si;
      connectors.qx = qx;
      connectors.sMin = sMin;
      connectors.dMin = dMin; // root.x = x1;
      // root.y = y1;
      // root.qx = qx;
      // root.r0 = si * rInc;
    } // d.connectors = connectors;
    // d.root = root;
    // return d;


    return connectors;
  },
  _drawConnectors: function _drawConnectors(pp, s, lVal, dir) {
    var i, ii, p;
    var ow, ra1, ra2, ta;
    if (!(pp && pp.length && lVal)) return;
    ii = pp.length;
    /* outline width */

    ow = s.lineWidth + s.outlineWidth; // ow = Math.min(
    // 	this._roundTo(s.radiusIncrement * this._rootFontSize, 0.5),
    // 	this._roundTo(s.lineWidth * (1 + s.outlineWidth), 0.5)
    // );

    /* arrow radiuses, direction */
    // ra1 = (s.radiusIncrement * this._rootFontSize) + s.lineWidth;

    ra1 = s.arrowSize * this._rootFontSize;
    ra2 = ra1 + (ow - s.lineWidth);
    ta = Math.PI * dir; // dir -= 2;

    this._setStyle(s); // if (lVal < 1) {
    // 	this._ctx.lineDashOffset = lMax * (1 + lVal);
    // 	this._ctx.setLineDash([lMax, lMax])
    // 	// this._ctx.lineDashOffset = lMax * (1 + lVal);;
    // 	// this._ctx.setLineDash([lMax * (1 - lVal), lMax]);
    // }
    // for (i = 0; i < ii; i++) {
    // p = pp[i];


    if (s.outlineWidth) {
      this._ctx.save();

      this._ctx.globalCompositeOperation = "destination-out";
      this._ctx.lineWidth = ow;

      for (i = 0; i < ii; i++) {
        p = pp[i];

        if (lVal < 1) {
          this._ctx.lineDashOffset = p.length * (1 + lVal);

          this._ctx.setLineDash([p.length, p.length]);
        }

        this._drawConnector(p, i, pp);

        if (lVal == 1) {
          this._drawArrowhead(p.x2, p.y2, ra2, dir * ta);
        }
      }

      this._ctx.restore();
    }

    for (i = 0; i < ii; i++) {
      p = pp[i];

      if (lVal < 1) {
        this._ctx.lineDashOffset = p.length * (1 + lVal);

        this._ctx.setLineDash([p.length, p.length]);
      }

      this._drawConnector(p, i, pp);

      if (lVal == 1) {
        this._drawArrowhead(p.x2, p.y2, ra1, dir * ta);
      }
    }
  },
  _drawArrowhead: function _drawArrowhead(x, y, r, t) {
    // this._ctx.save();
    // this._ctx.lineDashOffset = 0;
    // this._ctx.setLineDash([]);
    CanvasHelper.arrowhead2(this._ctx, x, y, r, t);

    this._ctx.stroke(); // this._ctx.restore();

  },
  _drawArrowhead2: function _drawArrowhead2(x, y, r, t) {
    CanvasHelper.arrowhead(this._ctx, x, y, r, t);

    this._ctx.fill();
  },
  // _drawArrowheadH: function(x, y, r, a) {
  // 	this._ctx.save();
  // 	this._ctx.lineDashOffset = 0;
  // 	this._ctx.setLineDash([]);
  // 	this._ctx.beginPath();
  // 	this._ctx.moveTo(x + r * 1 / dir, y - r);
  // 	this._ctx.lineTo(x, y);
  // 	this._ctx.lineTo(x + r * 1 / dir, y + r);
  // 	this._ctx.stroke();
  // 	this._ctx.restore();
  // },
  _drawConnector: function _drawConnector(p, i, pp) {
    this._ctx.beginPath();

    this._ctx.moveTo(p.x2, p.cy2);

    this._ctx.arcTo(p.tx2, p.cy2, p.tx1, p.cy1, p.r2);

    this._ctx.arcTo(p.tx1, p.cy1, p.cx1, p.cy1, p.r1);

    this._ctx.arcTo(p.cx0, p.cy1, p.cx0, p.y1, p.r0); // p.cx00 = p.x1 + ((p.r0 + p.di) * p.qx);
    // p.cy00 = (p.cy1 + p.y1) / 2;
    // this._ctx.arcTo(p.cx00, p.cy1, p.cx00, p.cy00, p.r0 / 2);
    // this._ctx.arcTo(p.cx00, p.y1, p.x1, p.y1, p.r0 / 2);
    // this._ctx.lineTo(p.x1, p.y1);
    // p.cx00 = p.x1 + (p.r0 * p.qx * 2);
    // this._ctx.lineTo(p.cx00, p.cy1);
    // this._ctx.quadraticCurveTo(p.cx0, p.cy1, p.cx0, p.y1);
    // this._ctx.lineTo(p.cx0, p.y1);


    this._ctx.stroke();
  },
  _roundTo: function _roundTo(n, p) {
    if (p > 1) p = 1 / p;
    return Math.round(n / p) * p;
  }
  /*
  _computeConnectors: function(d) {
  	var rBase = d.s.radiusBase;
  	var rInc = d.s.radiusIncrement;
  	var sMin = d.xMin;
  	var dMin = d.destMinX;
  		var lMax = 0;
  	var p, connectors = [];
  	var qx, x1, y1, tx;
  	var si; // ssEl's number of items above in the Y axis
  		if (d.rect.right < d.destRect.left) {
  		qx = 1;
  	} else if (d.destRect.right < d.rect.left) {
  		qx = -1;
  	} else {
  		qx = 0;
  	}
  		var ssEl, ddEls, ddNum, ssRect, ddRect, i;
  	ssEl = d.srcView.el.querySelector(".list-item.selected .label");
  	if (ssEl) {
  		ssRect = ssEl.getBoundingClientRect();
  		x1 = ssRect.left;
  		if (qx > 0) x1 += ssRect.width;
  		y1 = ssRect.top + ssRect.height / 2;
  		// r2 = rBase;
  		// cx1 = d.xMin;
  			si = 0;
  		ddEls = d.destView.el.querySelectorAll(".list-item:not(.excluded) .label");
  		ddNum = ddEls.length;
  		// dx = Math.abs(d.xMin - dData.xMin);
  			for (i = 0; i < ddNum; i++) {
  			p = {};
  			ddRect = ddEls[i].getBoundingClientRect();
  			p.x2 = ddRect.left;
  			if (qx < 0) p.x2 += ddRect.width;
  			p.y2 = ddRect.top + ddRect.height / 2;
  			p.x1 = x1;
  			p.y1 = y1;
  			p.dx = p.x1 - p.x2;
  			p.dy = p.y1 - p.y2;
  			p.qx = qx;
  			p.qy = Math.sign(p.dy);
  			// p.dLength = Math.abs(p.x) + Math.abs(p.y);
  			p.di = p.dy > 0 ? i : ddNum - (i + 1);
  			si = Math.max(si, p.di);
  			connectors[i] = p;
  		}
  			var a, rMax0 = ddNum * 0.5 * rInc;
  		for (i = 0; i < ddNum; i++) {
  			p = connectors[i];
  			p.r1 = p.di * rInc + rBase;
  			p.r2 = rBase;
  			// p.r2 = (si - p.di) * rInc + rBase;
  				p.cx1 = sMin;
  			p.cx2 = dMin - ((si - p.di) * rInc) * qx;
  			// p.cx2 = dMin;
  				a = (i - (ddNum - 1) / 2) * rInc;
  			p.cy1 = p.y1 + a;
  			p.cy2 = p.y2;
  				a = Math.abs(a);
  			p.r0 = a;
  			p.cx0 = p.x1 + (rMax0 - a) * qx;
  				tx = calcArcHConnector(p.cx1, p.cy1, p.r1, p.cx2, p.cy2, p.r2, 0.8);
  			p.tx1 = tx[0];
  			p.tx2 = tx[1];
  				// Find out longest node connection for setLineDash
  			lMax = Math.max(lMax, Math.abs(p.x1 - p.x2) + Math.abs(p.cy1 - p.cy2));
  		}
  		// Sort by distance y1 (original) > cy1 (rInc offset) distance
  		connectors.sort(function(a, b) {
  			// return Math.abs(b.y1 - b.cy1) - Math.abs(a.y1 - a.cy1);
  			// return a.r0 - b.r0;
  			return b.di - a.di;
  		});
  	}
  	d.connectors = connectors;
  	d.maxLength = lMax;
  	d.maxLength = qx;
  }, */

});

if (DEBUG) {
  // GraphView.prototype._logFlags = "";
  var applyFn = function applyFn(context, args) {
    return Array.prototype.shift.apply(args).apply(context, args);
  };

  GraphView.prototype._drawConnector = _.wrap(GraphView.prototype._drawConnector, function (fn, p, i, pp) {
    if (!this._debugGraph) {
      // visual debug aids are off
      return fn.call(this, p, i, pp);
    } // var isRtl = p.qx < 0;


    var isFirst = i == 0;
    var isLast = i == pp.length - 1; // guide color

    var gs = _dStyles[isFirst ? "salmon_dashed" : "lightskyblue_dashed"];

    if (isFirst) {
      CanvasHelper.drawVGuide(this._ctx, _dStyles["grey"], pp.sMin);
      CanvasHelper.drawVGuide(this._ctx, _dStyles["grey"], pp.dMin);
    }

    if (isFirst) {
      CanvasHelper.drawHGuide(this._ctx, _dStyles["silver_dashed"], p.y1);
      CanvasHelper.drawVGuide(this._ctx, _dStyles["silver_dashed"], p.x1);
      CanvasHelper.drawCircle(this._ctx, _dStyles["midnightblue"], p.x1, p.y1, 10);
    }

    if (isFirst || isLast) {
      // CanvasHelper.drawVGuide(this._ctx, gs, p.cx1 + (p.r1 * p.qx));
      CanvasHelper.drawVGuide(this._ctx, gs, p.tx2);
      CanvasHelper.drawVGuide(this._ctx, gs, p.cx2 - p.r2 * p.qx); // CanvasHelper.drawVGuide(this._ctx, gs, p.cx2);
      // CanvasHelper.drawHGuide(this._ctx, gs, p.cy2);
    }

    if (isFirst || isLast) {
      this._ctx.save();

      this._ctx.strokeStyle = _dStyles[isFirst ? "red" : "blue"].strokeStyle;
      this._ctx.lineWidth *= 1.5;
    } // }


    fn.call(this, p, i, pp); // if (isRtl) {

    if (isFirst || isLast) {
      this._ctx.restore();
    } // point color


    var pCol = isLast ? "midnightblue" : isFirst ? "sienna" : "grey";
    var ps = _dStyles[pCol];
    var pf = _dStyles[pCol + "_fill"]; // CanvasHelper.drawCrosshair(this._ctx, ps, p.x1 + ((p.r0 + p.di) * p.qx), p.cy1, 3);

    if (isFirst || isLast) {
      // moveTo(p.x2, p.cy2)
      CanvasHelper.drawCrosshair(this._ctx, ps, p.x2, p.cy2, 10);
      CanvasHelper.drawCircle(this._ctx, ps, p.x2, p.cy2, 3); // arcTo #1: (p.tx2, p.cy2, p.tx1, p.cy1, p.r2)

      CanvasHelper.drawSquare(this._ctx, ps, p.tx2, p.cy2, 4); // p1

      CanvasHelper.drawCircle(this._ctx, pf, p.tx1, p.cy1, 2); // p2
      // arcTo #2: (p.tx1, p.cy1, p.cx1, p.cy1, p.r1)

      CanvasHelper.drawSquare(this._ctx, ps, p.tx1, p.cy1, 4); // p1

      CanvasHelper.drawCircle(this._ctx, pf, p.cx1, p.cy1, 2); // p2
      // arcTo #2: (p.cx0, p.cy1, p.cx0, p.y1, p.r0)

      CanvasHelper.drawSquare(this._ctx, ps, p.cx0, p.cy1, 4); // p1

      CanvasHelper.drawCircle(this._ctx, pf, p.cx0, p.y1, 2); // p2

      CanvasHelper.drawCircle(this._ctx, _dStyles["green"], p.tx1, p.cy1, 4);
      CanvasHelper.drawCircle(this._ctx, _dStyles["green"], p.cx1, p.cy1, 4);
      CanvasHelper.drawCircle(this._ctx, _dStyles["green"], p.cx2, p.cy2, 4);
    } // }

  });

  GraphView.prototype._traceScroll = function (type) {
    var tpl = "%s:[%s] DPR:%i " + "[window: %i %i] " + "[html: %i %i %i] " + "[body: %i %i %i] " + "[container: %i %i %i] " + "[graph: %i %i %i]";
    console.log(tpl, this.cid, type, this._canvasRatio, window.pageYOffset, window.pageYOffset, document.documentElement.clientHeight, document.documentElement.scrollTop, document.documentElement.scrollHeight, document.body.clientHeight, document.body.scrollTop, document.body.scrollHeight, document.body.firstElementChild.clientHeight, document.body.firstElementChild.scrollTop, document.body.firstElementChild.scrollHeight, this.el.clientHeight, this.el.scrollTop, this.el.scrollHeight);
  };

  if (GraphView.prototype._logFlags.split(" ")["view.render"]) {
    // GraphView.prototype._requestRender = _.wrap(CanvasView.prototype._requestRender, function(fn) {
    // 	debouncedLog("%s::_requestRender", this.cid);
    // 	return applyMethod(this, arguments);
    // });
    var debouncedLog = _.debounce(_.bind(console.log, console), 500, true);

    GraphView.prototype._applyRender = _.wrap(CanvasView.prototype._applyRender, function (fn) {
      var retval;
      this._logFlags["view.render"] = false;
      debouncedLog("%s::_applyRender [debounced]", this.cid);
      retval = applyFn(this, arguments);
      this._logFlags["view.render"] = true;
      return retval;
    });
  }
}

module.exports = GraphView;

}).call(this,true,require("underscore"))

},{"app/control/Globals":55,"app/view/base/CanvasView":78,"color":12,"underscore":51,"utils/canvas/CanvasHelper":130,"utils/canvas/calcArcHConnector":138,"utils/geom/inflateRect":144}],93:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/component/GroupingListView
 */

/** @type {module:app/view/component/FilterableListView} */

var FilterableListView = require("app/view/component/FilterableListView");
/** @type {module:app/view/component/ClickableRenderer} */


var ClickableRenderer = require("app/view/render/ClickableRenderer");
/** @type {module:app/view/render/LabelRenderer} */


var LabelRenderer = require("app/view/render/LabelRenderer"); // /** @type {module:utils/array/difference} */
// var diff = require("utils/array/difference");

/**
 * @constructor
 * @type {module:app/view/component/GroupingListView}
 */


var GroupingListView = FilterableListView.extend({
  /** @type {string} */
  cidPrefix: "groupingList",

  /** @override */
  tagName: "dl",

  /** @override */
  className: "grouped",

  /** @type {Function|null} empty array */
  _groupingFn: null,
  //function() { return null; },

  /** @override */
  defaults: _.defaults({
    // defaults: {
    renderer: ClickableRenderer.extend({
      /** @override */
      cidPrefix: "groupingListItem",

      /** @override */
      tagName: "dl",

      /** @override */
      className: "list-item list-node"
    }),
    groupingRenderer: LabelRenderer.extend({
      /** @override */
      cidPrefix: "groupingListGroup",

      /** @override */
      tagName: "dt",

      /** @override */
      className: "list-group list-node"
    }),
    groupingFn: null // },

  }, FilterableListView.prototype.defaults),
  properties: {
    groups: {
      get: function get() {
        return this._groups;
      }
    },
    filteredGroups: {
      get: function get() {
        return this._filteredGroups;
      }
    }
  },

  /** @override */
  initialize: function initialize(options) {
    FilterableListView.prototype.initialize.apply(this, arguments);
    this._groups = [];
    this._filteredGroups = [];
    this._changedFilteredGroups = [];
    this._groupsByItemCid = {};
    this._groupingFn = options.groupingFn;
    this.groupingRenderer = options.groupingRenderer;

    this._computeGroups();

    if (this._groupingFn) {
      this._groups.forEach(this.createGroupingView, this);
    }
  },

  /**
   * Called once on collection change
   * @private
   */
  _computeGroups: function _computeGroups() {
    // this._groups = _.uniq(this.collection.map(this._groupingFn, this));
    this._groups.length = 0; // this._groupItems.length = 0;

    if (this._groupingFn) {
      this.collection.forEach(function (item) {
        var gIdx, gObj;
        gObj = this._groupingFn.apply(null, arguments);

        if (gObj) {
          gIdx = this._groups.indexOf(gObj);

          if (gIdx == -1) {
            gIdx = this._groups.length;
            this._groups[gIdx] = gObj; // this._groupItems[gIdx] = [];
          } // this._groupItems[gIdx].push(item);

        }

        this._groupsByItemCid[item.cid] = gObj;
      }, this);
    } else {
      this.collection.forEach(function (item) {
        this._groupsByItemCid[item.cid] = null;
      }, this);
    }
  },

  /** @private Create children views */
  createGroupingView: function createGroupingView(item) {
    var view = new this.groupingRenderer({
      model: item,
      el: this.el.querySelector(".list-group[data-id=\"" + item.id + "\"]")
    });
    this.itemViews.add(view);
    return view;
  },

  /* --------------------------- *
  /* Filter impl 1
  /* --------------------------- */

  /** @override */

  /*
  computeFilter_1: function() {
  	FilterableListView.prototype.computeFilter_1.apply(this, arguments);
  		if (this._groupingFn) {
  		if (this._filteredItems.length == 0) {
  			this._filteredGroups = [];
  		} else {
  			this._filteredGroups = _.uniq(this._filteredItems.map(function(item) {
  				return this._groupsByItemCid[item.cid];
  			}, this));
  		}
  	}
  	// if (this._groupingFn) {
  	// 	if (this._filteredItems.length == 0) {
  	// 		this._filteredGroups = [];
  	// 		this._groups.forEach(function(group) {
  	// 			this.itemViews.findByModel(group).el.classList.remove("excluded");
  	// 		}, this);
  	// 	} else {
  	// 		this._filteredGroups = _.uniq(this._filteredItems.map(function(item) {
  	// 			return this._groupsByItemCid[item.cid];
  	// 		}, this));
  	// 		this._groups.forEach(function(group) {
  	// 			this.itemViews.findByModel(group).el.classList.toggle("excluded", this._filteredGroups.indexOf(group) == -1);
  	// 		}, this);
  	// 	}
  	// }
  },
  */

  /* --------------------------- *
  /* Filter impl 2
  /* --------------------------- */
  // /** @override */
  // renderFilterFn_2: function() {
  // 	FilterableListView.prototype.renderFilterFn_2.apply(this, arguments);
  // },

  /** @override */
  computeFilter: function computeFilter() {
    FilterableListView.prototype.computeFilter.apply(this, arguments);

    if (this._groupingFn) {
      if (this._filteredItems.length == 0) {
        this._filteredGroups = this._groups.concat(); //[];
      } else {
        this._filteredGroups = _.uniq(this._filteredItems.map(function (item) {
          return this._groupsByItemCid[item.cid];
        }, this));
      }
    }
  },

  /** @override */
  applyFilter: function applyFilter() {
    FilterableListView.prototype.applyFilter.apply(this, arguments);

    this._groups.forEach(function (group) {
      this.itemViews.findByModel(group).el.classList.toggle("excluded", this._filteredGroups.indexOf(group) == -1);
    }, this);
  } // computeFiltered: function() {
  // 	FilterableListView.prototype.computeFiltered.apply(this, arguments);
  // },
  //
  // renderFiltered: function() {
  // 	FilterableListView.prototype.renderFiltered.apply(this, arguments);
  // },

});
module.exports = GroupingListView;

}).call(this,require("underscore"))

},{"app/view/component/FilterableListView":91,"app/view/render/ClickableRenderer":106,"app/view/render/LabelRenderer":113,"underscore":51}],94:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/component/PlayToggleSymbol
 */
// /** @type {module:app/control/Globals} */
// var Globals = require("app/control/Globals");

/** @type {module:app/view/base/CanvasView} */

var CanvasView = require("app/view/base/CanvasView");
/** @type {Function} */


var Color = require("color");
/** @type {module:utils/canvas/bitmap/stackBlurRGB} */


var stackBlurRGB = require("utils/canvas/bitmap/stackBlurRGB");
/** @type {module:utils/canvas/bitmap/getAverageRGB} */


var getAverageRGB = require("utils/canvas/bitmap/getAverageRGB");
/** @type {module:utils/canvas/bitmap/multiply} */


var multiply = require("utils/canvas/bitmap/multiply");
/** @type {module:utils/canvas/bitmap/desaturate} */


var desaturate = require("utils/canvas/bitmap/desaturate");
/** @type {module:utils/canvas/CanvasHelper} */


var roundRect = require("utils/canvas/CanvasHelper").roundRect;
/** @type {module:utils/ease/fn/easeInQuad} */


var easeIn = require("utils/ease/fn/easeInQuad");
/** @type {module:utils/ease/fn/easeOutQuad} */


var easeOut = require("utils/ease/fn/easeOutQuad");

var PI2 = Math.PI * 2;
var LOOP_OFFSET = 1.833333;

var INTEP_MS = require("app/control/Globals").TRANSITION_DURATION;

var FILTER_REFRESH_THRESHOLD = 0.5; //seconds elapsed

var FILTER_SCALE = 1.5;
var FILTER_RADIUS = 30; //pixels

var FILTER_MULTIPLY = 0.1;
var PlayToggleSymbol = {
  PLAY: "playing",
  PAUSE: "paused",
  WAITING: "waiting",
  ENDED: "ended"
};
module.exports = CanvasView.extend({
  /** @type {string} */
  cidPrefix: "playToggleSymbol",

  /** @type {string} */
  className: "play-toggle",
  defaults: {
    values: {
      _loop: 0,
      _arc: 0
    },
    maxValues: {
      _loop: 1
    },
    color: "rgba(255,255,255,1.0)",
    backgroundColor: "rgba(0,0,0,0.25)",
    paused: true,
    symbolName: "" // borderRadius: 3,
    // borderWidth: 3,

  },
  properties: {
    symbolName: {
      get: function get() {
        return this._symbolName;
      },
      set: function set(value) {
        this._setSymbolName(value);
      }
    }
  },

  /** @override */
  initialize: function initialize(options) {
    // TODO: cleanup options mess in CanvasView
    CanvasView.prototype.initialize.apply(this, arguments);
    this._options = _.extend(this._options, _.pick(options, "symbolName", "borderRadius", "borderWidth"));
    this.symbolName = this._options.symbolName;
  },

  /** @override */
  measureCanvas: function measureCanvas(w, h, s) {
    // make canvas square
    this._canvasHeight = this._canvasWidth = Math.min(w, h);
  },

  /** @override */
  updateCanvas: function updateCanvas(ctx, s) {
    var mObj = this._getFontMetrics(this._fontFamily);

    this._baselineShift = mObj ? (mObj.ascent + mObj.descent) / mObj.unitsPerEm : 0.7; // default value

    this._baselineShift *= this._fontSize * 0.5; // apply to font-size, halve it

    this._baselineShift = Math.round(this._baselineShift);
    this._canvasOffsetX = this._canvasOffsetY = this._canvasWidth / 2; // double SQRT1_2: square within circle within square

    this._radius = this._canvasWidth / 2 * Math.SQRT1_2 * Math.SQRT1_2 * Math.SQRT1_2;
    this._side = this._radius; // * Math.SQRT1_2; // * Math.SQRT1_2;
    // this._borderWidth = this._options.borderWidth * this._canvasRatio;
    // this._borderRadius = this._canvasWidth * this._canvasRatio / 2; //this._options.borderRadius * this._canvasRatio;
    // reset matrix and translate 0,0 to center

    this._ctx.setTransform(1, 0, 0, 1, this._canvasOffsetX, this._canvasOffsetY); // this._ctx.restore();
    // this._ctx.textBaseline = "middle";


    this._ctx.lineWidth = this._radius * (1 - Math.SQRT1_2); // this._ctx.fillStyle = "#FFF";

    this._ctx.shadowColor = "rgba(0,0,0,0.75)";
    this._ctx.shadowBlur = 1;
    this._ctx.shadowOffsetX = 2;
    this._ctx.shadowOffsetY = 2; // this._ctx.save();

    this._isImageDataInvalid = true; //console.log("%s::updateCanvas %s", this.cid, this._backgroundColor);
  },

  /* --------------------------- *
   * symbolName
   * --------------------------- */
  _symbolName: "",
  _setSymbolName: function _setSymbolName(value) {
    if (this._symbolName !== value) {
      this._lastSymbolName = this._symbolName;
      this._symbolName = value;
      this.refreshImageSource();
      this.requestRender(CanvasView.LAYOUT_INVALID);
      console.log("%s::[set] symbol %o (from %o)", this.attached ? this.parentView.cid : this.cid, this._symbolName, this._lastSymbolName, this.paused ? "paused" : "");
    }
  },

  /* --------------------------- *
   * setImageSource/refreshImageSource
   * --------------------------- */
  _imageSource: null,
  setImageSource: function setImageSource(imageSource) {
    if (this._imageSource !== imageSource) {
      this._imageSource = imageSource;
      this._isImageDataInvalid = true;
      this.requestRender(CanvasView.SIZE_INVALID);
    }
  },
  _imageDataTC: null,
  refreshImageSource: function refreshImageSource(threshold) {
    if (this._isImageDataInvalid || !(this._imageSource instanceof HTMLVideoElement)) {
      return; // data is marked for refresh already, or not a video
    }

    if (!_.isNumber(threshold)) {
      threshold = FILTER_REFRESH_THRESHOLD;
    }

    if (threshold < Math.abs(this._imageDataTC - this._imageSource.currentTime)) {
      this._isImageDataInvalid = true;
      this.requestRender(CanvasView.SIZE_INVALID);
    }
  },
  _imageData: null,
  _updateImageData: function _updateImageData() {
    if (this._imageSource === null) {
      this._imageData = null;
      this._imageDataTC = null;
      return;
    } // source scale, source rect, dest scale, dest rect, current timecode


    var s, sr, d, dr, tc; // Get source/dest offsets, intrinsic scale and timecode
    // ---------------------------------

    sr = this._imageSource.getBoundingClientRect();
    dr = this.el.getBoundingClientRect();

    if (this._imageSource instanceof HTMLVideoElement) {
      s = this._imageSource.videoWidth / sr.width;
      tc = this._imageSource.currentTime;
    } else {
      s = this._imageSource.naturalWidth / sr.width;
      tc = 0;
    }

    d = s * FILTER_SCALE; // draw source canvas maintaining position
    // ---------------------------------

    this._ctx.save();

    this._ctx.setTransform(1, 0, 0, 1, 0, 0);

    this._ctx.drawImage(this._imageSource, (dr.left - sr.left) * s + dr.width / 2 * s - dr.width / 2 * d, (dr.top - sr.top) * s + dr.height / 2 * s - dr.height / 2 * d, dr.width * d, dr.height * d, 0, 0, this.el.width, this.el.height); // if (d == s)
    // this._ctx.drawImage(this._imageSource,
    // 	(dr.left - sr.left) * s, (dr.top - sr.top) * s,
    // 	dr.width * s, dr.height * s,
    // 	0, 0, this.el.width, this.el.height
    // );
    // get ImageData
    // find luminosity threshold form average color
    // ---------------------------------


    var imgdata, isDark;
    imgdata = this._ctx.getImageData(0, 0, this.el.width, this.el.height); // isDark = !Color().rgb(getAverageRGB(imgdata)).dark();
    // this._ctx.globalCompositeOperation = "luminosity";
    // this._ctx.globalAlpha = 0.25;
    // this._ctx.fillStyle = (isDark ? "black" : "white");
    // this._ctx.fillRect(0, 0, this.el.width, this.el.height);

    this._ctx.clearRect(0, 0, this.el.width, this.el.height);

    this._ctx.restore(); // Store appropiate color values
    // ---------------------------------


    this._color = isDark ? "white" : "black"; // this._color = isDark ? "rgba(255,255,255,0.75)" : "rgba(0,0,0,0.75)";
    // this._backgroundColor = isDark ? "rgba(0,0,0,0.75)" : "rgba(255,255,255,0.74)";
    // this.el.style.color =
    // 	this._ctx.fillStyle =
    // 	this._ctx.strokeStyle =
    // 	this._color;
    // this.el.style.backgroundColor =
    // 	this._ctx.shadowColor =
    // 	this._backgroundColor;
    // this.el.classList.toggle("lod", isDark);
    // this.el.classList.toggle("dol", !isDark);
    // Apply filters and save results
    // ---------------------------------
    // imgdata = this._ctx.getImageData(0, 0, this.el.width, this.el.height);
    // imgdata = multiply(imgdata, (isDark ? 1 - FILTER_MULTIPLY : 1 + FILTER_MULTIPLY));
    // imgdata = desaturate(imgdata, 0.5);

    imgdata = multiply(imgdata, 1 + FILTER_MULTIPLY);
    imgdata = stackBlurRGB(imgdata, FILTER_RADIUS); // imgdata = null;

    this._imageData = imgdata;
    this._imageDataTC = tc;
  },

  /** @override */
  redraw: function redraw(ctx, intrp, flags) {
    this._clearCanvas();

    if (this._symbolName === 'waiting') {
      if (intrp.getTargetValue('_arc') === 0) {
        intrp.valueTo('_arc', 1, 0 * INTEP_MS, easeIn).updateValue('_arc');
      }
    } else {
      if (intrp.getTargetValue('_arc') === 1) {
        intrp.valueTo('_arc', 0, 0 * INTEP_MS, easeOut).updateValue('_arc');
      }
    }

    var a = intrp.getRenderedValue("_arc"); // while arc is > 0, loop indefinitely while spinning and restart
    // if at end. Otherwise let interp exhaust arc duration

    if (a > 0) {
      if (!intrp.paused && intrp.isAtTarget('_loop')) {
        // console.log("%s::redraw [loop]", this.cid, this.parentView.cid);
        intrp.valueTo('_loop', 0, 0).valueTo('_loop', 1, 2 * INTEP_MS).updateValue('_loop');
      }
    }

    var l = intrp.getRenderedValue("_loop"); // if (this._isImageDataInvalid) {
    // 	this._isImageDataInvalid = false;
    // 	this._updateImageData();
    // }
    // if (this._imageData !== null) {
    // 	ctx.putImageData(this._imageData, 0, 0);
    // }
    // always render while arc is > 0

    if (a > 0) {
      // arc span bounce
      var b = (l < 0.5 ? l % 0.5 : 0.5 - l % 0.5) * 2; // bounce + main arc span

      var aa = a * b * 0.25 + a * 0.125 + .0001; // rotation loop

      var ll = l + LOOP_OFFSET;
      ctx.beginPath();
      ctx.arc(0, 0, this._radius, (1 - aa + ll) * PI2, (aa + ll) * PI2, false);
      ctx.stroke();
    }

    switch (this._symbolName) {
      case "replay":
      case "ended":
      case "play":
        // this.drawPlay(ctx, (1 - a) * s);
        this.drawPlay(ctx, this._side);
        ctx.fill();
        break;

      case "pause":
        // this.drawPause(ctx, (1 - a) * s);
        this.drawPause(ctx, this._side);
        ctx.fill();
        break;

      case "waiting":
        switch (this._lastSymbolName) {
          case "replay":
          case "ended":
          case "play":
            this.drawPlay(ctx, (1 - a) * this._side);
            ctx.fill();
            break;

          case "pause":
            this.drawPause(ctx, (1 - a) * this._side);
            ctx.fill();
            break;

          default:
            break;
        }

        break;

      default:
        break;
    }
  },
  drawPlay: function drawPlay(ctx, r) {
    var tx = (1 - Math.SQRT1_2) * r;
    ctx.beginPath();
    ctx.moveTo(tx + r, 0);
    ctx.lineTo(tx - r, -r);
    ctx.lineTo(tx - r, r);
    ctx.closePath();
  },
  drawPause: function drawPause(ctx, r) {
    var w = r * 0.75;
    var h = r * 2;
    ctx.beginPath();
    ctx.rect(-r, -r, w, h);
    ctx.rect(r - w, -r, w, h);
    ctx.closePath();
  },
  drawLabel: function drawLabel(labelString) {
    var labelWidth = this._ctx.measureText(labelString).width;

    this._ctx.fillText(labelString, labelWidth * -0.5, // 0, labelWidth);
    this._baselineShift, labelWidth);
  }
}, PlayToggleSymbol);

}).call(this,require("underscore"))

},{"app/control/Globals":55,"app/view/base/CanvasView":78,"color":12,"underscore":51,"utils/canvas/CanvasHelper":130,"utils/canvas/bitmap/desaturate":132,"utils/canvas/bitmap/getAverageRGB":133,"utils/canvas/bitmap/multiply":135,"utils/canvas/bitmap/stackBlurRGB":137,"utils/ease/fn/easeInQuad":140,"utils/ease/fn/easeOutQuad":141}],95:[function(require,module,exports){
"use strict";
/**
 * @module app/view/component/SelectableListView
 */

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View");
/** @type {module:backbone.babysitter} */


var Container = require("backbone.babysitter");
/** @type {module:app/view/component/DefaultSelectableRenderer} */


var DefaultSelectableRenderer = require("app/view/render/DefaultSelectableRenderer");
/** @type {module:app/view/component/ClickableRenderer} */


var ClickableRenderer = require("app/view/render/ClickableRenderer");

var SelectableListView = View.extend({
  /** @type {string} */
  cidPrefix: "selectableList",

  /** @override */
  tagName: "ul",

  /** @override */
  className: "list selectable",

  /** @type {module:app/view/component/DefaultSelectableRenderer} */
  renderer: DefaultSelectableRenderer,

  /** @override */
  initialize: function initialize(options) {
    this._enabled = true;
    this._childrenInvalid = true;
    options.renderer && (this.renderer = options.renderer);
    this.showEmpty = !!options.showEmpty;
    this.itemViews = new Container();
    this.listenTo(this.collection, "add remove reset", this._onCollectionChange);
  },

  /** @override */
  remove: function remove() {
    this.removeChildren();
    View.prototype.remove.apply(this, arguments);
    return this;
  },
  _onCollectionChange: function _onCollectionChange(ev) {
    this._childrenInvalid = true;
    this.render();
  },

  /** @override */
  render: function render() {
    if (this._childrenInvalid) {
      this._childrenInvalid = false;
      this.createChildren();
    }

    return this;
  },

  /** @override */
  setEnabled: function setEnabled(enabled) {
    if (this._enabled !== enabled) {
      this._enabled = enabled;
      this.el.classList.toggle("disabled", !this._enabled);
    }
  },

  /* --------------------------- *
  /* Child views
  /* --------------------------- */
  createChildren: function createChildren() {
    var eltBuffer, view;
    this.removeChildren();
    this.el.innerHTML = "";

    if (this.collection.length) {
      eltBuffer = document.createDocumentFragment();

      if (this.showEmpty) {
        view = this.createEmptyView();
        eltBuffer.appendChild(view.render().el);
      }

      this.collection.each(function (model, index, arr) {
        view = this.createItemView(model, index);
        eltBuffer.appendChild(view.render().el);
      }, this);
      this.el.appendChild(eltBuffer);
    }
  },
  createItemView: function createItemView(model, index) {
    var view = new this.renderer({
      model: model
    });
    this.itemViews.add(view);
    this.listenTo(view, "renderer:click", this.onItemViewClick);
    return view;
  },
  removeChildren: function removeChildren() {
    this.itemViews.each(this.removeItemView, this);
  },
  removeItemView: function removeItemView(view) {
    this.stopListening(view);
    this.itemViews.remove(view);
    view.remove();
    return view;
  },

  /* --------------------------- *
  /* Child event handlers
  /* --------------------------- */

  /** @private */
  onItemViewClick: function onItemViewClick(item) {
    if (this.collection.selected !== item && this._enabled) {
      this.trigger("view:select:one", item);
    }
  },

  /* --------------------------- *
  /* Empty view
  /* --------------------------- */
  createEmptyView: function createEmptyView() {
    var view = new SelectableListView.EmptyRenderer({
      model: this.collection
    });
    this.itemViews.add(view);
    this.listenTo(view, "renderer:click", function () {
      this._enabled && this.trigger("view:select:none");
    });
    return view;
  }
}, {
  EmptyRenderer: ClickableRenderer.extend({
    /** @override */
    tagName: "li",

    /** @override */
    className: "list-item empty-item",

    /** @override */
    initialize: function initialize(options) {
      this.listenTo(this.model, "selected deselected", this.renderClassList);
      this.renderClassList();
    },

    /** @override */
    render: function render() {
      this.el.innerHTML = "<a href=\"#clear\"><b> </b></a>";
      this.renderClassList();
      return this;
    },
    renderClassList: function renderClassList() {
      this.el.classList.toggle("selected", this.model.selectedIndex === -1);
    }
  })
});
module.exports = SelectableListView;

},{"app/view/base/View":82,"app/view/render/ClickableRenderer":106,"app/view/render/DefaultSelectableRenderer":108,"backbone.babysitter":3}],96:[function(require,module,exports){
(function (_){
"use strict";
/** @type {Function} */

var Color = require("color");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:app/model/collection/BundleCollection} */


var bundles = require("app/model/collection/BundleCollection"); // - - - - - - - - - - - - - - - -
//  utils
// - - - - - - - - - - - - - - - -


function insertCSSRule(sheet, selector, style) {
  var cssText = "";

  for (var prop in style) {
    cssText += prop + ":" + style[prop] + ";";
  }

  sheet.insertRule(selector + "{" + cssText + "}", sheet.cssRules.length);
}

function selfAndDescendant(selfCls, cls) {
  return selfCls + " " + cls + ", " + selfCls + cls;
} // - - - - - - - - - - - - - - - -
//  root rules
// - - - - - - - - - - - - - - - -


var rootStyles = ["color", "background", "background-color"];

function initRootStyles(sheet, rootSelector, attrs, fgColor, bgColor, lnColor, hasDarkBg) {
  var s, revSelector, fgColorVal, bgColorVal; // var revFgColorVal, revBgColorVal;

  s = _.pick(attrs, rootStyles); // s["-webkit-font-smoothing"] = (hasDarkBg ? "antialiased" : "auto");

  /* NOTE: In Firefox '-moz-osx-font-smoothing: grayscale;'
  /* works both in light over dark and dark over light, hardcoded in _base.scss */
  //s["-moz-osx-font-smoothing"] = (hasDarkBg? "grayscale" : "auto");

  insertCSSRule(sheet, rootSelector, s); // A element
  // - - - - - - - - - - - - - - - -

  s = {};
  s["color"] = lnColor.rgb().string();
  insertCSSRule(sheet, rootSelector + " a", s);
  insertCSSRule(sheet, rootSelector + " .color-ln", s); // .color-fg05
  // - - - - - - - - - - - - - - - -

  s = {};
  s["color"] = Color(fgColor).mix(bgColor, 0.5).rgb().string();
  s["border-color"] = Color(fgColor).mix(bgColor, 0.3).rgb().string();
  insertCSSRule(sheet, rootSelector + " .color-fg05", s);
  fgColorVal = fgColor.rgb().string();
  bgColorVal = bgColor.rgb().string(); // revFgColorVal = Color(bgColor).mix(fgColor, 0.9).rgb().string();
  // revBgColorVal = Color(fgColor).mix(bgColor, 0.6).rgb().string();

  revSelector = rootSelector + " .color-reverse"; // .color-fg .color-bg
  // - - - - - - - - - - - - - - - -

  s = {
    "color": fgColorVal
  };
  insertCSSRule(sheet, rootSelector + " .color-fg", s);
  s = {
    "background-color": bgColorVal
  };
  insertCSSRule(sheet, rootSelector + " .color-bg", s); // html inverted text/background

  s = {
    "color": bgColorVal
  }; // s = { "color" : revFgColorVal };
  // s["-webkit-font-smoothing"] = (hasDarkBg ? "auto" : "antialiased");
  // insertCSSRule(sheet, revSelector + " .color-fg", s);
  // insertCSSRule(sheet, revSelector + ".color-fg", s);

  insertCSSRule(sheet, selfAndDescendant(revSelector, ".color-fg"), s);
  s = {
    "background-color": fgColorVal
  }; // s = { "background-color" : revBgColorVal };
  // insertCSSRule(sheet, revSelector + " .color-bg", s);
  // insertCSSRule(sheet, revSelector + ".color-bg", s);

  insertCSSRule(sheet, selfAndDescendant(revSelector, ".color-bg"), s); // .color-stroke .color-fill (SVG)
  // - - - - - - - - - - - - - - - -

  s = {
    "stroke": fgColorVal
  };
  insertCSSRule(sheet, rootSelector + " .color-stroke", s);
  s = {
    "fill": bgColorVal
  };
  insertCSSRule(sheet, rootSelector + " .color-fill", s); // svg inverted fill/stroke

  s = {
    "stroke": bgColorVal
  }; // insertCSSRule(sheet, revSelector + " .color-stroke", s);
  // insertCSSRule(sheet, revSelector + ".color-stroke", s);

  insertCSSRule(sheet, selfAndDescendant(revSelector, ".color-stroke"), s);
  s = {
    "fill": fgColorVal
  }; // insertCSSRule(sheet, revSelector + " .color-fill", s);
  // insertCSSRule(sheet, revSelector + ".color-fill", s);

  insertCSSRule(sheet, selfAndDescendant(revSelector, ".color-fill"), s); // .text-outline
  // - - - - - - - - - - - - - - - -
  // s = {
  // 	"text-shadow": "-1px -1px 0 " + bgColorVal +
  // 		", 1px -1px 0 " + bgColorVal +
  // 		", -1px 1px 0 " + bgColorVal +
  // 		", 1px 1px 0 " + bgColorVal
  // };
  // insertCSSRule(sheet, rootSelector + " :not(..collapsed-changing) .text-outline-bg", s);
} // - - - - - - - - - - - - - - - -
// carousel styles
// - - - - - - - - - - - - - - - -


var carouselStyles = ["box-shadow", "border", "border-radius"];

function initCarouselStyles(sheet, carouselSelector, attrs, fgColor, bgColor, lnColor, hasDarkBg) {
  var s = _.pick(attrs, carouselStyles); //, "background-color"]);


  insertCSSRule(sheet, carouselSelector + " .media-item .content", s); // .media-item .color-bg09
  // - - - - - - - - - - - - - - - -

  s = {};
  s["background-color"] = Color(bgColor).mix(fgColor, 0.05).rgb().string(); // s["background-color"] = Color(bgColor)[hasDarkBg ? "darken" : "lighten"](0.045).rgb().string();
  // s["background-color"] = Color(bgColor)[hasDarkBg ? "lighten" : "darken"](0.03).rgb().string();

  insertCSSRule(sheet, carouselSelector + " .media-item .color-bg09", s); // .media-item .placeholder
  // - - - - - - - - - - - - - - - -

  s = {}; // s["-webkit-font-smoothing"] = (hasDarkBg ? "auto" : "antialiased");
  // text color luminosity is inverse from body, apply oposite rendering mode

  s["color"] = bgColor.rgb().string(); // s["color"] = Color(bgColor)[hasDarkBg ? "darken" : "lighten"](0.045).rgb().string();

  s["background-color"] = Color(bgColor).mix(fgColor, 0.05).rgb().string(); // s["background-color"] = Color(bgColor).mix(fgColor, 0.8).alpha(0.3).rgba().string();
  // s["background-color"] = Color(bgColor)[hasDarkBg ? "lighten" : "darken"](0.03).rgb().string();

  "border-radius" in attrs && (s["border-radius"] = attrs["border-radius"]);
  insertCSSRule(sheet, carouselSelector + " .media-item .placeholder", s); // .empty-item A
  // - - - - - - - - - - - - - - - -

  s = {};
  s["text-decoration-color"] = Color(fgColor).mix(bgColor, 0.7).rgb().string();
  insertCSSRule(sheet, carouselSelector + " .empty-item A", s); // // .color-gradient
  // // - - - - - - - - - - - - - - - -
  // s = {};
  // s["background-color"] = "transparent";
  // s["background"] = "linear-gradient(to bottom, " +
  // 		Color(bgColor).alpha(0.00).rgba().string() + " 0%, " +
  // 		Color(bgColor).alpha(0.11).rgba().string() + " 100%)";
  // insertCSSRule(sheet, rootSelector + " .color-gradient", s);
  // s = {};
  // s["background-color"] = "transparent";
  // s["background"] = "linear-gradient(to bottom, " +
  // 		Color(fgColor).alpha(0.00).rgba().string() + " 0%, " +
  // 		Color(fgColor).alpha(0.11).rgba().string() + " 100%)";
  // insertCSSRule(sheet, revSelector + " .color-gradient", s);
  // insertCSSRule(sheet, revSelector + ".color-gradient", s);
}

module.exports = function () {
  var attrs, fgColor, bgColor, lnColor, hasDarkBg;
  attrs = Globals.DEFAULT_COLORS;
  fgColor = new Color(Globals.DEFAULT_COLORS["color"]);
  bgColor = new Color(Globals.DEFAULT_COLORS["background-color"]);
  lnColor = new Color(Globals.DEFAULT_COLORS["link-color"]);
  hasDarkBg = fgColor.luminosity() > bgColor.luminosity();
  var colorStyles = document.createElement("style");
  colorStyles.id = "colors";
  colorStyles.type = "text/css";
  document.head.appendChild(colorStyles); // var colorStyles = document.querySelector("link#folio");

  initRootStyles(colorStyles.sheet, ".app", attrs, fgColor, bgColor, lnColor, hasDarkBg);
  initCarouselStyles(colorStyles.sheet, ".carousel", attrs, fgColor, bgColor, lnColor, hasDarkBg); // - - - - - - - - - - - - - - - -
  // per-bundle rules
  // - - - - - - - - - - - - - - - -

  bundles.each(function (bundle) {
    attrs = bundle.attrs(); //get("attrs");

    fgColor = bundle.colors.fgColor;
    bgColor = bundle.colors.bgColor;
    lnColor = bundle.colors.lnColor;
    hasDarkBg = bundle.colors.hasDarkBg;
    initRootStyles(colorStyles.sheet, ".app." + bundle.get("domid"), attrs, fgColor, bgColor, lnColor, hasDarkBg);
    initCarouselStyles(colorStyles.sheet, ".carousel." + bundle.get("domid"), attrs, fgColor, bgColor, lnColor, hasDarkBg);
  });
};

}).call(this,require("underscore"))

},{"app/control/Globals":55,"app/model/collection/BundleCollection":64,"color":12,"underscore":51}],97:[function(require,module,exports){
"use strict";
/*global XMLHttpRequest */
// /** @type {module:underscore.string/lpad} */
// var classify = require("underscore.string/classify");
// var statusMsg = _.template("<%= status %> received from <%= url %> (<%= statusText %>)");
// var errMsg = _.template("'<%= errName %>' ocurred during request <%= url %>");

if (window.XMLHttpRequest && window.URL && window.Blob) {
  module.exports = function (url, progressFn) {
    return new Promise(function (resolve, reject) {
      var request = new XMLHttpRequest();
      request.open("GET", url, true); // request.timeout = 10000; // in milliseconds

      request.responseType = "blob";

      var errorFromEvent = function errorFromEvent(ev) {
        var err = new Error((ev.target.status > 0 ? "http_" + request.statusText.replace(/\s/g, "_") : ev.type + "_event").toUpperCase());
        err.infoCode = ev.target.status;
        err.infoSrc = url;
        err.logEvent = ev;
        err.logMessage = "_loadImageAsObjectURL::" + ev.type + " [reject]";
        return err;
      }; // if progressFn is supplied
      // - - - - - - - - - - - - - - - - - -


      if (progressFn) {
        request.onprogress = function (ev) {
          progressFn(ev.loaded / ev.total, request);
        };
      } // resolved/success
      // - - - - - - - - - - - - - - - - - -


      request.onload = function (ev) {
        // When the request loads, check whether it was successful
        if (request.status == 200) {
          // If successful, resolve the promise by passing back a reference url
          resolve(URL.createObjectURL(request.response));
        } else {
          reject(errorFromEvent(ev));
        }
      }; // normal abort
      // - - - - - - - - - - - - - - - - - -


      request.onabort = function (ev) {
        resolve(void 0);
      }; // reject/failure
      // - - - - - - - - - - - - - - - - - -


      request.onerror = function (ev) {
        reject(errorFromEvent(ev));
      };

      request.ontimeout = request.onerror; // finally
      // - - - - - - - - - - - - - - - - - -

      request.onloadend = function (ev) {
        //console.log("_loadImageAsObjectURL::%s [cleanup] (%s)", ev ? ev.type : "no event", url);
        request.onabort = request.ontimeout = request.onerror = void 0;
        request.onload = request.onloadend = void 0;

        if (progressFn) {
          request.onprogress = void 0;
        }
      };

      request.send();
    });
  };
} else {
  module.exports = function (url, progressFn) {
    return Promise.resolve(url);
  };
}

},{}],98:[function(require,module,exports){
"use strict";

module.exports = function (image, resolveEmpty) {
  return new Promise(function (resolve, reject) {
    if (!(image instanceof window.HTMLImageElement)) {
      //reject(new Error("not an HTMLImageElement"));
      reject("Error: not an HTMLImageElement");
    } else if (image.complete && (image.src.length > 0 || resolveEmpty)) {
      // if (image.src === "") console.warn("_whenImageLoads resolved with empty src");
      // else console.log("_whenImageLoads resolve-sync", image.src);
      resolve(image);
    } else {
      var handlers = {
        load: function load(ev) {
          // console.log("_whenImageLoads_dom resolve-async", ev.type, image.src);
          removeEventListeners();
          resolve(image);
        },
        error: function error(ev) {
          var err = new Error("Loading failed (" + ev.type + " event)");
          err.infoCode = -1;
          err.infoSrc = image.src;
          err.logEvent = ev;
          err.logMessage = "_whenImageLoads::" + ev.type + " [reject]";
          removeEventListeners();
          reject(err);
        }
      };
      handlers.abort = handlers.error;

      var removeEventListeners = function removeEventListeners() {
        for (var event in handlers) {
          if (handlers.hasOwnProperty(event)) {
            image.removeEventListener(event, handlers[event], false);
          }
        }
      };

      for (var event in handlers) {
        if (handlers.hasOwnProperty(event)) {
          image.addEventListener(event, handlers[event], false);
        }
      }
    }
  });
};

},{}],99:[function(require,module,exports){
(function (_){
"use strict";
/** @type {module:app/view/promise/_whenImageLoads} */

var _whenImageLoads = require("app/view/promise/_whenImageLoads");
/** @type {module:app/view/promise/_loadImageAsObjectURL} */


var _loadImageAsObjectURL = require("app/view/promise/_loadImageAsObjectURL"); // var isBlobRE = /^blob\:.*/;
// var logMessage = "%s::whenDefaultImageLoads [%s]: %s";


module.exports = function (view) {
  return new Promise(function (resolve, reject) {
    var source = view.model.get("source");

    if (source.has("prefetched")) {
      view.defaultImage.src = source.get("prefetched");

      _whenImageLoads(view.defaultImage).then(function (targetEl) {
        // console.log(logMessage, view.cid, "resolved", "prefetched");
        resolve(view);
      });
    } else {
      view.mediaState = "pending";
      var sUrl = source.get("original");

      var progressFn = function progressFn(progress, ev) {
        // console.log(logMessage, view.cid, "progress", progress);
        view.updateMediaProgress(progress, sUrl);
      };

      progressFn = _.throttle(progressFn, 100, {
        leading: true,
        trailing: false
      });

      _loadImageAsObjectURL(sUrl, progressFn).then(function (url) {
        if (/^blob\:.*/.test(url)) {
          source.set("prefetched", url);
        }

        view.defaultImage.src = url; // URL.revokeObjectURL(url);

        return view.defaultImage;
      }).then(_whenImageLoads).then(function (targetEl) {
        // console.log(logMessage, view.cid, "resolved", targetEl.src);
        view.on("view:removed", function () {
          var prefetched = source.get("prefetched");

          if (prefetched && /^blob\:/.test(prefetched)) {
            source.unset("prefetched", {
              silent: true
            });
            URL.revokeObjectURL(prefetched);
          }
        }); // view.placeholder.removeAttribute("data-progress");
        // view.updateMediaProgress(imageUrl, "complete");

        resolve(view);
      }, // 	})
      // .catch(
      function (err) {
        // console.warn(logMessage, view.cid, "rejected", err.message);
        // view.placeholder.removeAttribute("data-progress");
        // view.updateMediaProgress(imageUrl, progress);
        reject(err);
      });
    }
  });
};

}).call(this,require("underscore"))

},{"app/view/promise/_loadImageAsObjectURL":97,"app/view/promise/_whenImageLoads":98,"underscore":51}],100:[function(require,module,exports){
"use strict";
/* global Promise */

/** @type {module:app/view/base/ViewError} */

var ViewError = require("app/view/base/ViewError");
/** @type {module:app/view/base/ViewError} */


var whenViewIsAttached = require("app/view/promise/whenViewIsAttached");

function whenScrollingEnds(view) {
  return new Promise(function (resolve, reject) {
    var parent = view.parentView;

    if (parent === null) {
      console.error("%s::whenScrollingEnds [%s] (sync)", view.cid, "rejected", view.attached);
      reject(new ViewError(view, new Error("whenScrollingEnds: view has no parent")));
    } else if (!parent.scrolling) {
      // console.log("%s::whenScrollingEnds [%s] (sync)", view.cid, "resolved", view.attached);
      resolve(view);
    } else {
      var cleanup = function cleanup() {
        parent.off("view:scrollend", onScrollend);
        parent.off("view:remove", onRemove);
      };

      var onScrollend = function onScrollend() {
        // console.log("%s::whenScrollingEnds [%s]", view.cid, "resolved", view.attached);
        cleanup();
        resolve(view);
      };

      var onRemove = function onRemove() {
        // console.log("%s::whenScrollingEnds [%s]", view.cid, "rejected", view.attached);
        cleanup();
        reject(new ViewError(view, new Error("whenScrollingEnds: view was removed")));
      };

      parent.on("view:scrollend", onScrollend);
      parent.on("view:remove", onRemove);
    }
  });
}

module.exports = function (view) {
  return Promise.resolve(view).then(whenViewIsAttached).then(whenScrollingEnds);
};
/*
module.exports = function(view) {
	return Promise.resolve(view)
		.then(function(view) {
			if (view.attached) {
				return view;
			} else {
				return new Promise(function(resolve, reject) {
					view.once("view:attached", function(view) {
						resolve(view);
					});
				});
			}
		})
		.then(function(view) {
			if (!view.parentView.scrolling) {
				return view;
			} else {
				return new Promise(function(resolve, reject) {
					var resolveOnScrollend = function() {
						// console.log("%s::whenScrollingEnds [%s]", view.cid, "resolved");
						view.off("view:remove", rejectOnRemove);
						resolve(view);
					};
					var rejectOnRemove = function(view) {
						// console.log("%s::whenScrollingEnds [%s]", view.cid, "rejected");
						view.parentView.off("view:scrollend", resolveOnScrollend);
						reject(new ViewError(view,
							new Error("whenSelectScrollingEnds: view was removed ("+ view.cid +")")));
					};
					view.parentView.once("view:scrollend", resolveOnScrollend);
					view.once("view:remove", rejectOnRemove);
				});
			}
		});
};
*/

},{"app/view/base/ViewError":83,"app/view/promise/whenViewIsAttached":103}],101:[function(require,module,exports){
"use strict";
/** @type {module:app/view/base/ViewError} */

var ViewError = require("app/view/base/ViewError"); // var logMessage = "%s::whenSelectionDistanceIs [%s]: %s";

/**
 * @param {module:app/view/base/View}
 * @param {number} distance
 */


module.exports = function (view, distance) {
  return new Promise(function (resolve, reject) {
    // if (!(view.model && view.model.collection)) {
    // 	reject(new ViewError(view, new Error("whenSelectionIsContiguous: model.collection is empty")));
    // }
    var model = view.model;
    var collection = model.collection;

    var check = function check(n) {
      // Check indices for contiguity
      return Math.abs(collection.indexOf(model) - collection.selectedIndex) <= distance;
    };

    if (check()) {
      // console.log(logMessage, view.cid, "resolve", "sync");
      resolve(view);
    } else {
      var cleanupOnSettle = function cleanupOnSettle() {
        // console.log(logMessage, view.cid, "cleanup", "async");
        collection.off("select:one select:none", resolveOnSelect);
        view.off("view:removed", rejectOnRemove);
      };

      var resolveOnSelect = function resolveOnSelect(model) {
        if (check()) {
          // console.log(logMessage, view.cid, "resolve", "async");
          cleanupOnSettle();
          resolve(view);
        }
      };

      var rejectOnRemove = function rejectOnRemove(view) {
        cleanupOnSettle();
        reject(new ViewError(view, new Error("whenSelectionDistanceIs: view was removed")));
      };

      collection.on("select:one select:none", resolveOnSelect);
      view.on("view:removed", rejectOnRemove);
    }
  });
};

},{"app/view/base/ViewError":83}],102:[function(require,module,exports){
"use strict"; // /** @type {module:app/view/base/ViewError} */
// var ViewError = require("app/view/base/ViewError");

/** @type {module:app/view/promise/whenSelectionDistanceIs} */

var whenSelectionDistanceIs = require("app/view/promise/whenSelectionDistanceIs");
/** @param {module:app/view/base/View} */


module.exports = function (view) {
  return whenSelectionDistanceIs(view, 1);
};

},{"app/view/promise/whenSelectionDistanceIs":101}],103:[function(require,module,exports){
"use strict";

module.exports = function (view) {
  return new Promise(function (resolve, reject) {
    if (view.attached) {
      resolve(view);
    } else {
      view.on("view:attached", function (view) {
        resolve(view);
      });
    }
  });
};

},{}],104:[function(require,module,exports){
"use strict";

module.exports = function (view) {
  return new Promise(function (resolve, reject) {
    if (!view.invalidated) {
      resolve(view);
    } else {
      view.once("view:render:after", function (view, flags) {
        resolve(view);
      });
    }
  });
};

},{}],105:[function(require,module,exports){
(function (_){
"use strict";
/**
 * @module app/view/render/CarouselRenderer
 */

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View");
/** @type {module:underscore} */


var getBoxEdgeStyles = require("utils/css/getBoxEdgeStyles"); // FIXME: this fixup should not be done here
// /** @type {module:utils/net/toAbsoluteURL} */
// var toAbsoluteURL = require("utils/net/toAbsoluteURL");
// /** @type {string} */
// var ABS_APP_ROOT = toAbsoluteURL(require("app/control/Globals").APP_ROOT);

/**
 * @constructor
 * @type {module:app/view/render/CarouselRenderer}
 */


var CarouselRenderer = View.extend({
  /** @type {string} */
  cidPrefix: "carouselRenderer",

  /** @override */
  tagName: "div",

  /** @override */
  className: "carousel-item",

  /** @override */
  template: _.template("<div class=\"content sizing\"><%= name %></div>"),
  properties: {
    content: {
      get: function get() {
        return this._content || (this._content = this.el.querySelector(".content"));
      }
    },
    sizing: {
      get: function get() {
        return this._sizing || (this._sizing = this.el.querySelector(".sizing"));
      }
    }
  },

  /** @override */
  initialize: function initialize(options) {
    if (this.model.attr("@classname") !== void 0) {
      var clsAttr = this.model.attr("@classname").split(" ");

      for (var i = 0; i < clsAttr.length; i++) {
        this.el.classList.add(clsAttr[i]);
      }
    }

    options.parentView && (this.parentView = options.parentView);
    this.metrics = {};
    this.metrics.content = {};
    this.createChildren(); // this.enabled = !!options.enabled; // force bool

    this.setEnabled(!!options.enabled);
  },
  createChildren: function createChildren() {
    this.el.innerHTML = this.template(this.model.toJSON()); // FIXME: this fixup should not be done here
    // FIXED: now done in xslt

    /*this.el.querySelectorAll("a[href]").forEach(function(el) {
    	var url = toAbsoluteURL(el.getAttribute("href"));
    	if (url.indexOf(ABS_APP_ROOT) !== 0) {
    		el.setAttribute("target", "_blank");
    	}
    });*/
  },

  /** @return {HTMLElement} */
  getSizingEl: function getSizingEl() {
    return this._sizing || (this._sizing = this.el.querySelector(".sizing"));
  },

  /** @return {HTMLElement} */
  getContentEl: function getContentEl() {
    return this._content || (this._content = this.el.querySelector(".content"));
  },

  /** @return {this} */
  measure: function measure() {
    var sizing = this.getSizingEl();
    this.metrics = getBoxEdgeStyles(this.el, this.metrics);
    this.metrics.content = getBoxEdgeStyles(this.getContentEl(), this.metrics.content);
    sizing.style.maxWidth = "";
    sizing.style.maxHeight = "";
    this.metrics.content.x = sizing.offsetLeft + sizing.clientLeft;
    this.metrics.content.y = sizing.offsetTop + sizing.clientTop;
    this.metrics.content.width = sizing.clientWidth;
    this.metrics.content.height = sizing.clientHeight;
    return this;
  },

  /** @override */
  render: function render() {
    this.measure();
    return this;
  },
  getSelectionDistance: function getSelectionDistance() {
    return Math.abs(this.model.collection.indexOf(this.model) - this.model.collection.selectedIndex);
  }
});
module.exports = CarouselRenderer;

}).call(this,require("underscore"))

},{"app/view/base/View":82,"underscore":51,"utils/css/getBoxEdgeStyles":139}],106:[function(require,module,exports){
"use strict";
/**
 * @module app/view/render/ClickableRenderer
 */

/** @type {module:app/view/render/LabelRenderer} */

var LabelRenderer = require("app/view/render/LabelRenderer");
/**
 * @constructor
 * @type {module:app/view/render/ClickableRenderer}
 */


var ClickableRenderer = LabelRenderer.extend({
  /** @type {string} */
  cidPrefix: "clickableRenderer",
  // defaults: {
  // 	target: ".label"
  // },

  /** @override */
  events: {
    "click .label": function clickLabel(ev) {
      if (ev.defaultPrevented) return;
      ev.preventDefault();
      this.trigger("renderer:click", this.model, ev);
    },
    "click a": function clickA(ev) {
      ev.defaultPrevented || ev.preventDefault();
    }
  } // initialize: function(options) {
  // 	options || (options = {});
  // 	// if (options) {
  // 	options = _.defaults({}, options, _.result(this, 'defaults'));
  // 	// } else {
  // 	// 	 _.defaults({}, _.result(this, 'defaults'));
  // 	// }
  // 	this.events["click " + options.target] = this.clickHandler;
  // },
  //
  // clickHandler: function(ev) {
  // 	if (ev.defaultPrevented) return;
  //
  // 	ev.preventDefault();
  // 	this.trigger("renderer:click", this.model, ev);
  // }

});
module.exports = ClickableRenderer;

},{"app/view/render/LabelRenderer":113}],107:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function";

  return "<a href=\"#"
    + container.escapeExpression(((helper = (helper = helpers.domid || (depth0 != null ? depth0.domid : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"domid","hash":{},"data":data}) : helper)))
    + "\"><span class=\"label\">"
    + ((stack1 = ((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</span></a>";
},"useData":true});

},{"hbsfy/runtime":35}],108:[function(require,module,exports){
"use strict";
/**
 * @module app/view/render/DefaultSelectableRenderer
 */

/** @type {module:app/view/component/ClickableRenderer} */

var ClickableRenderer = require("app/view/render/ClickableRenderer");
/**
 * @constructor
 * @type {module:app/view/render/DefaultSelectableRenderer}
 */


var DefaultSelectableRenderer = ClickableRenderer.extend({
  /** @override */
  tagName: "li",

  /** @override */
  className: "list-item",

  /** @override */
  template: require("./DefaultSelectableRenderer.hbs"),
  initialize: function initialize(options) {
    this.listenTo(this.model, "selected deselected", this._renderClassList);

    this._renderClassList();
  },

  /** @override */
  render: function render() {
    this.el.innerHTML = this.template(this.model.toJSON());

    this._renderClassList();

    return this;
  },
  _renderClassList: function _renderClassList() {
    this.el.classList.toggle("selected", this.model.selected);
  }
});
module.exports = DefaultSelectableRenderer;

},{"./DefaultSelectableRenderer.hbs":107,"app/view/render/ClickableRenderer":106}],109:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<span class=\"label\">"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</span><a href=\"#"
    + alias4(((helper = (helper = helpers.domid || (depth0 != null ? depth0.domid : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"domid","hash":{},"data":data}) : helper)))
    + "\"><b> </b></a>";
},"useData":true});

},{"hbsfy/runtime":35}],110:[function(require,module,exports){
"use strict";
/**
 * @module app/view/render/DotNavigationRenderer
 */

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View"); // /** @type {module:app/view/component/ClickableRenderer} */
// var ClickableRenderer = require("app/view/render/LabelRenderer");

/** @type {string} */


var viewTemplate = require("./DotNavigationRenderer.hbs");
/**
 * @constructor
 * @type {module:app/view/render/DotNavigationRenderer}
 */


var DotNavigationRenderer = View.extend({
  /** @type {string} */
  cidPrefix: "dotRenderer",

  /** @override */
  tagName: "li",

  /** @override */
  className: "list-item",

  /** @override */
  template: viewTemplate,

  /** @override */
  events: {
    "click": function click(ev) {
      if (ev.defaultPrevented) return;
      ev.preventDefault();
      this.trigger("renderer:click", this.model, ev);
    },
    "click a": function clickA(ev) {
      ev.defaultPrevented || ev.preventDefault();
    }
  },

  /** @override */
  initialize: function initialize(options) {
    this.listenTo(this.model, "selected deselected", this.renderClassList);
    this.renderClassList();
  },

  /** @override */
  render: function render() {
    this.el.innerHTML = this.template(this.model.toJSON());
    this.renderClassList();
    return this;
  },
  renderClassList: function renderClassList() {
    this.el.classList.toggle("selected", this.model.selected);
  }
});
module.exports = DotNavigationRenderer;

},{"./DotNavigationRenderer.hbs":109,"app/view/base/View":82}],111:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\"placeholder sizing\"></div>\n<img class=\"content media-border default\" alt=\""
    + alias4(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"text","hash":{},"data":data}) : helper)))
    + "\" longdesc=\"#desc_m"
    + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\" />\n";
},"useData":true});

},{"hbsfy/runtime":35}],112:[function(require,module,exports){
"use strict";
/**
 * @module app/view/render/ImageRenderer
 */

/** @type {module:app/view/MediaRenderer} */

var MediaRenderer = require("./MediaRenderer");
/** @type {Function} */


var viewTemplate = require("./ImageRenderer.hbs");
/**
 * @constructor
 * @type {module:app/view/render/ImageRenderer}
 */


var ImageRenderer = MediaRenderer.extend({
  /** @type {string} */
  cidPrefix: "imageRenderer",

  /** @type {string} */
  className: MediaRenderer.prototype.className + " image-item",

  /** @type {Function} */
  template: viewTemplate,

  /** @override */
  initialize: function initialize(opts) {
    MediaRenderer.prototype.initialize.apply(this, arguments); // this.createChildren();
    // this.initializeAsync();
  },

  /* --------------------------- *
  /* children/layout
  /* --------------------------- */

  /** @override */
  createChildren: function createChildren() {
    MediaRenderer.prototype.createChildren.apply(this, arguments); // this.el.innerHTML = this.template(this.model.toJSON());

    this.placeholder = this.el.querySelector(".placeholder");
  },

  /** @override */
  render: function render() {
    MediaRenderer.prototype.render.apply(this, arguments); // this.measure();

    var img = this.getDefaultImage();
    img.setAttribute("width", this.metrics.media.width);
    img.setAttribute("height", this.metrics.media.height);
    var content = this.getContentEl();
    content.style.left = this.metrics.content.x + "px";
    content.style.top = this.metrics.content.y + "px"; // var sizing = this.getSizingEl();
    // sizing.style.maxWidth = this.metrics.content.width + "px";
    // sizing.style.maxHeight = this.metrics.content.height + "px";

    return this;
  },

  /* --------------------------- *
  /* initializeAsync
  /* --------------------------- */
  initializeAsync: function initializeAsync() {
    return MediaRenderer.prototype.initializeAsync.apply(this, arguments) // return MediaRenderer.whenSelectionIsContiguous(this)
    // // return Promise.resolve(this)
    // // 	.then(MediaRenderer.whenSelectionIsContiguous)
    // 	.then(MediaRenderer.whenSelectTransitionEnds)
    // 	.then(MediaRenderer.whenDefaultImageLoads)
    // .then(
    // 	function(view) {
    // 		view.mediaState = "ready";
    // 	})
    // .catch(
    // 	function(err) {
    // 		if (err instanceof ViewError) {
    // 			// NOTE: ignore ViewError type
    // 			// console.log(err.view.cid, err.view.model.cid, "ImageRenderer: " + err.message);
    // 		} else {
    // 			console.error(this.cid, err.name, err);
    // 			this.placeholder.innerHTML = "<p class=\"color-fg\" style=\"position:absolute;bottom:0;padding:3rem;\"><strong>" + err.name + "</strong> " + err.message + "</p>";
    // 			this.mediaState = "error";
    // 		}
    // 	}.bind(this))
    ;
  }
});
module.exports = ImageRenderer;

},{"./ImageRenderer.hbs":111,"./MediaRenderer":114}],113:[function(require,module,exports){
"use strict";
/**
 * @module app/view/render/LabelRenderer
 */

/** @type {module:app/view/base/View} */

var View = require("app/view/base/View");
/**
 * @constructor
 * @type {module:app/view/render/LabelRenderer}
 */


var LabelRenderer = View.extend({
  /** @type {string} */
  cidPrefix: "labelRenderer",
  properties: {
    label: {
      get: function get() {
        return this._label || (this._label = this.el.querySelector(".label"));
      } // measuredWidth: {
      // 	get: function() {
      // 		return this._measuredWidth;
      // 	}
      // },
      // measuredHeight: {
      // 	get: function() {
      // 		return this._measuredHeight;
      // 	}
      // },

    }
  }
  /* -------------------------------
  /* measure
  /* ------------------------------- */
  // _measuredWidth: null,
  // _measuredHeight: null,
  // measure: function() {},

});
module.exports = LabelRenderer;

},{"app/view/base/View":82}],114:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/*global XMLHttpRequest, HTMLMediaElement, MediaError*/

/**
 * @module app/view/render/MediaRenderer
 */

/** @type {module:underscore.strings/lpad} */

var lpad = require("underscore.string/lpad");
/** @type {module:app/model/item/MediaItem} */


var MediaItem = require("app/model/item/MediaItem");
/** @type {module:app/view/CarouselRenderer} */


var CarouselRenderer = require("app/view/render/CarouselRenderer"); // var errorTemplate = require("../template/ErrorBlock.hbs");
// /** @type {module:utils/css/getBoxEdgeStyles} */
// var getBoxEdgeStyles = require("utils/css/getBoxEdgeStyles");


var MediaRenderer = CarouselRenderer.extend({
  /** @type {string} */
  cidPrefix: "mediaRenderer",

  /** @type {string} */
  className: CarouselRenderer.prototype.className + " media-item",

  /** @type {module:app/model/MediaItem} */
  model: MediaItem,
  properties: {
    defaultImage: {
      get: function get() {
        return this._defaultImage || (this._defaultImage = this.el.querySelector("img.default"));
      }
    },
    mediaState: {
      get: function get() {
        return this._mediaState;
      },
      set: function set(state) {
        this._setMediaState(state);
      }
    }
  },

  /** @override */
  initialize: function initialize(opts) {
    // if (this.model.attrs().hasOwnProperty("@classname")) {
    // 	this.el.className += " " + this.model.attr("@classname");
    // }
    // NOTE: @classname attr handling moved to CarouselRenderer
    // if (this.model.attr("@classname") !== void 0) {
    // 	var clsAttr = this.model.attr("@classname").split(" ");
    // 	for (var i = 0; i < clsAttr.length; i++) {
    // 		this.el.classList.add(clsAttr[i]);
    // 	}
    // }
    CarouselRenderer.prototype.initialize.apply(this, arguments);
    this.metrics.media = {};
    this.mediaState = "idle";
    this.initializeAsync().then(this.whenInitialized).catch(this.whenInitializeError.bind(this));
  },
  initializeAsync: function initializeAsync() {
    // var MediaRenderer = Object.getPrototypeOf(this).constructor;
    return Promise.resolve(this).then(MediaRenderer.whenSelectionIsContiguous).then(MediaRenderer.whenScrollingEnds).then(MediaRenderer.whenDefaultImageLoads);
  },
  whenInitialized: function whenInitialized(view) {
    // console.log("%s::whenInitialized [%s]", view.cid, "resolved");
    view.mediaState = "ready";
    view.placeholder.removeAttribute("data-progress");
    return view;
  },
  whenInitializeError: function whenInitializeError(err) {
    if (err instanceof CarouselRenderer.ViewError) {
      // NOTE: ignore ViewError type
      return;
    } else if (err instanceof Error) {
      console.error(err.stack);
    }

    this.placeholder.removeAttribute("data-progress");
    this.mediaState = "error";
  },
  updateMediaProgress: function updateMediaProgress(progress, id) {
    if (_.isNumber(progress)) {
      this.placeholder.setAttribute("data-progress", lpad(Math.floor(progress * 100), 2, '0'));
    } // else if (progress === "complete") {
    // 	this.placeholder.removeAttribute("data-progress");
    // }

  },
  // whenMediaIsReady: function(view) {
  // 	return MediaRenderer.whenDefaultImageLoads(this, this.updateMediaProgress.bind(this));
  // },

  /* --------------------------- *
  /* child getters
  /* --------------------------- */

  /** @return {HTMLElement} */
  getDefaultImage: function getDefaultImage() {
    return this.defaultImage;
  },

  /* --------------------------- *
  /* children/layout
  /* --------------------------- */
  createChildren: function createChildren() {
    this.el.innerHTML = this.template(this.model.toJSON());
  },

  /** @override */
  measure: function measure() {
    CarouselRenderer.prototype.measure.apply(this, arguments);
    var sw, sh; // source dimensions

    var pcw, pch; // measured values

    var cx, cy, cw, ch, cs; // computed values

    var ew, eh; // content edge totals

    var cm; // content metrics

    cm = this.metrics.content;
    cx = cm.x;
    cy = cm.y;
    pcw = cm.width;
    pch = cm.height;
    ew = cm.paddingLeft + cm.paddingRight + cm.borderLeftWidth + cm.borderRightWidth;
    eh = cm.paddingTop + cm.paddingBottom + cm.borderTopWidth + cm.borderBottomWidth;
    pcw -= ew;
    pch -= eh;
    sw = this.model.get("source").get("w");
    sh = this.model.get("source").get("h"); // Unless both client dimensions are larger than the source's
    // choose constraint direction by aspect ratio

    if (sw < pcw && sh < pch) {
      cs = 1;
      cw = sw;
      ch = sh;
      this.metrics.fitDirection = "both";
    } else if (pcw / pch < sw / sh) {
      // fit width
      cw = pcw;
      cs = cw / sw; // ch = cs * sh;

      ch = Math.round(cs * sh);
      this.metrics.fitDirection = "width";
    } else {
      // fit height
      ch = pch;
      cs = ch / sh; // cw = cs * sw;

      cw = Math.round(cs * sw);
      this.metrics.fitDirection = "height";
    }

    this.metrics.content.x = cx;
    this.metrics.content.y = cy;
    this.metrics.content.width = cw + ew;
    this.metrics.content.height = ch + eh;
    this.metrics.media.x = cx + cm.paddingLeft + cm.borderLeftWidth;
    this.metrics.media.y = cy + cm.paddingTop + cm.borderTopWidth;
    this.metrics.media.width = cw;
    this.metrics.media.height = ch;
    this.metrics.media.scale = cs; // console.log("%s::measure mw:%s mh:%s fit: %s metrics: %o", this.cid, pcw, pch, this.metrics.fitDirection, this.metrics);
    // var sizing = this.getSizingEl();
    // sizing.style.maxWidth = (cw + ew) + "px";
    // sizing.style.maxHeight = (ch + eh) + "px";

    return this;
  },
  render: function render() {
    // NOTE: not calling super.render, calling measure ourselves
    this.measure();
    var sizing = this.getSizingEl();
    sizing.style.maxWidth = this.metrics.content.width + "px";
    sizing.style.maxHeight = this.metrics.content.height + "px";
    this.el.setAttribute("data-fit-dir", this.metrics.fitDirection);
    return this;
  },

  /* --------------------------- *
  /* mediaState
  /* --------------------------- */
  _mediaStateEnum: ["idle", "pending", "ready", "error"],
  _setMediaState: function _setMediaState(key) {
    if (this._mediaStateEnum.indexOf(key) === -1) {
      throw new Error("Argument " + key + " invalid. Must be one of: " + this._mediaStateEnum.join(", "));
    }

    if (this._mediaState !== key) {
      if (this._mediaState) {
        this.el.classList.remove(this._mediaState);
      }

      this.el.classList.add(key);
      this._mediaState = key;
      this.trigger("media:" + key);
    }
  }
}, {
  LOG_TO_SCREEN: true,

  /** @type {module:app/view/promise/whenSelectionDistanceIs} */
  whenSelectionDistanceIs: require("app/view/promise/whenSelectionDistanceIs"),

  /** @type {module:app/view/promise/whenSelectionIsContiguous} */
  whenSelectionIsContiguous: require("app/view/promise/whenSelectionIsContiguous"),
  // /** @type {module:app/view/promise/whenSelectTransitionEnds} */
  // whenSelectTransitionEnds: require("app/view/promise/whenSelectTransitionEnds"),

  /** @type {module:app/view/promise/whenScrollingEnds} */
  whenScrollingEnds: require("app/view/promise/whenScrollingEnds"),

  /** @type {module:app/view/promise/whenDefaultImageLoads} */
  whenDefaultImageLoads: require("app/view/promise/whenDefaultImageLoads")
});
/* ---------------------------
/* log to screen
/* --------------------------- */

if (DEBUG) {
  MediaRenderer = function (MediaRenderer) {
    if (!MediaRenderer.LOG_TO_SCREEN) return MediaRenderer;
    /** @type {Function} */

    var Color = require("color"); // /** @type {module:underscore.string/lpad} */
    // var lpad = require("underscore.string/lpad");
    // /** @type {module:underscore.string/rpad} */
    // var rpad = require("underscore.string/rpad");


    return MediaRenderer.extend({
      /** @override */
      initialize: function initialize() {
        var fgColor = new Color(this.model.attr("color"));
        var bgColor = new Color(this.model.attr("background-color"));
        this.__logColors = {
          normal: Color(fgColor).mix(bgColor, 0.75).hsl().string(),
          ignored: Color(fgColor).mix(bgColor, 0.25).hsl().string(),
          error: "brown",
          abort: "orange"
        };
        this.__logFrameStyle = "1px dashed " + Color(fgColor).mix(bgColor, 0.5).hsl().string();
        this.__logStartTime = Date.now();
        this.__rafId = -1;
        this.__onFrame = this.__onFrame.bind(this);
        MediaRenderer.prototype.initialize.apply(this, arguments);
      },
      initializeAsync: function initializeAsync() {
        return MediaRenderer.prototype.initializeAsync.apply(this, arguments).catch(function (err) {
          if (!(err instanceof MediaRenderer.ViewError)) {
            this.__logMessage(err.message, err.name, this.__logColors["error"]);
          }

          return Promise.reject(err);
        }.bind(this));
      },

      /** @override */
      createChildren: function createChildren() {
        var ret = MediaRenderer.prototype.createChildren.apply(this, arguments);
        this.__logElement = document.createElement("div");
        this.__logElement.className = "debug-log"; // this.__logElement.style.touchAction = "pan-y";

        this.__logHeaderEl = document.createElement("pre");
        this.__logHeaderEl.className = "log-header color-bg"; // Color(this.model.colors.fgColor).mix(fgColor, 0.9).rgb().string()
        // Color(this.model.colors.fgColor).alpha

        this.__logHeaderEl.textContent = this.__getHeaderText();

        this.__logElement.appendChild(this.__logHeaderEl);

        this.el.insertBefore(this.__logElement, this.el.firstElementChild);
        return ret;
      },

      /** @override */
      render: function render() {
        var ret = MediaRenderer.prototype.render.apply(this, arguments);
        this.__logElement.style.top = this.metrics.content.height + this.metrics.content.y + "px";
        this.__logElement.style.left = this.metrics.content.x + "px";
        this.__logElement.style.width = this.metrics.content.width + "px";
        this.__logElement.scrollTop = this.__logElement.scrollHeight;
        return ret;
      },
      whenInitializeError: function whenInitializeError(err) {
        // NOTE: not calling super
        // MediaRenderer.prototype.whenInitializeError.apply(this, arguments);
        if (err instanceof CarouselRenderer.ViewError) {
          // NOTE: ignore ViewError type
          // console.warn("%s::whenInitializeError ", err.view.cid, err.message);
          return;
        } else if (err instanceof Error) {
          console.warn(err.stack);
        } // this.placeholder.innerHTML = err ? errorTemplate(err) : "";


        this.placeholder.removeAttribute("data-progress");
        this.mediaState = "error"; // console.error("%s::initializeAsync [%s (caught)]: %s", this.cid, err.name, (err.info && err.info.logMessage) || err.message);
        // err.logEvent && console.log(err.logEvent);
      },

      /* --------------------------- *
      /* log methods
      /* --------------------------- */
      __logMessage: function __logMessage(msg, logtype, color) {
        var logEntryEl = document.createElement("pre");
        logtype || (logtype = "-");
        logEntryEl.textContent = this.__getTStamp() + " " + msg;
        logEntryEl.setAttribute("data-logtype", logtype);
        logEntryEl.style.color = color || this.__logColors[logtype] || this.__logColors.normal;

        this.__logElement.appendChild(logEntryEl);

        this.__logElement.scrollTop = this.__logElement.scrollHeight;

        if (this.__rafId == -1) {
          this.__rafId = this.requestAnimationFrame(this.__onFrame);
        }
      },
      __onFrame: function __onFrame(tstamp) {
        this.__rafId = -1;
        this.__logElement.lastElementChild.style.borderBottom = this.__logFrameStyle;
        this.__logElement.lastElementChild.style.paddingBottom = "2px";
        this.__logElement.lastElementChild.style.marginBottom = "2px";
      },
      __getTStamp: function __getTStamp() {
        // return new Date(Date.now() - this.__logStartTime).toISOString().substr(11, 12);
        return lpad(((Date.now() - this.__logStartTime) / 1000).toFixed(3), 8, "0");
      },
      __getHeaderText: function __getHeaderText() {
        return '';
      }
    });
  }(MediaRenderer);
} // end debug

/**
 * @constructor
 * @type {module:app/view/render/MediaRenderer}
 */


module.exports = MediaRenderer;

}).call(this,true,require("underscore"))

},{"app/model/item/MediaItem":71,"app/view/promise/whenDefaultImageLoads":99,"app/view/promise/whenScrollingEnds":100,"app/view/promise/whenSelectionDistanceIs":101,"app/view/promise/whenSelectionIsContiguous":102,"app/view/render/CarouselRenderer":105,"color":12,"underscore":51,"underscore.string/lpad":47}],115:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/view/render/PlayableRenderer
 */

/** @type {module:app/view/MediaRenderer} */

var MediaRenderer = require("app/view/render/MediaRenderer"); // /** @type {module:app/view/component/CanvasProgressMeter} */
// var ProgressMeter = require("app/view/component/CanvasProgressMeter");

/** @type {Function} */


var prefixedProperty = require("utils/prefixedProperty");
/** @type {Function} */


var prefixedEvent = require("utils/prefixedEvent"); // var visibilityHiddenProp = prefixedProperty("hidden", document);

/** @type {String} */


var visibilityStateProp = prefixedProperty("visibilityState", document);
/** @type {String} */

var visibilityChangeEvent = prefixedEvent("visibilitychange", document, "hidden"); // /** @type {Function} */
// var Color = require("color");
//
// /** @type {Function} */
// // var duotone = require("utils/canvas/bitmap/duotone");
// // var stackBlurMono = require("utils/canvas/bitmap/stackBlurMono");
// var stackBlurRGB = require("utils/canvas/bitmap/stackBlurRGB");
// // var getAverageRGBA = require("utils/canvas/bitmap/getAverageRGBA");
// var getAverageRGB = require("utils/canvas/bitmap/getAverageRGB");
// // var inflateRect = require("utils/geom/inflateRect");
//
// var WAIT_DEBOUNCE_MS = require("app/control/Globals").TRANSITION_DURATION;
// /** @type {HTMLCanvasElement} */
// var _sharedCanvas = null;
// /** @return {HTMLCanvasElement} */
// var getSharedCanvas = function() {
// 	if (_sharedCanvas === null) {
// 		_sharedCanvas = document.createElement("canvas");
// 	}
// 	return _sharedCanvas;
// };
// var SVG_NS = "http://www.w3.org/2000/svg";
// var XLINK_NS = "http://www.w3.org/1999/xlink";
//
// var useIdSeed = 0
// var createSVGUseElement = function() {
// 	var svgEl = document.createElementNS(SVG_NS, "use");
// 	svgEl.setAttributeNS(null, "id", name + (useIdSeed++));
// 	svgEl.setAttributeNS(null, "class", [name, "symbol"].join(" "));
// 	svgEl.setAttributeNS(XLINK_NS, "xlink:href", "#" + name);
// 	return svgEl;
// };
// function logAttachInfo(view, name, level) {
// 	if (["log", "info", "warn", "error"].indexOf(level) != -1) {
// 		level = "log";
// 	}
// 	console[level].call(console, "%s::%s [parent:%s %s %s depth:%s]", view.cid, name, view.parentView && view.parentView.cid, view.attached ? "attached" : "detached", view._viewPhase, view.viewDepth);
// }

/**
 * @constructor
 * @type {module:app/view/render/PlayableRenderer}
 */

var PlayableRenderer = MediaRenderer.extend({
  /** @type {string} */
  cidPrefix: "playableRenderer",

  /** @type {string|Function} */
  className: MediaRenderer.prototype.className + " playable-item",
  properties: {
    mediaPaused: {
      /** @return {Boolean} */
      get: function get() {
        return this._isMediaPaused();
      }
    },
    mediaWaiting: {
      /** @return {Boolean} */
      get: function get() {
        return this._isMediaWaiting();
      }
    },
    playbackRequested: {
      /** @return {Boolean} */
      get: function get() {
        return this._playbackRequested;
      },
      set: function set(value) {
        this._setPlaybackRequested(value);
      }
    },
    overlay: {
      /** @return {HTMLElement} */
      get: function get() {
        return this._overlay || (this._overlay = this.el.querySelector(".overlay"));
      }
    },
    // playToggle: {
    // 	/** @return {HTMLElement} */
    // 	get: function() {
    // 		return this._playToggle || (this._playToggle = this.el.querySelector(".play-toggle"));
    // 	}
    // },
    // playToggleSymbol: {
    // 	/** @return {HTMLElement} */
    // 	get: function() {
    // 		return this._playToggleSymbol || (this._playToggleSymbol = this.el.querySelector(".play-toggle-symbol"));
    // 	}
    // },
    playToggleHitarea: {
      /** @return {HTMLElement} */
      get: function get() {
        return this._playToggleHitarea || (this._playToggleHitarea = this.el.querySelector(".play-toggle-hitarea"));
      }
    }
  },

  /** @override */
  initialize: function initialize(opts) {
    this._playToggleSymbol = {}; // this._toggleWaiting = _.debounce(this._toggleWaiting, 500);
    // this._toggleWaiting = _.throttle(this._toggleWaiting, WAIT_DEBOUNCE_MS, { leading: true, trailing: true });

    _.bindAll(this, "_onPlaybackToggle", "_onVisibilityChange");

    MediaRenderer.prototype.initialize.apply(this, arguments);

    this._setPlaybackRequested(this._playbackRequested); // this.listenTo(this, "view:parentChange", function(childView, newParent, oldParent) {
    // 	// logAttachInfo(this, "[view:parentChange]", "info");
    // 	console.info("%s::[view:parentChange] '%s' to '%s'", this.cid, oldParent && oldParent.cid, newParent && newParent.cid);
    // });

  },
  // /** @override */
  // initializeAsync: function() {
  // 	return MediaRenderer.prototype.initialize.initializeAsync.apply(this, arguments);
  // },
  // /** @override */
  // remove: function() {
  // 	MediaRenderer.prototype.remove.apply(this, arguments);
  // 	return this;
  // },

  /* --------------------------- *
  /* children/layout
  /* --------------------------- */
  // createChildren: function() {
  // },

  /* --------------------------- *
  /* setEnabled
  /* --------------------------- */

  /** @override */
  setEnabled: function setEnabled(enabled) {
    MediaRenderer.prototype.setEnabled.apply(this, arguments); // this._validatePlayback(enabled);
    // if (enabled) {

    this._validatePlayback(); // } else {
    // 	// if selected, pause media
    // 	this.model.selected && this._togglePlayback(false);
    // 	// this._togglePlayback(false);
    // }
    // console.log("%s::setEnabled", this.cid, this.enabled);
    // this._playToggleSymbol.paused = (this.enabled && this.model.selected);
    //}

  },

  /* ---------------------------
  /* selection handlers
  /* --------------------------- */
  listenToSelection: function listenToSelection() {
    if (this._viewPhase != "initialized") throw new Error(this.cid + "::listenToSelection called while " + this._viewPhase); // logAttachInfo(this, "listenToSelection", "log");
    // this.listenTo(this, "view:removed", this.removeSelectionListeners);

    this.listenTo(this.model, "selected", this._onModelSelected);
    this.listenTo(this.model, "deselected", this._onModelDeselected);

    if (this.model.selected) {
      this._onModelSelected();
    }
  },

  /* model selected handlers:
  /* model selection toggles playback
  /* --------------------------- */
  _onModelSelected: function _onModelSelected() {
    console.log("%s::_onModelSelected _playbackRequested: %s, event: %s", this.cid, this._playbackRequested, this._toggleEvent);
    this.listenTo(this, "view:parentChange", this._onParentChange);
    if (this.parentView) this._onParentChange(this, this.parentView, null); // this.enabled = true;

    this._playToggleSymbol.paused = !this.enabled;

    this._listenWhileSelected();

    this._validatePlayback();
  },
  _onModelDeselected: function _onModelDeselected() {
    console.log("%s::_onModelDeselected _playbackRequested: %s, event: %s", this.cid, this._playbackRequested, this._toggleEvent);
    this.stopListening(this, "view:parentChange", this._onParentChange);
    if (this.parentView) this._onParentChange(this, null, this.parentView);
    this._playToggleSymbol.paused = true;

    this._stopListeningWhileSelected();

    this._validatePlayback(false); // this._togglePlayback(false);

  },

  /* view:parentChange handlers 3
  /* --------------------------- */
  _onParentChange: function _onParentChange(childView, newParent, oldParent) {
    // console.log("[scroll] %s::_onParentChange '%s' to '%s'", this.cid, oldParent && oldParent.cid, newParent && newParent.cid);
    if (oldParent) this.stopListening(oldParent, "view:scrollstart view:scrollend", this._onScrollChange);
    if (newParent) this.listenTo(newParent, "view:scrollstart view:scrollend", this._onScrollChange);
  },
  _onScrollChange: function _onScrollChange() {
    if (this.parentView === null) {
      throw new Error(this.cid + "::_onScrollChange parentView is null");
    }

    this._validatePlayback();
  },

  /* visibility dom event
  /* --------------------------- */
  _onVisibilityChange: function _onVisibilityChange(ev) {
    this._validatePlayback();
  },

  /* listen to DOM events
   * --------------------------- */
  _listenWhileSelected: function _listenWhileSelected() {
    this.listenTo(this, "view:removed", this._stopListeningWhileSelected);
    document.addEventListener(visibilityChangeEvent, this._onVisibilityChange, false);
    this.playToggleHitarea.addEventListener(this._toggleEvent, this._onPlaybackToggle, false);
  },
  _stopListeningWhileSelected: function _stopListeningWhileSelected() {
    this.stopListening(this, "view:removed", this._stopListeningWhileSelected);
    document.removeEventListener(visibilityChangeEvent, this._onVisibilityChange, false);
    this.playToggleHitarea.removeEventListener(this._toggleEvent, this._onPlaybackToggle, false);
  },

  /* --------------------------- *
  /* play-toggle
  /* --------------------------- */

  /** @type {String} */
  _toggleEvent: MediaRenderer.CLICK_EVENT,
  //window.hasOwnProperty("onpointerup") ? "pointerup" : "mouseup",
  _onPlaybackToggle: function _onPlaybackToggle(ev) {
    //console.log("%s[%sabled]::_onPlaybackToggle[%s] defaultPrevented: %s", this.cid, this.enabled ? "en" : "dis", ev.type, ev.defaultPrevented);
    // NOTE: Perform action if MouseEvent.button is 0 or undefined (0: left-button)
    if (this.enabled && !ev.defaultPrevented && !ev.button) {
      ev.preventDefault();
      this.playbackRequested = !this.playbackRequested;
    }
  },

  /* --------------------------- *
  /* playbackRequested
  /* --------------------------- */
  _playbackCount: 0,

  /** @type {Boolean?} */
  _playbackRequested: null,
  _setPlaybackRequested: function _setPlaybackRequested(value) {
    this._playbackRequested = value;
    var classList = this.content.classList;
    classList.toggle("playing", value === true);
    classList.toggle("paused", value === false);
    classList.toggle("requested", value === true || value === false);

    this._renderPlaybackState(); // this._validatePlayback(this.playbackRequested);
    // if (this.playbackRequested) {


    this._validatePlayback(); // } else {
    // 	this._togglePlayback(false);
    // }

  },

  /* --------------------------- *
  /* _togglePlayback
  /* --------------------------- */

  /** @param {Boolean} */
  _togglePlayback: function _togglePlayback(newPlayState) {
    if (DEBUG) this.__logMessage(["args:", Array.prototype.join.apply(arguments), "paused:", this._isMediaPaused() ? "pause" : "play", "media-state:", this.mediaState].join(" "), "toggle-playback");

    if (_.isBoolean(newPlayState) && newPlayState !== this._isMediaPaused()) {
      return; // requested state is current, do nothing
    } else {
      newPlayState = this._isMediaPaused();
    }

    if (newPlayState) {
      // changing to what?
      // this._playbackCount++;
      this._playMedia();
    } else {
      this._pauseMedia();
    }
    /* NOTE: called from _setPlaybackRequested */
    // this._renderPlaybackState();

  },
  _canResumePlayback: function _canResumePlayback() {
    return !!(this.enabled && this.model.selected && this.playbackRequested && this.mediaState === "ready" && this.attached && this.parentView !== null && !this.parentView.scrolling && document[visibilityStateProp] != "hidden");
  },
  _validatePlayback: function _validatePlayback(shortcircuit) {
    // a 'shortcircuit' boolean argument can be passed, and if false,
    // skip _canResumePlayback and pause playback right away
    if (arguments.length !== 0 && !shortcircuit) {
      this._togglePlayback(false);
    } else {
      this._togglePlayback(this._canResumePlayback());
    }

    this._playToggleSymbol.paused = !(this.attached && this.enabled && this.model.selected);
  },

  /* ---------------------------
  /* _setPlayToggleSymbol
  /* --------------------------- */
  _renderPlaybackState: function _renderPlaybackState() {
    if (!this.attached) {
      return;
    }

    if (this.progressMeter) {
      this.progressMeter.stalled = this._isMediaWaiting();
    } // this._setPlayToggleSymbol("waiting");
    // this.content.classList.toggle("waiting", true);
    // if (!this.content.classList.contains("started")) {
    // 	this._setPlayToggleSymbol("play");
    // } else


    var waiting = !this.parentView.scrolling && this._isMediaWaiting();

    if (this.playbackRequested) {
      if (waiting) {
        this._setPlayToggleSymbol("waiting");
      } else {
        this._setPlayToggleSymbol("play");
      }
    } else {
      if (this.content.classList.contains("started")) {
        this._setPlayToggleSymbol("pause");
      } else {
        this._setPlayToggleSymbol("play");
      }
    }

    var cls = this.content.classList;
    cls.toggle("playing", this.playbackRequested);
    cls.toggle("paused", !this.playbackRequested);
    cls.toggle("waiting", waiting); //console.log("%s::_renderPlaybackState [play: %s] [wait: %s] [symbol: %s]", this.cid, this.playbackRequested, this._isMediaWaiting(), this._playToggleSymbol.symbolName);
  },
  _setPlayToggleSymbol: function _setPlayToggleSymbol(symbolName) {
    //console.log("%s::_setPlayToggleSymbol [enabled: %s] [selected: %s] [symbol: %s]", this.cid, this.enabled, !!(this.model.selected), symbolName);
    // this._playToggleSymbol.paused = !(this.attached && this.enabled && !!(this.model.selected));
    this._playToggleSymbol.symbolName = symbolName;

    if (this.mediaState === "ready") {
      //this._playToggleSymbol.renderFlags) {
      this._playToggleSymbol.renderNow();
    }
  },
  // _playToggleSymbolSvg: null,
  // _playToggleSymbolName: null,
  // _setPlayToggleSymbol_svg: function(symbolName) {
  // 	if (this._playToggleSymbolName !== symbolName) {
  // 		var svgDoc = this.el.querySelector("svg.play-toggle-symbol");
  // 		if (this._playToggleSymbolSvg) {
  // 			svgDoc.removeChild(this._playToggleSymbolSvg);
  // 		}
  // 		var svgSym = document.createElementNS("http://www.w3.org/2000/svg", "use");
  // 		svgSym.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + symbolName);
  // 		svgDoc.appendChild(svgSym);
  // 		svgDoc.setAttributeNS(null, "class", symbolName + "-symbol play-toggle-symbol");
  //
  // 		this._playToggleSymbolSvg = svgSym;
  // 		this._playToggleSymbolName = symbolName;
  // 	}
  // },

  /* --------------------------- *
  /* waiting
  /* --------------------------- */
  _isWaiting: false,
  _isMediaWaiting: function _isMediaWaiting() {
    return this._isWaiting;
  },
  _toggleWaiting: function _toggleWaiting(waiting) {
    if (arguments.length === 0) {
      waiting = !this._isWaiting;
    } // if (this._isMediaPaused()) {
    // 	waiting = false;
    // }


    if (this._isWaiting !== waiting) {
      this._isWaiting = waiting;

      this._renderPlaybackState();
    }
  },

  /* --------------------------- *
  /* abstract
  /* --------------------------- */
  _isMediaPaused: function _isMediaPaused() {
    console.warn("%s::_isMediaPaused Not implemented", this.cid);
    return true;
  },
  _playMedia: function _playMedia() {
    console.warn("%s::_playMedia Not implemented", this.cid);
  },
  _pauseMedia: function _pauseMedia() {
    console.warn("%s::_pauseMedia Not implemented", this.cid);
  },

  /* --------------------------- *
  /* util
  /* --------------------------- */
  updateOverlay: function updateOverlay(mediaEl, targetEl, rectEl) {// this method is not critical, just catch and log all errors
    // try {
    // 	this._updateOverlay(mediaEl, targetEl, rectEl)
    // } catch (err) {
    // 	console.error("%s::updateOverlay", this.cid, err);
    // }
  }
  /**\/
  _drawMediaElement: function(ctx, mediaEl, dest) {
  	// destination rect
  	// NOTE: mediaEl is expected to have the same dimensions in this.metrics.media
  	mediaEl || (mediaEl = this.defaultImage);
  	dest || (dest = {
  		x: 0,
  		y: 0,
  		width: this.metrics.media.width,
  		height: this.metrics.media.height
  	});
  		// native/display scale
  	var sW = this.model.get("source").get("w"),
  		sH = this.model.get("source").get("h"),
  		rsX = sW / this.metrics.media.width,
  		rsY = sH / this.metrics.media.height;
  		// dest, scaled to native
  	var src = {
  		x: Math.max(0, dest.x * rsX),
  		y: Math.max(0, dest.y * rsY),
  		width: Math.min(sW, dest.width * rsX),
  		height: Math.min(sH, dest.height * rsY)
  	};
  		// resize canvas
  	// var canvas = ctx.canvas;
  	// if (canvas.width !== dest.width || canvas.height !== dest.height) {
  	// 	canvas.width = dest.width;
  	// 	canvas.height = dest.height;
  	// }
  	ctx.canvas.width = dest.width;
  	ctx.canvas.height = dest.height;
  		// copy image to canvas
  	ctx.clearRect(0, 0, dest.width, dest.height);
  	ctx.drawImage(mediaEl,
  		src.x, src.y, src.width, src.height,
  		0, 0, dest.width, dest.height // destination rect
  	);
  		return ctx;
  },
  	_getImageData: function(mediaEl, targetEl, rectEl) {
  	// src/dest rects
  	// ------------------------------
  	rectEl || (rectEl = targetEl);
  		// NOTE: does not work with svg element
  	// var tRect = rectEl.getBoundingClientRect();
  	// var cRect = mediaEl.getBoundingClientRect();
  	// var tX = tRect.x - cRect.x,
  	// 	tY = tRect.y - cRect.y,
  	// 	tW = tRect.width,
  	// 	tH = tRect.height;
  		// target bounds
  	var tX = rectEl.offsetLeft,
  		tY = rectEl.offsetTop,
  		tW = rectEl.offsetWidth,
  		tH = rectEl.offsetHeight;
  		if (tX === void 0 || tY === void 0 || tW === void 0 || tH === void 0) {
  		return;
  	}
  		// destination rect
  	var RECT_GROW = 0;
  	var dest = {
  		x: tX - RECT_GROW,
  		y: tY - RECT_GROW,
  		width: tW + RECT_GROW * 2,
  		height: tH + RECT_GROW * 2
  	};
  		// native/display scale
  	var sW = this.model.get("source").get("w"),
  		sH = this.model.get("source").get("h"),
  		rsX = sW / this.metrics.media.width,
  		rsY = sH / this.metrics.media.height;
  		// dest, scaled to native
  	var src = {
  		x: Math.max(0, dest.x * rsX),
  		y: Math.max(0, dest.y * rsY),
  		width: Math.min(sW, dest.width * rsX),
  		height: Math.min(sH, dest.height * rsY)
  	};
  		// Copy image to canvas
  	// ------------------------------
  	// canvas = document.createElement("canvas");
  	// canvas.style.width  = dest.width + "px";
  	// canvas.style.height = dest.height + "px";
  		var canvas = getSharedCanvas();
  	if (canvas.width !== dest.width || canvas.height !== dest.height) {
  		canvas.width = dest.width;
  		canvas.height = dest.height;
  	}
  	var ctx = canvas.getContext("2d");
  	ctx.clearRect(0, 0, dest.width, dest.height);
  	ctx.drawImage(mediaEl,
  		src.x, src.y, src.width, src.height,
  		0, 0, dest.width, dest.height // destination rect
  	);
  	return ctx.getImageData(0, 0, dest.width, dest.height);
  },
  	_updateOverlay: function(mediaEl, targetEl, rectEl) {
  	var canvas, ctx;
  	var imageData = this._getImageData(mediaEl, targetEl, rectEl);
  	var avgColor = Color().rgb(getAverageRGB(imageData));
  		// var avgHex = avgColor.hex().string(), els = this.el.querySelectorAll("img, video");
  	// for (var i = 0; i < els.length; i++) {
  	// 	els.item(i).style.backgroundColor = avgHex;
  	// }
  		targetEl.classList.toggle("over-dark", avgColor.dark());
  		// console.log("%s::updateOverlay() avgColor:%s (%s)", this.cid, avgColor.rgb().string(), avgColor.dark()?"dark":"light", targetEl);
  		// Color, filter opts
  	// ------------------------------
  		this.fgColor || (this.fgColor = new Color(this.model.attr("color")));
  	this.bgColor || (this.bgColor = new Color(this.model.attr("background-color")));
  		var opts = { radius: 20 };
  	var isFgDark = this.fgColor.luminosity() < this.bgColor.luminosity();
  	opts.x00 = isFgDark ? Color(this.fgColor).lighten(0.5) : Color(this.bgColor).darken(0.5);
  	opts.xFF = isFgDark ? Color(this.bgColor).lighten(0.5) : Color(this.fgColor).darken(0.5);
  		stackBlurRGB(imageData, { radius: 40 });
  	// stackBlurMono(imageData, opts);
  	// duotone(imageData, opts);
  		ctx = getSharedCanvas();
  	if (canvas.width !== imageData.width || canvas.height !== imageData.height) {
  		canvas.width = imageData.width;
  		canvas.height = imageData.height;
  	}
  	ctx = canvas.getContext("2d");
  	ctx.putImageData(imageData, 0, 0);
  	targetEl.style.backgroundOrigin = "border-box";
  	targetEl.style.backgroundClip = "content-box";
  	targetEl.style.backgroundSize = "100%";
  	// targetEl.style.padding = "0 0 5rem 0";
  	targetEl.style.backgroundImage = "url(" + canvas.toDataURL() + ")";
  } /**/

});
/* ---------------------------
/* Google Analytics
/* --------------------------- */

if (window.GA_ENABLED) {
  PlayableRenderer = function (PlayableRenderer) {
    /** @type {module:underscore.strings/dasherize} */
    var dasherize = require("underscore.string/dasherize"); // var readyEvents = ["playing", "waiting", "ended"];
    // var userEvents = ["play", "pause"];


    return PlayableRenderer.extend({
      /** @override */
      initialize: function initialize() {
        var retval = PlayableRenderer.prototype.initialize.apply(this, arguments);
        this._gaEventSuffix = this.playbackRequested ? "-autoplay" : "";
        return retval;
      },

      /** @override */
      _onPlaybackToggle: function _onPlaybackToggle(ev) {
        var retval = PlayableRenderer.prototype._onPlaybackToggle.apply(this, arguments);

        if (window.ga) {
          window.ga("send", {
            hitType: "event",
            eventCategory: dasherize(this.cidPrefix),
            eventAction: (this.playbackRequested ? "play" : "pause") + this._gaEventSuffix,
            eventLabel: this.model.get("text")
          });
        } else {
          console.warn("%s::_onPlaybackToggle window.ga is %s", this.cid, window.ga);
        }

        return retval;
      } // /** @override */
      // _togglePlayback: function(newPlayState) {
      // 	var retval = PlayableRenderer.prototype._togglePlayback.apply(this, arguments);
      // 	window.ga("send", {
      // 		hitType: "event",
      // 		eventCategory: "Playable",
      // 		eventAction: this.playbackRequested ? "play" : "pause",
      // 		eventLabel: this.model.get("text"),
      // 	});
      // 	return retval;
      // },

    });
  }(PlayableRenderer);
} // if (DEBUG) {
// 	PlayableRenderer.prototype._logFlags = "";
//
// 	PlayableRenderer = (function(PlayableRenderer) {
// 		if (!PlayableRenderer.LOG_TO_SCREEN) return PlayableRenderer;
//
// 		/** @type {module:underscore.strings/lpad} */
// 		var lpad = require("underscore.string/lpad");
//
// 		return PlayableRenderer.extend({
// 			_canResumePlayback: function() {
// 				var retval = PlayableRenderer.prototype._canResumePlayback.apply(this.arguments);
// 				console.log("[scroll] %s::_canResumePlayback():%s", this.cid, retval, {
// 					"enabled": this.enabled,
// 					"selected": (!!this.model.selected),
// 					"playbackRequested": this.playbackRequested,
// 					"attached": this.attached,
// 					"parentView": (this.parentView && this.parentView.cid),
// 					"!scrolling": (this.parentView && !this.parentView.scrolling),
// 					"mediaState": this.mediaState,
// 					// "!document.hidden": !document[visibilityHiddenProp],
// 					"visibilityState": document[visibilityStateProp]
// 				});
// 				return retval;
// 			},
// 		});
// 	})(PlayableRenderer);
// }


module.exports = PlayableRenderer;

}).call(this,true,require("underscore"))

},{"app/view/render/MediaRenderer":114,"underscore":51,"underscore.string/dasherize":42,"utils/prefixedEvent":145,"utils/prefixedProperty":146}],116:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\"placeholder sizing\"></div>\n<div class=\"content\">\n	<div class=\"media-border content-size\"></div>\n	<div class=\"controls content-size\">\n		<canvas class=\"progress-meter\"></canvas>\n	</div>\n	<div class=\"sequence media-size\">\n		<img class=\"sequence-step current default\" alt=\""
    + alias4(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"text","hash":{},"data":data}) : helper)))
    + "\" longdesc=\"#desc_m"
    + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\" />\n	</div>\n	<div class=\"overlay media-size play-toggle-hitarea\">\n		<canvas class=\"play-toggle\"/>\n	</div>\n</div>\n";
},"useData":true});

},{"hbsfy/runtime":35}],117:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/**
 * @module app/view/render/SequenceRenderer
 */

/* --------------------------- *
 * Imports
 * --------------------------- */

/** @type {module:backbone.babysitter} */

var Container = require("backbone.babysitter");
/** @type {module:app/view/base/View} */


var View = require("app/view/base/View");
/** @type {module:app/view/render/PlayableRenderer} */


var PlayableRenderer = require("app/view/render/PlayableRenderer"); // /** @type {module:app/model/SelectableCollection} */
// var SelectableCollection = require("app/model/SelectableCollection");

/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals");
/** @type {module:app/view/component/CanvasProgressMeter} */


var ProgressMeter = require("app/view/component/CanvasProgressMeter");
/** @type {module:app/view/component/PlayToggleSymbol} */


var PlayToggleSymbol = require("app/view/component/PlayToggleSymbol");
/** @type {module:utils/Timer} */


var Timer = require("utils/Timer"); // /** @type {Function} */
// var transitionEnd = require("utils/event/transitionEnd");
// /** @type {module:utils/prefixedProperty} */
// var prefixed = require("utils/prefixedProperty");

/** @type {Function} */


var _whenImageLoads = require("app/view/promise/_whenImageLoads");
/** @type {module:app/view/promise/_loadImageAsObjectURL} */


var _loadImageAsObjectURL = require("app/view/promise/_loadImageAsObjectURL"); // /** @type {Function} */
// var whenSelectionDistanceIs = require("app/view/promise/whenSelectionDistanceIs");
// var whenSelectTransitionEnds = require("app/view/promise/whenSelectTransitionEnds");
// var whenDefaultImageLoads = require("app/view/promise/whenDefaultImageLoads");
// /** @type {Function} */
// var Color = require("color");
// var duotone = require("utils/canvas/bitmap/duotone");
// var stackBlurRGB = require("utils/canvas/bitmap/stackBlurRGB");
// var stackBlurMono = require("utils/canvas/bitmap/stackBlurMono");
// var getAverageRGBA = require("utils/canvas/bitmap/getAverageRGBA");


var errorTemplate = require("../template/ErrorBlock.hbs");

var MIN_STEP_INTERVAL = 2 * Globals.TRANSITION_DURATION + Globals.TRANSITION_DELAY_INTERVAL;
var DEFAULT_STEP_INTERVAL = 6 * Globals.TRANSITION_DURATION + Globals.TRANSITION_DELAY_INTERVAL;
/* --------------------------- *
 * Private classes
 * --------------------------- */

/**
 * @constructor
 * @type {module:app/view/render/SequenceRenderer.PrefetechedSourceRenderer}
 */

var PrefetechedSourceRenderer = View.extend({
  cidPrefix: "sequenceStepRenderer",

  /** @type {string} */
  className: "sequence-step",

  /** @type {string} */
  tagName: "img",
  properties: {
    ready: {
      get: function get() {
        return this._ready;
      }
    }
  },

  /** @override */
  initialize: function initialize(opts) {
    !this.el.hasAttribute("alt") && this.el.setAttribute("alt", this.model.get("src")); // this.el.setAttribute("longdesc", this.model.get("original"));

    if (this.model.has("prefetched")) {
      this._renderPrefetched();
    } else {
      this.listenTo(this.model, "change:prefetched", this._renderPrefetched);
    }

    this.listenTo(this.model, "selected deselected", this._renderSelection);

    this._renderSelection();
  },
  _renderSelection: function _renderSelection() {
    this.el.classList.toggle("current", !!this.model.selected);
  },
  _renderPrefetched: function _renderPrefetched() {
    var prefetched = this.model.get("prefetched");

    if (prefetched !== this.el.src) {
      this.el.src = prefetched;
    }

    _whenImageLoads(this.el).then(function (el) {
      this.requestAnimationFrame(function (tstamp) {
        this._setReady(true);
      });
    }.bind(this), function (err) {
      // this._setReady(false);
      err instanceof Error || (err = new Error("cannot load prefetched url"));
      throw err;
    }.bind(this));
  },

  /** @type {boolean} */
  _ready: false,
  _setReady: function _setReady(ready) {
    if (this._ready !== ready) {
      this._ready = !!ready; // make bool

      this.trigger("renderer:ready", this);
    }
  },
  render: function render() {
    // if (this.model.has("prefetched")) {
    // 	this._renderPrefetched();
    // }
    // this.el.classList.toggle("current", !!this.model.selected);
    console.log("%s::render", this.cid);
    return this;
  }
});
/**
 * @constructor
 * @type {module:app/view/render/SequenceRenderer.SimpleSourceRenderer}
 */
// var SimpleSourceRenderer = View.extend({
//
// 	cidPrefix: "sequenceStepRenderer",
// 	/** @type {string} */
// 	className: "sequence-step",
// 	/** @type {string} */
// 	tagName: "img",
//
// 	/** @override */
// 	initialize: function (options) {
// 		// this.el.classList.toggle("current", this.model.hasOwnProperty("selected"));
// 		this.el.classList.toggle("current", !!this.model.selected);
// 		this.listenTo(this.model, {
// 			"selected": function () {
// 				this.el.classList.add("current");
// 			},
// 			"deselected": function () {
// 				this.el.classList.remove("current");
// 			}
// 		});
// 		if (this.el.src === "") {
// 			this.el.src = Globals.MEDIA_DIR + "/" + this.model.get("src");
// 		}
//
// 		if (this.model.has("error")) {
// 			this._onModelError();
// 		} else {
// 			this.listenToOnce(this.model, "change:error", this._onModelError);
// 			// this.listenToOnce(this.model, {
// 			// 	"change:source": this._onModelSource,
// 			// 	"change:error": this._onModelError,
// 			// });
// 		}
// 	},
//
// 	// _onModelSource: function() {
// 	// 	this.el.src = Globals.MEDIA_DIR + "/" + this.model.get("src");
// 	// 	// console.log("%s::change:src", this.cid, this.model.get("src"));
// 	// },
//
// 	_onModelError: function() {
// 		var err = this.model.get("error");
// 		var errEl = document.createElement("div");
// 		errEl.className = "error color-bg" + (this.model.selected? " current" : "");
// 		errEl.innerHTML = errorTemplate(err);
// 		this.setElement(errEl, true);
// 		console.log("%s::change:error", this.cid, err.message, err.infoSrc);
// 	},
// });

var SourceErrorRenderer = View.extend({
  /** @type {string} */
  className: "sequence-step error",

  /** @override */
  cidPrefix: "sourceErrorRenderer",

  /** @override */
  template: errorTemplate,

  /** @type {boolean} */
  ready: true,
  initialize: function initialize(opts) {
    // var handleSelectionChange = function onSelectionChange () {
    // 	this.el.classList.toggle("current", !!this.model.selected);
    // };
    // this.listenTo(this.model, "selected deselected", handleSelectionChange);
    // // this.el.classList.toggle("current", !!this.model.selected);
    // handleSelectionChange.call(this);
    this.listenTo(this.model, "selected deselected", function () {
      this.el.classList.toggle("current", !!this.model.selected);
    });
  },
  render: function render() {
    this.el.classList.toggle("current", !!this.model.selected);
    this.el.innerHTML = this.template(this.model.get("error"));
    return this;
  }
});
var SequenceStepRenderer = PrefetechedSourceRenderer; // var SequenceStepRenderer = SimpleSourceRenderer;

/**
 * @constructor
 * @type {module:app/view/render/SequenceRenderer}
 */

var SequenceRenderer = PlayableRenderer.extend({
  /** @type {string} */
  cidPrefix: "sequenceRenderer",

  /** @type {string} */
  className: PlayableRenderer.prototype.className + " sequence-item",

  /** @type {Function} */
  template: require("./SequenceRenderer.hbs"),

  /* --------------------------- *
  /* initialize
  /* --------------------------- */
  initialize: function initialize(opts) {
    this.sources = this.model.get("sources");
    PlayableRenderer.prototype.initialize.apply(this, arguments);
  },

  /* --------------------------- *
   * children
   * --------------------------- */

  /** @override */
  createChildren: function createChildren() {
    PlayableRenderer.prototype.createChildren.apply(this, arguments);
    this.placeholder = this.el.querySelector(".placeholder");
    this.sequence = this.content.querySelector(".sequence"); // styles
    // ---------------------------------

    var s,
        attrs = this.model.attrs(); // var s, attrs = this.model.get("attrs");

    s = _.pick(attrs, "box-shadow", "border", "border-radius");

    _.extend(this.content.querySelector(".media-border").style, s);

    s = _.pick(attrs, "border-radius");

    _.extend(this.sequence.style, s);

    _.extend(this.placeholder.style, s); // model
    // ---------------------------------


    this.sources.select(this.model.get("source")); // itemViews
    // ---------------------------------

    this.itemViews = new Container(); // add default image as renderer (already in DOM)

    this.itemViews.add(new SequenceStepRenderer({
      el: this.getDefaultImage(),
      model: this.model.get("source")
    }));
  },

  /* --------------------------- *
   * layout/render
   * --------------------------- */

  /** @override */
  render: function render() {
    PlayableRenderer.prototype.render.apply(this, arguments);
    var els, el, i, cssW, cssH;
    var content = this.content; // media-size
    // ---------------------------------

    cssW = this.metrics.media.width + "px";
    cssH = this.metrics.media.height + "px";
    els = this.el.querySelectorAll(".media-size");

    for (i = 0; i < els.length; i++) {
      el = els.item(i);
      el.style.width = cssW;
      el.style.height = cssH;
    }

    content.style.width = cssW;
    content.style.height = cssH; // content-position
    // ---------------------------------

    var cssX, cssY;
    cssX = this.metrics.content.x + "px";
    cssY = this.metrics.content.y + "px";
    content.style.left = cssX;
    content.style.top = cssY;
    el = this.el.querySelector(".controls"); // el.style.left = cssX;
    // el.style.top = cssY;

    el.style.width = this.metrics.content.width + "px";
    el.style.height = this.metrics.content.height + "px"; // // content-size
    // // ---------------------------------
    // cssW = this.metrics.content.width + "px";
    // cssH = this.metrics.content.height + "px";
    //
    // els = this.el.querySelectorAll(".content-size");
    // for (i = 0; i < els.length; i++) {
    // 	el = els.item(i);
    // 	el.style.width = cssW;
    // 	el.style.height = cssH;
    // }

    return this;
  },

  /* --------------------------- *
   * initializeAsync
   * --------------------------- */
  initializePlayable: function initializePlayable() {
    // model
    // ---------------------------------
    // this.sources.select(this.model.get("source"));
    this.content.classList.add("started"); // Sequence model
    // ---------------------------------

    PlayableRenderer.whenSelectionDistanceIs(this, 0) // .then(function(view) {
    // 	/* defaultImage is loaded, add `started` rightaway */
    // 	view.content.classList.add("started");
    // 	return view;
    // })
    .then(this._preloadAllItems, function (err) {
      return err instanceof View.ViewError ? void 0 : err; // Ignore ViewError
    });
    this._sequenceInterval = Math.max(parseInt(this.model.attr("@sequence-interval")), MIN_STEP_INTERVAL) || DEFAULT_STEP_INTERVAL; // timer
    // ---------------------------------

    /* timer will be started when _validatePlayback is called from _onModelSelected */

    this.timer = new Timer();
    this.listenTo(this, "view:removed", function () {
      this.timer.stop();
      this.stopListening(this.timer);
    });
    this.listenTo(this.timer, {
      "start": this._onTimerStart,
      "resume": this._onTimerResume,
      "pause": this._onTimerPause,
      "end": this._onTimerEnd // "stop": function () {}, // stop is only called on view remove

    }); // play-toggle-symbol
    // ---------------------------------

    this._playToggleSymbol = new PlayToggleSymbol(_.extend({
      el: this.el.querySelector(".play-toggle")
    }, this._playToggleSymbol || {})); // progress-meter model
    // ---------------------------------

    this._sourceProgressByIdx = this.sources.map(function () {
      return 0;
    });
    this._sourceProgressByIdx[0] = 1; // first item is already loaded
    // progress-meter
    // ---------------------------------

    this.progressMeter = new ProgressMeter({
      el: this.el.querySelector(".progress-meter"),
      color: this.model.attr("color"),
      // backgroundColor: this.model.attr("background-color"),
      values: {
        available: this._sourceProgressByIdx.concat()
      },
      maxValues: {
        amount: this.sources.length,
        available: this.sources.length
      },
      labelFn: function () {
        if (this.playbackRequested === false) return Globals.PAUSE_CHAR;
        return this.sources.selectedIndex + 1 + "/" + this.sources.length;
      }.bind(this)
    }); // this.el.querySelector(".top-bar")
    //		.appendChild(this.progressMeter.render().el);
  },
  initializeAsync: function initializeAsync() {
    return PlayableRenderer.prototype.initializeAsync.apply(this, arguments).then(function (view) {
      return view.whenAttached();
    }).then(function (view) {
      view.initializePlayable(); // view.updateOverlay(view.defaultImage, view.playToggle); //view.overlay);

      view.listenToSelection();
      return view;
    });
  },
  whenInitialized: function whenInitialized(view) {
    var retval = PlayableRenderer.prototype.whenInitialized.apply(this, arguments);

    view._validatePlayback();

    return retval;
  },

  /* --------------------------- *
   * _preloadAllItems
   * --------------------------- */
  _preloadAllItems: function _preloadAllItems(view) {
    view.once("view:remove", function () {
      var silent = {
        silent: true
      };
      view.sources.forEach(function (item, index, sources) {
        // view.stopListening(item, "change:progress");
        var prefetched = item.get("prefetched");

        if (prefetched && /^blob\:/.test(prefetched)) {
          item.set("progress", 0, silent);
          item.unset("prefetched", silent);
          URL.revokeObjectURL(prefetched);
        }
      });
    });
    return view.sources.reduce(function (lastPromise, item, index, sources) {
      return lastPromise.then(function (view) {
        if (view._viewPhase === "disposed") {
          /** do nothing */
          return view;
        } else if (item.has("prefetched")) {
          view._updateItemProgress(1, index);

          return view;
        } else {
          var onItemProgress = function onItemProgress(item, progress) {
            view._updateItemProgress(progress, index);
          };

          view.listenTo(item, "change:progress", onItemProgress);
          view.once("view:remove", function (view) {
            view.stopListening(item, "change:progress", onItemProgress);
          });
          return _loadImageAsObjectURL(item.get("original"), function (progress, request) {
            /* NOTE: Since we are calling URL.revokeObjectURL when view is removed, also abort incomplete requests. Otherwise, clear the callback reference from XMLHttpRequest.onprogress  */
            if (view._viewPhase === "disposed") {
              //console.warn("%s::_preloadAllItems aborting XHR [%s %s] (%s)", view.cid, request.status, request.readyState, item.get("original"), request);
              request.abort(); // request.onprogress = void 0;
            } else {
              item.set("progress", progress);
            }
          }).then(function (pUrl) {
            item.set({
              "progress": pUrl ? 1 : 0,
              "prefetched": pUrl
            });
            return view;
          }, function (err) {
            item.set({
              "progress": 0,
              "error": err
            });
            return view;
          });
        }
      });
    }, Promise.resolve(view));
  },
  // _preloadAllItems2: function(view) {
  // 	return view.sources.reduce(function(lastPromise, item, index, sources) {
  // 		return lastPromise.then(function(view) {
  // 			var itemView = view._getItemView(item);
  // 			return _whenImageLoads(itemView.el).then(function(url){
  // 				view._updateItemProgress(1, index);
  // 				return view;
  // 			}, function(err) {
  // 				view._updateItemProgress(0, index);
  // 				item.set("error", err);
  // 				return view;
  // 			});
  // 		});
  // 	}, Promise.resolve(view));
  // },
  _updateItemProgress: function _updateItemProgress(progress, index) {
    this._sourceProgressByIdx[index] = progress;

    if (this.progressMeter) {
      this.progressMeter.valueTo("available", this._sourceProgressByIdx, 300);
    }
  },

  /* ---------------------------
   * PlayableRenderer implementation
   * --------------------------- */

  /** @override initial value */
  _playbackRequested: true,

  /** @type {Boolean} internal store */
  _paused: true,

  /** @override */
  _isMediaPaused: function _isMediaPaused() {
    return this._paused;
  },

  /** @override */
  _playMedia: function _playMedia() {
    if (!this._paused) return;
    this._paused = false;

    if (!this._isMediaWaiting()) {
      if (this.timer.status === Timer.PAUSED) {
        this.timer.start(); // resume, actually
      } else {
        this.timer.start(this._sequenceInterval);
      }
    }
  },

  /** @override */
  _pauseMedia: function _pauseMedia() {
    if (this._paused) return;
    this._paused = true;

    if (this.timer.status === Timer.STARTED) {
      this.timer.pause();
    }
  },
  // /** @override */
  // _renderPlaybackState: function() {
  // 	// if (!this.content.classList.contains("started")) {
  // 	// 	this.content.classList.add("started");
  // 	// }
  // 	PlayableRenderer.prototype._renderPlaybackState.apply(this, arguments);
  // },

  /* --------------------------- *
  /* sequence private
  /* --------------------------- */
  _onTimerStart: function _onTimerStart(duration) {
    var item;

    if (this.sources.selectedIndex === -1) {
      item = this.model.get("source");
    } else {
      item = this.sources.followingOrFirst();
    }

    this.sources.select(item);
    this.progressMeter.valueTo("amount", this.sources.selectedIndex + 1, duration);
    this.content.classList.toggle("playback-error", item.has("error")); // var currView = this.itemViews.findByModel(item);
    // if (!item.has("error") && currView !== null) {
    // 	this._playToggleSymbol.setImageSource(currView.el);
    // 	// this.updateOverlay(currView.el, this.playToggle);
    // } else {
    // 	this._playToggleSymbol.setImageSource(null);
    // }
    // // init next renderer now to have smoother transitions
    // this._getItemView(this.sources.followingOrFirst());
  },
  _onTimerResume: function _onTimerResume(duration) {
    this.progressMeter.valueTo("amount", this.sources.selectedIndex + 1, duration);
  },
  _onTimerPause: function _onTimerPause(duration) {
    this.progressMeter.valueTo("amount", this.progressMeter.getRenderedValue("amount"), 0);
  },

  /* last completely played sequence index */
  // _lastPlayedIndex: -1,
  _onTimerEnd: function _onTimerEnd() {
    var nextItem, nextView;

    var showNextView = function (result) {
      // console.log("%s::showNextView %sms %s", context.cid, context._sequenceInterval, nextItem.cid)
      this.setImmediate(function () {
        if (!this.mediaPaused) {
          this.timer.start(this._sequenceInterval);
        }
      });
      return result;
    }.bind(this); // get next item init next renderer


    nextItem = this.sources.followingOrFirst();
    nextView = this._getItemView(nextItem);

    if (nextItem.has("error")) {
      showNextView();
    } else if (nextItem.has("prefetched")) {
      _whenImageLoads(nextView.el).then(showNextView, showNextView);
    } else {
      /* TODO: add ga event 'media-waiting' */
      // window.ga("send", "event", "sequence-item", "waiting", this.model.get("text"));
      // console.log("%s:[waiting] %sms %s", context.cid, nextItem.cid);
      this._toggleWaiting(true);

      this.listenToOnce(nextItem, "change:prefetched change:error", function (model) {
        // console.log("%s:[playing] %sms %s", context.cid, nextItem.cid);
        this._toggleWaiting(false);

        _whenImageLoads(nextView.el).then(showNextView, showNextView);
      });
    }
  },
  _getItemView: function _getItemView(item) {
    var view = this.itemViews.findByModel(item);

    if (!view) {
      view = new (item.has("error") ? SourceErrorRenderer : SequenceStepRenderer)({
        model: item
      });
      this.itemViews.add(view);
      this.sequence.appendChild(view.render().el);
    }

    return view;
  }
  /* --------------------------- *
  /* progress meter
  /* --------------------------- */
  // _createDefaultItemData: function() {
  // 	var canvas = document.createElement("canvas");
  // 	var context = canvas.getContext("2d");
  // 	var imageData = this._drawMediaElement(context).getImageData(0, 0, canvas.width, canvas.height);
  //
  // 	var opts = { radius: 20 };
  // 	var fgColor = new Color(this.model.attr("color"));
  // 	var bgColor = new Color(this.model.attr("background-color"));
  // 	var isFgDark = fgColor.luminosity() < bgColor.luminosity();
  // 	opts.x00 = isFgDark? Color(fgColor).lighten(0.33) : Color(bgColor).darken(0.33);
  // 	opts.xFF = isFgDark? Color(bgColor).lighten(0.33) : Color(fgColor).darken(0.33);
  //
  // 	stackBlurMono(imageData, opts);
  // 	duotone(imageData, opts);
  // 	// stackBlurRGB(imageData, opts);
  //
  // 	context.putImageData(imageData, 0, 0);
  // 	return canvas.toDataURL();
  // },

});

if (DEBUG) {
  SequenceRenderer = function (SequenceRenderer) {
    if (!SequenceRenderer.LOG_TO_SCREEN) return SequenceRenderer; // /** @type {module:underscore.strings/lpad} */
    // var rpad = require("underscore.string/rpad");

    /** @type {module:underscore.strings/lpad} */

    var lpad = require("underscore.string/lpad");
    /** @type {module:underscore.strings/capitalize} */


    var caps = require("underscore.string/capitalize");

    return SequenceRenderer.extend({
      /** @override */
      initialize: function initialize() {
        SequenceRenderer.prototype.initialize.apply(this, arguments);
        this.__logColors = _.extend({
          "media:play": "darkred",
          "media:pause": "darkred",
          "timer:start": "darkgreen",
          "timer:end": "darkgreen",
          "timer:resume": "green",
          "timer:pause": "green",
          "load:progress": "blue",
          "load:complete": "darkblue"
        }, this.__logColors);
      },
      // __getHeaderText: function() {
      // 	var fmt1 = function(s) {
      // 		return lpad(caps(s), 8).substr(0, 8).toUpperCase();
      // 	};
      // 	var fmt2 = function(s) {
      // 		return lpad(caps(s), 8).substr(0, 8).toUpperCase();
      // 	};
      // 	var o = {
      // 		"tstamp": fmt1,
      // 		"index": fmt2,
      // 		"duration": fmt1,
      // 		"playback": fmt1,
      // 		"media": fmt1,
      // 		"timer": fmt1,
      // 		"next": fmt1,
      // 	};
      // 	return Object.keys(o).map(function(s, i, a) {
      // 		return o[s](s);
      // 	}).join(" ");
      // 	// Object.keys(o).reduce(function(ss, s, i, a) {
      // 	// 	return ss + " " + lpad(caps(s), 8).substr(0, 8).toUpperCase();
      // 	// }, "");
      // },
      __getHeaderText: function __getHeaderText() {
        return ["tstamp", "index", "duration", "playback", "media", "timer", "next"].map(function (s, i, a) {
          return lpad(caps(s), 8).substr(0, 8).toUpperCase();
        }).join(" ");
      },
      __logTimerEvent: function __logTimerEvent(evname, msg) {
        var logMsg = [this.sources.selectedIndex, (this.timer.getDuration() * .001).toFixed(3), this.playbackRequested ? ">>" : "::", this.mediaPaused ? "paused" : this.mediaWaiting ? "waiting" : "playing", this.timer.getStatus(), this.sources.followingOrFirst().has("prefetched") ? "ready" : "pending"].map(function (s, i, a) {
          return lpad(s, 8).substr(0, 8).toUpperCase();
        });
        msg && logMsg.push(msg);
        logMsg = logMsg.join(" ");

        this.__logMessage(logMsg, evname); // console.log("%s::[%s] %s", this.cid, evname, logMsg);

      },
      _playMedia: function _playMedia() {
        this.__logTimerEvent("media:play");

        SequenceRenderer.prototype._playMedia.apply(this, arguments); // this.__logTimerEvent("< media:play");
        // console.log("%s::_playMedia()", this.cid);

      },
      _pauseMedia: function _pauseMedia() {
        this.__logTimerEvent("media:pause");

        SequenceRenderer.prototype._pauseMedia.apply(this, arguments); // this.__logTimerEvent("< media:pause");
        // console.log("%s::_pauseMedia()", this.cid);

      },
      _onTimerStart: function _onTimerStart() {
        this.__logTimerEvent("timer:start");

        SequenceRenderer.prototype._onTimerStart.apply(this, arguments);
      },
      _onTimerResume: function _onTimerResume() {
        this.__logTimerEvent("timer:resume");

        SequenceRenderer.prototype._onTimerResume.apply(this, arguments);
      },
      _onTimerPause: function _onTimerPause() {
        this.__logTimerEvent("timer:pause");

        SequenceRenderer.prototype._onTimerPause.apply(this, arguments);
      },
      _onTimerEnd: function _onTimerEnd() {
        this.__logTimerEvent("timer:end");

        SequenceRenderer.prototype._onTimerEnd.apply(this, arguments);
      },
      _updateItemProgress: function _updateItemProgress(progress, srcIdx) {
        if (progress == 1) {
          this.__logTimerEvent("load:complete", "item " + srcIdx + ": complete");
        } else if (srcIdx === this.sources.selectedIndex) {
          this.__logTimerEvent("load:progress", "item " + srcIdx + ": " + progress);
        }

        SequenceRenderer.prototype._updateItemProgress.apply(this, arguments);
      },
      _preloadAllItems: function _preloadAllItems(view) {
        view.__logMessage(view.cid + "::_preloadAllItems", "load:start");

        SequenceRenderer.prototype._preloadAllItems.apply(view, arguments);
      }
    });
  }(SequenceRenderer);
}

module.exports = SequenceRenderer;

}).call(this,true,require("underscore"))

},{"../template/ErrorBlock.hbs":122,"./SequenceRenderer.hbs":116,"app/control/Globals":55,"app/view/base/View":82,"app/view/component/CanvasProgressMeter":87,"app/view/component/PlayToggleSymbol":94,"app/view/promise/_loadImageAsObjectURL":97,"app/view/promise/_whenImageLoads":98,"app/view/render/PlayableRenderer":115,"backbone.babysitter":3,"underscore":51,"underscore.string/capitalize":41,"underscore.string/lpad":47,"utils/Timer":126}],118:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../template/svg/FullscreenSymbol.hbs');
HandlebarsCompiler.registerPartial('../template/svg/FullscreenSymbol.hbs', partial$0);
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper;

  return "<div class=\"placeholder sizing\"></div>\n<div class=\"content media-border\">\n	<div class=\"controls content-size\">\n		<canvas class=\"progress-meter\"></canvas>\n	</div>\n	<div class=\"crop-box media-size\">\n		<video width=\"240\" height=\"180\" muted playsinline></video>\n		<img class=\"poster default\" alt=\""
    + container.escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"text","hash":{},"data":data}) : helper)))
    + "\" width=\"240\" height=\"180\" />\n	</div>\n	<div class=\"overlay media-size play-toggle-hitarea\">\n			<canvas class=\"play-toggle\"></canvas>\n		<a class=\"fullscreen-toggle\" href=\"javascript:(void 0)\">\n"
    + ((stack1 = container.invokePartial(partials["../template/svg/FullscreenSymbol.hbs"],depth0,{"name":"../template/svg/FullscreenSymbol.hbs","data":data,"indent":"\t\t\t","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
    + "		</a>\n	</div>\n</div>\n";
},"usePartial":true,"useData":true});

},{"../template/svg/FullscreenSymbol.hbs":125,"hbsfy/runtime":35}],119:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/*global HTMLMediaElement, MediaError*/

/**
 * @module app/view/render/VideoRenderer
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML5_audio_and_video
 */

/* --------------------------- *
 * Imports
 * --------------------------- */
// /** @type {module:backbone} */
// var Backbone = require("backbone");

/** @type {module:app/control/Globals} */

var Globals = require("app/control/Globals");
/** @type {module:app/view/render/PlayableRenderer} */


var PlayableRenderer = require("app/view/render/PlayableRenderer");
/** @type {module:app/view/component/CanvasProgressMeter} */


var ProgressMeter = require("app/view/component/CanvasProgressMeter"); // /** @type {module:app/view/component/PlayToggleSymbol} */


var PlayToggleSymbol = require("app/view/component/PlayToggleSymbol"); // var stackBlurMono = require("utils/canvas/bitmap/stackBlurMono");
// var stackBlurRGB = require("utils/canvas/bitmap/stackBlurRGB");
// /** @type {module:utils/prefixedStyleName} */
// var prefixedStyleName = require("utils/prefixedStyleName");

/** @type {module:utils/prefixedEvent} */


var prefixedEvent = require("utils/prefixedEvent"); // var whenViewIsAttached = require("app/view/promise/whenViewIsAttached");
// /** @type {Function} */
// var whenSelectionDistanceIs = require("app/view/promise/whenSelectionDistanceIs");

/* --------------------------- *
 * private static
 * --------------------------- */


var fullscreenChangeEvent = prefixedEvent("fullscreenchange", document); // var fullscreenErrorEvent = prefixedEvent("fullscreenerror", document);

var formatTimecode = function formatTimecode(value) {
  if (isNaN(value)) return ""; //value = 0;

  if (value >= 3600) return (value / 3600 | 0) + "H";
  if (value >= 60) return (value / 60 | 0) + "M"; // if (value >= 10) return "0" + (value | 0) + "S";

  return (value | 0) + "S";
};

var VIDEO_CROP_PX = Globals.VIDEO_CROP_PX;
var SYNC_TIMEOUT_MS = 1200;
var SYNC_THRESHOLD_MS = 100;
/**
 * @constructor
 * @type {module:app/view/render/VideoRenderer}
 */

var VideoRenderer = PlayableRenderer.extend({
  /** @type {string} */
  cidPrefix: "videoRenderer",

  /** @type {string} */
  className: PlayableRenderer.prototype.className + " video-item",

  /** @type {Function} */
  template: require("./VideoRenderer.hbs"),
  // events: (function() {
  // 	var ret = {};
  // 	ret[PlayableRenderer.CLICK_EVENT + " .fullscreen-toggle"] = "_onFullscreenToggle";
  // 	return ret;
  // }()),
  // events: function() {
  // 	var events = {};
  // 	events[PlayableRenderer.CLICK_EVENT + " .fullscreen-toggle"] = "_onFullscreenToggle";
  // 	return _.extend(events, _.result(this, PlayableRenderer.prototype.events));
  // },
  // events: {
  // 	"click .fullscreen-toggle": "_onFullscreenToggle",
  // },
  properties: {
    fullscreenToggle: {
      /** @return {HTMLElement} */
      get: function get() {
        return this._fullscreenToggle || (this._fullscreenToggle = this.el.querySelector(".fullscreen-toggle"));
      }
    }
  },

  /** @override */
  initialize: function initialize(opts) {
    PlayableRenderer.prototype.initialize.apply(this, arguments);

    _.bindAll(this, "_updatePlaybackState", "_updateCurrTimeValue", "_updateBufferedValue", "_onMediaError", "_onMediaEnded", // "_onMediaPlayingOnce",
    "_onFullscreenChange", "_onFullscreenToggle");

    _.bindAll(this, "_playbackTimeoutFn_playing", "_playbackTimeoutFn_waiting"); // var onPeerSelect = function() {
    // 	this.content.style.display = (this.getSelectionDistance() > 1)? "none": "";
    // };
    // this.listenTo(this.model.collection, "select:one select:none", onPeerSelect);
    // onPeerSelect();

  },

  /* --------------------------- *
   * children
   * --------------------------- */

  /** @override */
  createChildren: function createChildren() {
    PlayableRenderer.prototype.createChildren.apply(this, arguments);
    this.placeholder = this.el.querySelector(".placeholder"); // this.overlay = this.content.querySelector(".overlay");

    this.video = this.content.querySelector("video"); // this.video.loop = this.model.attrs().hasOwnProperty("@video-loop");
    // this.video.setAttribute("muted", "muted");
    // this.video.setAttribute("playsinline", "playsinline");
    // if (this.model.attr("@video-loop") !== void 0) {
    // 	this.video.setAttribute("loop", "loop");
    // }

    this.video.setAttribute("preload", "none");
    if (this.video.controlList) this.video.controlList.add("nodownload"); // this.video.muted = true;
    // this.video.playsinline = true;
    // this.video.preload = "auto";

    this.video.loop = this.model.attr("@video-loop") !== void 0;
    this.video.src = this.findPlayableSource(this.video);
  },

  /* --------------------------- *
   * layout/render
   * --------------------------- */
  measure: function measure() {
    PlayableRenderer.prototype.measure.apply(this, arguments); // NOTE: Vertical 1px video crop
    // - Cropped in CSS: video, .poster { margin-top: -1px; margin-bottom: -1px;}
    // - Cropped height is adjusted in metrics obj
    // - Crop amount added back to actual video on render()

    this.metrics.media.height += VIDEO_CROP_PX * 2;
    this.metrics.content.height += VIDEO_CROP_PX * 2;
  },

  /** @override */
  render: function render() {
    PlayableRenderer.prototype.render.apply(this, arguments);
    var els, el, i, cssW, cssH;
    var img = this.defaultImage;
    var content = this.content; // media-size
    // ---------------------------------

    cssW = this.metrics.media.width + "px";
    cssH = this.metrics.media.height + "px";
    els = this.el.querySelectorAll(".media-size");

    for (i = 0; i < els.length; i++) {
      el = els.item(i);
      el.style.width = cssW;
      el.style.height = cssH;
    }

    content.style.width = cssW;
    content.style.height = this.metrics.media.height + VIDEO_CROP_PX + "px"; // content-position
    // ---------------------------------

    var cssX, cssY;
    cssX = this.metrics.content.x + "px";
    cssY = this.metrics.content.y + "px";
    content.style.left = cssX;
    content.style.top = cssY;
    el = this.el.querySelector(".controls"); // el.style.left = cssX;
    // controls.style.top = cssY;

    el.style.width = this.metrics.content.width + "px";
    el.style.height = this.metrics.content.height + "px"; // // content-size
    // // ---------------------------------
    // cssW = this.metrics.content.width + "px";
    // cssH = this.metrics.content.height + "px";
    //
    // els = this.el.querySelectorAll(".content-size");
    // for (i = 0; i < els.length; i++) {
    // 	el = els.item(i);
    // 	el.style.width = cssW;
    // 	el.style.height = cssH;
    // }
    // NOTE: elements below must use video's UNCROPPED height, so +2px

    this.video.setAttribute("width", this.metrics.media.width);
    this.video.setAttribute("height", this.metrics.media.height - VIDEO_CROP_PX * 2);
    img.setAttribute("width", this.metrics.media.width);
    img.setAttribute("height", this.metrics.media.height - VIDEO_CROP_PX * 2);
    return this;
  },

  /* --------------------------- *
   * initializeAsync
   * --------------------------- */
  initializeAsync: function initializeAsync() {
    return Promise.resolve(this).then(PlayableRenderer.whenSelectionIsContiguous).then(PlayableRenderer.whenScrollingEnds).then(PlayableRenderer.whenViewIsAttached).then(function (view) {
      // console.log("%s::initializeAsync [attached, scrollend, selected > %o, preload:%s] ('%o')", view.cid, view.model.getDistanceToSelected(), view.video.preload, view.model.get("name"));
      return Promise.all([PlayableRenderer.whenDefaultImageLoads(view), view.whenVideoHasMetadata(view)]).then(function () {
        return view;
      });
    }).then(function (view) {
      // console.log("%s::initializeAsync [defaultImage, preload:%s] ('%o')", view.cid, view.video.preload, view.model.get("name"));
      view.initializePlayable(); // view.updateOverlay(view.defaultImage, view.playToggle); //view.overlay);

      view.listenToSelection();
      return view;
    }); // videoEl.setAttribute("preload", "metadata");
  },
  initializePlayable: function initializePlayable() {
    // When selected for the first time
    // ---------------------------------
    PlayableRenderer.whenSelectionDistanceIs(this, 0).then(function (view) {
      view.video.setAttribute("preload", "auto");
      view.video.preload = "auto"; // console.log("%s::initializeAsync [selected, preload:%s] ('%o')", view.cid, view.video.preload, view.model.get("name"));

      return view;
    }).catch(function (reason) {
      if (reason instanceof PlayableRenderer.ViewError) {
        console.log("%s::%s", reason.view.cid, reason.message);
      } else {
        console.warn(reason); // return Promise.reject(reason);
      }
    }); // play-toggle-symbol
    // ---------------------------------

    this._playToggleSymbol = new PlayToggleSymbol(_.extend({
      el: this.el.querySelector(".play-toggle")
    }, this._playToggleSymbol || {})); // this._playToggleSymbol.setImageSource(this.defaultImage, 0, 0);
    // this.listenToElementOnce(this.video, "timeupdate", function(ev) {
    // 	this._playToggleSymbol.setImageSource(this.video);
    // });
    // progress-meter
    // ---------------------------------

    this.progressMeter = new ProgressMeter({
      el: this.el.querySelector(".progress-meter"),
      color: this.model.attr("color"),
      // backgroundColor: this.model.attr("background-color"),
      maxValues: {
        amount: this.video.duration,
        available: this.video.duration
      },
      labelFn: function (value, total) {
        if (!this._started || this.video.ended || isNaN(value)) {
          return formatTimecode(total);
        } else if (!this.playbackRequested) {
          return Globals.PAUSE_CHAR;
        } else {
          return formatTimecode(total - value);
        }
      }.bind(this)
    }); // this.el.querySelector(".controls").appendChild(this.progressMeter.el);
    // var el = this.el.querySelector(".progress-meter");
    // el.parentNode.replaceChild(this.progressMeter.el, el);
    // var parentEl = this.el.querySelector(".controls");
    // parentEl.insertBefore(this.progressMeter.el, parentEl.firstChild);
    // this._setPlayToggleSymbol("play-symbol");

    this._renderPlaybackState(); // listen to video events
    // ---------------------------------
    // this.video.poster = this.model.get("source").get("original");


    this.addMediaListeners();
  },

  /* --------------------------- *
   * whenVideoHasMetadata promise
   * --------------------------- */
  whenVideoHasMetadata: function whenVideoHasMetadata(view) {
    // NOTE: not pretty !!!
    return new Promise(function (resolve, reject) {
      var videoEl = view.video;
      var eventHandlers = {
        loadedmetadata: function loadedmetadata(ev) {
          if (ev) removeEventListeners(); // console.log("%s::whenVideoHasMetadata [%s] %s", view.cid, "resolved", ev ? ev.type : "sync");

          resolve(view);
        },
        abort: function abort(ev) {
          if (ev) removeEventListeners();
          reject(new PlayableRenderer.ViewError(view, new Error("whenVideoHasMetadata: view was removed")));
        },
        error: function error(ev) {
          if (ev) removeEventListeners();
          var err;

          if (videoEl.error) {
            err = new Error(_.invert(MediaError)[videoEl.error.code]);
            err.infoCode = videoEl.error.code;
          } else {
            err = new Error("Unspecified error");
          }

          err.infoSrc = videoEl.src;
          err.logMessage = "whenVideoHasMetadata: " + err.name + " " + err.infoSrc;
          err.logEvent = ev;
          reject(err);
        }
      }; //  (videoEl.preload == "auto" && videoEl.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA)
      // 	(videoEl.preload == "metadata" && videoEl.readyState >= HTMLMediaElement.HAVE_METADATA)

      if (videoEl.error) {
        eventHandlers.error();
      } else if (videoEl.readyState >= HTMLMediaElement.HAVE_METADATA) {
        eventHandlers.loadedmetadata();
      } else {
        var sources = videoEl.querySelectorAll("source");
        var errTarget = sources.length > 0 ? sources.item(sources.length - 1) : videoEl;
        var errCapture = errTarget === videoEl; // use capture with HTMLMediaElement

        var removeEventListeners = function removeEventListeners() {
          errTarget.removeEventListener("error", eventHandlers.error, errCapture);

          for (var ev in eventHandlers) {
            if (ev !== "error" && eventHandlers.hasOwnProperty(ev)) {
              videoEl.removeEventListener(ev, eventHandlers[ev], false);
            }
          }
        };

        errTarget.addEventListener("error", eventHandlers.error, errCapture);

        for (var ev in eventHandlers) {
          if (ev !== "error" && eventHandlers.hasOwnProperty(ev)) {
            videoEl.addEventListener(ev, eventHandlers[ev], false);
          }
        }
        /* NOTE: MS Edge ignores js property, using setAttribute */


        videoEl.setAttribute("preload", "metadata");
        videoEl.preload = "metadata"; // videoEl.setAttribute("poster", view.get("source").get("original"));
        // videoEl.setAttribute("preload", "metadata");
        // videoEl.poster = view.model.get("source").get("original");
        // videoEl.loop = view.model.attr("@video-loop") !== void 0;
        // videoEl.src = view.findPlayableSource(videoEl);
        // videoEl.load();
        // console.log("%s::whenVideoHasMetadata [preload:%s]", view.cid, videoEl.preload);
      }
    });
  },
  findPlayableSource: function findPlayableSource(video) {
    var playable = this.model.get("sources").find(function (source) {
      return /^video\//.test(source.get("mime")) && video.canPlayType(source.get("mime")) != "";
    });
    return playable ? playable.get("original") : "";
  },

  /* ---------------------------
   * PlayableRenderer implementation
   * --------------------------- */
  // /** @override */
  // _canResumePlayback: function() {
  // 	return PlayableRenderer.prototype._canResumePlayback.apply(this, arguments) && this.video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA;
  // },

  /** @override initial value */
  _playbackRequested: false,

  /** @override */
  _isMediaPaused: function _isMediaPaused() {
    return this.video.paused;
  },

  /** @override */
  _playMedia: function _playMedia() {
    if (this.video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA && this.video.seekable.length == 0) {
      console.warn(this.cid, "WTF! got video data, but cannot seek, calling load()"); // this._logMessage("call:load", "got video data, but cannot seek, calling load()", "orange");

      if (_.isFunction(this.video.load)) {
        this.video.load();
      }
    }
    /* NOTE: loop is false, restart from end on request */
    else if (this.video.ended) {
        this.video.currentTime = this.video.seekable.start(0);
      }
    /* if not enough data */


    if (this.video.readyState < HTMLMediaElement.HAVE_ENOUGH_DATA) {
      if (this.video.networkState == HTMLMediaElement.NETWORK_IDLE) {
        this.video.load();
      } //else {
      // var _playStamp = this._playbackCount;
      // console.log("%s::_playMedia %s waiting [#%s]", this.cid, this._isMediaWaiting() ? "continue" : "begin", _playStamp);
      //
      // this.listenToElementOnce(this.video, "canplaythrough", function(ev) {
      // 	console.log("%s::_playMedia end waiting [#%s]", this.cid, _playStamp);
      //
      // 	this._toggleWaiting(false);
      // 	// this.playbackRequested && this.video.play();
      // 	this._validatePlayback();
      // });
      //}

      /* NOTE: on "canplaythrough" _playMedia() will be called again if still required */


      this._toggleWaiting(true);
    }
    /* play */
    else {
        /* NOTE: current browsers return a promise */
        this.video.play();
      }
  },

  /** @override */
  _pauseMedia: function _pauseMedia() {
    // this._setPlayToggleSymbol("play-symbol");
    this.video.pause(); // this._renderPlaybackState();
  },

  /* ---------------------------
  /* DOM events
  /* --------------------------- */
  _listenWhileSelected: function _listenWhileSelected() {
    PlayableRenderer.prototype._listenWhileSelected.apply(this, arguments);

    this.fullscreenToggle.addEventListener(this._toggleEvent, this._onFullscreenToggle, false);
  },
  _stopListeningWhileSelected: function _stopListeningWhileSelected() {
    PlayableRenderer.prototype._stopListeningWhileSelected.apply(this, arguments);

    this.fullscreenToggle.removeEventListener(this._toggleEvent, this._onFullscreenToggle, false);
  },

  /* ---------------------------
  /* media events
  /* --------------------------- */
  addMediaListeners: function addMediaListeners() {
    // if (!this._started) {
    // 	this.addListeners(this.video, this.playingOnceEvents, this._onMediaPlayingOnce);
    // }
    this.addListeners(this.video, this.updatePlaybackEvents, this._updatePlaybackState);
    this.addListeners(this.video, this.updateBufferedEvents, this._updateBufferedValue);
    this.addListeners(this.video, this.updateCurrTimeEvents, this._updateCurrTimeValue);
    this.video.addEventListener("ended", this._onMediaEnded, false);
    this.video.addEventListener("error", this._onMediaError, true);
    this.on("view:removed", this.removeMediaListeners, this);
  },
  removeMediaListeners: function removeMediaListeners() {
    this.off("view:removed", this.removeMediaListeners, this); // if (!this._started) {
    // 	this.removeListeners(this.video, this.playingOnceEvents, this._onMediaPlayingOnce);
    // }

    this.removeListeners(this.video, this.updatePlaybackEvents, this._updatePlaybackState);
    this.removeListeners(this.video, this.updateBufferedEvents, this._updateBufferedValue);
    this.removeListeners(this.video, this.updateCurrTimeEvents, this._updateCurrTimeValue);
    this.video.removeEventListener("ended", this._onMediaEnded, false);
    this.video.removeEventListener("error", this._onMediaError, true);
  },

  /* ---------------------------
  /* media event handlers
  /* --------------------------- */
  _onMediaError: function _onMediaError(ev) {
    this.removeMediaListeners();
    this.removeSelectionListeners();
    this._started = false;
    this.content.classList.remove("started");
    this.mediaState = "error";
    this.playbackRequested = false; // this.content.classList.remove("ended");
    // this.content.classList.remove("waiting");

    this._exitFullscreen();
  },
  _onMediaEnded: function _onMediaEnded(ev) {
    this.playbackRequested = false;

    this._exitFullscreen();
  },
  _exitFullscreen: function _exitFullscreen() {
    /* NOTE: polyfill should handle this on iOS? */
    if (this.video.webkitDisplayingFullscreen) {
      this.video.webkitExitFullscreen();
    }

    if (document.fullscreenElement === this.video) {
      this.video.exitFullscreen();
    }
  },

  /* ---------------------------
  /* _onMediaPlayingOnce
  /* --------------------------- */
  // playingOnceEvents: "playing waiting",
  //
  // _onMediaPlayingOnce: function(ev) {
  // 	this.removeListeners(this.video, this.playingOnceEvents, this._onMediaPlayingOnce);
  // 	if (!this._started) {
  // 		this._started = true;
  // 		this.content.classList.add("started");
  // 	}
  // },

  /* ---------------------------
  /* _updateCurrTimeValue
  /* --------------------------- */
  updateCurrTimeEvents: "playing waiting pause timeupdate seeked",
  //.split(" "),
  _updateCurrTimeValue: function _updateCurrTimeValue(ev) {
    if (this.video.played.length) {
      this.content.classList.add("started");
    }

    if (this.progressMeter) {
      this.progressMeter.valueTo("amount", this.video.currentTime, 0);
    }
  },

  /* ---------------------------
  /* _updatePlaybackState
  /* --------------------------- */
  // updatePlaybackEvents: "playing play waiting pause seeking seeked ended",
  updatePlaybackEvents: "timeupdate playing pause waiting canplaythrough seeked",
  _isPlaybackWaiting: false,
  _playbackStartTS: -1,
  _playbackStartTC: -1,
  _updatePlaybackState: function _updatePlaybackState(ev) {
    // var isWaiting = false;
    // var symbolName = "play-symbol";
    // NOTE: clearTimeout will cancel both setTimeout and setInterval IDs
    window.clearTimeout(this._playbackTimeoutID);
    this._playbackTimeoutID = -1;

    if (this.playbackRequested) {
      if (ev.type !== "timeupdate") {
        this._playbackStartTS = ev.timeStamp;
        this._playbackStartTC = this.video.currentTime;
      }

      switch (ev.type) {
        case "timeupdate":
          if (SYNC_THRESHOLD_MS < Math.abs(ev.timeStamp - this._playbackStartTS - (this.video.currentTime - this._playbackStartTC) * 1000)) {
            this._playbackStartTS = ev.timeStamp;
            this._playbackStartTC = this.video.currentTime;
            this._playbackTimeoutID = window.setTimeout(this._playbackTimeoutFn_waiting, SYNC_TIMEOUT_MS);

            this._toggleWaiting(true); // break;

          } else {
            this._playbackTimeoutID = window.setTimeout(this._playbackTimeoutFn_playing, SYNC_TIMEOUT_MS);

            this._toggleWaiting(false);
          }

          break;

        case "playing":
          this._playbackStartTS = ev.timeStamp;
          this._playbackStartTC = this.video.currentTime;
          this._playbackTimeoutID = window.setTimeout(this._playbackTimeoutFn_playing, SYNC_TIMEOUT_MS);

          this._toggleWaiting(false);

          break;

        case "pause":
          /* NOTE: this.playbackRequested is true, the pause wasn't triggered
           * from UI, but by the waiting handler below, so we treat it as
           * waiting */
          // if (!this.playbackRequested) {
          // 	this._toggleWaiting(false);
          // }
          this._toggleWaiting(this.playbackRequested);

          break;

        case "canplaythrough":
          this._toggleWaiting(false);

          this._validatePlayback();

          break;

        case "waiting":
          /* NOTE: if the video is seeking, give it a chance to resume, so do
           * nothing, and handle things on seeked/playing */
          if (!this.video.seeking) {
            /* if not enough data */
            if (this.video.readyState < HTMLMediaElement.HAVE_ENOUGH_DATA) {
              this.video.pause(); // this.listenToElementOnce(this.video, "canplaythrough", function() {
              // 	this._toggleWaiting(false);
              // 	this._validatePlayback();
              // this.playbackRequested && this.video.play();
              // });
            }

            this._toggleWaiting(true);
          }

          break;

        default:
          this._toggleWaiting(false);

          break;
      }
    } else {
      this._toggleWaiting(false);
    }
  },
  _playbackTimeoutID: -1,
  _playbackTimeoutFn_playing: function _playbackTimeoutFn_playing() {
    this._playbackTimeoutID = -1;

    this._toggleWaiting(true); // this._renderPlaybackState();
    // this._setPlayToggleSymbol("waiting-symbol");
    // this.content.classList.add("waiting");
    // this.progressMeter.stalled = true;
    // this._isPlaybackWaiting = true;

  },
  _playbackTimeoutFn_waiting: function _playbackTimeoutFn_waiting() {
    if (SYNC_THRESHOLD_MS < (this.video.currentTime - this._playbackStartTC) * 1000) {
      this._playbackTimeoutID = window.setTimeout(this._playbackTimeoutFn_waiting, SYNC_TIMEOUT_MS);
    } else {
      // since there is no event.timeStamp
      // var delta = this.video.currentTime - this._playbackStartTC;
      // this._playbackStartTS += delta * 1000;
      // this._playbackStartTS = window.performance.now();
      this._playbackStartTS += SYNC_TIMEOUT_MS;
      this._playbackStartTC = this.video.currentTime;
      this._playbackTimeoutID = window.setTimeout(this._playbackTimeoutFn_playing, SYNC_TIMEOUT_MS);

      this._toggleWaiting(false); // this._renderPlaybackState();
      // this._setPlayToggleSymbol("pause-symbol");
      // this.content.classList.remove("waiting");
      // this.progressMeter.stalled = false;
      // this._isPlaybackWaiting = false;

    }
  },

  /** @override */
  _renderPlaybackState: function _renderPlaybackState() {
    // if (DEBUG) {
    // 	this.__logMessage([
    // 	"mediaState:", this.mediaState,
    // 	"played:", this.video.played.length,
    // 	"ended:", this.video.ended,
    // 	"toggle.paused:", this._playToggleSymbol.paused
    // ].join(" "), "_renderPlaybackState");
    // }
    // console.log("%s::_renderPlaybackState mediaState:%s played:%o ended:%o",
    // 	this.cid, this.mediaState, this.video.played.length, this.video.ended);
    //
    // if (this.mediaState === "ready") {
    // 	this.updateOverlay(this.video, this.playToggle);
    // }
    var cls = this.content.classList; // if (!this._started && this.playbackRequested &&
    // 		this.video.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA) {
    // 	this._started = true;
    // 	cls.add("started");
    // }
    // cls.toggle("started", (this.video.played.length > 0));

    cls.toggle("ended", this.video.ended);

    PlayableRenderer.prototype._renderPlaybackState.apply(this, arguments);
  },
  _setPlayToggleSymbol: function _setPlayToggleSymbol(symbolName) {
    // if (this.video.ended) {
    // 	console.log("%s::_setPlayToggleSymbol %s -> ended", this.cid, symbolName);
    // }
    // if (this.mediaState === "ready") {
    // 	if (this.playbackRequested && !this._isMediaWaiting()) {
    // 		this._playToggleSymbol.setImageSource(null);
    // 	} else {
    // 		this._playToggleSymbol.setImageSource(this.video);
    // 	}
    // 	this._playToggleSymbol.refreshImageSource();
    // }
    return PlayableRenderer.prototype._setPlayToggleSymbol.call(this, this.video.ended ? "ended" : symbolName);
  },

  /* ---------------------------
  /* _updateBufferedValue
  /* --------------------------- */
  // updateBufferedEvents: "progress canplay canplaythrough playing timeupdate",//loadeddata
  updateBufferedEvents: "progress canplay canplaythrough play playing",
  _updateBufferedValue: function _updateBufferedValue(ev) {
    // if (!this._started) return;
    var bRanges = this.video.buffered;

    if (bRanges.length > 0) {
      this._bufferedValue = bRanges.end(bRanges.length - 1);

      if (this.progressMeter && this.video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
        this.progressMeter.valueTo("available", this._bufferedValue, 300); // this.progressMeter.valueTo("available", this._bufferedValue, Math.max(0, 1000 * (this._bufferedValue - (this.progressMeter.getTargetValue("available") | 0))));
      }
    }
  },

  /* ---------------------------
  /* fullscreen api
  /* --------------------------- */
  _onFullscreenToggle: function _onFullscreenToggle(ev) {
    // NOTE: Ignore if MouseEvent.button is 0 or undefined (0: left-button)
    if (!ev.defaultPrevented && !ev.button && this.model.selected) {
      ev.preventDefault();

      try {
        if (document.hasOwnProperty("fullscreenElement") && document.fullscreenElement !== this.video) {
          document.addEventListener(fullscreenChangeEvent, this._onFullscreenChange, false);
          this.video.requestFullscreen();
        } else if (this.video.webkitSupportsFullscreen && !this.video.webkitDisplayingFullscreen) {
          this.video.addEventListener("webkitbeginfullscreen", this._onFullscreenChange, false);
          this.video.webkitEnterFullScreen();
        }
      } catch (err) {
        this.video.controls = false;
        console.error(err);
      }
    }
  },
  _onFullscreenChange: function _onFullscreenChange(ev) {
    switch (ev.type) {
      case fullscreenChangeEvent:
        // var isOwnFullscreen = Modernizr.prefixed("fullscreenElement", document) === this.video;
        var isOwnFullscreen = document.fullscreenElement === this.video;
        this.video.controls = isOwnFullscreen;

        if (!isOwnFullscreen) {
          document.removeEventListener(fullscreenChangeEvent, this._onFullscreenChange, false);
        }

        break;

      case "webkitbeginfullscreen":
        this.video.controls = true;
        this.video.removeEventListener("webkitbeginfullscreen", this._onFullscreenChange, false);
        this.video.addEventListener("webkitendfullscreen", this._onFullscreenChange, false);
        break;

      case "webkitendfullscreen":
        this.video.removeEventListener("webkitendfullscreen", this._onFullscreenChange, false);
        this.video.controls = false;
        break;
    }
  }
});
module.exports = VideoRenderer;
/* ---------------------------
/* log to screen
/* --------------------------- */

if (DEBUG) {
  module.exports = function (VideoRenderer) {
    if (!VideoRenderer.LOG_TO_SCREEN) return VideoRenderer;
    /** @type {Function} */

    var Color = require("color");
    /** @type {module:underscore.strings/lpad} */


    var lpad = require("underscore.string/lpad");
    /** @type {module:underscore.strings/rpad} */


    var rpad = require("underscore.string/rpad"); // var fullscreenEvents = [
    // 	fullscreenChangeEvent, fullscreenErrorEvent,
    // 	"webkitbeginfullscreen", "webkitendfullscreen",
    // ];


    var mediaEvents = require("utils/event/mediaEventsEnum");

    var logPlaybackStateEvents, logBufferedEvents, logPlayedEvents; // logPlaybackStateEvents = ["playing", "waiting", "ended", "pause", "seeking", "seeked"];
    // logBufferedEvents = ["progress", "durationchange", "canplay", "play"];
    // logPlayedEvents = ["playing", "timeupdate"];

    logPlaybackStateEvents = ["loadstart", "progress", "suspend", "abort", "error", "emptied", "stalled"];
    logBufferedEvents = ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", // seeking changed to true
    "seeked", // seeking changed to false
    "ended"];
    logPlayedEvents = ["play", "pause"]; // Exclude some events from log

    mediaEvents = _.without(mediaEvents, "resize", "error"); // Make sure event subsets exist in the main set

    logPlaybackStateEvents = _.intersection(mediaEvents, logPlaybackStateEvents);
    logBufferedEvents = _.intersection(mediaEvents, logBufferedEvents);
    logPlayedEvents = _.intersection(mediaEvents, logPlayedEvents);

    var readyStateSymbols = _.invert(_.pick(HTMLMediaElement, function (val, key, obj) {
      return /^HAVE_/.test(key);
    }));

    var readyStateToString = function readyStateToString(el) {
      return readyStateSymbols[el.readyState] + "(" + el.readyState + ")";
    };

    var networkStateSymbols = _.invert(_.pick(HTMLMediaElement, function (val, key, obj) {
      return /^NETWORK_/.test(key);
    }));

    var networkStateToString = function networkStateToString(el) {
      return networkStateSymbols[el.networkState] + "(" + el.networkState + ")";
    };

    var mediaErrorSymbols = _.invert(MediaError);

    var mediaErrorToString = function mediaErrorToString(el) {
      return el.error ? mediaErrorSymbols[el.error.code] + "(" + el.error.code + ")" : "[MediaError null]";
    };

    var findRangeIndex = function findRangeIndex(range, currTime) {
      for (var i = 0, ii = range.length; i < ii; i++) {
        if (range.start(i) <= currTime && currTime <= range.end(i)) {
          return i;
        }
      }

      return -1;
    };

    var formatVideoError = function formatVideoError(video) {
      return [mediaErrorToString(video), networkStateToString(video), readyStateToString(video)].join(" ");
    };

    var getVideoStatsCols = function getVideoStatsCols() {
      return "0000.000 [Curr/Total] [Seekable]  [Buffered]  networkState readyState      Playback"; // return "0000.620 [t:  0.0  27.4] [s: 27.4 0/1] [b:  0.5 0/1] LOADING(2)   FUTURE_DATA(3)  :: (::)";
    };

    var formatVideoStats = function formatVideoStats(video) {
      var currTime = video.currentTime,
          durTime = video.duration,
          bRanges = video.buffered,
          bRangeIdx,
          sRanges = video.seekable,
          sRangeIdx;
      bRangeIdx = findRangeIndex(bRanges, currTime);
      sRangeIdx = findRangeIndex(sRanges, currTime);
      return ["[" + lpad(currTime.toFixed(1), 5) + " " + lpad(!isNaN(durTime) ? durTime.toFixed(1) : "-", 4) + "]", "[" + lpad(sRangeIdx >= 0 ? sRanges.end(sRangeIdx).toFixed(1) : "-", 5) + " " + (sRangeIdx >= 0 ? sRangeIdx : "-") + "/" + sRanges.length + "]", "[" + lpad(bRangeIdx >= 0 ? bRanges.end(bRangeIdx).toFixed(1) : "-", 5) + " " + (bRangeIdx >= 0 ? bRangeIdx : "-") + "/" + bRanges.length + "]", rpad(networkStateToString(video).substr(8), 12), rpad(readyStateToString(video).substr(5), 15), video.ended ? ">:" : video.paused ? "::" : ">>"]; //.join(" ");
    };

    return VideoRenderer.extend({
      /** @override */
      initialize: function initialize() {
        VideoRenderer.prototype.initialize.apply(this, arguments);

        _.bindAll(this, "__handleMediaEvent");

        var fgColor = this.model.attr("color"),
            red = new Color("red"),
            blue = new Color("blue"),
            green = new Color("green");

        for (var i = 0; i < mediaEvents.length; i++) {
          var ev = mediaEvents[i];
          this.video.addEventListener(ev, this.__handleMediaEvent, false);
          var c = new Color(fgColor),
              cc = 1;
          if (logBufferedEvents.indexOf(ev) != -1) c.mix(green, cc /= 2);
          if (logPlayedEvents.indexOf(ev) != -1) c.mix(red, cc /= 2);
          if (logPlaybackStateEvents.indexOf(ev) != -1) c.mix(blue, cc /= 2);
          this.__logColors[ev] = c.rgb().string();
        }

        this.video.addEventListener("error", this.__handleMediaEvent, true);
      },

      /** @override */
      remove: function remove() {
        VideoRenderer.prototype.remove.apply(this, arguments);

        for (var i = 0; i < mediaEvents.length; i++) {
          if (mediaEvents[i] == "error") continue;
          this.video.removeEventListener(mediaEvents[i], this.__handleMediaEvent, false);
        }

        this.video.removeEventListener("error", this.__handleMediaEvent, true);
      },
      // /** @override */
      // _onVisibilityChange: function(ev) {
      // 	VideoRenderer.prototype._onVisibilityChange.apply(this, arguments);
      // 	var stateVal = Modernizr.prefixed("visibilityState", document);
      // 	this.__logEvent("visibilityState:" + stateVal, ev.type + ":" + stateVal);
      // },
      //
      // /** @override */
      // _onFullscreenChange: function(ev) {
      // 	VideoRenderer.prototype._onFullscreenChange.apply(this, arguments);
      // 	var logtype = (document.fullscreenElement === this.video ? "enter:" : "exit:") + ev.type;
      // 	this.__logEvent("document.fullscreenElement: " + this.cid, logtype);
      // },

      /** @override */
      _onFullscreenToggle: function _onFullscreenToggle(ev) {
        if (!ev.defaultPrevented && this.model.selected) {
          this.__logEvent("fullscreen-toggle", ev.type);
        }

        VideoRenderer.prototype._onFullscreenToggle.apply(this, arguments);
      },

      /** @override */
      _playbackTimeoutFn_playing: function _playbackTimeoutFn_playing() {
        VideoRenderer.prototype._playbackTimeoutFn_playing.apply(this, arguments); // this.__logEvent(formatVideoStats(this.video).join(" "), "timeout-play");


        this.__handleMediaEvent({
          type: "timeout-play",
          timeStamp: null,
          isTimeout: true
        });
      },

      /** @override */
      _playbackTimeoutFn_waiting: function _playbackTimeoutFn_waiting() {
        VideoRenderer.prototype._playbackTimeoutFn_waiting.apply(this, arguments); // this.__logEvent(formatVideoStats(this.video).join(" "), "timeout-wait");


        this.__handleMediaEvent({
          type: "timeout-wait",
          timeStamp: null,
          isTimeout: true
        });
      },
      __handleMediaEvent: function __handleMediaEvent(ev) {
        var evmsg = formatVideoStats(this.video);

        if (this.playbackRequested === true) {
          evmsg.push("(>>)");
        } else if (this.playbackRequested === false) {
          evmsg.push("(::)");
        } else {
          evmsg.push("(--)");
        }

        if (this.playbackRequested) {
          evmsg.push(this._playbackTimeoutID !== -1 ? "W" : "-");
        } else {
          evmsg.push(this._playbackTimeoutID !== -1 ? "?" : "!");
        } // evmsg.push(this._playToggleSymbol.symbolName);


        var ts, tc;

        if (this.updatePlaybackEvents.indexOf(ev.type) > -1 || ev.isTimeout) {
          // evmsg.push(this._playbackStartTS.toFixed(2));
          ts = ev.timeStamp - this._playbackStartTS;
          tc = this.video.currentTime - this._playbackStartTC;
          ts *= .001; // s to ms

          evmsg.push(Math.abs(tc - ts).toFixed(3));
        } // else {
        // 	ts = this._playbackStartTS;
        // 	tc = this._playbackStartTC;
        // }
        // ts *= .001; // s to ms
        // evmsg.push(Math.abs(tc - ts).toFixed(3));
        // evmsg.push("TC:" + tc.toFixed(3));
        // evmsg.push("TS:" + ts.toFixed(3));


        this.__logEvent(evmsg.join(" "), ev.type);

        if (ev.type === "error" || ev.type === "abort") {
          this.__logMessage(formatVideoError(this.video), ev.type);
        }
      },
      __logEvent: function __logEvent(msg, logtype, color) {
        var logEntryEl = this.__logElement.lastElementChild;

        if (logEntryEl && logEntryEl.getAttribute("data-logtype") == logtype && (logtype === "timeupdate" || logtype === "progress")) {
          var logRepeatVal = parseInt(logEntryEl.getAttribute("data-logrepeat"));
          logEntryEl.textContent = this.__getTStamp() + " " + msg;
          logEntryEl.setAttribute("data-logrepeat", isNaN(logRepeatVal) ? 2 : ++logRepeatVal);
        } else {
          this.__logMessage(msg, logtype, color);
        }
      },
      __getHeaderText: function __getHeaderText() {
        return getVideoStatsCols();
      }
    });
  }(module.exports);
}

}).call(this,true,require("underscore"))

},{"./VideoRenderer.hbs":118,"app/control/Globals":55,"app/view/component/CanvasProgressMeter":87,"app/view/component/PlayToggleSymbol":94,"app/view/render/PlayableRenderer":115,"color":12,"underscore":51,"underscore.string/lpad":47,"underscore.string/rpad":49,"utils/event/mediaEventsEnum":143,"utils/prefixedEvent":145}],120:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function";

  return "<div id=\"desc_b"
    + container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\" class=\"content sizing mdown\">"
    + ((stack1 = ((helper = (helper = helpers.desc || (depth0 != null ? depth0.desc : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"desc","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":35}],121:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function";

  return "<div id=\"desc_m"
    + container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
    + "\" class=\"content sizing\"><p>"
    + ((stack1 = ((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</p>"
    + ((stack1 = ((helper = (helper = helpers.sub || (depth0 != null ? depth0.sub : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"sub","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":35}],122:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
    var helper;

  return "		<p><code>"
    + container.escapeExpression(((helper = (helper = helpers.infoSrc || (depth0 != null ? depth0.infoSrc : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"infoSrc","hash":{},"data":data}) : helper)))
    + "</code></p>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "<div class=\"error-title color-fg color-reverse\">"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</div>\n<div class=\"error-message color-fg\">\n	<p><strong>"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
    + "</strong> <code>"
    + alias4(((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"message","hash":{},"data":data}) : helper)))
    + "</code></p>\n"
    + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.infoSrc : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"useData":true});

},{"hbsfy/runtime":35}],123:[function(require,module,exports){
"use strict"; // var Handlebars = require("handlebars")["default"];

var Handlebars = require("hbsfy/runtime");
/** @type {Function} */


var Color = require("color");
/** @type {module:app/control/Globals} */


var Globals = require("app/control/Globals"); // (function() {


var helpers = {
  /*
  /* Arithmetic helpers
  /*/
  add: function add(value, addition) {
    return value + addition;
  },
  subtract: function subtract(value, substraction) {
    return value - substraction;
  },
  divide: function divide(value, divisor) {
    return value / divisor;
  },
  multiply: function multiply(value, multiplier) {
    return value * multiplier;
  },
  floor: function floor(value) {
    return Math.floor(value);
  },
  ceil: function ceil(value) {
    return Math.ceil(value);
  },
  round: function round(value) {
    return Math.round(value);
  },
  global: function global(value) {
    return Globals[value];
  },

  /*
  /* Flow control helpers
  /*/
  is: function is(a, b, opts) {
    return a === b ? opts.fn(this) : opts.inverse(this);
  },
  isnot: function isnot(a, b, opts) {
    return a !== b ? opts.fn(this) : opts.inverse(this);
  },
  isany: function isany(value) {
    var i = 0,
        ii = arguments.length - 2,
        opts = arguments[ii + 1];

    do {
      if (value === arguments[++i]) {
        return opts.fn(this);
      }
    } while (i < ii);

    return opts.inverse(this);
  },
  contains: function contains(a, b, opts) {
    return a.indexOf(b) !== -1 ? opts.fn(this) : opts.inverse(this);
  },
  ignore: function ignore() {
    return "";
  },

  /*
  /* Color helpers
  /*/
  mix: function mix(colora, colorb, amount) {
    return new Color(colora).mix(new Color(colorb), amount).rgb().string();
  },
  lighten: function lighten(color, amount) {
    return new Color(color).lighten(amount).rgb().string();
  },
  darken: function darken(color, amount) {
    return new Color(color).darken(amount).rgb().string();
  } // colorFormat: function(color, fmt) {
  // 	switch (fmt) {
  // 		case "rgb":
  // 			return new Color(color).rgb().string();
  // 		case "hsl":
  // 			return new Color(color).hsl().string();
  // 		case "hex": default:
  // 			return new Color(color).hex().string();
  // 	}
  // },

};

for (var helper in helpers) {
  if (helpers.hasOwnProperty(helper)) {
    Handlebars.registerHelper(helper, helpers[helper]);
  }
} // })();
// module.exports = Handlebars;

},{"app/control/Globals":55,"color":12,"hbsfy/runtime":35}],124:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<svg class=\"cog-symbol icon\" viewBox=\"-100 -100 200 200\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMidYMid meet\">\n	<path d=\"M11.754,-99.307c-7.809,-0.924 -15.699,-0.924 -23.508,0l-3.73,20.82c-6.254,1.234 -12.338,3.21 -18.123,5.888l-15.255,-14.651c-6.861,3.842 -13.244,8.48 -19.018,13.818l9.22,19.036c-4.335,4.674 -8.095,9.849 -11.201,15.416l-20.953,-2.886c-3.292,7.141 -5.731,14.645 -7.265,22.357l18.648,9.981c-0.759,6.329 -0.759,12.727 0,19.056l-18.648,9.981c1.534,7.712 3.973,15.216 7.265,22.357l20.953,-2.886c3.106,5.567 6.866,10.742 11.201,15.416l-9.22,19.036c5.774,5.338 12.157,9.976 19.018,13.818l15.255,-14.651c5.785,2.678 11.869,4.654 18.123,5.888l3.73,20.82c7.809,0.924 15.699,0.924 23.508,0l3.73,-20.82c6.254,-1.234 12.338,-3.21 18.123,-5.888l15.255,14.651c6.861,-3.842 13.244,-8.48 19.018,-13.818l-9.22,-19.036c4.335,-4.674 8.095,-9.849 11.201,-15.416l20.953,2.886c3.292,-7.141 5.731,-14.645 7.265,-22.357l-18.648,-9.981c0.759,-6.329 0.759,-12.727 0,-19.056l18.648,-9.981c-1.534,-7.712 -3.973,-15.216 -7.265,-22.357l-20.953,2.886c-3.106,-5.567 -6.866,-10.742 -11.201,-15.416l9.22,-19.036c-5.774,-5.338 -12.157,-9.976 -19.018,-13.818l-15.255,14.651c-5.785,-2.678 -11.869,-4.654 -18.123,-5.888l-3.73,-20.82ZM0,-33c18.213,0 33,14.787 33,33c0,18.213 -14.787,33 -33,33c-18.213,0 -33,-14.787 -33,-33c0,-18.213 14.787,-33 33,-33Z\" style=\"fill:currentColor;fill-rule:evenodd;\"/>\n</svg>\n";
},"useData":true});

},{"hbsfy/runtime":35}],125:[function(require,module,exports){
"use strict";
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<svg class=\"fullscreen-symbol\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" preserveAspectRatio=\"xMidYMid meet\" viewBox=\"-21 -21 42 42\">\n	<path id=\"fullscreen-shadow\" d=\"M-5,5 L-20,20 M-7,20 L-20,20 L-20,7 M5,-5 L20,-20 M7,-20 L20,-20 L20,-7\" class=\"bg-color-stroke\" style=\"fill:none\" vector-effect=\"non-scaling-stroke\" transform=\"translate(2 2)\"/>\n	<path id=\"fullscreen-path\" d=\"M-5,5 L-20,20 M-7,20 L-20,20 L-20,7 M5,-5 L20,-20 M7,-20 L20,-20 L20,-7\" class=\"color-stroke\" style=\"fill:none\" vector-effect=\"non-scaling-stroke\" />\n</svg>\n";
},"useData":true});

},{"hbsfy/runtime":35}],126:[function(require,module,exports){
(function (_){
"use strict";
/** @type {module:backbone} */

var Events = require("backbone").Events; // var defaultOptions = {
// 	tick: 1,
// 	onstart: null,
// 	ontick: null,
// 	onpause: null,
// 	onstop: null,
// 	onend: null
// }


var idSeed = 0;

var Timer = function Timer(options) {
  // if (!(this instanceof Timer)) {
  // 	return new Timer(options);
  // }
  this._id = idSeed++; // this._options = {};

  this._duration = 0;
  this._status = "initialized";
  this._start = 0; // this._measures = [];
  // for (var prop in defaultOptions) {
  // 	this._options[prop] = defaultOptions[prop];
  // }
  // this.options(options);
};

_.extend(Timer.prototype, Events, {
  start: function start(duration) {
    if (!_.isNumber(duration) && !this._duration) {
      return this;
    } // duration && (duration *= 1000)


    if (this._timeout && this._status === "started") {
      return this;
    }

    var evName = this._status === "stopped" ? "start" : "resume";
    this._duration = duration || this._duration;
    this._timeout = window.setTimeout(end.bind(this), this._duration); // if (typeof this._options.ontick === "function") {
    // 	this._interval = setInterval(function() {
    // 		this.trigger("tick", this.getDuration())
    // 	}.bind(this), +this._options.tick * 1000)
    // }

    this._start = _now();
    this._status = "started";
    this.trigger(evName, this.getDuration());
    return this;
  },
  pause: function pause() {
    if (this._status !== "started") {
      return this;
    }

    this._duration -= _now() - this._start;
    clear.call(this, false);
    this._status = "paused";
    this.trigger("pause", this.getDuration());
    return this;
  },
  stop: function stop() {
    if (!/started|paused/.test(this._status)) {
      return this;
    }

    clear.call(this, true);
    this._status = "stopped";
    this.trigger("stop");
    return this;
  },
  getDuration: function getDuration() {
    if (this._status === "started") {
      return this._duration - (_now() - this._start);
    }

    if (this._status === "paused") {
      return this._duration;
    }

    return 0;
  },
  getStatus: function getStatus() {
    return this._status;
  }
});

var _now = window.performance ? window.performance.now.bind(window.performance) : Date.now.bind(Date);

function end() {
  clear.call(this);
  this._status = "stopped";
  this.trigger("end");
}

function clear(clearDuration) {
  window.clearTimeout(this._timeout); // window.clearInterval(this._interval);

  if (clearDuration === true) {
    this._duration = 0;
  }
}

Object.defineProperties(Timer.prototype, {
  duration: {
    enumerable: true,
    get: function get() {
      return this.getDuration();
    }
  },
  status: {
    enumerable: true,
    get: function get() {
      return this.getStatus();
    }
  }
});
Object.defineProperties(Timer, {
  STOPPED: {
    enumerable: true,
    value: "stopped"
  },
  STARTED: {
    enumerable: true,
    value: "started"
  },
  PAUSED: {
    enumerable: true,
    value: "paused"
  }
});
module.exports = Timer;

}).call(this,require("underscore"))

},{"backbone":5,"underscore":51}],127:[function(require,module,exports){
"use strict";
/* -------------------------------
/* Imports
/* ------------------------------- */

/** @type {module:utils/TransformItem} */

var TransformItem = require("./TransformItem");

var idSeed = 0;
var cidSeed = 100;
var slice = Array.prototype.slice;
/**
 * @constructor
 * @type {module:app/helper/TransformHelper}
 */

function TransformHelper() {
  this.id = idSeed++;
  this._items = [];
  this._itemsById = {};
}

TransformHelper.prototype = Object.create({
  /* -------------------------------
  /* Private
  /* ------------------------------- */
  _get: function _get(el) {
    if (this.has(el)) {
      return this._itemsById[el.eid];
    } else {
      return this._add(el);
    }
  },
  _add: function _add(el) {
    var item, id; // id = el.eid || el.cid || el.id;
    // if (!id || (this._itemsById[id] && (this._itemsById[id].el !== el))) {
    // 	id = "elt" + cidSeed++;
    // }
    // if (!el.eid) {
    // 	id = el.eid || el.cid || ("elt" + cidSeed++);
    // }

    id = el.eid || el.cid || "elt" + cidSeed++;
    item = new TransformItem(el, id);
    this._itemsById[id] = item;

    this._items.push(item);

    return item;
  },
  _remove: function _remove(el) {
    if (this.has(el)) {
      var o = this._itemsById[el.eid];

      this._items.splice(this._items.indexOf(o), 1);

      o.destroy();
      delete this._itemsById[el.eid];
    }
  },
  _invoke: function _invoke(funcName, args, startIndex) {
    var i, ii, j, jj, el, o, rr;
    var funcArgs = null;

    if (startIndex !== void 0) {
      funcArgs = slice.call(args, 0, startIndex);
    } else {
      startIndex = 0;
    }

    for (i = startIndex, ii = args.length, rr = []; i < ii; ++i) {
      el = args[i]; // iterate on NodeList, Arguments, Array...

      if (el.length) {
        for (j = 0, jj = el.length; j < jj; ++j) {
          o = this._get(el[j]);
          rr.push(o[funcName].apply(o, funcArgs));
        }
      } else {
        o = this._get(el);
        rr.push(o[funcName].apply(o, funcArgs));
      }
    }

    return rr;
  },

  /* -------------------------------
  /* Public
  /* ------------------------------- */
  has: function has(el) {
    return el.eid && this._itemsById[el.eid] !== void 0;
  },
  getItems: function getItems() {
    var i,
        j,
        el,
        ret = [];

    for (i = 0; i < arguments.length; ++i) {
      el = arguments[i];

      if (el.length) {
        for (j = 0; j < el.length; ++j) {
          ret.push(this._get(el[j]));
        }
      } else {
        ret.push(this._get(el));
      }
    }

    return ret;
  },
  get: function get(el) {
    return this._get(el);
  },
  add: function add() {
    var i, j, el;

    for (i = 0; i < arguments.length; ++i) {
      el = arguments[i];

      if (el.length) {
        for (j = 0; j < el.length; ++j) {
          this._get(el[j]);
        }
      } else {
        this._get(el);
      }
    }
  },
  remove: function remove() {
    var i, j, el;

    for (i = 0; i < arguments.length; ++i) {
      el = arguments[i];

      if (el.length) {
        for (j = 0; j < el.length; ++j) {
          this._remove(el[j]);
        }
      } else {
        this._remove(el);
      }
    }
  },

  /* --------------------------------
  /* public
  /* -------------------------------- */

  /* public: single arg
  /* - - - - - - - - - - - - - - - - */
  hasOffset: function hasOffset(el) {
    return this.has(el) ? this._itemsById[el.eid].hasOffset : void 0;
  },

  /* public: capture
  /* - - - - - - - - - - - - - - - - */
  capture: function capture() {
    this._invoke("capture", arguments);
  },
  captureAll: function captureAll() {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].capture();
    }
  },
  clearCapture: function clearCapture() {
    this._invoke("clearCapture", arguments);
  },
  clearAllCaptures: function clearAllCaptures() {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].clearCapture();
    }
  },

  /* public: offset
  /* - - - - - - - - - - - - - - - - */
  offset: function offset(x, y) {
    this._invoke("offset", arguments, 2);
  },
  offsetAll: function offsetAll(x, y) {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].offset(x, y);
    }
  },
  clearOffset: function clearOffset() {
    this._invoke("clearOffset", arguments);
  },
  clearAllOffsets: function clearAllOffsets() {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].clearOffset();
    }
  },

  /* public: transitions
  /* - - - - - - - - - - - - - - - - */
  runTransition: function runTransition(transition) {
    this._invoke("runTransition", arguments, 1);
  },
  runAllTransitions: function runAllTransitions(transition) {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].runTransition(transition);
    }
  },
  clearTransition: function clearTransition() {
    this._invoke("clearTransition", arguments);
  },
  clearAllTransitions: function clearAllTransitions() {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].clearTransition();
    }
  },
  stopTransition: function stopTransition() {
    this._invoke("stopTransition", arguments);
  },
  stopAllTransitions: function stopAllTransitions() {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].stopTransition();
    }
  },
  whenTransitionEnds: function whenTransitionEnds() {
    var res = this._invoke("whenTransitionEnds", arguments);

    return res.length != 0 ? Promise.all(res) : Promise.resolve(null);
  },
  whenAllTransitionsEnd: function whenAllTransitionsEnd() {
    return this._items.length != 0 ? Promise.all(this._items.map(function (o) {
      return o.whenTransitionEnds();
    })) : Promise.resolve(null);
  },
  promise: function promise() {
    return arguments.length == 0 ? this.whenAllTransitionsEnd() : this.whenTransitionEnds.call(this, arguments);
  },

  /* -------------------------------
  /* validation
  /* ------------------------------- */
  validate: function validate() {
    for (var i = 0, ii = this._items.length; i < ii; i++) {
      this._items[i].validate();
    }
  }
}, {
  items: {
    get: function get() {
      return this._items;
    }
  }
});
module.exports = TransformHelper;

},{"./TransformItem":128}],128:[function(require,module,exports){
(function (DEBUG,_){
"use strict";
/* -------------------------------
 * Imports
 * ------------------------------- */

/** @type {module:utils/prefixedProperty} */

var prefixedProperty = require("utils/prefixedProperty");
/** @type {module:utils/prefixedStyleName} */


var prefixedStyleName = require("utils/prefixedStyleName");
/** @type {module:utils/prefixedEvent} */


var prefixedEvent = require("utils/prefixedEvent");
/** @type {String} */


var transitionEnd = prefixedEvent("transitionend"); //var transitionEnd = require("utils/event/transitionEnd");
// /** @type {Function} */
// var slice = Array.prototype.slice;
// /** @type {module:utils/debug/traceElement} */
// var traceElt = require("./debug/traceElement");
// var traceEltCache = {};
// var log = function() {
// 	var logFn = "log";
// 	var args = slice.apply(arguments);
// 	switch(args[0]) {
// 		case "error":
// 		case "warn":
// 		case "info":
// 			logFn = args.shift();
// 			break;
// 		default:
// 			// break;
// 			return;
// 	}
// 	var el, txId;
// 	if ((el = args[0]) && (txId = el.eid)) {
// 		args[0] = traceEltCache[txId] || (traceEltCache[txId] = el);
// 	}
// 	args[0] = "\t" + args[0];
// 	console[logFn].apply(console, args);
// };

/* jshint -W079 */
// var console = (function(target) {
// 	return Object.getOwnPropertyNames(target).reduce(function(proxy, prop) {
// 		if ((typeof target[prop]) == "function") {
// 			switch (prop) {
// 				case "error":
// 				case "warn":
// 				case "info":
// 					proxy[prop] = function () {
// 						var args = slice.apply(arguments);
// 						if (typeof args[0] == "string") {
// 							args[0] = prop + "::" + args[0];
// 						}
// 						return target[prop].apply(target, args);
// 					};
// 					break;
// 				case "log":
// 					proxy[prop] = function() {};
// 					break;
// 				default:
// 					proxy[prop] = target[prop].bind(target);
// 					break;
// 			}
// 		} else {
// 			Object.defineProperty(proxy, prop, {
// 				get: function() { return target[prop]; },
// 				set: function(val) { target[prop] = val; }
// 			});
// 		}
// 		return proxy;
// 	}, {});
// })(window.console);

/* jshint +W079 */

/* -------------------------------
/* Private static
/* ------------------------------- */

var NO_TRANSITION_VALUE = "none 0s step-start 0s"; // var NO_TRANSITION_VALUE = "all 0.001s step-start 0.001s";

var UNSET_TRANSITION = {
  name: "unset",
  className: "tx-unset",
  property: "none",
  easing: "ease",
  delay: 0,
  duration: 0,
  cssText: "unset"
}; // var translateTemplate = _.template("translate(<%= _renderedX %>px, <%= _renderedY %>px)";
// var translate3dTemplate = _.template("translate3d(<%= _renderedX %>px, <%= _renderedY %>px, 0px)";
// var transitionTemplate = _.template("<%= property %> <% duration/1000 %>s <%= easing %> <% delay/1000 %>s");

var translateTemplate = function (fn) {
  return function (o) {
    return fn(o._renderedX, o._renderedY);
  };
}(require("app/control/Globals").TRANSLATE_TEMPLATE);

var transitionTemplate = function transitionTemplate(o) {
  return o.property + " " + o.duration / 1000 + "s " + o.easing + " " + o.delay / 1000 + "s";
};

var propDefaults = {
  "opacity": "1",
  "visibility": "visible",
  "transform": "matrix(1, 0, 0, 1, 0, 0)",
  "transformStyle": "",
  "transition": "" // "willChange": "",
  // "transitionDuration": "0s",
  // "transitionDelay": "0s",
  // "transitionProperty": "none",
  // "transitionTimingFunction": "ease"

};
var propKeys = Object.keys(propDefaults);
var propNames = propKeys.reduce(function (obj, propName) {
  obj[propName] = prefixedProperty(propName);
  return obj;
}, {});

var styleNames = function (camelToDashed) {
  return propKeys.map(camelToDashed).reduce(function (obj, propName) {
    obj[propName] = prefixedStyleName(propName);
    return obj;
  }, {});
}(require("utils/strings/camelToDashed"));

var resolveAll = function resolveAll(pp, result) {
  if (pp.length != 0) {
    pp.forEach(function (p, i, a) {
      p.resolve(result);
      a[i] = null;
    });
    pp.length = 0;
  }

  return pp;
};

var rejectAll = function rejectAll(pp, reason) {
  if (pp.length != 0) {
    pp.forEach(function (p, i, a) {
      p.reject(reason);
      a[i] = null;
    });
    pp.length = 0;
  }

  return pp;
};
/* -------------------------------
 * TransformItem
 * ------------------------------- */

/**
 * @constructor
 */


var TransformItem = function TransformItem(el, id) {
  this.el = el;
  this.id = id;
  this.el.eid = id;
  this._onTransitionEnd = this._onTransitionEnd.bind(this);
  this.el.addEventListener(transitionEnd, this._onTransitionEnd, false);
  this._captureInvalid = false;
  this._capturedChanged = false;
  this._capturedX = null;
  this._capturedY = null;
  this._currCapture = {};
  this._lastCapture = {};
  this._hasOffset = false;
  this._offsetInvalid = false;
  this._offsetX = null;
  this._offsetY = null;
  this._renderedX = null;
  this._renderedY = null;
  this._hasTransition = false;
  this._transitionInvalid = false;
  this._transitionRunning = false;
  this._transition = _.extend({}, UNSET_TRANSITION); //{};

  this._promises = [];
  this._pendingPromises = [];
};

TransformItem.prototype = Object.create({
  /* -------------------------------
  /* Public
  /* ------------------------------- */

  /* destroy
  /* - - - - - - - - - - - - - - - - */
  destroy: function destroy() {
    // NOTE: style property may have been modified; clearOffset(element) should
    // be called explicitly if clean up is required.
    this.el.removeEventListener(transitionEnd, this._onTransitionEnd, false);
    rejectAll(this._pendingPromises, this);
    rejectAll(this._promises, this); // delete this.el.eid;
  },

  /* capture
  /* - - - - - - - - - - - - - - - - */
  capture: function capture(force) {
    // console.log("tx[%s]::capture", this.id);
    if (force) {
      this.clearCapture();
    }

    this._validateCapture();

    return this;
  },
  clearCapture: function clearCapture() {
    // console.log("tx[%s]::clearCapture", this.id);
    // this._hasOffset = false;
    this._captureInvalid = true;
    return this;
  },

  /* offset/clear
  /* - - - - - - - - - - - - - - - - */
  offset: function offset(x, y) {
    // console.log("tx[%s]::offset", this.id);
    this._hasOffset = true;
    this._offsetInvalid = true;
    this._offsetX = x || 0;
    this._offsetY = y || 0; // if (this.immediate) this._validateOffset();

    return this;
  },
  clearOffset: function clearOffset() {
    if (this._hasOffset) {
      // console.log("tx[%s]::clearOffset", this.id);
      this._hasOffset = false;
      this._offsetInvalid = true;
      this._offsetX = null;
      this._offsetY = null; // if (this.immediate) this._validateOffset();
    } // else {
    // 	console.log("tx[%s]::clearOffset no offset to clear", this.id);
    // }


    return this;
  },

  /* transitions
  /* - - - - - - - - - - - - - - - - */
  runTransition: function runTransition(transition) {
    if (!transition) {
      // || (transition.duration + transition.delay) == 0) {
      return this.clearTransition();
    }

    var lastValue = this._transitionValue;
    var lastName = this._transition.name;
    this._transition.property = styleNames["transform"];
    this._transition = _.extend(this._transition, transition);
    this._transitionValue = transitionTemplate(this._transition);

    if (this._transitionInvalid) {
      console.warn("tx[%s]::runTransition set over (%s:'%s' => %s:'%s')", this.id, lastName, lastValue, this._transition.name, this._transitionValue);
    }

    this._hasTransition = true;
    this._transitionInvalid = true; // if (this.immediate) this._validateTransition();

    return this;
  },
  clearTransition: function clearTransition() {
    this._transition = _.extend(this._transition, UNSET_TRANSITION);
    this._transitionValue = NO_TRANSITION_VALUE;
    this._hasTransition = false;
    this._transitionInvalid = true; // if (this.immediate) this._validateTransition();

    return this;
  },
  stopTransition: function stopTransition() {
    // this._transition.name = "[none]";
    // this._transition.property = "none";
    this._transition = _.extend(this._transition, UNSET_TRANSITION);
    this._transitionValue = NO_TRANSITION_VALUE;
    this._hasTransition = false;
    this._transitionInvalid = true; // if (this.immediate) this._validateTransition();

    return this;
  },
  whenTransitionEnds: function whenTransitionEnds() {
    var d, p, pp;

    if (this._transitionInvalid || this._transitionRunning) {
      d = {};
      p = new Promise(function (resolve, reject) {
        d.resolve = resolve;
        d.reject = reject;
      });
      pp = this._transitionInvalid ? this._pendingPromises : this._promises;
      pp.push(d);
    } else {
      p = Promise.resolve(this);
    }

    return p;
  },

  /* validation
  /* - - - - - - - - - - - - - - - - */
  validate: function validate() {
    // this.el.removeEventListener(transitionEnd, this._onTransitionEnd, false);
    this._ignoreEvent = true;

    if (this._captureInvalid) {
      var lastX = this._renderedX !== null ? this._renderedX : this._capturedX,
          lastY = this._renderedY !== null ? this._renderedY : this._capturedY; // this._validateTransition();

      this._validateCapture();

      this._validateOffset();

      var currX = this._renderedX !== null ? this._renderedX : this._capturedX,
          currY = this._renderedY !== null ? this._renderedY : this._capturedY;

      if (lastX === currX && lastY === currY) {
        this._hasTransition && console.warn("tx[%s]::validate unchanged: last:[%i,%i] curr:[%i,%i]", this.el.id || this.id, lastX, lastY, currX, currY); // console.info("tx[%s]::validate unchanged: last:[%f,%f] curr:[%f,%f] render:[%f,%f] captured[%f,%f]", this.el.id || this.id, lastX, lastY, currX, currY, this._renderedX, this._renderedY, this._capturedX, this._capturedY);

        this.clearTransition(); // this._validateTransition();
      }

      this._validateTransition();
    } else {
      // this._validateCapture();
      this._validateTransition();

      this._validateOffset();
    } // this.el.addEventListener(transitionEnd, this._onTransitionEnd, false);


    this._ignoreEvent = false; // if (this._capturedChanged) {
    // 	console.error("tx[%s]::validate capture changed: [%f,%f]", this.id, this._capturedX, this._capturedY);
    // }

    this._capturedChanged = false;
    return this;
  },

  /* -------------------------------
  /* Private
  /* ------------------------------- */
  _validateCapture: function _validateCapture() {
    if (!this._captureInvalid) {
      return;
    } // var computed, capturedValues;


    var transformValue = null;

    if (this._hasOffset && !this._offsetInvalid) {
      // this is an explicit call to capture() instead of a subcall from _validateOffset()
      transformValue = this._getCSSProp("transform");

      if (transformValue === "") {
        console.error("tx[%s]::_capture valid offset (%i,$i) but transformValue=\"\"", this.id, this._offsetX, this._offsetY);
      }

      this._removeCSSProp("transform");
    } // NOTE: reusing object, all props will be overwritten


    this._lastCapture = this._currCapture;
    this._currCapture = this._getComputedCSSProps();

    if (this._currCapture.transform !== this._lastCapture.transform) {
      var m, mm; //, ret = {};

      mm = this._currCapture.transform.match(/(matrix|matrix3d)\(([^\)]+)\)/);

      if (mm) {
        m = mm[2].split(",");

        if (mm[1] === "matrix") {
          this._capturedX = parseFloat(m[4]);
          this._capturedY = parseFloat(m[5]);
        } else {
          this._capturedX = parseFloat(m[12]);
          this._capturedY = parseFloat(m[13]);
        }
      } else {
        this._capturedX = 0;
        this._capturedY = 0;
      }

      this._capturedChanged = true;
    }

    if (transformValue !== null) {
      console.log("tx[%s]::_capture reapplying '%s'", this.id, transformValue);

      this._setCSSProp("transform", transformValue);
    }

    this._captureInvalid = false;
  },
  _validateOffset: function _validateOffset() {
    if (this._offsetInvalid) {
      // this._validateCapture();
      this._offsetInvalid = false;

      if (this._hasOffset) {
        var tx = this._offsetX + this._capturedX;
        var ty = this._offsetY + this._capturedY;

        if (tx !== this._renderedX || ty !== this._renderedY) {
          this._renderedX = tx;
          this._renderedY = ty;

          this._setCSSProp("transform", translateTemplate(this));
        }
      } else {
        this._renderedX = null;
        this._renderedY = null;

        this._removeCSSProp("transform");
      }
    }
  },
  _validateTransition: function _validateTransition() {
    if (this._transitionInvalid) {
      // this._validateCapture();
      this._transitionInvalid = false; // save promises made while invalid

      var reject = this._promises; // prepare _promises and push in new ones

      this._promises = this._pendingPromises; // whatever still here is to be rejected. reuse array

      this._pendingPromises = rejectAll(reject, this); // Set running flag, if there's a transition to run

      this._transitionRunning = this._hasTransition; // Set the css value (which will be empty string if there's no transition)

      this._setCSSProp("transition", this._transitionValue);

      if (DEBUG) {
        if (this._hasTransition) {
          this.el.setAttribute("data-tx", this._transition.name);
        }
      }

      if (!this._hasTransition) {
        // if there is no transition, resolve promises now
        resolveAll(this._promises, this);
      }
    }
  },
  _onTransitionEnd: function _onTransitionEnd(ev) {
    if (this._ignoreEvent) {
      return;
    }

    if (this._transitionRunning && this.el === ev.target && this._transition.property == ev.propertyName) {
      this._hasTransition = false;
      this._transitionRunning = false;

      this._removeCSSProp("transition");

      resolveAll(this._promises, this);

      if (DEBUG) {
        if (this.el.hasAttribute("data-tx")) {
          // this.el.setAttribute("data-tx-last", this.el.getAttribute("data-tx"));
          this.el.removeAttribute("data-tx");
        }
      }
    }
  },

  /* -------------------------------
  /* CSS
  /* ------------------------------- */
  _getCSSProp: function _getCSSProp(prop) {
    return this.el.style[propNames[prop]]; // return this.el.style[prefixedProperty(prop)];
    // return this.el.style.getPropertyValue(styleNames[prop]);
  },
  _setCSSProp: function _setCSSProp(prop, value) {
    if (prop === "transition" && value == NO_TRANSITION_VALUE) {
      value = "";
    }

    if (value === null || value === void 0 || value === "") {
      this._removeCSSProp(prop);
    } else {
      this.el.style[propNames[prop]] = value; // this.el.style.setProperty(styleNames[prop], value);
    }
  },
  _removeCSSProp: function _removeCSSProp(prop) {
    this.el.style[propNames[prop]] = ""; // this.el.style.removeProperty(styleNames[prop]);
  },
  _getComputedCSSProps: function _getComputedCSSProps() {
    var values = {};
    var computed = window.getComputedStyle(this.el);

    for (var p in propNames) {
      values[p] = computed[propNames[p]];
    }

    return values;
  }
}, {
  transition: {
    get: function get() {
      return this._transition;
    }
  },
  hasTransition: {
    get: function get() {
      return this._hasTransition;
    }
  },
  capturedChanged: {
    get: function get() {
      return this._capturedChanged;
    }
  },
  capturedX: {
    get: function get() {
      return this._capturedX;
    }
  },
  capturedY: {
    get: function get() {
      return this._capturedY;
    }
  },
  hasOffset: {
    get: function get() {
      return this._hasOffset;
    }
  },
  offsetX: {
    get: function get() {
      return this._offsetX;
    }
  },
  offsetY: {
    get: function get() {
      return this._offsetY;
    }
  }
});
module.exports = TransformItem;

}).call(this,true,require("underscore"))

},{"app/control/Globals":55,"underscore":51,"utils/prefixedEvent":145,"utils/prefixedProperty":146,"utils/prefixedStyleName":147,"utils/strings/camelToDashed":151}],129:[function(require,module,exports){
"use strict";

module.exports = function (a1, a2, dest) {
  return a1.reduce(function (res, o, i, a) {
    if (a2.indexOf(o) == -1) res.push(o);
    return res;
  }, dest !== void 0 ? dest : []);
};

},{}],130:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var PI2 = Math.PI * 2;
var splice = Array.prototype.splice; // var concat = Array.prototype.concat;

/*
 *	Using javascript to convert radians to degrees with positive and
 *	negative values [https://stackoverflow.com/questions/29588404/]
 *	`(((r * (180/Math.PI)) % 360) + 360) % 360;`
 *	`function mod(n, m) {
 *		return ((n % m) + m) % m;
 *	}`
 */

var _mod = function _mod(n, m) {
  return (n % m + m) % m;
};

var setStyle = function setStyle(ctx, s) {
  if (_typeof(s) != "object") return;

  for (var p in s) {
    switch (_typeof(ctx[p])) {
      case "undefined":
        break;

      case "function":
        if (Array.isArray(s[p])) {
          ctx[p].apply(ctx, s[p]);
        } else {
          ctx[p].call(ctx, s[p]);
        }

        break;

      default:
        ctx[p] = s[p];
    }
  }
};

var _drawShape = function _drawShape(fn, s, ctx) {
  ctx.save();

  if (s) {
    setStyle(ctx, s);
  }

  fn.apply(null, splice.call(arguments, 2));

  if ('strokeStyle' in s) {
    /* ctx.lineWidth > 0 */
    ctx.stroke();
  }

  if ('fillStyle' in s) {
    /* ctx.fillStyle !== "transparent" */
    ctx.fill();
  }

  ctx.restore();
};

module.exports = {
  setStyle: setStyle,
  vGuide: function vGuide(ctx, x) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, ctx.canvas.height);
  },
  drawVGuide: function drawVGuide(ctx, s, x) {
    _drawShape(this.vGuide, s, ctx, x);
  },
  hGuide: function hGuide(ctx, y) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(ctx.canvas.width, y);
  },
  drawHGuide: function drawHGuide(ctx, s, y) {
    _drawShape(this.hGuide, s, ctx, y);
  },
  crosshair: function crosshair(ctx, x, y, r) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.PI / 4);
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.lineTo(0, r);
    ctx.moveTo(-r, 0);
    ctx.lineTo(r, 0);
    ctx.restore();
  },
  drawCrosshair: function drawCrosshair(ctx, s, x, y, r) {
    _drawShape(this.crosshair, s, ctx, x, y, r);
  },
  circle: function circle(ctx, x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, PI2);
  },
  drawCircle: function drawCircle(ctx, s, x, y, r) {
    _drawShape(this.circle, s, ctx, x, y, r);
  },
  square: function square(ctx, x, y, r) {
    r = Math.floor(r / 2) * 2;
    ctx.beginPath();
    ctx.rect(x - r, y - r, r * 2, r * 2);
  },
  drawSquare: function drawSquare(ctx, s, x, y, r) {
    _drawShape(this.square, s, ctx, x, y, r);
  },
  arrowhead: function arrowhead(ctx, x, y, r, t) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(_mod(t, PI2));
    ctx.translate(r * 0.5, 0);
    ctx.beginPath();
    ctx.moveTo(0, 0); // ctx.lineTo(-r, r * Math.SQRT1_2);
    // ctx.lineTo(-r, -r * Math.SQRT1_2);

    ctx.lineTo(-r * Math.SQRT2, r * Math.SQRT1_2);
    ctx.arcTo(0, 0, -r * Math.SQRT2, -r * Math.SQRT1_2, r); // ctx.quadraticCurveTo(0, 0, -r * Math.SQRT2, -r * Math.SQRT1_2);

    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.restore();
  },
  drawArrowhead: function drawArrowhead(ctx, s, x, y, r, t) {
    _drawShape(this.arrowhead, s, ctx, x, y, r, t);
  },
  arrowhead2: function arrowhead2(ctx, x, y, r, t) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(_mod(t, PI2));
    ctx.beginPath();
    ctx.moveTo(-r, r * Math.SQRT1_2);
    ctx.lineTo(0, 0);
    ctx.lineTo(-r, -r * Math.SQRT1_2);
    ctx.restore();
  },
  drawArrowhead2: function drawArrowhead2(ctx, s, x, y, r, t) {
    _drawShape(this.arrowhead, s, ctx, x, y, r, t);
  },
  rect: function rect(ctx, a1, a2, a3, a4) {
    if (_typeof(a1) === "object") {
      a4 = a1.height;
      a3 = a1.width;
      a2 = a1.top;
      a1 = a1.left;
    }

    ctx.beginPath();
    ctx.rect(a1, a2, a3, a4);
  },
  drawRect: function drawRect(ctx, s, a1, a2, a3, a4) {
    _drawShape(this.rect, s, ctx, a1, a2, a3, a4);
  },
  roundRect: function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  },
  drawRoundRect: function drawRoundRect(ctx, s, x, y, w, h, r) {
    _drawShape(this.roundRect, s, ctx, x, y, h, r);
  },
  quadRoundRect: function quadRoundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.closePath();
  },
  drawQuadRoundRect: function drawQuadRoundRect(ctx, s, x, y, w, h, r) {
    _drawShape(this.quadRoundRect, s, ctx, x, y, h, r);
  }
};

},{}],131:[function(require,module,exports){
"use strict";
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author: Mario Klingemann
Contact:  mario@quasimondo.com
Website: http://www.quasimondo.com/StackBlurForCanvas
Twitter: @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

module.exports = function () {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
};

},{}],132:[function(require,module,exports){
"use strict";

module.exports = function (imageData, adj) {
  var pixels = imageData.data;
  var r, g, b, s;
  var i, ii;

  if (arguments.length === 1) {
    for (i = 0, ii = pixels.length; i < ii; i += 4) {
      pixels[i] = (pixels[i] * 299 + pixels[i + 1] * 587 + pixels[i + 2] * 144) / 1000;
    }
  } else if (arguments.length === 2) {
    if (0 >= adj > 1) {
      console.warn("argument out of range (1-0)", adj);
      return imageData;
    }

    for (i = 0, ii = pixels.length; i < ii; i += 4) {
      r = pixels[i];
      g = pixels[i + 1];
      b = pixels[i + 2]; // s = ((r * 299 + g * 587 + b * 144) / 1000) * (1 - adj);
      // pixels[i] = r * adj + s;
      // pixels[i + 1] = g * adj + s;
      // pixels[i + 2] = b * adj + s;

      s = Math.max(r, g, b);

      if (s === 0) {
        pixels[i] = Math.round(255 * adj);
        pixels[i + 1] = Math.round(255 * adj);
        pixels[i + 2] = Math.round(255 * adj);
      } else {
        s = 255 * adj / s;
        pixels[i] = Math.round(r * s);
        pixels[i + 1] = Math.round(g * s);
        pixels[i + 2] = Math.round(b * s);
      }
    }
  }

  return imageData;
}; // function saturation(r,g,b, s) {
//     var min = rgb.indexOf(Math.min.apply(null, rgb)), // index of min
//         max = rgb.indexOf(Math.max.apply(null, rgb)), // index of max
//         mid = [0, 1, 2].filter(function (i) {return i !== min && i !== max;})[0],
//         a = rgb[max] - rgb[min],
//         b = rgb[mid] - rgb[min],
//         x = rgb[max],
//         arr = [x, x, x];
//     if (min === max) {
//         min = 2; // both max = min = 0, => mid = 1, so set min = 2
//         a = 1;   // also means a = b = 0, don't want division by 0 in `b / a`
//     }
//
//     arr[max] = x;
//     arr[min] = Math.round(x * (1 - s));
//     arr[mid] = Math.round(x * ((1 - s) + s * b / a));
//
//     return arr;
// }
// function nvalue(rgb, v) {
//     var x = Math.max.apply(null, rgb);
//     if (x === 0)
//         return [
//             Math.round(255 * v),
//             Math.round(255 * v),
//             Math.round(255 * v)
//         ];
//     x = 255 * v / x;
//     return [
//         Math.round(rgb[0] * x),
//         Math.round(rgb[1] * x),
//         Math.round(rgb[2] * x)
//     ];
// }

},{}],133:[function(require,module,exports){
"use strict";

module.exports = function (imageData, opts) {
  var pixels = imageData.data;
  var pixelsNum = pixels.length;
  var rgbAvg = [0, 0, 0];
  var i;

  for (i = 0; i < pixelsNum; i += 4) {
    rgbAvg[0] += pixels[i];
    rgbAvg[1] += pixels[i + 1];
    rgbAvg[2] += pixels[i + 2];
  }

  for (i = 0; i < 3; i++) {
    rgbAvg[i] = rgbAvg[i] / (pixelsNum / 4) | 0;
  }

  return rgbAvg;
};

},{}],134:[function(require,module,exports){
"use strict";
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author: Mario Klingemann
Contact:  mario@quasimondo.com
Website: http://www.quasimondo.com/StackBlurForCanvas
Twitter: @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

module.exports = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];

},{}],135:[function(require,module,exports){
"use strict";

module.exports = function (pixels, adjustment) {
  var d = pixels.data;

  for (var i = 0; i < d.length; i += 4) {
    d[i] *= adjustment;
    d[i + 1] *= adjustment;
    d[i + 2] *= adjustment;
  }

  return pixels;
};

},{}],136:[function(require,module,exports){
"use strict";
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author: Mario Klingemann
Contact:  mario@quasimondo.com
Website: http://www.quasimondo.com/StackBlurForCanvas
Twitter: @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

module.exports = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];

},{}],137:[function(require,module,exports){
"use strict";
/* jshint ignore:start */

/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author: Mario Klingemann
Contact:  mario@quasimondo.com
Website: http://www.quasimondo.com/StackBlurForCanvas
Twitter: @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var mul_table = require("./mul_table");

var shg_table = require("./shg_table");

var BlurStack = require("./BlurStack");

module.exports = function (imageData, opts) {
  if (_typeof(opts) === "object" && opts.hasOwnProperty("radius")) {
    opts = opts.radius;
  }

  if (typeof opts !== "number" || isNaN(opts) || 1 > opts) {
    // no valid argument value do nothing
    return imageData;
  }

  var radius = opts | 0;
  var pixels = imageData.data,
      width = imageData.width,
      height = imageData.height;
  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, r_out_sum, g_out_sum, b_out_sum, r_in_sum, g_in_sum, b_in_sum, pr, pg, pb, rbs;
  var div = radius + radius + 1;
  var w4 = width << 2;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;

  for (i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) var stackEnd = stack;
  }

  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;
  yw = yi = 0;
  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];

  for (y = 0; y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    for (i = 1; i < radiusPlus1; i++) {
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      stack = stack.next;
    }

    stackIn = stackStart;
    stackOut = stackEnd;

    for (x = 0; x < width; x++) {
      pixels[yi] = r_sum * mul_sum >> shg_sum;
      pixels[yi + 1] = g_sum * mul_sum >> shg_sum;
      pixels[yi + 2] = b_sum * mul_sum >> shg_sum;
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
      r_in_sum += stackIn.r = pixels[p];
      g_in_sum += stackIn.g = pixels[p + 1];
      b_in_sum += stackIn.b = pixels[p + 2];
      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      stackOut = stackOut.next;
      yi += 4;
    }

    yw += width;
  }

  for (x = 0; x < width; x++) {
    g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    stack = stackStart;

    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack = stack.next;
    }

    yp = width;

    for (i = 1; i <= radius; i++) {
      yi = yp + x << 2;
      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      stack = stack.next;

      if (i < heightMinus1) {
        yp += width;
      }
    }

    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;

    for (y = 0; y < height; y++) {
      p = yi << 2;
      pixels[p] = r_sum * mul_sum >> shg_sum;
      pixels[p + 1] = g_sum * mul_sum >> shg_sum;
      pixels[p + 2] = b_sum * mul_sum >> shg_sum;
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
      r_sum += r_in_sum += stackIn.r = pixels[p];
      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      stackOut = stackOut.next;
      yi += width;
    }
  }

  return imageData;
};
/* jshint ignore:end */

},{"./BlurStack":131,"./mul_table":134,"./shg_table":136}],138:[function(require,module,exports){
"use strict";
/**
 * @module utils/canvas/calcArcHConnector
 */

module.exports = function (x1, y1, r1, x2, y2, r2, ro) {
  var qx = x2 > x1 ? 1 : -1;
  var qy = y2 > y1 ? 1 : -1;
  var dy = Math.abs(y2 - y1);
  var dx = Math.abs(x2 - x1);
  var rr = r1 + r2;
  var tx1, tx2, c, tx, ty;

  if (dy < 1) {
    // points are aligned horizontally, no arcs needed
    tx1 = 0;
    tx2 = dx; // return [x1, x2];
  }

  if (dy >= rr && dx >= rr) {
    // arcs fit horizontally:
    // second circle center is r1+r2, tangent intersect at x=r1
    c = rr;
    tx1 = r1;
    tx2 = r1;
  } else {
    // arcs overlap horizontally:
    // find second circle center
    c = Math.sqrt(dy * r2 * 2 + dy * r1 * 2 - dy * dy); // circles tangent point

    tx = c * r1 / rr;
    ty = dy * r1 / rr;

    if (r1 < ty || c > dx) {
      return;
    } // tangent perpendicular slope


    var slope = (rr - dy) / c; // tangent intersections

    tx1 = tx - ty * slope;
    tx2 = dy * slope + tx1;
    /*
    // circle centers
    var ccx1, ccy1, ccx2, ccy2;
    ccx1 = 0;
    ccy1 = r1;
    ccx2 = c;
    ccy2 = dy - r2;
    // tangent perpendicular slope
    var slope = (ccy1 - ccy2) / (ccx2 - ccx1);
    var xSec = tx - (ty * slope);
    // tangent intersections
    tx1 = xSec;
    tx2 = (dy * slope) + xSec;
    */
  } // offset arcTo's in x-axis


  if (ro > 0) {
    if (ro > 1) {
      ro = Math.min(dx - rr, ro);
    } else {
      ro *= dx - rr;
    }

    tx1 += ro;
    tx2 += ro;
  }

  return [tx1 * qx + x1, tx2 * qx + x1, tx1, tx2];
};
/*
var drawArcConnector = function(ctx, x1, y1, x2, y2, r) {
	var dx, dy, hx, hy, gx, gy;

	hx = 0;
	hy = 0;
	gx = (x1 + x2) / 2;
	gy = (y1 + y2) / 2;
	dx = Math.abs(x1 - gx);
	dy = Math.abs(y1 - gy);

	if (dx < r && dy < r) {
		r = Math.min(dx * Math.SQRT1_2, dy * Math.SQRT1_2);
	} else {
		if (dx < r) {
			hy = Math.acos(dx / r) * r * 0.5;
			if (y1 > y2) hy *= -1;
		}
		if (dy < r) {
			hx = Math.acos(dy / r) * r * 0.5;
			if (x1 > x2) hx *= -1;
		}
	}
	ctx.arcTo(gx - hx, y1, gx + hx, y2, r);
	ctx.arcTo(gx + hx, y2, x2, y2, r);
};

var drawArcConnector2 = function(ctx, x1, y1, x2, y2, r) {
	var dx, dy, hx, hy, cx1, cx2;

	hx = 0;
	hy = 0;
	dx = Math.abs(x2 - x1) / 2;
	dy = Math.abs(y1 - y2) / 2;

	if (dx < r && dy < r) {
		r = Math.min(dx * Math.SQRT1_2, dy * Math.SQRT1_2);
	} else {
		if (dx < r) {
			hy = Math.acos(dx / r) * r;
		}
		if (dy < r) {
			hx = Math.acos(dy / r) * r;
		}
	}
	cx1 = x1 + dx;
	cx2 = x2 - (dx - hx / 2);
	ctx.arcTo(cx1, y1, cx2, y2, r);
	ctx.arcTo(cx2, y2, x2, y2, r);
};

var drawArcConnector1 = function(ctx, x1, y1, x2, y2, r) {
	var dx, dy, cx;

	dx = Math.abs(x2 - x1) / 2;
	dy = Math.abs(y1 - y2) / 2;
	r = Math.min(r, dy * Math.SQRT1_2);
	if (x1 < x2) {
		cx = x1 + dx + r;
	} else {
		cx = x2 - dx - r;
	}
	// cx = (x2 + x1) / 2;
	// cx += x1 < x2 ? r : -r;

	ctx.arcTo(cx, y1, cx, y2, r);
	ctx.arcTo(cx, y2, x2, y2, r);
};
*/

},{}],139:[function(require,module,exports){
(function (DEBUG){
"use strict";
/* global HTMLElement, CSSStyleDeclaration */
// var parseSize = require("./parseSize");

var CSS_BOX_PROPS = ["boxSizing", "position", "objectFit"];
var CSS_EDGE_PROPS = ["marginTop", "marginBottom", "marginLeft", "marginRight", "borderTopWidth", "borderBottomWidth", "borderLeftWidth", "borderRightWidth", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight"];
var CSS_POS_PROPS = ["top", "bottom", "left", "right"];
var CSS_SIZE_PROPS = ["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight"];
var CSS_ALL_PROPS = CSS_EDGE_PROPS.concat(CSS_SIZE_PROPS, CSS_POS_PROPS); // var COMPUTED_PROPS = [
// 	"clientLeft", "clientTop", "clientWidth", "clientHeight",
// 	"offsetLeft", "offsetTop", "offsetWidth", "offsetHeight"
// ];
// var o = _.pick(element, function(val) {
// 	return /^(offset|client)(Left|Top|Width|Height)/.test(val);
// });

var cssDimensionRE = /^(-?[\d\.]+)(px|em|rem)$/; // var cssDimRe = /^([-\.0-9]+)([rem]+)$/;

module.exports = function (s, m, includeSizePos) {
  if (s instanceof HTMLElement) {
    s = getComputedStyle(s);
  }

  if (DEBUG) {
    if (!(s instanceof CSSStyleDeclaration)) {
      throw new Error("Not a CSSStyleDeclaration nor HTMLElement");
    }
  }

  var v, p, i, ii, emPx, remPx;
  m || (m = {});
  emPx = m.fontSize = parseFloat(s.fontSize);

  for (i = 0, ii = CSS_BOX_PROPS.length; i < ii; i++) {
    p = CSS_BOX_PROPS[i];

    if (p in s) {
      m[p] = s[p];
    }
  }

  var cssProps = includeSizePos ? CSS_EDGE_PROPS : CSS_ALL_PROPS;

  for (i = 0, ii = cssProps.length; i < ii; i++) {
    p = cssProps[i];
    m["_" + p] = s[p];

    if (s[p] && (v = cssDimensionRE.exec(s[p]))) {
      if (v[2] === "px") {
        m[p] = parseFloat(v[1]);
      } else if (v[2] === "em") {
        m[p] = parseFloat(v[1]) * emPx;
      } else if (v[2] === "rem") {
        remPx || (remPx = parseFloat(getComputedStyle(document.documentElement).fontSize));
        m[p] = parseFloat(v[1]) * remPx;
      } else {
        console.warn("Ignoring value", p, v[1], v[2]);
        m[p] = null;
      }
    } // else {
    //	console.warn("Ignoring unitless value", p, v);
    //}

  }

  return m;
};

}).call(this,true)

},{}],140:[function(require,module,exports){
"use strict";
/* easeInQuad */

module.exports = function (x, t, b, c, d) {
  return c * (t /= d) * t + b;
};

},{}],141:[function(require,module,exports){
"use strict";
/* easeOutQuad */

module.exports = function (t, b, c, d) {
  return -c * (t /= d) * (t - 2) + b;
};

},{}],142:[function(require,module,exports){
"use strict";
/**
 * @param {number} i current iteration
 * @param {number} s start value
 * @param {number} d change in value
 * @param {number} t total iterations
 * @return {number}
 */

var linear = function linear(i, s, d, t) {
  return d * i / t + s;
};

module.exports = linear;

},{}],143:[function(require,module,exports){
"use strict";
/* https://html.spec.whatwg.org/multipage/media.html#event-media-canplay
 */

module.exports = [// networkState
"loadstart", "progress", "suspend", "abort", "error", "emptied", "stalled", // readyState
"loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", //
"seeking", // seeking changed to true
"seeked", // seeking changed to false
"ended", // ended is true
//
"durationchange", // duration updated
"timeupdate", // currentTime updated
"play", // paused is false
"pause", // paused is false
"paused", // ??
"ratechange", //
"resize", "volumechange"];

},{}],144:[function(require,module,exports){
"use strict";
/**
 * @module app/view/component/GraphView
 */

module.exports = function (rect, dx, dy) {
  if (arguments.length == 2) {
    dy = dx;
  }

  var r = {
    width: rect.width + dx * 2,
    height: rect.height + dy * 2
  };

  if (r.width >= 0) {
    r.left = rect.left - dx;
    r.right = r.left + r.width;
    r.x = r.left;
  } else {
    r.right = rect.right + dx;
    r.left = rect.right - r.width;
    r.y = r.right;
  }

  if (r.height >= 0) {
    r.top = rect.top - dy;
    r.bottom = r.top + r.height;
    r.y = r.top;
  } else {
    r.bottom = rect.bottom + dy;
    r.top = rect.bottom - r.height;
    r.y = r.bottom;
  }

  return r;
};

},{}],145:[function(require,module,exports){
"use strict";
/** @type {Array} lowercase prefixes */

var lcPrefixes = [""].concat(require("./prefixes"));
/** @type {Array} capitalized prefixes */

var ucPrefixes = lcPrefixes.map(function (s) {
  return s === "" ? s : s.charAt(0).toUpperCase() + s.substr(1);
});
/** @type {Object} specific event solvers */

var _solvers = {};
/** @type {Object} cached values */

var _cache = {};
/**
 * @param {String} name Unprefixed event name
 * @param {?Object} obj Prefix test target
 * @param {?String} testProp Proxy property to test prefixes
 * @return {String|null}
 */

var _prefixedEvent = function _prefixedEvent(name, obj, testProp) {
  var prefixes = /^[A-Z]/.test(name) ? ucPrefixes : lcPrefixes;
  obj || (obj = document);

  for (var i = 0; i < prefixes.length; i++) {
    if (testProp) {
      if (prefixes[i] + testProp in obj) {
        return prefixes[i] + name;
      }
    }

    if ("on" + prefixes[i] + name in obj) {
      return prefixes[i] + name;
    }
  }

  return null;
}; // transitionend


_solvers["transitionend"] = function () {
  var prop,
      style = document.body.style,
      map = {
    "transition": "transitionend",
    "WebkitTransition": "webkitTransitionEnd",
    "MozTransition": "transitionend",
    // "msTransition" : "MSTransitionEnd",
    "OTransition": "oTransitionEnd"
  };

  for (prop in map) {
    if (prop in style) {
      return map[prop];
    }
  }

  return null;
};
/**
 * get the prefixed property
 * @param {String} property name
 * @param {Object} look-up object
 * @returns {String|null} prefixed
 */


module.exports = function (evName) {
  if (!_cache.hasOwnProperty(evName)) {
    _cache[evName] = _solvers.hasOwnProperty(evName) ? _solvers[evName]() : _prefixedEvent.apply(null, arguments);

    if (_cache[evName] === null) {
      console.warn("Event '%s' not found", evName);
    } else {
      console.log("Event '%s' found as '%s'", evName, _cache[evName]);
    }
  }

  return _cache[evName]; // return _cache[evName] || (_cache[evName] = _solvers[evName]? _solvers[evName].call() : _prefixedProperty.apply(null, arguments));
};
/*
var defaultTest = function(name, obj) {
	var prefixes = /^[A-Z]/.test(name)? ucPrefixes : lcPrefixes;
	for (var i = 0; i < prefixes.length; i++) {
		if (("on" + prefixes[i] + name) in obj) {
			console.log("Event '%s' found as '%s'", name, prefixes[i] + name);
			return prefixes[i] + name;
		}
	}
	return null;
};

var proxyTest = function(name, obj, testProp) {
	var prefixes = /^[A-Z]/.test(name)? ucPrefixes : lcPrefixes;
	for (var i = 0; i < prefixes.length; i++) {
		if ((prefixes[i] + testProp) in obj) {
			console.log("Event %s inferred as '%s' from property '%s'", name, prefixes[i] + name, testProp);
			return prefixes[i] + name;
		}
	}
	return null;
};
*/

},{"./prefixes":148}],146:[function(require,module,exports){
"use strict";
/**
/* @module utils/prefixedProperty
/*/

/** @type {module:utils/prefixes} */

var prefixes = require("./prefixes");
/** @type {Number} prefix count */


var _prefixNum = prefixes.length;
/** @type {Array} cached values */

var _cache = {};

var _prefixedProperty = function _prefixedProperty(prop, obj) {
  var prefixedProp, camelProp;

  if (prop in obj) {
    console.log("Property '%s' found unprefixed", prop);
    return prop;
  }

  camelProp = prop[0].toUpperCase() + prop.slice(1);

  for (var i = 0; i < _prefixNum; i++) {
    prefixedProp = prefixes[i] + camelProp;

    if (prefixedProp in obj) {
      console.log("Property '%s' found as '%s'", prop, prefixedProp);
      return prefixedProp;
    }
  }

  console.error("Property '%s' not found", prop);
  return null;
};
/**
 * get the prefixed property
 * @param {String} property name
 * @param {Object} look-up object
 * @returns {String|null} prefixed
 */


module.exports = function (prop, obj) {
  return _cache[prop] || (_cache[prop] = _prefixedProperty(prop, obj || document.body.style));
};

},{"./prefixes":148}],147:[function(require,module,exports){
"use strict";
/**
/* @module utils/prefixedStyleName
/*/

/** @type {module:utils/prefixes} */

var prefixes = require("./prefixes"); //.map(function(prefix) { return "-" + prefix + "-"; });

/** @type {Number} prefix count */


var _prefixNum = prefixes.length;
/** @type {Array} cached values */

var _cache = {};

var _prefixedStyleName = function _prefixedStyleName(style, styleObj) {
  var prefixedStyle;

  if (style in styleObj) {
    console.log("CSS style '%s' found unprefixed", style);
    return style;
  }

  for (var i = 0; i < _prefixNum; i++) {
    prefixedStyle = "-" + prefixes[i] + "-" + style; // prefixedStyle = prefixes[i] + style;

    if (prefixedStyle in styleObj) {
      console.log("CSS style '%s' found as '%s'", style, prefixedStyle);
      return prefixedStyle;
    }
  }

  console.warn("CSS style '%s' not found", style);
  return null;
};
/**
 * get the prefixed style name
 * @param {String} style name
 * @param {Object} look-up style object
 * @returns {String|Undefined} prefixed
 */


module.exports = function (style, styleObj) {
  // return _cache[style] || (_cache[style] = _prefixedStyleName_reverse(style, styleObj || document.body.style));
  return _cache[style] || (_cache[style] = _prefixedStyleName(style, styleObj || document.body.style));
}; // /** @type {module:utils/strings/camelToDashed} */
// var camelToDashed = require("./strings/camelToDashed");
// /** @type {module:utils/prefixedProperty} */
// var prefixedProperty = require("./prefixedProperty");
// /** @type {module:utils/strings/dashedToCamel} */
// var dashedToCamel = require("./strings/dashedToCamel");
//
// var _prefixedStyleName_reverse = function (style, styleObj) {
// 	var camelProp, prefixedProp;
// 	camelProp = dashedToCamel(style);
// 	prefixedProp = prefixedProperty(camelProp, styleObj);
// 	return prefixedProp? (camelProp === prefixedProp? "" : "-") + camelToDashed(prefixedProp) : null;
// };

},{"./prefixes":148}],148:[function(require,module,exports){
"use strict";

module.exports = ["webkit", "moz", "ms", "o"];

},{}],149:[function(require,module,exports){
"use strict";

module.exports = function (pp, reason) {
  if (pp.length > 0) {
    pp.forEach(function (p, i, a) {
      p.reject(reason);
      a[i] = null;
    });
    pp.length = 0;
  }

  return pp;
};

},{}],150:[function(require,module,exports){
"use strict";

module.exports = function (pp, result) {
  if (pp.length != 0) {
    pp.forEach(function (p, i, a) {
      p.resolve(result);
      a[i] = null;
    });
    pp.length = 0;
  }

  return pp;
};

},{}],151:[function(require,module,exports){
"use strict";

module.exports = function (str) {
  return str.replace(/[A-Z]/g, function ($0) {
    return "-" + $0.toLowerCase();
  });
};

},{}],152:[function(require,module,exports){
"use strict";

module.exports = function (s) {
  return s.replace(/<[^>]+>/g, "");
};

},{}],153:[function(require,module,exports){
"use strict";
/** @type {module:hammerjs} */

var Hammer = require("hammerjs"); // /**
//  * get a usable string, used as event postfix
//  * @param {Const} state
//  * @returns {String} state
//  */
// function stateStr(state) {
// 	if (state & Hammer.STATE_CANCELLED) {
// 		return "cancel";
// 	} else if (state & Hammer.STATE_ENDED) {
// 		return "end";
// 	} else if (state & Hammer.STATE_CHANGED) {
// 		return "move";
// 	} else if (state & Hammer.STATE_BEGAN) {
// 		return "start";
// 	}
// 	return "";
// }

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */


function dirStr(direction) {
  if (direction == Hammer.DIRECTION_DOWN) {
    return "down";
  } else if (direction == Hammer.DIRECTION_UP) {
    return "up";
  } else if (direction == Hammer.DIRECTION_LEFT) {
    return "left";
  } else if (direction == Hammer.DIRECTION_RIGHT) {
    return "right";
  }

  return "";
} ///**
// * Pan
// * Recognized when the pointer is down and moved in the allowed direction.
// * @constructor
// * @extends AttrRecognizer
// */
//function PanRecognizer() {
//	Hammer.AttrRecognizer.apply(this, arguments);
//
//	this.pX = null;
//	this.pY = null;
//}
//
//inherit(PanRecognizer, Hammer.AttrRecognizer, {
//	/**
//	/* @namespace
//	/* @memberof PanRecognizer
//	/*/
//	defaults: {
//		event: "pan",
//		threshold: 10,
//		pointers: 1,
//		direction: DIRECTION_ALL
//	},
//
//	getTouchAction: function() {
//		var direction = this.options.direction;
//		var actions = [];
//		if (direction & DIRECTION_HORIZONTAL) {
//			actions.push(TOUCH_ACTION_PAN_Y);
//		}
//		if (direction & DIRECTION_VERTICAL) {
//			actions.push(TOUCH_ACTION_PAN_X);
//		}
//		return actions;
//	},
//
//	directionTest: function(input) {
//		var options = this.options;
//		var hasMoved = true;
//		var distance = input.distance;
//		var direction = input.direction;
//		var x = input.deltaX;
//		var y = input.deltaY;
//
//		// lock to axis?
//		if (!(direction & options.direction)) {
//			if (options.direction & DIRECTION_HORIZONTAL) {
//				direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
//				hasMoved = x != this.pX;
//				distance = Math.abs(input.deltaX);
//			} else {
//				direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
//				hasMoved = y != this.pY;
//				distance = Math.abs(input.deltaY);
//			}
//		}
//		input.direction = direction;
//		return hasMoved && distance > options.threshold && direction & options.direction;
//	},
//
//	attrTest: function(input) {
//		return AttrRecognizer.prototype.attrTest.call(this, input) &&
//			(this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
//	},
//
//	emit: function(input) {
//		this.pX = input.deltaX;
//		this.pY = input.deltaY;
//
//		var direction = dirStr(input.direction);
//		if (direction) {
//			this.manager.emit(this.options.event + direction, input);
//		}
//
//		this._super.emit.call(this, input);
//	}
//});

/**
 * SmoothPan
 * @constructor
 * @extends Hammer.Pan
 */


function SmoothPan() {
  var ret = Hammer.Pan.apply(this, arguments);
  this.thresholdOffsetX = null;
  this.thresholdOffsetY = null;
  this.thresholdOffset = null;
  return ret;
}

Hammer.inherit(SmoothPan, Hammer.Pan, {
  emit: function emit(input) {
    // Inheritance breaks, so this code is taken from PanRecognizer.emit
    //	this._super.emit.call(this, input); // Triggers infinite recursion
    //	Hammer.Pan.prototype.emit.apply(this, arguments); // This breaks too
    var threshold = this.options.threshold;
    var direction = input.direction;

    if (this.state == Hammer.STATE_BEGAN) {
      this.thresholdOffsetX = direction & Hammer.DIRECTION_HORIZONTAL ? direction & Hammer.DIRECTION_LEFT ? threshold : -threshold : 0;
      this.thresholdOffsetY = direction & Hammer.DIRECTION_VERTICAL ? direction & Hammer.DIRECTION_UP ? threshold : -threshold : 0; // this.thresholdOffset = (direction & Hammer.DIRECTION_HORIZONTAL)? input.thresholdOffsetX : input.thresholdOffsetY;
      // console.log("RECOGNIZER STATE", dirStr(direction), stateStr(this.state), this.thresholdOffsetX);
    }

    input.thresholdOffsetX = this.thresholdOffsetX;
    input.thresholdOffsetY = this.thresholdOffsetY;
    input.thresholdDeltaX = input.deltaX + this.thresholdOffsetX;
    input.thresholdDeltaY = input.deltaY + this.thresholdOffsetY;
    this.pX = input.deltaX;
    this.pY = input.deltaY;
    direction = dirStr(direction);

    if (direction) {
      this.manager.emit(this.options.event + direction, input);
    }

    return Hammer.Recognizer.prototype.emit.apply(this, arguments);
  }
});
module.exports = SmoothPan;

},{"hammerjs":15}],154:[function(require,module,exports){
module.exports={
	"video_crop_px": "0",
	"transform_type": "3d",
	"transitions": {
		"ease": "ease-in-out",
		"duration_ms": "350",
		"delay_interval_ms": "34",
		"min_delay_ms": "34"
	},
	"breakpoints": {
		"landscape": "'(orientation: landscape)'",
		"portrait": "'(orientation: portrait)'",
		"xsmall-stretch": "'not screen and (min-width: 460px), not screen and (min-height: 420px)'",
		"small-stretch": "'not screen and (min-width: 704px), not screen and (min-height: 540px)'",
		"default":"'only screen and (min-width: 704px) and (min-height: 540px)'",
		"medium-wide": "'only screen and (min-width: 1024px) and (min-height: 540px)'",
		"large-wide": "'only screen and (min-width: 1224px) and (min-height: 704px)'",
		"xlarge-wide": "'only screen and (min-width: 1824px) and (min-height: 1024px)'"
	},
	"default_colors": {
		"color": "hsl(47, 5%, 15%)",
		"background-color": "hsl(47, 5%, 95%)",
		"link-color": "hsl(10, 80%, 50%)"
	},
	"temp": {
		"collapse_offset": "360"
	},
	"_ignore": {
		"transitions": {
			"ease": "cubic-bezier(0.42, 0.0, 0.58, 1.0)",
			"duration_ms": "400",
			"delay_interval_ms": "134",
			"min_delay_ms": "34"
		},
		"default_colors": {
			"--link-color": "hsl(10, 80%, 50%)",
			"--alt-background-color": "unset"
		},
		"units": {
			"hu_px": "20",
			"vu_px": "12"
		},
		"breakpoints": {
			"mobile": "'not screen and (min-width: 704px), not screen and (min-height: 540px)'",
			"unsupported": "'not screen and (min-width: 704px)'",
			"unquoted": "only screen and (min-width: 1824px)",
			"unquoted_neg": "not screen and (min-width: 704px)",
			"quoted_combined": "'not screen and (min-width: 704px), not screen and (min-height: 540px)'",
			"array": [
				"only screen and (min-width: 704px)",
				"not screen and (min-width: 704px)",
				"not screen and (min-height: 540px)"
			]
		}
	}
}

},{}]},{},[53])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQmFja2JvbmUuTXV0YXRvcnMvYmFja2JvbmUubXV0YXRvcnMuanMiLCJub2RlX21vZHVsZXMvQmFja2JvbmUuTXV0YXRvcnMvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS5iYWJ5c2l0dGVyL2xpYi9iYWNrYm9uZS5iYWJ5c2l0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhY2tib25lLm5hdGl2ZS9iYWNrYm9uZS5uYXRpdmUuanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUvYmFja2JvbmUuanMiLCJub2RlX21vZHVsZXMvY2xhc3NsaXN0LXBvbHlmaWxsL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2NvbnZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9yb3V0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9hdXRvLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMucnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9kZWNvcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy9pbmxpbmUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9leGNlcHRpb24uanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9ibG9jay1oZWxwZXItbWlzc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2lmLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9sb2cuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGJzZnkvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9tdXRhdGlvbi1vYnNlcnZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3dpenpsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtc3dpenpsZS9ub2RlX21vZHVsZXMvaXMtYXJyYXlpc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS5zdHJpbmcvY2FwaXRhbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlLnN0cmluZy9kYXNoZXJpemUuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS5zdHJpbmcvaGVscGVyL2RlZmF1bHRUb1doaXRlU3BhY2UuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS5zdHJpbmcvaGVscGVyL2VzY2FwZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlLnN0cmluZy9oZWxwZXIvbWFrZVN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlLnN0cmluZy9oZWxwZXIvc3RyUmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUuc3RyaW5nL2xwYWQuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS5zdHJpbmcvcGFkLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUuc3RyaW5nL3JwYWQuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS5zdHJpbmcvdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJub2RlX21vZHVsZXMvd2ViZm9udGxvYWRlci93ZWJmb250bG9hZGVyLmpzIiwic3JjL2pzL2FwcC9BcHAuanMiLCJzcmMvanMvYXBwL2NvbnRyb2wvQ29udHJvbGxlci5qcyIsInNyYy9qcy9hcHAvY29udHJvbC9HbG9iYWxzLmpzIiwic3JjL2pzL2FwcC9kZWJ1Zy9EZWJ1Z1Rvb2xiYXIuanMiLCJzcmMvanMvYXBwL2RlYnVnL3RlbXBsYXRlL0RlYnVnVG9vbGJhci5TVkdHcmlkLmhicyIsInNyYy9qcy9hcHAvZGVidWcvdGVtcGxhdGUvRGVidWdUb29sYmFyLmhicyIsInNyYy9qcy9hcHAvbW9kZWwvQXBwU3RhdGUuanMiLCJzcmMvanMvYXBwL21vZGVsL0Jhc2VJdGVtLmpzIiwic3JjL2pzL2FwcC9tb2RlbC9CYXNlTW9kZWwuanMiLCJzcmMvanMvYXBwL21vZGVsL1NlbGVjdGFibGVDb2xsZWN0aW9uLmpzIiwic3JjL2pzL2FwcC9tb2RlbC9jb2xsZWN0aW9uL0FydGljbGVDb2xsZWN0aW9uLmpzIiwic3JjL2pzL2FwcC9tb2RlbC9jb2xsZWN0aW9uL0J1bmRsZUNvbGxlY3Rpb24uanMiLCJzcmMvanMvYXBwL21vZGVsL2NvbGxlY3Rpb24vS2V5d29yZENvbGxlY3Rpb24uanMiLCJzcmMvanMvYXBwL21vZGVsL2NvbGxlY3Rpb24vVHlwZUNvbGxlY3Rpb24uanMiLCJzcmMvanMvYXBwL21vZGVsL2hlbHBlci9ib290c3RyYXAuanMiLCJzcmMvanMvYXBwL21vZGVsL2l0ZW0vQXJ0aWNsZUl0ZW0uanMiLCJzcmMvanMvYXBwL21vZGVsL2l0ZW0vQnVuZGxlSXRlbS5qcyIsInNyYy9qcy9hcHAvbW9kZWwvaXRlbS9LZXl3b3JkSXRlbS5qcyIsInNyYy9qcy9hcHAvbW9kZWwvaXRlbS9NZWRpYUl0ZW0uanMiLCJzcmMvanMvYXBwL21vZGVsL2l0ZW0vU291cmNlSXRlbS5qcyIsInNyYy9qcy9hcHAvbW9kZWwvaXRlbS9UeXBlSXRlbS5qcyIsInNyYy9qcy9hcHAvdmlldy9BcHBWaWV3LmpzIiwic3JjL2pzL2FwcC92aWV3L0NvbnRlbnRWaWV3LmpzIiwic3JjL2pzL2FwcC92aWV3L05hdmlnYXRpb25WaWV3LmpzIiwic3JjL2pzL2FwcC92aWV3L2Jhc2UvQ2FsbGJhY2tRdWV1ZS5qcyIsInNyYy9qcy9hcHAvdmlldy9iYXNlL0NhbnZhc1ZpZXcuanMiLCJzcmMvanMvYXBwL3ZpZXcvYmFzZS9JbnRlcnBvbGF0b3IuanMiLCJzcmMvanMvYXBwL3ZpZXcvYmFzZS9QcmVmaXhlZEV2ZW50cy5qcyIsInNyYy9qcy9hcHAvdmlldy9iYXNlL1RvdWNoTWFuYWdlci5qcyIsInNyYy9qcy9hcHAvdmlldy9iYXNlL1ZpZXcuanMiLCJzcmMvanMvYXBwL3ZpZXcvYmFzZS9WaWV3RXJyb3IuanMiLCJzcmMvanMvYXBwL3ZpZXcvY29tcG9uZW50L0FydGljbGVCdXR0b24uaGJzIiwic3JjL2pzL2FwcC92aWV3L2NvbXBvbmVudC9BcnRpY2xlQnV0dG9uLmpzIiwic3JjL2pzL2FwcC92aWV3L2NvbXBvbmVudC9BcnRpY2xlVmlldy5qcyIsInNyYy9qcy9hcHAvdmlldy9jb21wb25lbnQvQ2FudmFzUHJvZ3Jlc3NNZXRlci5qcyIsInNyYy9qcy9hcHAvdmlldy9jb21wb25lbnQvQ2Fyb3VzZWwuanMiLCJzcmMvanMvYXBwL3ZpZXcvY29tcG9uZW50L0NvbGxlY3Rpb25TdGFjay5oYnMiLCJzcmMvanMvYXBwL3ZpZXcvY29tcG9uZW50L0NvbGxlY3Rpb25TdGFjay5qcyIsInNyYy9qcy9hcHAvdmlldy9jb21wb25lbnQvRmlsdGVyYWJsZUxpc3RWaWV3LmpzIiwic3JjL2pzL2FwcC92aWV3L2NvbXBvbmVudC9HcmFwaFZpZXcuanMiLCJzcmMvanMvYXBwL3ZpZXcvY29tcG9uZW50L0dyb3VwaW5nTGlzdFZpZXcuanMiLCJzcmMvanMvYXBwL3ZpZXcvY29tcG9uZW50L1BsYXlUb2dnbGVTeW1ib2wuanMiLCJzcmMvanMvYXBwL3ZpZXcvY29tcG9uZW50L1NlbGVjdGFibGVMaXN0Vmlldy5qcyIsInNyYy9qcy9hcHAvdmlldy9oZWxwZXIvY3JlYXRlQ29sb3JTdHlsZVNoZWV0LmpzIiwic3JjL2pzL2FwcC92aWV3L3Byb21pc2UvX2xvYWRJbWFnZUFzT2JqZWN0VVJMLmpzIiwic3JjL2pzL2FwcC92aWV3L3Byb21pc2UvX3doZW5JbWFnZUxvYWRzLmpzIiwic3JjL2pzL2FwcC92aWV3L3Byb21pc2Uvd2hlbkRlZmF1bHRJbWFnZUxvYWRzLmpzIiwic3JjL2pzL2FwcC92aWV3L3Byb21pc2Uvd2hlblNjcm9sbGluZ0VuZHMuanMiLCJzcmMvanMvYXBwL3ZpZXcvcHJvbWlzZS93aGVuU2VsZWN0aW9uRGlzdGFuY2VJcy5qcyIsInNyYy9qcy9hcHAvdmlldy9wcm9taXNlL3doZW5TZWxlY3Rpb25Jc0NvbnRpZ3VvdXMuanMiLCJzcmMvanMvYXBwL3ZpZXcvcHJvbWlzZS93aGVuVmlld0lzQXR0YWNoZWQuanMiLCJzcmMvanMvYXBwL3ZpZXcvcHJvbWlzZS93aGVuVmlld0lzUmVuZGVyZWQuanMiLCJzcmMvanMvYXBwL3ZpZXcvcmVuZGVyL0Nhcm91c2VsUmVuZGVyZXIuanMiLCJzcmMvanMvYXBwL3ZpZXcvcmVuZGVyL0NsaWNrYWJsZVJlbmRlcmVyLmpzIiwic3JjL2pzL2FwcC92aWV3L3JlbmRlci9EZWZhdWx0U2VsZWN0YWJsZVJlbmRlcmVyLmhicyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvRGVmYXVsdFNlbGVjdGFibGVSZW5kZXJlci5qcyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvRG90TmF2aWdhdGlvblJlbmRlcmVyLmhicyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvRG90TmF2aWdhdGlvblJlbmRlcmVyLmpzIiwic3JjL2pzL2FwcC92aWV3L3JlbmRlci9JbWFnZVJlbmRlcmVyLmhicyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvSW1hZ2VSZW5kZXJlci5qcyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvTGFiZWxSZW5kZXJlci5qcyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvTWVkaWFSZW5kZXJlci5qcyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvUGxheWFibGVSZW5kZXJlci5qcyIsInNyYy9qcy9hcHAvdmlldy9yZW5kZXIvU2VxdWVuY2VSZW5kZXJlci5oYnMiLCJzcmMvanMvYXBwL3ZpZXcvcmVuZGVyL1NlcXVlbmNlUmVuZGVyZXIuanMiLCJzcmMvanMvYXBwL3ZpZXcvcmVuZGVyL1ZpZGVvUmVuZGVyZXIuaGJzIiwic3JjL2pzL2FwcC92aWV3L3JlbmRlci9WaWRlb1JlbmRlcmVyLmpzIiwic3JjL2pzL2FwcC92aWV3L3RlbXBsYXRlL0Nhcm91c2VsLkVtcHR5UmVuZGVyZXIuQnVuZGxlLmhicyIsInNyYy9qcy9hcHAvdmlldy90ZW1wbGF0ZS9Db2xsZWN0aW9uU3RhY2suTWVkaWEuaGJzIiwic3JjL2pzL2FwcC92aWV3L3RlbXBsYXRlL0Vycm9yQmxvY2suaGJzIiwic3JjL2pzL2FwcC92aWV3L3RlbXBsYXRlL19oZWxwZXJzLmpzIiwic3JjL2pzL2FwcC92aWV3L3RlbXBsYXRlL3N2Zy9Db2dTeW1ib2wuaGJzIiwic3JjL2pzL2FwcC92aWV3L3RlbXBsYXRlL3N2Zy9GdWxsc2NyZWVuU3ltYm9sLmhicyIsInNyYy9qcy91dGlscy9UaW1lci5qcyIsInNyYy9qcy91dGlscy9UcmFuc2Zvcm1IZWxwZXIuanMiLCJzcmMvanMvdXRpbHMvVHJhbnNmb3JtSXRlbS5qcyIsInNyYy9qcy91dGlscy9hcnJheS9kaWZmZXJlbmNlLmpzIiwic3JjL2pzL3V0aWxzL2NhbnZhcy9DYW52YXNIZWxwZXIuanMiLCJzcmMvanMvdXRpbHMvY2FudmFzL2JpdG1hcC9CbHVyU3RhY2suanMiLCJzcmMvanMvdXRpbHMvY2FudmFzL2JpdG1hcC9kZXNhdHVyYXRlLmpzIiwic3JjL2pzL3V0aWxzL2NhbnZhcy9iaXRtYXAvZ2V0QXZlcmFnZVJHQi5qcyIsInNyYy9qcy91dGlscy9jYW52YXMvYml0bWFwL211bF90YWJsZS5qcyIsInNyYy9qcy91dGlscy9jYW52YXMvYml0bWFwL211bHRpcGx5LmpzIiwic3JjL2pzL3V0aWxzL2NhbnZhcy9iaXRtYXAvc2hnX3RhYmxlLmpzIiwic3JjL2pzL3V0aWxzL2NhbnZhcy9iaXRtYXAvc3RhY2tCbHVyUkdCLmpzIiwic3JjL2pzL3V0aWxzL2NhbnZhcy9jYWxjQXJjSENvbm5lY3Rvci5qcyIsInNyYy9qcy91dGlscy9jc3MvZ2V0Qm94RWRnZVN0eWxlcy5qcyIsInNyYy9qcy91dGlscy9lYXNlL2ZuL2Vhc2VJblF1YWQuanMiLCJzcmMvanMvdXRpbHMvZWFzZS9mbi9lYXNlT3V0UXVhZC5qcyIsInNyYy9qcy91dGlscy9lYXNlL2ZuL2xpbmVhci5qcyIsInNyYy9qcy91dGlscy9ldmVudC9tZWRpYUV2ZW50c0VudW0uanMiLCJzcmMvanMvdXRpbHMvZ2VvbS9pbmZsYXRlUmVjdC5qcyIsInNyYy9qcy91dGlscy9wcmVmaXhlZEV2ZW50LmpzIiwic3JjL2pzL3V0aWxzL3ByZWZpeGVkUHJvcGVydHkuanMiLCJzcmMvanMvdXRpbHMvcHJlZml4ZWRTdHlsZU5hbWUuanMiLCJzcmMvanMvdXRpbHMvcHJlZml4ZXMuanMiLCJzcmMvanMvdXRpbHMvcHJvbWlzZS9yZWplY3RBbGwuanMiLCJzcmMvanMvdXRpbHMvcHJvbWlzZS9yZXNvbHZlQWxsLmpzIiwic3JjL2pzL3V0aWxzL3N0cmluZ3MvY2FtZWxUb0Rhc2hlZC5qcyIsInNyYy9qcy91dGlscy9zdHJpbmdzL3N0cmlwVGFncy5qcyIsInNyYy9qcy91dGlscy90b3VjaC9TbW9vdGhQYW5SZWNvZ25pemVyLmpzIiwic3JjL3Nhc3MvdmFyaWFibGVzLmpzb24iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4a0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qISBCYWNrYm9uZS5NdXRhdG9ycyAtIHYwLjQuNFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5CdWlsZCBAIDIwMTUtMDItMDNcbkRvY3VtZW50YXRpb24gYW5kIEZ1bGwgTGljZW5zZSBBdmFpbGFibGUgYXQ6XG5odHRwOi8vYXNjaWlkaXNjby5naXRodWIuY29tL0JhY2tib25lLk11dGF0b3JzL2luZGV4Lmh0bWxcbmdpdDovL2dpdGh1Yi5jb20vYXNjaWlkaXNjby9CYWNrYm9uZS5NdXRhdG9ycy5naXRcbkNvcHlyaWdodCAoYykgMjAxNSBTZWJhc3RpYW4gR29sYXNjaCA8cHVibGljQGFzY2lpZGlzY28uY29tPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxudG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxudGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG5hbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcblxuU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG5EQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLFxuQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG5JTiBUSEUgU09GVFdBUkUuKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCd1bmRlcnNjb3JlJyksIHJlcXVpcmUoJ2JhY2tib25lJykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdiYWNrYm9uZSddLCBmdW5jdGlvbiAoXywgQmFja2JvbmUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIHVzZSB0aGUgQU1EIGJyYW5jaCBvZiBCYWNrXG4gICAgICAgICAgICBfID0gXyA9PT0gdW5kZWYgPyByb290Ll8gOiBfO1xuICAgICAgICAgICAgQmFja2JvbmUgPSBCYWNrYm9uZSA9PT0gdW5kZWYgPyByb290LkJhY2tib25lIDogQmFja2JvbmU7XG4gICAgICAgICAgICByZXR1cm4gKHJvb3QucmV0dXJuRXhwb3J0c0dsb2JhbCA9IGZhY3RvcnkoXywgQmFja2JvbmUsIHJvb3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0c0dsb2JhbCA9IGZhY3Rvcnkocm9vdC5fLCByb290LkJhY2tib25lKTtcbiAgICB9XG5cbi8vIFVzYWdlOlxuLy9cbi8vIE5vdGU6IFRoaXMgcGx1Z2luIGlzIFVNRCBjb21wYXRpYmxlLCB5b3UgY2FuIHVzZSBpdCBpbiBub2RlLCBhbWQgYW5kIHZhbmlsbGEganMgZW52c1xuLy9cbi8vIFZhbmlsbGEgSlM6XG4vLyA8c2NyaXB0IHNyYz1cInVuZGVyc2NvcmUuanNcIj48L3NjcmlwdD5cbi8vIDxzY3JpcHQgc3JjPVwiYmFja2JvbmUuanNcIj48L3NjcmlwdD5cbi8vIDxzY3JpcHQgc3JjPVwiYmFja2JvbmUubXV0YXRvcnMuanNcIj48L3NjcmlwdD5cbi8vXG4vLyBOb2RlOlxuLy8gdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xuLy8gdmFyIE11dGF0b3JzID0gcmVxdWlyZSgnYmFja2JvbmUubXV0YXRvcnMnKTtcbi8vXG4vL1xuLy8gQU1EOlxuLy8gZGVmaW5lKFsndW5kZXJzY29yZScsICdiYWNrYm9uZScsICdiYWNrYm9uZS5tdXRhdG9ycyddLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIE11dGF0b3JzKSB7XG4vLyAgICAvLyBpbnNlcnQgc2FtcGxlIGZyb20gYmVsb3dcbi8vICAgIHJldHVybiBVc2VyO1xuLy8gfSk7XG4vL1xuLy8gdmFyIFVzZXIgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuLy8gICAgbXV0YXRvcnM6IHtcbi8vICAgICAgICBmdWxsbmFtZTogZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdG5hbWUgKyAnICcgKyB0aGlzLmxhc3RuYW1lO1xuLy8gICAgICAgIH1cbi8vICAgIH0sXG4vL1xuLy8gICAgZGVmYXVsdHM6IHtcbi8vICAgICAgICBmaXJzdG5hbWU6ICdTZWJhc3RpYW4nLFxuLy8gICAgICAgIGxhc3RuYW1lOiAnR29sYXNjaCdcbi8vICAgIH1cbi8vIH0pO1xuLy9cbi8vIHZhciB1c2VyID0gbmV3IFVzZXIoKTtcbi8vIHVzZXIuZ2V0KCdmdWxsbmFtZScpIC8vIHJldHVybnMgJ1NlYmFzdGlhbiBHb2xhc2NoJ1xuLy8gdXNlci50b0pTT04oKSAvLyByZXR1cm4gJ3tmaXJzdG5hbWU6ICdTZWJhc3RpYW4nLCBsYXN0bmFtZTogJ0dvbGFzY2gnLCBmdWxsbmFtZTogJ1NlYmFzdGlhbiBHb2xhc2NoJ30nXG5cbn0odGhpcywgZnVuY3Rpb24gKF8sIEJhY2tib25lLCByb290LCB1bmRlZikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIGNoZWNrIGlmIHdlIHVzZSB0aGUgYW1kIGJyYW5jaCBvZiBiYWNrYm9uZSBhbmQgdW5kZXJzY29yZVxuICAgIEJhY2tib25lID0gQmFja2JvbmUgPT09IHVuZGVmID8gcm9vdC5CYWNrYm9uZSA6IEJhY2tib25lO1xuICAgIF8gPSBfID09PSB1bmRlZiA/IHJvb3QuXyA6IF87XG5cbiAgICAvLyBleHRlbmQgYmFja2JvbmVzIG1vZGVsIHByb3RvdHlwZSB3aXRoIHRoZSBtdXRhdG9yIGZ1bmN0aW9uYWxpdHlcbiAgICB2YXIgTXV0YXRvciAgICAgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb2xkR2V0ICAgICAgPSBCYWNrYm9uZS5Nb2RlbC5wcm90b3R5cGUuZ2V0LFxuICAgICAgICBvbGRTZXQgICAgICA9IEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5zZXQsXG4gICAgICAgIG9sZFRvSnNvbiAgID0gQmFja2JvbmUuTW9kZWwucHJvdG90eXBlLnRvSlNPTjtcblxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IE1vZGVscyBkZWNsYXJlZCB3aXRob3V0IHRoZSBtdXRhdG9ycyBvYmplY3QgZG8gbm90IHRocm93IGFuZCBlcnJvclxuICAgIE11dGF0b3IucHJvdG90eXBlLm11dGF0b3JzID0ge307XG5cbiAgICAvLyBvdmVycmlkZSBnZXQgZnVuY3Rpb25hbGl0eSB0byBmZXRjaCB0aGUgbXV0YXRvciBwcm9wc1xuICAgIE11dGF0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHZhciBpc011dGF0b3IgPSB0aGlzLm11dGF0b3JzICE9PSB1bmRlZjtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgZ2V0dGVyIG11dGF0aW9uXG4gICAgICAgIGlmIChpc011dGF0b3IgPT09IHRydWUgJiYgXy5pc0Z1bmN0aW9uKHRoaXMubXV0YXRvcnNbYXR0cl0pID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yc1thdHRyXS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIGRlZXBlciBuZXN0ZWQgZ2V0dGVyIG11dGF0aW9uXG4gICAgICAgIGlmIChpc011dGF0b3IgPT09IHRydWUgJiYgXy5pc09iamVjdCh0aGlzLm11dGF0b3JzW2F0dHJdKSA9PT0gdHJ1ZSAmJiBfLmlzRnVuY3Rpb24odGhpcy5tdXRhdG9yc1thdHRyXS5nZXQpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yc1thdHRyXS5nZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbGRHZXQuY2FsbCh0aGlzLCBhdHRyKTtcbiAgICB9O1xuXG4gICAgLy8gb3ZlcnJpZGUgc2V0IGZ1bmN0aW9uYWxpdHkgdG8gc2V0IHRoZSBtdXRhdG9yIHByb3BzXG4gICAgTXV0YXRvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlzTXV0YXRvciA9IHRoaXMubXV0YXRvcnMgIT09IHVuZGVmLFxuICAgICAgICAgICAgcmV0ID0gbnVsbCxcbiAgICAgICAgICAgIGF0dHJzID0gbnVsbDtcblxuXHRcdHJldCA9IG9sZFNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIHNlYW1sZWFzc2x5IHN0b2xlbiBmcm9tIGJhY2tib25lIGNvcmVcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNldHRlciBhY3Rpb24gaXMgdHJpZ2dlcmVkXG4gICAgICAgIC8vIHVzaW5nIGtleSA8LT4gdmFsdWUgb3Igb2JqZWN0XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGtleSkgfHwga2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJzID0ge307XG4gICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgZGVlcGVyIG5lc3RlZCBzZXR0ZXIgbXV0YXRpb25cbiAgICAgICAgaWYgKGlzTXV0YXRvciA9PT0gdHJ1ZSAmJiBfLmlzT2JqZWN0KHRoaXMubXV0YXRvcnNba2V5XSkgPT09IHRydWUpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzZXQgYSBzaW5nbGUgdmFsdWVcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5tdXRhdG9yc1trZXldLnNldCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLm11dGF0b3JzW2tleV0uc2V0LmNhbGwodGhpcywga2V5LCBhdHRyc1trZXldLCBvcHRpb25zLCBfLmJpbmQob2xkU2V0LCB0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoXy5pc0Z1bmN0aW9uKHRoaXMubXV0YXRvcnNba2V5XSkpe1xuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMubXV0YXRvcnNba2V5XS5jYWxsKHRoaXMsIGtleSwgYXR0cnNba2V5XSwgb3B0aW9ucywgXy5iaW5kKG9sZFNldCwgdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTXV0YXRvciA9PT0gdHJ1ZSAmJiBfLmlzT2JqZWN0KGF0dHJzKSkge1xuICAgICAgICAgICAgXy5lYWNoKGF0dHJzLCBfLmJpbmQoZnVuY3Rpb24gKGF0dHIsIGF0dHJLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdCh0aGlzLm11dGF0b3JzW2F0dHJLZXldKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNldCBhIHNpbmdsZSB2YWx1ZVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gdGhpcy5tdXRhdG9yc1thdHRyS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYoXy5pc0Z1bmN0aW9uKG1ldGguc2V0KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRoID0gbWV0aC5zZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihfLmlzRnVuY3Rpb24obWV0aCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmIHx8IChfLmlzT2JqZWN0KG9wdGlvbnMpID09PSB0cnVlICYmIG9wdGlvbnMuc2lsZW50ICE9PSB0cnVlICYmIChvcHRpb25zLm11dGF0b3JzICE9PSB1bmRlZiAmJiBvcHRpb25zLm11dGF0b3JzLnNpbGVudCAhPT0gdHJ1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtdXRhdG9yczpzZXQ6JyArIGF0dHJLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aC5jYWxsKHRoaXMsIGF0dHJLZXksIGF0dHIsIG9wdGlvbnMsIF8uYmluZChvbGRTZXQsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLy8gb3ZlcnJpZGUgdG9KU09OIGZ1bmN0aW9uYWxpdHkgdG8gc2VyaWFsaXplIG11dGF0b3IgcHJvcGVydGllc1xuICAgIE11dGF0b3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGZldGNoIHllIG9sZGUgdmFsdWVzXG4gICAgICAgIHZhciBhdHRyID0gb2xkVG9Kc29uLmNhbGwodGhpcyksXG4gICAgICAgICAgICBpc1NhdmluZyxcbiAgICAgICAgICAgIGlzVHJhbnNpZW50O1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIG11dGF0b3JzIChpZiB0aGVyZSBhcmUgc29tZSlcbiAgICAgICAgXy5lYWNoKHRoaXMubXV0YXRvcnMsIF8uYmluZChmdW5jdGlvbiAobXV0YXRvciwgbmFtZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBzb21lIGdldHRlciBtdXRhdGlvbnNcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHRoaXMubXV0YXRvcnNbbmFtZV0pID09PSB0cnVlICYmIF8uaXNGdW5jdGlvbih0aGlzLm11dGF0b3JzW25hbWVdLmdldCkpIHtcbiAgICAgICAgICAgICAgICBpc1NhdmluZyA9ICh0aGlzLmlzU2F2aW5nKSA/IHRoaXMuaXNTYXZpbmcob3B0aW9ucywgbXV0YXRvciwgbmFtZSkgOiBfLmhhcyhvcHRpb25zIHx8IHt9LCAnZW11bGF0ZUhUVFAnKTtcbiAgICAgICAgICAgICAgICBpc1RyYW5zaWVudCA9IHRoaXMubXV0YXRvcnNbbmFtZV0udHJhbnNpZW50O1xuICAgICAgICAgICAgICAgIGlmICghaXNTYXZpbmcgfHwgIWlzVHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgICBhdHRyW25hbWVdID0gXy5iaW5kKHRoaXMubXV0YXRvcnNbbmFtZV0uZ2V0LCB0aGlzKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMubXV0YXRvcnNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgYXR0cltuYW1lXSA9IF8uYmluZCh0aGlzLm11dGF0b3JzW25hbWVdLCB0aGlzKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfTtcblxuICAgIC8vIG92ZXJyaWRlIGdldCBmdW5jdGlvbmFsaXR5IHRvIGdldCBIVE1MLWVzY2FwZWQgdGhlIG11dGF0b3IgcHJvcHNcbiAgICBNdXRhdG9yLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbiAoYXR0cil7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmdldChhdHRyKTtcbiAgICAgICAgcmV0dXJuIF8uZXNjYXBlKHZhbCA9PSBudWxsID8gJycgOiAnJyArIHZhbCk7XG4gICAgfTtcblxuICAgIC8vIGV4dGVuZCB0aGUgbW9kZWxzIHByb3RvdHlwZVxuICAgIF8uZXh0ZW5kKEJhY2tib25lLk1vZGVsLnByb3RvdHlwZSwgTXV0YXRvci5wcm90b3R5cGUpO1xuXG4gICAgLy8gbWFrZSBtdXRhdG9ycyBnbG9iYWxseSBhdmFpbGFibGUgdW5kZXIgdGhlIEJhY2tib25lIG5hbWVzcGFjZVxuICAgIEJhY2tib25lLk11dGF0b3JzID0gTXV0YXRvcjtcbiAgICByZXR1cm4gTXV0YXRvcjtcbn0pKTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuNC40XG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi5cbiAgdmFyIGJyZWFrZXIgPSB7fTtcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgICBjb25jYXQgICAgICAgICAgID0gQXJyYXlQcm90by5jb25jYXQsXG4gICAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVGb3JFYWNoICAgICAgPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgbmF0aXZlTWFwICAgICAgICAgID0gQXJyYXlQcm90by5tYXAsXG4gICAgbmF0aXZlUmVkdWNlICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2UsXG4gICAgbmF0aXZlUmVkdWNlUmlnaHQgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCxcbiAgICBuYXRpdmVGaWx0ZXIgICAgICAgPSBBcnJheVByb3RvLmZpbHRlcixcbiAgICBuYXRpdmVFdmVyeSAgICAgICAgPSBBcnJheVByb3RvLmV2ZXJ5LFxuICAgIG5hdGl2ZVNvbWUgICAgICAgICA9IEFycmF5UHJvdG8uc29tZSxcbiAgICBuYXRpdmVJbmRleE9mICAgICAgPSBBcnJheVByb3RvLmluZGV4T2YsXG4gICAgbmF0aXZlTGFzdEluZGV4T2YgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZixcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbiAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuNC40JztcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIG9iamVjdHMgd2l0aCB0aGUgYnVpbHQtaW4gYGZvckVhY2hgLCBhcnJheXMsIGFuZCByYXcgb2JqZWN0cy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZvckVhY2hgIGlmIGF2YWlsYWJsZS5cbiAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uaGFzKG9iaiwga2V5KSkge1xuICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGluZGV4ID0ga2V5cyA/IGtleXNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtpbmRleF07XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2luZGV4XSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiAhaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0sIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZXZlcnlgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlRXZlcnkgJiYgb2JqLmV2ZXJ5ID09PSBuYXRpdmVFdmVyeSkgcmV0dXJuIG9iai5ldmVyeShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICByZXR1cm4gYW55KG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzLCBmaXJzdCkge1xuICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKSByZXR1cm4gZmlyc3QgPyBudWxsIDogW107XG4gICAgcmV0dXJuIF9bZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10ob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRyc1trZXldICE9PSB2YWx1ZVtrZXldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLndoZXJlKG9iaiwgYXR0cnMsIHRydWUpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODA3OTdcbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogLUluZmluaXR5LCB2YWx1ZTogLUluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPj0gcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBvYmopO1xuICAgIH1cbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gSW5maW5pdHk7XG4gICAgdmFyIHJlc3VsdCA9IHtjb21wdXRlZCA6IEluZmluaXR5LCB2YWx1ZTogSW5maW5pdHl9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBjb21wdXRlZCA8IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYW4gYXJyYXkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByYW5kO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNodWZmbGVkID0gW107XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oaW5kZXgrKyk7XG4gICAgICBzaHVmZmxlZFtpbmRleCAtIDFdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBsb29rdXAgaXRlcmF0b3JzLlxuICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihvYmopeyByZXR1cm4gb2JqW3ZhbHVlXTsgfTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHZhciBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUgOiB2YWx1ZSxcbiAgICAgICAgaW5kZXggOiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWEgOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCA8IHJpZ2h0LmluZGV4ID8gLTEgOiAxO1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQsIGJlaGF2aW9yKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKHZhbHVlIHx8IF8uaWRlbnRpdHkpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgIGJlaGF2aW9yKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGdyb3VwKG9iaiwgdmFsdWUsIGNvbnRleHQsIGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgICAgKF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBncm91cChvYmosIHZhbHVlLCBjb250ZXh0LCBmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgICAgaWYgKCFfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldID0gMDtcbiAgICAgIHJlc3VsdFtrZXldKys7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3IgPT0gbnVsbCA/IF8uaWRlbnRpdHkgOiBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVttaWRdKSA8IHZhbHVlID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gU2FmZWx5IGNvbnZlcnQgYW55dGhpbmcgaXRlcmFibGUgaW50byBhIHJlYWwsIGxpdmUgYXJyYXkuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIChuICE9IG51bGwpICYmICFndWFyZCA/IHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pIDogYXJyYXlbMF07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxuICAvLyBgXy5tYXBgLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gKChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAoKG4gIT0gbnVsbCkgJiYgIWd1YXJkKSB7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgb3V0cHV0KSB7XG4gICAgZWFjaChpbnB1dCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHNoYWxsb3cgPyBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpIDogZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgb3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvbXBsZXRlbHkgZmxhdHRlbmVkIHZlcnNpb24gb2YgYW4gYXJyYXkuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRvcjtcbiAgICAgIGl0ZXJhdG9yID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSA6IGFycmF5O1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBlYWNoKGluaXRpYWwsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKGlzU29ydGVkID8gKCFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IHZhbHVlKSA6ICFfLmNvbnRhaW5zKHNlZW4sIHZhbHVlKSkge1xuICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICByZXN1bHRzLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBhcmd1bWVudHMpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoXy51bmlxKGFycmF5KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZXZlcnkocmVzdCwgZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZihvdGhlciwgaXRlbSkgPj0gMDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3MsICdsZW5ndGgnKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmdzLCBcIlwiICsgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBseSB1cyB3aXRoIGluZGV4T2YgKEknbSBsb29raW5nIGF0IHlvdSwgKipNU0lFKiopLFxuICAvLyB3ZSBuZWVkIHRoaXMgZnVuY3Rpb24uIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW5cbiAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gKGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGwgKyBpc1NvcnRlZCkgOiBpc1NvcnRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSwgaXNTb3J0ZWQpO1xuICAgIGZvciAoOyBpIDwgbDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbGFzdEluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaGFzSW5kZXggPSBmcm9tICE9IG51bGw7XG4gICAgaWYgKG5hdGl2ZUxhc3RJbmRleE9mICYmIGFycmF5Lmxhc3RJbmRleE9mID09PSBuYXRpdmVMYXN0SW5kZXhPZikge1xuICAgICAgcmV0dXJuIGhhc0luZGV4ID8gYXJyYXkubGFzdEluZGV4T2YoaXRlbSwgZnJvbSkgOiBhcnJheS5sYXN0SW5kZXhPZihpdGVtKTtcbiAgICB9XG4gICAgdmFyIGkgPSAoaGFzSW5kZXggPyBmcm9tIDogYXJyYXkubGVuZ3RoKTtcbiAgICB3aGlsZSAoaS0tKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgd2hpbGUoaWR4IDwgbGVuKSB7XG4gICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCAmJiBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhbGwgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0XG4gIC8vIGFsbCBjYWxsYmFja3MgZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkgZnVuY3MgPSBfLmZ1bmN0aW9ucyhvYmopO1xuICAgIGVhY2goZnVuY3MsIGZ1bmN0aW9uKGYpIHsgb2JqW2ZdID0gXy5iaW5kKG9ialtmXSwgb2JqKTsgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtbyA9IHt9O1xuICAgIGhhc2hlciB8fCAoaGFzaGVyID0gXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF8uaGFzKG1lbW8sIGtleSkgPyBtZW1vW2tleV0gOiAobWVtb1trZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gXy5kZWxheS5hcHBseShfLCBbZnVuYywgMV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgdGltZW91dCwgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG5ldyBEYXRlO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9O1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtmdW5jXTtcbiAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGZ1bmNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIGlmICh0aW1lcyA8PSAwKSByZXR1cm4gZnVuYygpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gbmF0aXZlS2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXNba2V5cy5sZW5ndGhdID0ga2V5O1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgdmFsdWVzLnB1c2gob2JqW2tleV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBwYWlycy5wdXNoKFtrZXksIG9ialtrZXldXSk7XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmVzdWx0W29ialtrZXldXSA9IGtleTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBlYWNoKGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSBpbiBvYmopIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICghXy5jb250YWlucyhrZXlzLCBrZXkpKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAob2JqW3Byb3BdID09IG51bGwpIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgSGFybW9ueSBgZWdhbGAgcHJvcG9zYWw6IGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbC5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuICAgIHZhciBzaXplID0gMCwgcmVzdWx0ID0gdHJ1ZTtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3Rgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIChhQ3RvciBpbnN0YW5jZW9mIGFDdG9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICBlc2NhcGU6IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAgICcvJzogJyYjeDJGOydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcHJvcGVydHkgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdDtcbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx0JzogICAgICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICAgIHZhciByZW5kZXI7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHsgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdOyB9KTtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcblxuICAgIHRyeSB7XG4gICAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHJldHVybiByZW5kZXIoZGF0YSwgXyk7XG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAoc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicpICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXyhvYmopLmNoYWluKCk7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09ICdzaGlmdCcgfHwgbmFtZSA9PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIF8uZXh0ZW5kKF8ucHJvdG90eXBlLCB7XG5cbiAgICAvLyBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gICAgY2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2hhaW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICAgIH1cblxuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEJhY2tib25lLkJhYnlTaXR0ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHYwLjEuMTFcbi8vXG4vLyBDb3B5cmlnaHQgKGMpMjAxNiBEZXJpY2sgQmFpbGV5LCBNdXRlZCBTb2x1dGlvbnMsIExMQy5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlXG4vL1xuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWFyaW9uZXR0ZWpzL2JhY2tib25lLmJhYnlzaXR0ZXJcblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnYmFja2JvbmUnLCAndW5kZXJzY29yZSddLCBmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoQmFja2JvbmUsIF8pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KEJhY2tib25lLCBfKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5KHJvb3QuQmFja2JvbmUsIHJvb3QuXyk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHByZXZpb3VzQ2hpbGRWaWV3Q29udGFpbmVyID0gQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyO1xuXG4gIC8vIEJhYnlTaXR0ZXIuQ2hpbGRWaWV3Q29udGFpbmVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIFByb3ZpZGUgYSBjb250YWluZXIgdG8gc3RvcmUsIHJldHJpZXZlIGFuZFxuICAvLyBzaHV0IGRvd24gY2hpbGQgdmlld3MuXG4gIFxuICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIgPSAoZnVuY3Rpb24gKEJhY2tib25lLCBfKSB7XG4gIFxuICAgIC8vIENvbnRhaW5lciBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgICB2YXIgQ29udGFpbmVyID0gZnVuY3Rpb24odmlld3Mpe1xuICAgICAgdGhpcy5fdmlld3MgPSB7fTtcbiAgICAgIHRoaXMuX2luZGV4QnlNb2RlbCA9IHt9O1xuICAgICAgdGhpcy5faW5kZXhCeUN1c3RvbSA9IHt9O1xuICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gIFxuICAgICAgXy5lYWNoKHZpZXdzLCB0aGlzLmFkZCwgdGhpcyk7XG4gICAgfTtcbiAgXG4gICAgLy8gQ29udGFpbmVyIE1ldGhvZHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgICBfLmV4dGVuZChDb250YWluZXIucHJvdG90eXBlLCB7XG4gIFxuICAgICAgLy8gQWRkIGEgdmlldyB0byB0aGlzIGNvbnRhaW5lci4gU3RvcmVzIHRoZSB2aWV3XG4gICAgICAvLyBieSBgY2lkYCBhbmQgbWFrZXMgaXQgc2VhcmNoYWJsZSBieSB0aGUgbW9kZWxcbiAgICAgIC8vIGNpZCAoYW5kIG1vZGVsIGl0c2VsZikuIE9wdGlvbmFsbHkgc3BlY2lmeVxuICAgICAgLy8gYSBjdXN0b20ga2V5IHRvIHN0b3JlIGFuIHJldHJpZXZlIHRoZSB2aWV3LlxuICAgICAgYWRkOiBmdW5jdGlvbih2aWV3LCBjdXN0b21JbmRleCl7XG4gICAgICAgIHZhciB2aWV3Q2lkID0gdmlldy5jaWQ7XG4gIFxuICAgICAgICAvLyBzdG9yZSB0aGUgdmlld1xuICAgICAgICB0aGlzLl92aWV3c1t2aWV3Q2lkXSA9IHZpZXc7XG4gIFxuICAgICAgICAvLyBpbmRleCBpdCBieSBtb2RlbFxuICAgICAgICBpZiAodmlldy5tb2RlbCl7XG4gICAgICAgICAgdGhpcy5faW5kZXhCeU1vZGVsW3ZpZXcubW9kZWwuY2lkXSA9IHZpZXdDaWQ7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGluZGV4IGJ5IGN1c3RvbVxuICAgICAgICBpZiAoY3VzdG9tSW5kZXgpe1xuICAgICAgICAgIHRoaXMuX2luZGV4QnlDdXN0b21bY3VzdG9tSW5kZXhdID0gdmlld0NpZDtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBGaW5kIGEgdmlldyBieSB0aGUgbW9kZWwgdGhhdCB3YXMgYXR0YWNoZWQgdG9cbiAgICAgIC8vIGl0LiBVc2VzIHRoZSBtb2RlbCdzIGBjaWRgIHRvIGZpbmQgaXQuXG4gICAgICBmaW5kQnlNb2RlbDogZnVuY3Rpb24obW9kZWwpe1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlNb2RlbENpZChtb2RlbC5jaWQpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBGaW5kIGEgdmlldyBieSB0aGUgYGNpZGAgb2YgdGhlIG1vZGVsIHRoYXQgd2FzIGF0dGFjaGVkIHRvXG4gICAgICAvLyBpdC4gVXNlcyB0aGUgbW9kZWwncyBgY2lkYCB0byBmaW5kIHRoZSB2aWV3IGBjaWRgIGFuZFxuICAgICAgLy8gcmV0cmlldmUgdGhlIHZpZXcgdXNpbmcgaXQuXG4gICAgICBmaW5kQnlNb2RlbENpZDogZnVuY3Rpb24obW9kZWxDaWQpe1xuICAgICAgICB2YXIgdmlld0NpZCA9IHRoaXMuX2luZGV4QnlNb2RlbFttb2RlbENpZF07XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRCeUNpZCh2aWV3Q2lkKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gRmluZCBhIHZpZXcgYnkgYSBjdXN0b20gaW5kZXhlci5cbiAgICAgIGZpbmRCeUN1c3RvbTogZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgdmlld0NpZCA9IHRoaXMuX2luZGV4QnlDdXN0b21baW5kZXhdO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlDaWQodmlld0NpZCk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEZpbmQgYnkgaW5kZXguIFRoaXMgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYVxuICAgICAgLy8gc3RhYmxlIGluZGV4LlxuICAgICAgZmluZEJ5SW5kZXg6IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX3ZpZXdzKVtpbmRleF07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIHJldHJpZXZlIGEgdmlldyBieSBpdHMgYGNpZGAgZGlyZWN0bHlcbiAgICAgIGZpbmRCeUNpZDogZnVuY3Rpb24oY2lkKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdzW2NpZF07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIFJlbW92ZSBhIHZpZXdcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24odmlldyl7XG4gICAgICAgIHZhciB2aWV3Q2lkID0gdmlldy5jaWQ7XG4gIFxuICAgICAgICAvLyBkZWxldGUgbW9kZWwgaW5kZXhcbiAgICAgICAgaWYgKHZpZXcubW9kZWwpe1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRleEJ5TW9kZWxbdmlldy5tb2RlbC5jaWRdO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBkZWxldGUgY3VzdG9tIGluZGV4XG4gICAgICAgIF8uYW55KHRoaXMuX2luZGV4QnlDdXN0b20sIGZ1bmN0aW9uKGNpZCwga2V5KSB7XG4gICAgICAgICAgaWYgKGNpZCA9PT0gdmlld0NpZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4QnlDdXN0b21ba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgICAvLyByZW1vdmUgdGhlIHZpZXcgZnJvbSB0aGUgY29udGFpbmVyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl92aWV3c1t2aWV3Q2lkXTtcbiAgXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbGVuZ3RoXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlbmd0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQ2FsbCBhIG1ldGhvZCBvbiBldmVyeSB2aWV3IGluIHRoZSBjb250YWluZXIsXG4gICAgICAvLyBwYXNzaW5nIHBhcmFtZXRlcnMgdG8gdGhlIGNhbGwgbWV0aG9kIG9uZSBhdCBhXG4gICAgICAvLyB0aW1lLCBsaWtlIGBmdW5jdGlvbi5jYWxsYC5cbiAgICAgIGNhbGw6IGZ1bmN0aW9uKG1ldGhvZCl7XG4gICAgICAgIHRoaXMuYXBwbHkobWV0aG9kLCBfLnRhaWwoYXJndW1lbnRzKSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEFwcGx5IGEgbWV0aG9kIG9uIGV2ZXJ5IHZpZXcgaW4gdGhlIGNvbnRhaW5lcixcbiAgICAgIC8vIHBhc3NpbmcgcGFyYW1ldGVycyB0byB0aGUgY2FsbCBtZXRob2Qgb25lIGF0IGFcbiAgICAgIC8vIHRpbWUsIGxpa2UgYGZ1bmN0aW9uLmFwcGx5YC5cbiAgICAgIGFwcGx5OiBmdW5jdGlvbihtZXRob2QsIGFyZ3Mpe1xuICAgICAgICBfLmVhY2godGhpcy5fdmlld3MsIGZ1bmN0aW9uKHZpZXcpe1xuICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odmlld1ttZXRob2RdKSl7XG4gICAgICAgICAgICB2aWV3W21ldGhvZF0uYXBwbHkodmlldywgYXJncyB8fCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gVXBkYXRlIHRoZSBgLmxlbmd0aGAgYXR0cmlidXRlIG9uIHRoaXMgY29udGFpbmVyXG4gICAgICBfdXBkYXRlTGVuZ3RoOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmxlbmd0aCA9IF8uc2l6ZSh0aGlzLl92aWV3cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIC8vIEJvcnJvd2luZyB0aGlzIGNvZGUgZnJvbSBCYWNrYm9uZS5Db2xsZWN0aW9uOlxuICAgIC8vIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy9kb2NzL2JhY2tib25lLmh0bWwjc2VjdGlvbi0xMDZcbiAgICAvL1xuICAgIC8vIE1peCBpbiBtZXRob2RzIGZyb20gVW5kZXJzY29yZSwgZm9yIGl0ZXJhdGlvbiwgYW5kIG90aGVyXG4gICAgLy8gY29sbGVjdGlvbiByZWxhdGVkIGZlYXR1cmVzLlxuICAgIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsXG4gICAgICAnc2VsZWN0JywgJ3JlamVjdCcsICdldmVyeScsICdhbGwnLCAnc29tZScsICdhbnknLCAnaW5jbHVkZScsXG4gICAgICAnY29udGFpbnMnLCAnaW52b2tlJywgJ3RvQXJyYXknLCAnZmlyc3QnLCAnaW5pdGlhbCcsICdyZXN0JyxcbiAgICAgICdsYXN0JywgJ3dpdGhvdXQnLCAnaXNFbXB0eScsICdwbHVjaycsICdyZWR1Y2UnXTtcbiAgXG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgQ29udGFpbmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aWV3cyA9IF8udmFsdWVzKHRoaXMuX3ZpZXdzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdmlld3NdLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICBcbiAgICAvLyByZXR1cm4gdGhlIHB1YmxpYyBBUElcbiAgICByZXR1cm4gQ29udGFpbmVyO1xuICB9KShCYWNrYm9uZSwgXyk7XG4gIFxuXG4gIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lci5WRVJTSU9OID0gJzAuMS4xMSc7XG5cbiAgQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyID0gcHJldmlvdXNDaGlsZFZpZXdDb250YWluZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lcjtcblxufSkpO1xuIiwiLyoqXG4gKiBCYWNrYm9uZS5OYXRpdmVcbiAqXG4gKiBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9pbmtsaW5nL2JhY2tib25lLm5hdGl2ZVxuICpcbiAqIENvcHlyaWdodCAyMDEzIElua2xpbmcgU3lzdGVtcywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbGlicmFyeSBpcyB0byBhbGxvdyBCYWNrYm9uZSB0byB3b3JrIHdpdGhvdXQgbmVlZGluZyB0byBsb2FkIGpRdWVyeSBvciBaZXB0by5cbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBhIGJhc2ljIGpRdWVyeS1saWtlIGltcGxlbWVudGF0aW9uIGZvciBCYWNrYm9uZSwgaW1wbGVtZW50aW5nIHRoZVxuICogbWluaW11bSBmdW5jdGlvbmFsaXR5IGZvciBCYWNrYm9uZSB0byBmdW5jdGlvbi4gV2UgYXNzdW1lIHRoYXQgQmFja2JvbmUgYXBwbGljYXRpb25zIHVzaW5nXG4gKiB0aGlzIHdpbGwgbm90IGV4cGVjdCB0aGUgc3RhbmRhcmQgalF1ZXJ5IEFQSSB0byB3b3JrLCBhbmQgd2lsbCBpbnN0ZWFkIHVzZSBuYXRpdmUgSlMgZnVuY3Rpb25zLlxuICpcbiAqIEtlZXAgaW4gbWluZCB0aGF0IGR1ZSB0byB0aGUgQVBJcyBpbiB0aGlzLCBpdCB3aWxsIGxpa2VseSBvbmx5IHdvcmsgb24gcmVjZW50IGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6XG4gKiAgLSBDb3JlIEJhY2tib25lIG9ubHkgbmVlZHMgY29sbGVjdGlvbnMgd2l0aCBzaW5nbGUgbWVtYmVycywgc28gdGhhdCBpcyBhbGwgdGhhdCBoYXMgYmVlblxuICogICAgICBzdXBwb3J0ZWQgaW4gdGhpcyBsaWJyYXJ5LiBJdCBpcyBleHBlY3RlZCB0aGF0IHlvdSB3aWxsIGp1c3QgdXNlIHF1ZXJ5U2VsZWN0b3JBbGwgaW5zdGVhZC5cbiAqICAgICAgVGhpcyB3aWxsIGJlIG1vc3Qgb2J2aW91cyBpZiB5b3UgbWFrZSBoZWF2eSB1c2Ugb2YgJ3ZpZXcuJCcuXG4gKiAgLSBFdmVudHMgZGVsZWdhdGVkIHdpdGggc2VsZWN0b3JzIHN0YXJ0aW5nIHdpdGggJz4nIGFyZSBub3Qgc3VwcG9ydGVkLlxuICogIC0gRHVlIHRvICdjdXJyZW50VGFyZ2V0JyBiZWluZyByZWFkLW9ubHkgb24gc3RhbmRhcmQgRE9NIGV2ZW50cywgd2UgY2Fubm90IG1ha2Ugc3RhbmRhcmRcbiAqICAgICAgZXZlbnRzIGJlaGF2ZSBpZGVudGljYWxseSB0byBqUXVlcnkncyBldmVudHMgd2hlbiBkZWxlZ2F0aW9uIGlzIHVzZWQuIFRoZSBlbGVtZW50IG1hdGNoaW5nXG4gKiAgICAgIHRoZSBkZWxlZ2F0ZSBzZWxlY3RvciBpcyBpbnN0ZWFkIHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGV2ZW50IGhhbmRsZXJzLlxuICogIC0gVGhlICckLmFqYXgnIGltcGxlbWVudGF0aW9uIGlzIHZlcnkgc2ltcGxlIGFuZCBsaWtlbHkgbmVlZHMgdG8gYmUgZXhwYW5kZWQgdG8gYmV0dGVyIHN1cHBvcnRcbiAqICAgICAgc3RhbmRhcmQgdXNlLWNhc2VzLlxuICpcbiAqIFRlc3RlZCB3aXRoIEJhY2tib25lIHYwLjkuMiBhbmQgMS4wLjAuXG4gKi9cbihmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFuIGV2ZW50IG5hbWUgYW5kL29yIGEgbmFtZXNwYWNlLlxuICAgIHZhciBuYW1lc3BhY2VSRSA9IC9eKFteLl0rKT8oPzpcXC4oW14uXSspKT8kLztcblxuICAgIHZhciBtYXRjaGVzU2VsZWN0b3IgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgbnVsbDtcbiAgICBpZiAoIW1hdGNoZXNTZWxlY3Rvcil7XG4gICAgICAgIFsnd2Via2l0JywgJ21veicsICdvJywgJ21zJ10uZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpe1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBFbGVtZW50LnByb3RvdHlwZVtwcmVmaXggKyAnTWF0Y2hlc1NlbGVjdG9yJ107XG4gICAgICAgICAgICBpZiAoZnVuYykgbWF0Y2hlc1NlbGVjdG9yID0gZnVuYztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGVsZW1lbnQgcHJvcGVydHkgdG8gc2F2ZSB0aGUgY2FjaGUga2V5IG9uLlxuICAgIHZhciBjYWNoZUtleVByb3AgPSAnYmFja2JvbmVOYXRpdmVLZXknICsgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgaWQgPSAxO1xuICAgIHZhciBoYW5kbGVycyA9IHt9O1xuICAgIHZhciB1bnVzZWRLZXlzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV2ZW50IGhhbmRsZXJzIGZvciBhIGdpdmVuIGVsZW1lbnQsIGNyZWF0aW5nIGFuIGVtcHR5IHNldCBpZiBvbmUgZG9lc24ndCBleGlzdC5cbiAgICAgKlxuICAgICAqIFRvIGF2b2lkIGNvbnN0YW50bHkgZmlsbGluZyB0aGUgaGFuZGxlcnMgb2JqZWN0IHdpdGggbnVsbCB2YWx1ZXMsIHdlIHJldXNlIG9sZCBJRHMgdGhhdFxuICAgICAqIGhhdmUgYmVlbiBjcmVhdGVkIGFuZCB0aGVuIGNsZWFyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRvIGdldCBoYW5kbGVycyBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgaGFuZGxlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlcnNGb3IoZWwpe1xuICAgICAgICBpZiAoIWVsW2NhY2hlS2V5UHJvcF0pe1xuICAgICAgICAgICAgLy8gUGljayBhIG5ldyBrZXksIGZyb20gdGhlIHVudXNlZCBwb29sLCBvciBtYWtlIGEgbmV3IG9uZS5cbiAgICAgICAgICAgIGVsW2NhY2hlS2V5UHJvcF0gPSB1bnVzZWRLZXlzLmxlbmd0aCA9PT0gMCA/ICsraWQgOiB1bnVzZWRLZXlzLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gZWxbY2FjaGVLZXlQcm9wXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2NhY2hlS2V5XSB8fCAoaGFuZGxlcnNbY2FjaGVLZXldID0gW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBldmVudCBoYW5kbGVycyBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBjbGVhci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhckhhbmRsZXJzKGVsKXtcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gZWxbY2FjaGVLZXlQcm9wXTtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2NhY2hlS2V5XSl7XG4gICAgICAgICAgICBoYW5kbGVyc1tjYWNoZUtleV0gPSBudWxsO1xuICAgICAgICAgICAgZWxbY2FjaGVLZXlQcm9wXSA9IG51bGw7XG4gICAgICAgICAgICB1bnVzZWRLZXlzLnB1c2goY2FjaGVLZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGV2ZW50IGhhbmRsZXJzIHRvIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudEVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYmluZCBldmVudCBoYW5kbGVycyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCB0byBiaW5kLCBlLmcuICdjbGljaycuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIChPcHRpb25hbCkgVGhlIHNlbGVjdG9yIHRvIG1hdGNoIHdoZW4gYW4gZXZlbnQgcHJvcGFnYXRlcyB1cC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50LCBFbGVtZW50KX0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb24ocGFyZW50RWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3RvciwgY2FsbGJhY2spe1xuICAgICAgICAvLyBBZGp1c3QgYXJndW1lbnRzIGlmIHNlbGVjdG9yIHdhcyBub3QgcHJvdmlkZWQuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWVzcGFjZVJFLmV4ZWMoZXZlbnROYW1lKTtcbiAgICAgICAgZXZlbnROYW1lID0gcGFydHNbMV0gfHwgbnVsbDtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHBhcnRzWzJdIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHJldHVybjtcblxuICAgICAgICB2YXIgaGFuZGxlciA9IGNhbGxiYWNrO1xuICAgICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAoc2VsZWN0b3Ipe1xuICAgICAgICAgICAgLy8gRXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyIHRvIG1hdGNoIGEgc2VsZWN0b3IgZm9yIGNoaWxkIGVsZW1lbnQgZXZlbnRzLlxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlbCA9IGV2ZW50LnRhcmdldDsgZWwgJiYgZWwgIT09IHBhcmVudEVsZW1lbnQ7IGVsID0gZWwucGFyZW50RWxlbWVudCl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzU2VsZWN0b3IuY2FsbChlbCwgc2VsZWN0b3IpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBkb2VzIG5vdCBpbmNsdWRlIHRoZSBzZWNvbmQgYXJndW1lbnQsIGJ1dCB3ZSBoYXZlIGluY2x1ZGVkIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2ltcGxpY2l0eSBiZWNhdXNlICd0aGlzJyB3aWxsIGxpa2VseSBiZSBib3VuZCB0byB0aGUgdmlldyBpbnNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjaywgYW5kIGFzIG5vdGVkIGFib3ZlLCB3ZSBjYW5ub3Qgb3ZlcnJpZGUgJ2N1cnJlbnRUYXJnZXQnLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsQ2FsbGJhY2suY2FsbChlbCwgZXZlbnQsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGFuZGFyZCBldmVudCBoYW5kbGVyIGJvdW5kIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWxDYWxsYmFjay5jYWxsKHBhcmVudEVsZW1lbnQsIGV2ZW50LCBwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcblxuICAgICAgICAvLyBTYXZlIGV2ZW50IGhhbmRsZXIgbWV0YWRhdGEgc28gdGhhdCB0aGUgaGFuZGxlciBjYW4gYmUgdW5ib3VuZCBsYXRlci5cbiAgICAgICAgaGFuZGxlcnNGb3IocGFyZW50RWxlbWVudCkucHVzaCh7XG4gICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlciBmcm9tIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudEVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdW5iaW5kIGV2ZW50IGhhbmRsZXJzIGZyb20uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAoT3B0aW9uYWwpIFRoZSBldmVudCB0byB1bmJpbmQsIGUuZy4gJ2NsaWNrJy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgKE9wdGlvbmFsKSBUaGUgc2VsZWN0b3IgdG8gdW5iaW5kLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQsIEVsZW1lbnQpfSBjYWxsYmFjayAoT3B0aW9uYWwpIFRoZSBmdW5jdGlvbiB0byB1bmJpbmQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2ZmKHBhcmVudEVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnRzID0gbmFtZXNwYWNlUkUuZXhlYyhldmVudE5hbWUgfHwgJycpO1xuICAgICAgICBldmVudE5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHBhcnRzWzJdO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBoYW5kbGVyc0ZvcihwYXJlbnRFbGVtZW50KSB8fCBbXTtcblxuICAgICAgICBpZiAoIWV2ZW50TmFtZSAmJiAhbmFtZXNwYWNlICYmICFzZWxlY3RvciAmJiAhY2FsbGJhY2spe1xuICAgICAgICAgICAgLy8gRmFzdHBhdGggdG8gcmVtb3ZlIGFsbCBoYW5kbGVycy5cbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGl0ZW0uZXZlbnROYW1lLCBpdGVtLmhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xlYXJIYW5kbGVycyhwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkSGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoIW5hbWVzcGFjZSB8fCBpdGVtLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWV2ZW50TmFtZSB8fCBpdGVtLmV2ZW50TmFtZSA9PT0gZXZlbnROYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWNhbGxiYWNrIHx8IGl0ZW0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXNlbGVjdG9yIHx8IGl0ZW0uc2VsZWN0b3IgPT09IHNlbGVjdG9yKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGl0ZW0uZXZlbnROYW1lLCBpdGVtLmhhbmRsZXIsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5pbmRleE9mKGl0ZW0pLCAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSBjbGVhckhhbmRsZXJzKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IGpRdWVyeS1zdHlsZSBlbGVtZW50IHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudHxXaW5kb3d9IGVsZW1lbnQgVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHBvc3NpYmxlIHZhbHVlcyBmb3IgdGhpc1xuICAgICAqICAgICAgYXJndW1lbnQ6XG4gICAgICogICAgICAtIHtzdHJpbmd9IEEgc25pcHBldCBvZiBIVE1MLCBpZiBpdCBzdGFydHMgd2l0aCBhICc8Jywgb3IgYSBzZWxlY3RvciB0byBmaW5kLlxuICAgICAqICAgICAgLSB7RWxlbWVudH0gQW4gZXhpc3RpbmcgZWxlbWVudCB0byB3cmFwLlxuICAgICAqICAgICAgLSB7V2luZG93fSBUaGUgd2luZG93IG9iamVjdCB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dCBUaGUgY29udGV4dCB0byBzZWFyY2ggd2l0aGluLCBpZiBhIHNlbGVjdG9yIHdhcyBnaXZlbi5cbiAgICAgKiAgICAgIERlZmF1bHRzIHRvIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uICQoZWxlbWVudCwgY29udGV4dCl7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgIC8vIENhbGwgYXMgYSBjb25zdHJ1Y3RvciBpZiBpdCB3YXMgdXNlZCBhcyBhIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgJCkpIHJldHVybiBuZXcgJChlbGVtZW50LCBjb250ZXh0KTtcblxuICAgICAgICBpZiAoIWVsZW1lbnQpe1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICBpZiAoL15cXHMqPC8udGVzdChlbGVtZW50KSl7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYXJiaXRyYXJ5IEhUTUwgaW50byBhbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzWzBdID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIGJvdGggdGhlICdFbGVtZW50JyBhbmQgJ1dpbmRvdycgY2FzZSwgYXMgYm90aCBzdXBwb3J0XG4gICAgICAgICAgICAvLyBldmVudCBiaW5kaW5nIHZpYSAnYWRkRXZlbnRMaXN0ZW5lcicuXG4gICAgICAgICAgICB0aGlzWzBdID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIGJ5IEJhY2tib25lLCBidXQgb25seSBpbiBjb2RlLXBhdGhzIGZvciBJRSA2Lzcgc3VwcG9ydC5cbiAgICAgICAgICogU2luY2Ugbm9uZSBvZiB0aGlzIHdpbGwgd29yayBmb3Igb2xkIElFIGFueXdheSwgdGhleSBhcmUgbm90IGltcGxlbWVudGVkLCBhbmRcbiAgICAgICAgICogaW5zdGVhZCBsZWZ0IGZvciBkb2N1bWVudGF0aW9uIHB1cnBvc2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VkIGluIEJhY2tib25lLkhpc3RvcnkucHJvdG90eXBlLnN0YXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZTogbnVsbCxcbiAgICAgICAgYXBwZW5kVG86IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgaXMgbm90IHN1cHBvcnRlZCB0byBlbmNvdXJhZ2UgdGhlIHVzZSBvZiBxdWVyeVNlbGVjdG9yKEFsbCkgYXMgYW4gYWx0ZXJuYXRpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIGUuZy5cbiAgICAgICAgICogSW5zdGVhZCBvZiAndGhpcy4kKHNlbCknLCB1c2UgJ3RoaXMuZWwucXVlcnlTZWxlY3RvckFsbChzZWwpJy5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZCBpbiBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS4kLCBidXQgbm90IGFjdHVhbGx5IGNhbGxlZCBpbnRlcm5hbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGF0dHJpYnV0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWQgaW4gQmFja2JvbmUuVmlldy5wcm90b3R5cGUubWFrZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgQSBzZXQgb2YgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7JH0gVGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKGF0dHJzKXtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpe1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXR0cil7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1swXS5pbm5lckhUTUwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0udGV4dENvbnRlbnQgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLmNsYXNzTmFtZSA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgZWxlbWVudC4gQmFja2JvbmUgZG9lcyBub3QgdXNlIHRoZSBuby1hcmd1bWVudCB2ZXJzaW9uXG4gICAgICAgICAqIHRvIHJlYWQgaW5uZXJIVE1MLCBzbyB0aGF0IGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZCBpbiBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5tYWtlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBUaGUgSFRNTCB0byBzZXQgYXMgdGhlIGVsZW1lbnQgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7JH0gVGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGh0bWw6IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgICAgICAgdGhpc1swXS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBib3VuZCB0byBpdCBhbmRcbiAgICAgICAgICogaXRzIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VkIGluIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7JH0gVGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXNbMF07XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50RWxlbWVudCkgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG5cbiAgICAgICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnQgaGFuZGxlcnMgb24gdGhlIGVsZW1lbnQgYW5kIGNoaWxkcmVuLlxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlbW92ZUNoaWxkRXZlbnRzKGVsZW1lbnQpe1xuICAgICAgICAgICAgICAgIG9mZihlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZEV2ZW50cyhlbGVtZW50LmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmluZCBhbiBldmVudCBoYW5kbGVyIHRvIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gYmluZCwgZS5nLiAnY2xpY2snLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgKE9wdGlvbmFsKSBUaGUgc2VsZWN0b3IgdG8gbWF0Y2ggd2hlbiBhbiBldmVudCBwcm9wYWdhdGVzIHVwLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50LCBFbGVtZW50KX0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBzZWxlY3RvciwgY2FsbGJhY2spe1xuICAgICAgICAgICAgb24odGhpc1swXSwgZXZlbnROYW1lLCBzZWxlY3RvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZCBhbiBldmVudCBoYW5kbGVyIHRvIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAoT3B0aW9uYWwpIFRoZSBldmVudCB0byB1bmJpbmQsIGUuZy4gJ2NsaWNrJy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIChPcHRpb25hbCkgVGhlIHNlbGVjdG9yIHRvIHVuYmluZC5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCwgRWxlbWVudCl9IGNhbGxiYWNrIChPcHRpb25hbCkgVGhlIGZ1bmN0aW9uIHRvIHVuYmluZC5cbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24oZXZlbnROYW1lLCBzZWxlY3RvciwgY2FsbGJhY2spe1xuICAgICAgICAgICAgb2ZmKHRoaXNbMF0sIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEJhY2tib25lIHYwLjkuMiBzdXBwb3J0LlxuICAgICAgICBiaW5kOiBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50TmFtZSwgY2FsbGJhY2spe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBzZWxlY3RvciwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbihzZWxlY3RvciwgZXZlbnROYW1lLCBjYWxsYmFjayl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBzZWxlY3RvciwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gQUpBWCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgY29ubmVjdGlvbjpcbiAgICAgKiAgICAgIC0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gY29ubmVjdCB0by5cbiAgICAgKiAgICAgIC0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiByZXF1ZXN0LCBlLmcuICdHRVQnLCBvciAnUE9TVCcuXG4gICAgICogICAgICAtIHtzdHJpbmd9IGRhdGFUeXBlIFRoZSB0eXBlIG9mIGRhdGEgZXhwZWN0ZWQsICdqc29uJy5cbiAgICAgKiAgICAgIC0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQtdHlwZSBvZiB0aGUgZGF0YS5cbiAgICAgKiAgICAgIC0ge3N0cmluZ3xvYmplY3R9IGRhdGEgVGhlIGNvbnRlbnQgdG8gc2VuZC5cbiAgICAgKiAgICAgIC0ge2Z1bmN0aW9uKFhNTEh0dHBSZXF1ZXN0KX0gYmVmb3JlU2VuZCBBIGNhbGxiYWNrIHRvIGNhbGwgYmVmb3JlIHNlbmRpbmcuXG4gICAgICogICAgICAtIHtib29sZWFufSBwcm9jZXNzRGF0YSBUcnVlIGlmICdkYXRhJyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgICogICAgICAgICAgdG8gYSBxdWVyeSBzdHJpbmcgZnJvbSBhbiBvYmplY3QuXG4gICAgICogICAgICAtIHtmdW5jdGlvbih7c3RyaW5nfG9iamVjdH0sIHtzdHJpbmd9LCB7WE1MSHR0cFJlcXVlc3R9KX0gc3VjY2VzcyBUaGUgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiAgICAgIC0ge2Z1bmN0aW9uKHtYTUxIdHRwUmVxdWVzdH0pfSBlcnJvciBUaGUgZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgJC5hamF4ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCAnR0VUJztcbiAgICAgICAgdmFyIHVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICB2YXIgcHJvY2Vzc0RhdGEgPSBvcHRpb25zLnByb2Nlc3NEYXRhID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHRpb25zLnByb2Nlc3NEYXRhO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGRhdGEgZm9yIHNlbmRpbmcuXG4gICAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICBpZiAocHJvY2Vzc0RhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKXtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhkYXRhKS5tYXAoZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwcm9wKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhW3Byb3BdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YSA9IHBhcmFtcy5qb2luKCcmJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEYXRhIGZvciBHRVQgYW5kIEhFQUQgZ29lcyBpbiB0aGUgVVJMLlxuICAgICAgICBpZiAoZGF0YSAmJiAodHlwZSA9PT0gJ0dFVCcgfHwgdHlwZSA9PT0gJ0hFQUQnKSl7XG4gICAgICAgICAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3Blbih0eXBlLCB1cmwsIHRydWUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlKSB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgb3B0aW9ucy5jb250ZW50VHlwZSk7XG4gICAgICAgIGlmIChvcHRpb25zLmJlZm9yZVNlbmQpIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpO1xuXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBKU09OIGJlZm9yZSBjYWxsaW5nIHN1Y2Nlc3MuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhVHlwZSA9PT0gJ2pzb24nKXtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVycm9yICYmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSl7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhc3QgdHdvIGFyZ3VtZW50cyBvbmx5IGFwcGx5IHRvIHYwLjkuMi5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSBvcHRpb25zLnN1Y2Nlc3MoY29udGVudCwgeGhyLnN0YXR1c1RleHQsIHhocik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGlzIGluY29uc2lzdGVudCB3aXRoIHYwLjkuMiwgYnV0IGlzIGNvcnJlY3QgZm9yIDEuMC4wLlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSBvcHRpb25zLmVycm9yKHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSBvcHRpb25zLmVycm9yKHhocik7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIG9uL29mZiBmb3IgZXh0ZXJuYWwgdXNlIHdpdGggaGF2aW5nIHRvIGluc3RhbnRpYXRlIGEgd3JhcHBlci5cbiAgICAkLm9uID0gb247XG4gICAgJC5vZmYgPSBvZmY7XG5cbiAgICBpZih0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9ICQ7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgIHZhciBvcmlnaW5hbEJhY2tib25lTmF0aXZlID0gcm9vdC5CYWNrYm9uZSA/IHJvb3QuQmFja2JvbmUuTmF0aXZlIDogbnVsbDtcbiAgICB2YXIgb3JpZ2luYWwkID0gcm9vdC4kO1xuICAgIGlmIChyb290LkJhY2tib25lKSByb290LkJhY2tib25lLk5hdGl2ZSA9ICQ7XG4gICAgcm9vdC4kID0gJDtcblxuICAgICQubm9Db25mbGljdCA9IGZ1bmN0aW9uKGRlZXApe1xuICAgICAgICByb290LiQgPSBvcmlnaW5hbCQ7XG4gICAgICAgIGlmIChkZWVwKSByb290LkJhY2tib25lLk5hdGl2ZSA9IG9yaWdpbmFsQmFja2JvbmVOYXRpdmU7XG4gICAgICAgIHJldHVybiAkO1xuICAgIH07XG5cbiAgICBpZiAocm9vdC5CYWNrYm9uZSl7XG4gICAgICAgIGlmIChyb290LkJhY2tib25lLnNldERvbUxpYnJhcnkpeyAvLyB2MC45LjJcbiAgICAgICAgICAgIHJvb3QuQmFja2JvbmUuc2V0RG9tTGlicmFyeSgkKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gdjEuMC4wXG4gICAgICAgICAgICByb290LkJhY2tib25lLiQgPSAkO1xuICAgICAgICB9XG4gICAgfVxufSkuY2FsbCh0aGlzKTtcbiIsIi8vICAgICBCYWNrYm9uZS5qcyAxLjEuMlxuXG4vLyAgICAgKGMpIDIwMTAtMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIEJhY2tib25lIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjpcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBTZXQgdXAgQmFja2JvbmUgYXBwcm9wcmlhdGVseSBmb3IgdGhlIGVudmlyb25tZW50LiBTdGFydCB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xuICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICB9KTtcblxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfKTtcblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIHt9LCByb290Ll8sIChyb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKSk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgbG9jYWwgcmVmZXJlbmNlcyB0byBhcnJheSBtZXRob2RzIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgYXJyYXkgPSBbXTtcbiAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiAgdmFyIHNwbGljZSA9IGFycmF5LnNwbGljZTtcblxuICAvLyBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuIEtlZXAgaW4gc3luYyB3aXRoIGBwYWNrYWdlLmpzb25gLlxuICBCYWNrYm9uZS5WRVJTSU9OID0gJzEuMS4yJztcblxuICAvLyBGb3IgQmFja2JvbmUncyBwdXJwb3NlcywgalF1ZXJ5LCBaZXB0bywgRW5kZXIsIG9yIE15IExpYnJhcnkgKGtpZGRpbmcpIG93bnNcbiAgLy8gdGhlIGAkYCB2YXJpYWJsZS5cbiAgQmFja2JvbmUuJCA9ICQ7XG5cbiAgLy8gUnVucyBCYWNrYm9uZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlXG4gIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cbiAgQmFja2JvbmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuQmFja2JvbmUgPSBwcmV2aW91c0JhY2tib25lO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cbiAgLy8gd2lsbCBmYWtlIGBcIlBBVENIXCJgLCBgXCJQVVRcImAgYW5kIGBcIkRFTEVURVwiYCByZXF1ZXN0cyB2aWEgdGhlIGBfbWV0aG9kYCBwYXJhbWV0ZXIgYW5kXG4gIC8vIHNldCBhIGBYLUh0dHAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gIEJhY2tib25lLmVtdWxhdGVIVFRQID0gZmFsc2U7XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUpTT05gIHRvIHN1cHBvcnQgbGVnYWN5IHNlcnZlcnMgdGhhdCBjYW4ndCBkZWFsIHdpdGggZGlyZWN0XG4gIC8vIGBhcHBsaWNhdGlvbi9qc29uYCByZXF1ZXN0cyAuLi4gd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHtcblxuICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pIHx8ICFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIGV2ZW50cy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCB0aGlzfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAgIC8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgb25jZTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBvbmNlID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgb25lIG9yIG1hbnkgY2FsbGJhY2tzLiBJZiBgY29udGV4dGAgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAgIC8vIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cy5cbiAgICBvZmY6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmV0YWluLCBldiwgZXZlbnRzLCBuYW1lcywgaSwgbCwgaiwgaztcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICFldmVudHNBcGkodGhpcywgJ29mZicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHJlbW92ZSA9ICFuYW1lICYmICFjYWxsYmFjaztcbiAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBpZiAob2JqKSAobGlzdGVuaW5nVG8gPSB7fSlbb2JqLl9saXN0ZW5JZF0gPSBvYmo7XG4gICAgICBmb3IgKHZhciBpZCBpbiBsaXN0ZW5pbmdUbykge1xuICAgICAgICBvYmogPSBsaXN0ZW5pbmdUb1tpZF07XG4gICAgICAgIG9iai5vZmYobmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgICBpZiAocmVtb3ZlIHx8IF8uaXNFbXB0eShvYmouX2V2ZW50cykpIGRlbGV0ZSB0aGlzLl9saXN0ZW5pbmdUb1tpZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJbXBsZW1lbnQgZmFuY3kgZmVhdHVyZXMgb2YgdGhlIEV2ZW50cyBBUEkgc3VjaCBhcyBtdWx0aXBsZSBldmVudFxuICAvLyBuYW1lcyBgXCJjaGFuZ2UgYmx1clwiYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50IG1hcHMgYHtjaGFuZ2U6IGFjdGlvbn1gXG4gIC8vIGluIHRlcm1zIG9mIHRoZSBleGlzdGluZyBBUEkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihvYmosIGFjdGlvbiwgbmFtZSwgcmVzdCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtrZXksIG5hbWVba2V5XV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IG5hbWVzLlxuICAgIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtuYW1lc1tpXV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4gIC8vIEJhY2tib25lIGV2ZW50cyBoYXZlIDMgYXJndW1lbnRzKS5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihldmVudHMsIGFyZ3MpIHtcbiAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7IHJldHVybjtcbiAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xuICAgICAgY2FzZSAyOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKTsgcmV0dXJuO1xuICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7IHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nVG9baWRdID0gb2JqO1xuICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG4gIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cbiAgLy8gd2FudCBnbG9iYWwgXCJwdWJzdWJcIiBpbiBhIGNvbnZlbmllbnQgcGxhY2UuXG4gIF8uZXh0ZW5kKEJhY2tib25lLCBFdmVudHMpO1xuXG4gIC8vIEJhY2tib25lLk1vZGVsXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbiAgLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuICAvLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXG4gIC8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuICAvLyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgYXNzaWduZWQgZm9yIHlvdS5cbiAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgnYycpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQgLS0gYnV0IG92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWRcbiAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRyLCBhdHRycywgdW5zZXQsIGNoYW5nZXMsIHNpbGVudCwgY2hhbmdpbmcsIHByZXYsIGN1cnJlbnQ7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdW5zZXQgICAgICAgICAgID0gb3B0aW9ucy51bnNldDtcbiAgICAgIHNpbGVudCAgICAgICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgY2hhbmdlcyAgICAgICAgID0gW107XG4gICAgICBjaGFuZ2luZyAgICAgICAgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nICA9IHRydWU7XG5cbiAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXMsIHByZXYgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIGBpZGAuXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IGF0dHJzW3RoaXMuaWRBdHRyaWJ1dGVdO1xuXG4gICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAvLyBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgIC8vIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICB2YXIgdmFsLCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sICh2YWwgPSBkaWZmW2F0dHJdKSkpIGNvbnRpbnVlO1xuICAgICAgICAoY2hhbmdlZCB8fCAoY2hhbmdlZCA9IHt9KSlbYXR0cl0gPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgIC8vIG1vZGVsIGRpZmZlcnMgZnJvbSBpdHMgY3VycmVudCBhdHRyaWJ1dGVzLCB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICAvLyB0cmlnZ2VyaW5nIGEgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAoIW1vZGVsLnNldChtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSwgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcbiAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMsIG1ldGhvZCwgeGhyLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWV9LCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgICAgLy8gYHNldChhdHRyKS5zYXZlKG51bGwsIG9wdHMpYCB3aXRoIHZhbGlkYXRpb24uIE90aGVyd2lzZSwgY2hlY2sgaWZcbiAgICAgIC8vIHRoZSBtb2RlbCB3aWxsIGJlIHZhbGlkIHdoZW4gdGhlIGF0dHJpYnV0ZXMsIGlmIGFueSwgYXJlIHNldC5cbiAgICAgIGlmIChhdHRycyAmJiAhb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXG4gICAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQgfHwgbW9kZWwuaXNOZXcoKSkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMud2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oW15cXC9dKSQvLCAnJDEvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbC5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBfLmVhY2gobW9kZWxNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsYWdvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHZhciBpLCBsLCBpbmRleCwgbW9kZWw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICAgIHZhciBpLCBsLCBpZCwgbW9kZWwsIGF0dHJzLCBleGlzdGluZywgc29ydDtcbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQ7XG4gICAgICB2YXIgdGFyZ2V0TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIChhdCA9PSBudWxsKSAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcbiAgICAgIHZhciB0b0FkZCA9IFtdLCB0b1JlbW92ZSA9IFtdLCBtb2RlbE1hcCA9IHt9O1xuICAgICAgdmFyIGFkZCA9IG9wdGlvbnMuYWRkLCBtZXJnZSA9IG9wdGlvbnMubWVyZ2UsIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuICAgICAgdmFyIG9yZGVyID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmUgPyBbXSA6IGZhbHNlO1xuXG4gICAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgICAvLyBmcm9tIGJlaW5nIGFkZGVkLlxuICAgICAgZm9yIChpID0gMCwgbCA9IG1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYXR0cnMgPSBtb2RlbHNbaV0gfHwge307XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgaWQgPSBtb2RlbCA9IGF0dHJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gYXR0cnNbdGFyZ2V0TW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgaWYgKGV4aXN0aW5nID0gdGhpcy5nZXQoaWQpKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzID09PSBtb2RlbCA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBhdHRycztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQgJiYgZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cikpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGFkZCBtdWx0aXBsZSBtb2RlbHMgd2l0aCB0aGUgc2FtZSBgaWRgLlxuICAgICAgICBtb2RlbCA9IGV4aXN0aW5nIHx8IG1vZGVsO1xuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW21vZGVsLmlkXSkpIG9yZGVyLnB1c2gobW9kZWwpO1xuICAgICAgICBtb2RlbE1hcFttb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgbm9uZXhpc3RlbnQgbW9kZWxzIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwWyhtb2RlbCA9IHRoaXMubW9kZWxzW2ldKS5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gdG9BZGQubGVuZ3RoO1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShhdCArIGksIDAsIHRvQWRkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9yZGVyKSB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBvcmRlcmVkTW9kZWxzID0gb3JkZXIgfHwgdG9BZGQ7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9yZGVyZWRNb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0IGV2ZW50cy5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIChtb2RlbCA9IHRvQWRkW2ldKS50cmlnZ2VyKCdhZGQnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnQgfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KDApO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHwgdGhpcy5fYnlJZFtvYmouaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIG1vZGVscyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzIG9mXG4gICAgLy8gYGZpbHRlcmAuXG4gICAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShhdHRycykpIHJldHVybiBmaXJzdCA/IHZvaWQgMCA6IFtdO1xuICAgICAgcmV0dXJuIHRoaXNbZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG1vZGVsLmdldChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpIHx8IHRoaXMuY29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeSh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2RlbHMuc29ydChfLmJpbmQodGhpcy5jb21wYXJhdG9yLCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFBsdWNrIGFuIGF0dHJpYnV0ZSBmcm9tIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmludm9rZSh0aGlzLm1vZGVscywgJ2dldCcsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgZGVmYXVsdCBzZXQgb2YgbW9kZWxzIGZvciB0aGlzIGNvbGxlY3Rpb24sIHJlc2V0dGluZyB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIHdoZW4gdGhleSBhcnJpdmUuIElmIGByZXNldDogdHJ1ZWAgaXMgcGFzc2VkLCB0aGUgcmVzcG9uc2VcbiAgICAvLyBkYXRhIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGByZXNldGAgbWV0aG9kIGluc3RlYWQgb2YgYHNldGAuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MoY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kZWwgaW4gdGhpcyBjb2xsZWN0aW9uLiBBZGQgdGhlIG1vZGVsIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gaW1tZWRpYXRlbHksIHVubGVzcyBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgLy8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBhZ3JlZS5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmICghKG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIGNvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscyk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHJldHVybiBhdHRycztcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgIGlmICghbW9kZWwuY29sbGVjdGlvbikgbW9kZWwuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldmVyIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAobW9kZWwgJiYgZXZlbnQgPT09ICdjaGFuZ2U6JyArIG1vZGVsLmlkQXR0cmlidXRlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLnByZXZpb3VzKG1vZGVsLmlkQXR0cmlidXRlKV07XG4gICAgICAgIGlmIChtb2RlbC5pZCAhPSBudWxsKSB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAvLyA5MCUgb2YgdGhlIGNvcmUgdXNlZnVsbmVzcyBvZiBCYWNrYm9uZSBDb2xsZWN0aW9ucyBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZFxuICAvLyByaWdodCBoZXJlOlxuICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdjb2xsZWN0JywgJ3JlZHVjZScsICdmb2xkbCcsXG4gICAgJ2luamVjdCcsICdyZWR1Y2VSaWdodCcsICdmb2xkcicsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLCAnc2VsZWN0JyxcbiAgICAncmVqZWN0JywgJ2V2ZXJ5JywgJ2FsbCcsICdzb21lJywgJ2FueScsICdpbmNsdWRlJywgJ2NvbnRhaW5zJywgJ2ludm9rZScsXG4gICAgJ21heCcsICdtaW4nLCAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2hlYWQnLCAndGFrZScsICdpbml0aWFsJywgJ3Jlc3QnLFxuICAgICd0YWlsJywgJ2Ryb3AnLCAnbGFzdCcsICd3aXRob3V0JywgJ2RpZmZlcmVuY2UnLCAnaW5kZXhPZicsICdzaHVmZmxlJyxcbiAgICAnbGFzdEluZGV4T2YnLCAnaXNFbXB0eScsICdjaGFpbicsICdzYW1wbGUnXTtcblxuICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG4gIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm1vZGVscyk7XG4gICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHRha2UgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LlxuICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXMubW9kZWxzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAvLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAvLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cbiAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuICAvLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBtZXJnZWQgYXMgcHJvcGVydGllcy5cbiAgdmFyIHZpZXdPcHRpb25zID0gWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2lkJywgJ2F0dHJpYnV0ZXMnLCAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJ107XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChWaWV3LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAvLyBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcnJlZCB0byBnbG9iYWwgbG9va3VwcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSksIGluY2x1ZGluZyBldmVudFxuICAgIC8vIHJlLWRlbGVnYXRpb24uXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLiRlbCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWxlbWVudCA6IEJhY2tib25lLiQoZWxlbWVudCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgICBpZiAoZGVsZWdhdGUgIT09IGZhbHNlKSB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIC8vIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLCBgYmx1cmAsIGFuZFxuICAgIC8vIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKSkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdLCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQ7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lLCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgd2l0aCBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgIHVuZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdmFyICRlbCA9IEJhY2tib25lLiQoJzwnICsgXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSArICc+JykuYXR0cihhdHRycyk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgkZWwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5zeW5jXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYW5nZSB0aGUgbWFubmVyIGluIHdoaWNoIEJhY2tib25lIHBlcnNpc3RzXG4gIC8vIG1vZGVscyB0byB0aGUgc2VydmVyLiBZb3Ugd2lsbCBiZSBwYXNzZWQgdGhlIHR5cGUgb2YgcmVxdWVzdCwgYW5kIHRoZVxuICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxuICAvLyB0byB0aGUgbW9kZWwncyBgdXJsKClgLiBTb21lIHBvc3NpYmxlIGN1c3RvbWl6YXRpb25zIGNvdWxkIGJlOlxuICAvL1xuICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cbiAgLy8gKiBTZW5kIHVwIHRoZSBtb2RlbHMgYXMgWE1MIGluc3RlYWQgb2YgSlNPTi5cbiAgLy8gKiBQZXJzaXN0IG1vZGVscyB2aWEgV2ViU29ja2V0cyBpbnN0ZWFkIG9mIEFqYXguXG4gIC8vXG4gIC8vIFR1cm4gb24gYEJhY2tib25lLmVtdWxhdGVIVFRQYCBpbiBvcmRlciB0byBzZW5kIGBQVVRgIGFuZCBgREVMRVRFYCByZXF1ZXN0c1xuICAvLyBhcyBgUE9TVGAsIHdpdGggYSBgX21ldGhvZGAgcGFyYW1ldGVyIGNvbnRhaW5pbmcgdGhlIHRydWUgSFRUUCBtZXRob2QsXG4gIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgLy8gaW5zdGVhZCBvZiBgYXBwbGljYXRpb24vanNvbmAgd2l0aCB0aGUgbW9kZWwgaW4gYSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICAvLyBVc2VmdWwgd2hlbiBpbnRlcmZhY2luZyB3aXRoIHNlcnZlci1zaWRlIGxhbmd1YWdlcyBsaWtlICoqUEhQKiogdGhhdCBtYWtlXG4gIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxuICBCYWNrYm9uZS5zeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gbWV0aG9kTWFwW21ldGhvZF07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMsIHVubGVzcyBzcGVjaWZpZWQuXG4gICAgXy5kZWZhdWx0cyhvcHRpb25zIHx8IChvcHRpb25zID0ge30pLCB7XG4gICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXG4gICAgICBlbXVsYXRlSlNPTjogQmFja2JvbmUuZW11bGF0ZUpTT05cbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgSlNPTi1yZXF1ZXN0IG9wdGlvbnMuXG4gICAgdmFyIHBhcmFtcyA9IHt0eXBlOiB0eXBlLCBkYXRhVHlwZTogJ2pzb24nfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSBVUkwuXG4gICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgcGFyYW1zLnVybCA9IF8ucmVzdWx0KG1vZGVsLCAndXJsJykgfHwgdXJsRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsICYmIG1vZGVsICYmIChtZXRob2QgPT09ICdjcmVhdGUnIHx8IG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHwgbWV0aG9kID09PSAncGF0Y2gnKSkge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgcGFyYW1zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmF0dHJzIHx8IG1vZGVsLnRvSlNPTihvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICBwYXJhbXMuZGF0YSA9IHBhcmFtcy5kYXRhID8ge21vZGVsOiBwYXJhbXMuZGF0YX0gOiB7fTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcbiAgICAvLyBBbmQgYW4gYFgtSFRUUC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAodHlwZSA9PT0gJ1BVVCcgfHwgdHlwZSA9PT0gJ0RFTEVURScgfHwgdHlwZSA9PT0gJ1BBVENIJykpIHtcbiAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xuICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHBhcmFtcy5kYXRhLl9tZXRob2QgPSB0eXBlO1xuICAgICAgdmFyIGJlZm9yZVNlbmQgPSBvcHRpb25zLmJlZm9yZVNlbmQ7XG4gICAgICBvcHRpb25zLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCB0eXBlKTtcbiAgICAgICAgaWYgKGJlZm9yZVNlbmQpIHJldHVybiBiZWZvcmVTZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdHRVQnICYmICFvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMucHJvY2Vzc0RhdGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgYFBBVENIYCByZXF1ZXN0LCBhbmQgd2UncmUgaW4gYW4gb2xkIEludGVybmV0IEV4cGxvcmVyXG4gICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxuICAgIC8vIGZvciBYSFIgaW5zdGVhZC4gUmVtb3ZlIHRoaXMgbGluZSB3aGVuIGpRdWVyeSBzdXBwb3J0cyBgUEFUQ0hgIG9uIElFOC5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdQQVRDSCcgJiYgbm9YaHJQYXRjaCkge1xuICAgICAgcGFyYW1zLnhociA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgYW55IEFqYXggb3B0aW9ucy5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICByZXR1cm4geGhyO1xuICB9O1xuXG4gIHZhciBub1hoclBhdGNoID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmXG4gICAgICAhKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAobmV3IFhNTEh0dHBSZXF1ZXN0KS5kaXNwYXRjaEV2ZW50KTtcblxuICAvLyBNYXAgZnJvbSBDUlVEIHRvIEhUVFAgZm9yIG91ciBkZWZhdWx0IGBCYWNrYm9uZS5zeW5jYCBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIG1ldGhvZE1hcCA9IHtcbiAgICAnY3JlYXRlJzogJ1BPU1QnLFxuICAgICd1cGRhdGUnOiAnUFVUJyxcbiAgICAncGF0Y2gnOiAgJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAgICdHRVQnXG4gIH07XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5LlxuICBCYWNrYm9uZS5hamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEJhY2tib25lLlJvdXRlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxuICAvLyBtYXRjaGVkLiBDcmVhdGluZyBhIG5ldyBvbmUgc2V0cyBpdHMgYHJvdXRlc2AgaGFzaCwgaWYgbm90IHNldCBzdGF0aWNhbGx5LlxuICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMucm91dGVzKSB0aGlzLnJvdXRlcyA9IG9wdGlvbnMucm91dGVzO1xuICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXG4gIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XG4gIHZhciBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2c7XG4gIHZhciBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZztcbiAgdmFyIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFJvdXRlci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gTWFudWFsbHkgYmluZCBhIHNpbmdsZSBuYW1lZCByb3V0ZSB0byBhIGNhbGxiYWNrLiBGb3IgZXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgICB0aGlzLnJvdXRlKCdzZWFyY2gvOnF1ZXJ5L3A6bnVtJywgJ3NlYXJjaCcsIGZ1bmN0aW9uKHF1ZXJ5LCBudW0pIHtcbiAgICAvLyAgICAgICAuLi5cbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKSByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gdGhpc1tuYW1lXTtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5yb3V0ZShyb3V0ZSwgZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCk7XG4gICAgICAgIHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzKTtcbiAgICAgICAgcm91dGVyLnRyaWdnZXIuYXBwbHkocm91dGVyLCBbJ3JvdXRlOicgKyBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeGVjdXRlIGEgcm91dGUgaGFuZGxlciB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLiAgVGhpcyBpcyBhblxuICAgIC8vIGV4Y2VsbGVudCBwbGFjZSB0byBkbyBwcmUtcm91dGUgc2V0dXAgb3IgcG9zdC1yb3V0ZSBjbGVhbnVwLlxuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvLyBTaW1wbGUgcHJveHkgdG8gYEJhY2tib25lLmhpc3RvcnlgIHRvIHNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEJhY2tib25lLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgIC8vIHJvdXRlcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSByb3V0ZSBtYXAuXG4gICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnJvdXRlcykgcmV0dXJuO1xuICAgICAgdGhpcy5yb3V0ZXMgPSBfLnJlc3VsdCh0aGlzLCAncm91dGVzJyk7XG4gICAgICB2YXIgcm91dGUsIHJvdXRlcyA9IF8ua2V5cyh0aGlzLnJvdXRlcyk7XG4gICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm91dGUocm91dGUsIHRoaXMucm91dGVzW3JvdXRlXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSByb3V0ZSBzdHJpbmcgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3VpdGFibGUgZm9yIG1hdGNoaW5nXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteLz9dKyknO1xuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyhbXj9dKj8pJyk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICcoPzpcXFxcPyhbXFxcXHNcXFxcU10qKSk/JCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSwgaSkge1xuICAgICAgICAvLyBEb24ndCBkZWNvZGUgdGhlIHNlYXJjaCBwYXJhbXMuXG4gICAgICAgIGlmIChpID09PSBwYXJhbXMubGVuZ3RoIC0gMSkgcmV0dXJuIHBhcmFtIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLkhpc3RvcnlcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEhhbmRsZXMgY3Jvc3MtYnJvd3NlciBoaXN0b3J5IG1hbmFnZW1lbnQsIGJhc2VkIG9uIGVpdGhlclxuICAvLyBbcHVzaFN0YXRlXShodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2hpc3RvcnkuaHRtbCkgYW5kIHJlYWwgVVJMcywgb3JcbiAgLy8gW29uaGFzaGNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZSlcbiAgLy8gYW5kIFVSTCBmcmFnbWVudHMuIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIG5laXRoZXIgKG9sZCBJRSwgbmF0Y2gpLFxuICAvLyBmYWxscyBiYWNrIHRvIHBvbGxpbmcuXG4gIHZhciBIaXN0b3J5ID0gQmFja2JvbmUuSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBfLmJpbmRBbGwodGhpcywgJ2NoZWNrVXJsJyk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBgSGlzdG9yeWAgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICB0aGlzLmhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgYSBsZWFkaW5nIGhhc2gvc2xhc2ggYW5kIHRyYWlsaW5nIHNwYWNlLlxuICB2YXIgcm91dGVTdHJpcHBlciA9IC9eWyNcXC9dfFxccyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgZGV0ZWN0aW5nIE1TSUUuXG4gIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciByZW1vdmluZyBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG4gICAgfSxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgLy8gdGhlIGhhc2gsIG9yIHRoZSBvdmVycmlkZS5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UgfHwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IGRlY29kZVVSSSh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpO1xuICAgICAgICAgIGlmICghZnJhZ21lbnQuaW5kZXhPZihyb290KSkgZnJhZ21lbnQgPSBmcmFnbWVudC5zbGljZShyb290Lmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZFwiKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XG4gICAgICAvLyBJcyBwdXNoU3RhdGUgZGVzaXJlZCAuLi4gaXMgaXQgYXZhaWxhYmxlP1xuICAgICAgdGhpcy5vcHRpb25zICAgICAgICAgID0gXy5leHRlbmQoe3Jvb3Q6ICcvJ30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMub3B0aW9ucy5wdXNoU3RhdGUgJiYgdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgdmFyIGZyYWdtZW50ICAgICAgICAgID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRvY01vZGUgICAgICAgICAgID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgdmFyIG9sZElFICAgICAgICAgICAgID0gKGlzRXhwbG9yZXIuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICBpZiAob2xkSUUgJiYgdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IEJhY2tib25lLiQoJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgdGFiaW5kZXg9XCItMVwiPicpO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGZyYW1lLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xuICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZSh0aGlzLnJvb3QgKyAnIycgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpICYmIGxvYy5oYXNoKSB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpLnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB0aGlzLnJvb3QgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcbiAgICAgIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIGN1cnJlbnQgVVJMIGZyYWdtZW50LiBJZiBhIHJvdXRlIHN1Y2NlZWRzIHdpdGggYVxuICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgIGxvYWRVcmw6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLmFueSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICB2YXIgdXJsID0gdGhpcy5yb290ICsgKGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJykpO1xuXG4gICAgICAvLyBTdHJpcCB0aGUgaGFzaCBmb3IgbWF0Y2hpbmcuXG4gICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJyk7XG5cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBmcmFnbWVudCkgcmV0dXJuO1xuICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICBpZiAoZnJhZ21lbnQgPT09ICcnICYmIHVybCAhPT0gJy8nKSB1cmwgPSB1cmwuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAvLyBJZiBwdXNoU3RhdGUgaXMgYXZhaWxhYmxlLCB3ZSB1c2UgaXQgdG8gc2V0IHRoZSBmcmFnbWVudCBhcyBhIHJlYWwgVVJMLlxuICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuXG4gICAgICAvLyBJZiBoYXNoIGNoYW5nZXMgaGF2ZW4ndCBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIHVwZGF0ZSB0aGUgaGFzaFxuICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIGlmICh0aGlzLmlmcmFtZSAmJiAoZnJhZ21lbnQgIT09IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSkpKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYoIW9wdGlvbnMucmVwbGFjZSkgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmlmcmFtZS5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcblxuICAgIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgIGlmIChwcm90b1Byb3BzKSBfLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIGEgVVJMIGlzIG5lZWRlZCwgYW5kIG5vbmUgaXMgc3VwcGxpZWQuXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gIH07XG5cbiAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmU7XG5cbn0pKTtcbiIsIi8qXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cbiAqIDEuMS4yMDE3MDQyN1xuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xuXG5pZiAoXCJkb2N1bWVudFwiIGluIHdpbmRvdy5zZWxmKSB7XG5cbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbi8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxuaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKSkgXG5cdHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XG5cbihmdW5jdGlvbiAodmlldykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XG5cbnZhclxuXHQgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXG5cdCwgcHJvdG9Qcm9wID0gXCJwcm90b3R5cGVcIlxuXHQsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXG5cdCwgb2JqQ3RyID0gT2JqZWN0XG5cdCwgc3RyVHJpbSA9IFN0cmluZ1twcm90b1Byb3BdLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuXHR9XG5cdCwgYXJySW5kZXhPZiA9IEFycmF5W3Byb3RvUHJvcF0uaW5kZXhPZiB8fCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhclxuXHRcdFx0ICBpID0gMFxuXHRcdFx0LCBsZW4gPSB0aGlzLmxlbmd0aFxuXHRcdDtcblx0XHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fVxuXHQvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcblx0LCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG5cdFx0dGhpcy5uYW1lID0gdHlwZTtcblx0XHR0aGlzLmNvZGUgPSBET01FeGNlcHRpb25bdHlwZV07XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxuXHQsIGNoZWNrVG9rZW5BbmRHZXRJbmRleCA9IGZ1bmN0aW9uIChjbGFzc0xpc3QsIHRva2VuKSB7XG5cdFx0aWYgKHRva2VuID09PSBcIlwiKSB7XG5cdFx0XHR0aHJvdyBuZXcgRE9NRXgoXG5cdFx0XHRcdCAgXCJTWU5UQVhfRVJSXCJcblx0XHRcdFx0LCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcblx0XHRcdHRocm93IG5ldyBET01FeChcblx0XHRcdFx0ICBcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiXG5cdFx0XHRcdCwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcblx0fVxuXHQsIENsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0dmFyXG5cdFx0XHQgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcblx0XHRcdCwgY2xhc3NlcyA9IHRyaW1tZWRDbGFzc2VzID8gdHJpbW1lZENsYXNzZXMuc3BsaXQoL1xccysvKSA6IFtdXG5cdFx0XHQsIGkgPSAwXG5cdFx0XHQsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXG5cdFx0O1xuXHRcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMucHVzaChjbGFzc2VzW2ldKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdH07XG5cdH1cblx0LCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cblx0LCBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XG5cdH1cbjtcbi8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcbi8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxuRE9NRXhbcHJvdG9Qcm9wXSA9IEVycm9yW3Byb3RvUHJvcF07XG5jbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcblx0cmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcbn07XG5jbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuXHR0b2tlbiArPSBcIlwiO1xuXHRyZXR1cm4gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSAhPT0gLTE7XG59O1xuY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xuXHR2YXJcblx0XHQgIHRva2VucyA9IGFyZ3VtZW50c1xuXHRcdCwgaSA9IDBcblx0XHQsIGwgPSB0b2tlbnMubGVuZ3RoXG5cdFx0LCB0b2tlblxuXHRcdCwgdXBkYXRlZCA9IGZhbHNlXG5cdDtcblx0ZG8ge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblx0XHRpZiAoY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKSA9PT0gLTEpIHtcblx0XHRcdHRoaXMucHVzaCh0b2tlbik7XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0d2hpbGUgKCsraSA8IGwpO1xuXG5cdGlmICh1cGRhdGVkKSB7XG5cdFx0dGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG5cdH1cbn07XG5jbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHZhclxuXHRcdCAgdG9rZW5zID0gYXJndW1lbnRzXG5cdFx0LCBpID0gMFxuXHRcdCwgbCA9IHRva2Vucy5sZW5ndGhcblx0XHQsIHRva2VuXG5cdFx0LCB1cGRhdGVkID0gZmFsc2Vcblx0XHQsIGluZGV4XG5cdDtcblx0ZG8ge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblx0XHRpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cdFx0d2hpbGUgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0XHRpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG5cdFx0fVxuXHR9XG5cdHdoaWxlICgrK2kgPCBsKTtcblxuXHRpZiAodXBkYXRlZCkge1xuXHRcdHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuXHR9XG59O1xuY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuXHR0b2tlbiArPSBcIlwiO1xuXG5cdHZhclxuXHRcdCAgcmVzdWx0ID0gdGhpcy5jb250YWlucyh0b2tlbilcblx0XHQsIG1ldGhvZCA9IHJlc3VsdCA/XG5cdFx0XHRmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXG5cdFx0OlxuXHRcdFx0Zm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcblx0O1xuXG5cdGlmIChtZXRob2QpIHtcblx0XHR0aGlzW21ldGhvZF0odG9rZW4pO1xuXHR9XG5cblx0aWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xuXHRcdHJldHVybiBmb3JjZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gIXJlc3VsdDtcblx0fVxufTtcbmNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbn07XG5cbmlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcblx0dmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuXHRcdCAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcblx0XHQsIGVudW1lcmFibGU6IHRydWVcblx0XHQsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHR9O1xuXHR0cnkge1xuXHRcdG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcblx0fSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXG5cdFx0Ly8gYWRkaW5nIHVuZGVmaW5lZCB0byBmaWdodCB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9pc3N1ZXMvMzZcblx0XHQvLyBtb2Rlcm5pZSBJRTgtTVNXNyBtYWNoaW5lIGhhcyBJRTggOC4wLjYwMDEuMTg3MDIgYW5kIGlzIGFmZmVjdGVkXG5cdFx0aWYgKGV4Lm51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcblx0XHRcdGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcblx0XHRcdG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcblx0XHR9XG5cdH1cbn0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xuXHRlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xufVxuXG59KHdpbmRvdy5zZWxmKSk7XG5cbn1cblxuLy8gVGhlcmUgaXMgZnVsbCBvciBwYXJ0aWFsIG5hdGl2ZSBjbGFzc0xpc3Qgc3VwcG9ydCwgc28ganVzdCBjaGVjayBpZiB3ZSBuZWVkXG4vLyB0byBub3JtYWxpemUgdGhlIGFkZC9yZW1vdmUgYW5kIHRvZ2dsZSBBUElzLlxuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKTtcblxuXHR0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYzFcIiwgXCJjMlwiKTtcblxuXHQvLyBQb2x5ZmlsbCBmb3IgSUUgMTAvMTEgYW5kIEZpcmVmb3ggPDI2LCB3aGVyZSBjbGFzc0xpc3QuYWRkIGFuZFxuXHQvLyBjbGFzc0xpc3QucmVtb3ZlIGV4aXN0IGJ1dCBzdXBwb3J0IG9ubHkgb25lIGFyZ3VtZW50IGF0IGEgdGltZS5cblx0aWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xuXHRcdHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRcdHZhciBvcmlnaW5hbCA9IERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXTtcblxuXHRcdFx0RE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odG9rZW4pIHtcblx0XHRcdFx0dmFyIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0dG9rZW4gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0b3JpZ2luYWwuY2FsbCh0aGlzLCB0b2tlbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0XHRjcmVhdGVNZXRob2QoJ2FkZCcpO1xuXHRcdGNyZWF0ZU1ldGhvZCgncmVtb3ZlJyk7XG5cdH1cblxuXHR0ZXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiYzNcIiwgZmFsc2UpO1xuXG5cdC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3Rcblx0Ly8gc3VwcG9ydCB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuXHRpZiAodGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzNcIikpIHtcblx0XHR2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xuXG5cdFx0RE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbih0b2tlbiwgZm9yY2UpIHtcblx0XHRcdGlmICgxIGluIGFyZ3VtZW50cyAmJiAhdGhpcy5jb250YWlucyh0b2tlbikgPT09ICFmb3JjZSkge1xuXHRcdFx0XHRyZXR1cm4gZm9yY2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gX3RvZ2dsZS5jYWxsKHRoaXMsIHRva2VuKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdH1cblxuXHR0ZXN0RWxlbWVudCA9IG51bGw7XG59KCkpO1xuXG59XG4iLCIvKiBNSVQgbGljZW5zZSAqL1xudmFyIGNzc0tleXdvcmRzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xuXG4vLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4vLyAgICAgICB2YWx1ZXMgdGhhdCBnaXZlIGNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cykuXG4vLyAgICAgICBkbyBub3QgdXNlIGJveCB2YWx1ZXMgdHlwZXMgKGkuZS4gTnVtYmVyKCksIFN0cmluZygpLCBldGMuKVxuXG52YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKHZhciBrZXkgaW4gY3NzS2V5d29yZHMpIHtcblx0aWYgKGNzc0tleXdvcmRzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRyZXZlcnNlS2V5d29yZHNbY3NzS2V5d29yZHNba2V5XV0gPSBrZXk7XG5cdH1cbn1cblxudmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0cmdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3JnYid9LFxuXHRoc2w6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHNsJ30sXG5cdGhzdjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc3YnfSxcblx0aHdiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2h3Yid9LFxuXHRjbXlrOiB7Y2hhbm5lbHM6IDQsIGxhYmVsczogJ2NteWsnfSxcblx0eHl6OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ3h5eid9LFxuXHRsYWI6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGFiJ30sXG5cdGxjaDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsY2gnfSxcblx0aGV4OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydoZXgnXX0sXG5cdGtleXdvcmQ6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2tleXdvcmQnXX0sXG5cdGFuc2kxNjoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTE2J119LFxuXHRhbnNpMjU2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMjU2J119LFxuXHRoY2c6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ2gnLCAnYycsICdnJ119LFxuXHRhcHBsZToge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXX0sXG5cdGdyYXk6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2dyYXknXX1cbn07XG5cbi8vIGhpZGUgLmNoYW5uZWxzIGFuZCAubGFiZWxzIHByb3BlcnRpZXNcbmZvciAodmFyIG1vZGVsIGluIGNvbnZlcnQpIHtcblx0aWYgKGNvbnZlcnQuaGFzT3duUHJvcGVydHkobW9kZWwpKSB7XG5cdFx0aWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVsIGxhYmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHRpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNoYW5uZWxzfSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBsYWJlbHN9KTtcblx0fVxufVxuXG5jb252ZXJ0LnJnYi5oc2wgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cdHZhciBoO1xuXHR2YXIgcztcblx0dmFyIGw7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRsID0gKG1pbiArIG1heCkgLyAyO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG5cdFx0cyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHR9XG5cblx0cmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmhzdiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF07XG5cdHZhciBnID0gcmdiWzFdO1xuXHR2YXIgYiA9IHJnYlsyXTtcblx0dmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXHR2YXIgdjtcblxuXHRpZiAobWF4ID09PSAwKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IChkZWx0YSAvIG1heCAqIDEwMDApIC8gMTA7XG5cdH1cblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdHYgPSAoKG1heCAvIDI1NSkgKiAxMDAwKSAvIDEwO1xuXG5cdHJldHVybiBbaCwgcywgdl07XG59O1xuXG5jb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdO1xuXHR2YXIgZyA9IHJnYlsxXTtcblx0dmFyIGIgPSByZ2JbMl07XG5cdHZhciBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG5cdHZhciB3ID0gMSAvIDI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKTtcblxuXHRiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cblx0cmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmNteWsgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBjO1xuXHR2YXIgbTtcblx0dmFyIHk7XG5cdHZhciBrO1xuXG5cdGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcblx0YyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcblxuXHRyZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufTtcblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9lbi5tLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UjU3F1YXJlZF9FdWNsaWRlYW5fZGlzdGFuY2VcbiAqICovXG5mdW5jdGlvbiBjb21wYXJhdGl2ZURpc3RhbmNlKHgsIHkpIHtcblx0cmV0dXJuIChcblx0XHRNYXRoLnBvdyh4WzBdIC0geVswXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMV0gLSB5WzFdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsyXSAtIHlbMl0sIDIpXG5cdCk7XG59XG5cbmNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuXHRpZiAocmV2ZXJzZWQpIHtcblx0XHRyZXR1cm4gcmV2ZXJzZWQ7XG5cdH1cblxuXHR2YXIgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHR2YXIgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG5cdGZvciAodmFyIGtleXdvcmQgaW4gY3NzS2V5d29yZHMpIHtcblx0XHRpZiAoY3NzS2V5d29yZHMuaGFzT3duUHJvcGVydHkoa2V5d29yZCkpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGNzc0tleXdvcmRzW2tleXdvcmRdO1xuXG5cdFx0XHQvLyBDb21wdXRlIGNvbXBhcmF0aXZlIGRpc3RhbmNlXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBjb21wYXJhdGl2ZURpc3RhbmNlKHJnYiwgdmFsdWUpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3Rcblx0XHRcdGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG59O1xuXG5jb252ZXJ0LmtleXdvcmQucmdiID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcblx0cmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufTtcblxuY29udmVydC5yZ2IueHl6ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuXHRnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcblx0YiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cblx0dmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG5cdHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuXHR2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuXHRyZXR1cm4gW3ggKiAxMDAsIHkgKiAxMDAsIHogKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IubGFiID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgeHl6ID0gY29udmVydC5yZ2IueHl6KHJnYik7XG5cdHZhciB4ID0geHl6WzBdO1xuXHR2YXIgeSA9IHh5elsxXTtcblx0dmFyIHogPSB4eXpbMl07XG5cdHZhciBsO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRsID0gKDExNiAqIHkpIC0gMTY7XG5cdGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5oc2wucmdiID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgaCA9IGhzbFswXSAvIDM2MDtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgdDE7XG5cdHZhciB0Mjtcblx0dmFyIHQzO1xuXHR2YXIgcmdiO1xuXHR2YXIgdmFsO1xuXG5cdGlmIChzID09PSAwKSB7XG5cdFx0dmFsID0gbCAqIDI1NTtcblx0XHRyZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuXHR9XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHR0MiA9IGwgKiAoMSArIHMpO1xuXHR9IGVsc2Uge1xuXHRcdHQyID0gbCArIHMgLSBsICogcztcblx0fVxuXG5cdHQxID0gMiAqIGwgLSB0MjtcblxuXHRyZ2IgPSBbMCwgMCwgMF07XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0dDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcblx0XHRpZiAodDMgPCAwKSB7XG5cdFx0XHR0MysrO1xuXHRcdH1cblx0XHRpZiAodDMgPiAxKSB7XG5cdFx0XHR0My0tO1xuXHRcdH1cblxuXHRcdGlmICg2ICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0Mztcblx0XHR9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQyO1xuXHRcdH0gZWxzZSBpZiAoMyAqIHQzIDwgMikge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWwgPSB0MTtcblx0XHR9XG5cblx0XHRyZ2JbaV0gPSB2YWwgKiAyNTU7XG5cdH1cblxuXHRyZXR1cm4gcmdiO1xufTtcblxuY29udmVydC5oc2wuaHN2ID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgaCA9IGhzbFswXTtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgc21pbiA9IHM7XG5cdHZhciBsbWluID0gTWF0aC5tYXgobCwgMC4wMSk7XG5cdHZhciBzdjtcblx0dmFyIHY7XG5cblx0bCAqPSAyO1xuXHRzICo9IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuXHRzbWluICo9IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0diA9IChsICsgcykgLyAyO1xuXHRzdiA9IGwgPT09IDAgPyAoMiAqIHNtaW4pIC8gKGxtaW4gKyBzbWluKSA6ICgyICogcykgLyAobCArIHMpO1xuXG5cdHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YucmdiID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgaCA9IGhzdlswXSAvIDYwO1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cdHZhciBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG5cdHZhciBmID0gaCAtIE1hdGguZmxvb3IoaCk7XG5cdHZhciBwID0gMjU1ICogdiAqICgxIC0gcyk7XG5cdHZhciBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSk7XG5cdHZhciB0ID0gMjU1ICogdiAqICgxIC0gKHMgKiAoMSAtIGYpKSk7XG5cdHYgKj0gMjU1O1xuXG5cdHN3aXRjaCAoaGkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRyZXR1cm4gW3YsIHQsIHBdO1xuXHRcdGNhc2UgMTpcblx0XHRcdHJldHVybiBbcSwgdiwgcF07XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cmV0dXJuIFtwLCB2LCB0XTtcblx0XHRjYXNlIDM6XG5cdFx0XHRyZXR1cm4gW3AsIHEsIHZdO1xuXHRcdGNhc2UgNDpcblx0XHRcdHJldHVybiBbdCwgcCwgdl07XG5cdFx0Y2FzZSA1OlxuXHRcdFx0cmV0dXJuIFt2LCBwLCBxXTtcblx0fVxufTtcblxuY29udmVydC5oc3YuaHNsID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgaCA9IGhzdlswXTtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuXHR2YXIgbG1pbjtcblx0dmFyIHNsO1xuXHR2YXIgbDtcblxuXHRsID0gKDIgLSBzKSAqIHY7XG5cdGxtaW4gPSAoMiAtIHMpICogdm1pbjtcblx0c2wgPSBzICogdm1pbjtcblx0c2wgLz0gKGxtaW4gPD0gMSkgPyBsbWluIDogMiAtIGxtaW47XG5cdHNsID0gc2wgfHwgMDtcblx0bCAvPSAyO1xuXG5cdHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5jb252ZXJ0Lmh3Yi5yZ2IgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdHZhciBoID0gaHdiWzBdIC8gMzYwO1xuXHR2YXIgd2ggPSBod2JbMV0gLyAxMDA7XG5cdHZhciBibCA9IGh3YlsyXSAvIDEwMDtcblx0dmFyIHJhdGlvID0gd2ggKyBibDtcblx0dmFyIGk7XG5cdHZhciB2O1xuXHR2YXIgZjtcblx0dmFyIG47XG5cblx0Ly8gd2ggKyBibCBjYW50IGJlID4gMVxuXHRpZiAocmF0aW8gPiAxKSB7XG5cdFx0d2ggLz0gcmF0aW87XG5cdFx0YmwgLz0gcmF0aW87XG5cdH1cblxuXHRpID0gTWF0aC5mbG9vcig2ICogaCk7XG5cdHYgPSAxIC0gYmw7XG5cdGYgPSA2ICogaCAtIGk7XG5cblx0aWYgKChpICYgMHgwMSkgIT09IDApIHtcblx0XHRmID0gMSAtIGY7XG5cdH1cblxuXHRuID0gd2ggKyBmICogKHYgLSB3aCk7IC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblx0c3dpdGNoIChpKSB7XG5cdFx0ZGVmYXVsdDpcblx0XHRjYXNlIDY6XG5cdFx0Y2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG5cdFx0Y2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC5jbXlrLnJnYiA9IGZ1bmN0aW9uIChjbXlrKSB7XG5cdHZhciBjID0gY215a1swXSAvIDEwMDtcblx0dmFyIG0gPSBjbXlrWzFdIC8gMTAwO1xuXHR2YXIgeSA9IGNteWtbMl0gLyAxMDA7XG5cdHZhciBrID0gY215a1szXSAvIDEwMDtcblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblxuXHRyID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG5cdGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcblx0YiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5yZ2IgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdHZhciB4ID0geHl6WzBdIC8gMTAwO1xuXHR2YXIgeSA9IHh5elsxXSAvIDEwMDtcblx0dmFyIHogPSB4eXpbMl0gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuXHRnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcblx0YiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogciAqIDEyLjkyO1xuXG5cdGcgPSBnID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGcgKiAxMi45MjtcblxuXHRiID0gYiA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBiICogMTIuOTI7XG5cblx0ciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcblx0ZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcblx0YiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoubGFiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcblx0dmFyIGwgPSBsYWJbMF07XG5cdHZhciBhID0gbGFiWzFdO1xuXHR2YXIgYiA9IGxhYlsyXTtcblx0dmFyIHg7XG5cdHZhciB5O1xuXHR2YXIgejtcblxuXHR5ID0gKGwgKyAxNikgLyAxMTY7XG5cdHggPSBhIC8gNTAwICsgeTtcblx0eiA9IHkgLSBiIC8gMjAwO1xuXG5cdHZhciB5MiA9IE1hdGgucG93KHksIDMpO1xuXHR2YXIgeDIgPSBNYXRoLnBvdyh4LCAzKTtcblx0dmFyIHoyID0gTWF0aC5wb3coeiwgMyk7XG5cdHkgPSB5MiA+IDAuMDA4ODU2ID8geTIgOiAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eiA9IHoyID4gMC4wMDg4NTYgPyB6MiA6ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cblx0eCAqPSA5NS4wNDc7XG5cdHkgKj0gMTAwO1xuXHR6ICo9IDEwOC44ODM7XG5cblx0cmV0dXJuIFt4LCB5LCB6XTtcbn07XG5cbmNvbnZlcnQubGFiLmxjaCA9IGZ1bmN0aW9uIChsYWIpIHtcblx0dmFyIGwgPSBsYWJbMF07XG5cdHZhciBhID0gbGFiWzFdO1xuXHR2YXIgYiA9IGxhYlsyXTtcblx0dmFyIGhyO1xuXHR2YXIgaDtcblx0dmFyIGM7XG5cblx0aHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuXHRoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cblx0cmV0dXJuIFtsLCBjLCBoXTtcbn07XG5cbmNvbnZlcnQubGNoLmxhYiA9IGZ1bmN0aW9uIChsY2gpIHtcblx0dmFyIGwgPSBsY2hbMF07XG5cdHZhciBjID0gbGNoWzFdO1xuXHR2YXIgaCA9IGxjaFsyXTtcblx0dmFyIGE7XG5cdHZhciBiO1xuXHR2YXIgaHI7XG5cblx0aHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG5cdGEgPSBjICogTWF0aC5jb3MoaHIpO1xuXHRiID0gYyAqIE1hdGguc2luKGhyKTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIHIgPSBhcmdzWzBdO1xuXHR2YXIgZyA9IGFyZ3NbMV07XG5cdHZhciBiID0gYXJnc1syXTtcblx0dmFyIHZhbHVlID0gMSBpbiBhcmd1bWVudHMgPyBhcmd1bWVudHNbMV0gOiBjb252ZXJ0LnJnYi5oc3YoYXJncylbMl07IC8vIGhzdiAtPiBhbnNpMTYgb3B0aW1pemF0aW9uXG5cblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuXG5cdGlmICh2YWx1ZSA9PT0gMCkge1xuXHRcdHJldHVybiAzMDtcblx0fVxuXG5cdHZhciBhbnNpID0gMzBcblx0XHQrICgoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyKVxuXHRcdHwgKE1hdGgucm91bmQoZyAvIDI1NSkgPDwgMSlcblx0XHR8IE1hdGgucm91bmQociAvIDI1NSkpO1xuXG5cdGlmICh2YWx1ZSA9PT0gMikge1xuXHRcdGFuc2kgKz0gNjA7XG5cdH1cblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuaHN2LmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIG9wdGltaXphdGlvbiBoZXJlOyB3ZSBhbHJlYWR5IGtub3cgdGhlIHZhbHVlIGFuZCBkb24ndCBuZWVkIHRvIGdldFxuXHQvLyBpdCBjb252ZXJ0ZWQgZm9yIHVzLlxuXHRyZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMjU2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIHIgPSBhcmdzWzBdO1xuXHR2YXIgZyA9IGFyZ3NbMV07XG5cdHZhciBiID0gYXJnc1syXTtcblxuXHQvLyB3ZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0aWYgKHIgPT09IGcgJiYgZyA9PT0gYikge1xuXHRcdGlmIChyIDwgOCkge1xuXHRcdFx0cmV0dXJuIDE2O1xuXHRcdH1cblxuXHRcdGlmIChyID4gMjQ4KSB7XG5cdFx0XHRyZXR1cm4gMjMxO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLnJvdW5kKCgociAtIDgpIC8gMjQ3KSAqIDI0KSArIDIzMjtcblx0fVxuXG5cdHZhciBhbnNpID0gMTZcblx0XHQrICgzNiAqIE1hdGgucm91bmQociAvIDI1NSAqIDUpKVxuXHRcdCsgKDYgKiBNYXRoLnJvdW5kKGcgLyAyNTUgKiA1KSlcblx0XHQrIE1hdGgucm91bmQoYiAvIDI1NSAqIDUpO1xuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5hbnNpMTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGNvbG9yID0gYXJncyAlIDEwO1xuXG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGNvbG9yID09PSAwIHx8IGNvbG9yID09PSA3KSB7XG5cdFx0aWYgKGFyZ3MgPiA1MCkge1xuXHRcdFx0Y29sb3IgKz0gMy41O1xuXHRcdH1cblxuXHRcdGNvbG9yID0gY29sb3IgLyAxMC41ICogMjU1O1xuXG5cdFx0cmV0dXJuIFtjb2xvciwgY29sb3IsIGNvbG9yXTtcblx0fVxuXG5cdHZhciBtdWx0ID0gKH5+KGFyZ3MgPiA1MCkgKyAxKSAqIDAuNTtcblx0dmFyIHIgPSAoKGNvbG9yICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0dmFyIGcgPSAoKChjb2xvciA+PiAxKSAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBiID0gKCgoY29sb3IgPj4gMikgJiAxKSAqIG11bHQpICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gaGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoYXJncyA+PSAyMzIpIHtcblx0XHR2YXIgYyA9IChhcmdzIC0gMjMyKSAqIDEwICsgODtcblx0XHRyZXR1cm4gW2MsIGMsIGNdO1xuXHR9XG5cblx0YXJncyAtPSAxNjtcblxuXHR2YXIgcmVtO1xuXHR2YXIgciA9IE1hdGguZmxvb3IoYXJncyAvIDM2KSAvIDUgKiAyNTU7XG5cdHZhciBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcblx0dmFyIGIgPSAocmVtICUgNikgLyA1ICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgaW50ZWdlciA9ICgoTWF0aC5yb3VuZChhcmdzWzBdKSAmIDB4RkYpIDw8IDE2KVxuXHRcdCsgKChNYXRoLnJvdW5kKGFyZ3NbMV0pICYgMHhGRikgPDwgOClcblx0XHQrIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMHhGRik7XG5cblx0dmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LmhleC5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZjAtOV17Nn18W2EtZjAtOV17M30vaSk7XG5cdGlmICghbWF0Y2gpIHtcblx0XHRyZXR1cm4gWzAsIDAsIDBdO1xuXHR9XG5cblx0dmFyIGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cblx0aWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuXHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoY2hhcikge1xuXHRcdFx0cmV0dXJuIGNoYXIgKyBjaGFyO1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0dmFyIGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuXHR2YXIgciA9IChpbnRlZ2VyID4+IDE2KSAmIDB4RkY7XG5cdHZhciBnID0gKGludGVnZXIgPj4gOCkgJiAweEZGO1xuXHR2YXIgYiA9IGludGVnZXIgJiAweEZGO1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oY2cgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cdHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heChyLCBnKSwgYik7XG5cdHZhciBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbihyLCBnKSwgYik7XG5cdHZhciBjaHJvbWEgPSAobWF4IC0gbWluKTtcblx0dmFyIGdyYXlzY2FsZTtcblx0dmFyIGh1ZTtcblxuXHRpZiAoY2hyb21hIDwgMSkge1xuXHRcdGdyYXlzY2FsZSA9IG1pbiAvICgxIC0gY2hyb21hKTtcblx0fSBlbHNlIHtcblx0XHRncmF5c2NhbGUgPSAwO1xuXHR9XG5cblx0aWYgKGNocm9tYSA8PSAwKSB7XG5cdFx0aHVlID0gMDtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IHIpIHtcblx0XHRodWUgPSAoKGcgLSBiKSAvIGNocm9tYSkgJSA2O1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gZykge1xuXHRcdGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuXHR9IGVsc2Uge1xuXHRcdGh1ZSA9IDQgKyAociAtIGcpIC8gY2hyb21hICsgNDtcblx0fVxuXG5cdGh1ZSAvPSA2O1xuXHRodWUgJT0gMTtcblxuXHRyZXR1cm4gW2h1ZSAqIDM2MCwgY2hyb21hICogMTAwLCBncmF5c2NhbGUgKiAxMDBdO1xufTtcblxuY29udmVydC5oc2wuaGNnID0gZnVuY3Rpb24gKGhzbCkge1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciBjID0gMTtcblx0dmFyIGYgPSAwO1xuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0YyA9IDIuMCAqIHMgKiBsO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSAyLjAgKiBzICogKDEuMCAtIGwpO1xuXHR9XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKGwgLSAwLjUgKiBjKSAvICgxLjAgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LmhjZyA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXG5cdHZhciBjID0gcyAqIHY7XG5cdHZhciBmID0gMDtcblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLnJnYiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGggPSBoY2dbMF0gLyAzNjA7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHRpZiAoYyA9PT0gMC4wKSB7XG5cdFx0cmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcblx0fVxuXG5cdHZhciBwdXJlID0gWzAsIDAsIDBdO1xuXHR2YXIgaGkgPSAoaCAlIDEpICogNjtcblx0dmFyIHYgPSBoaSAlIDE7XG5cdHZhciB3ID0gMSAtIHY7XG5cdHZhciBtZyA9IDA7XG5cblx0c3dpdGNoIChNYXRoLmZsb29yKGhpKSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gdjsgcHVyZVsyXSA9IDA7IGJyZWFrO1xuXHRcdGNhc2UgMTpcblx0XHRcdHB1cmVbMF0gPSB3OyBwdXJlWzFdID0gMTsgcHVyZVsyXSA9IDA7IGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdHB1cmVbMF0gPSAwOyBwdXJlWzFdID0gMTsgcHVyZVsyXSA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdHB1cmVbMF0gPSAwOyBwdXJlWzFdID0gdzsgcHVyZVsyXSA9IDE7IGJyZWFrO1xuXHRcdGNhc2UgNDpcblx0XHRcdHB1cmVbMF0gPSB2OyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IDE7IGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSB3O1xuXHR9XG5cblx0bWcgPSAoMS4wIC0gYykgKiBnO1xuXG5cdHJldHVybiBbXG5cdFx0KGMgKiBwdXJlWzBdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsxXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVcblx0XTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzdiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHZhciBmID0gMDtcblxuXHRpZiAodiA+IDAuMCkge1xuXHRcdGYgPSBjIC8gdjtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBmICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmhzbCA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdHZhciBsID0gZyAqICgxLjAgLSBjKSArIDAuNSAqIGM7XG5cdHZhciBzID0gMDtcblxuXHRpZiAobCA+IDAuMCAmJiBsIDwgMC41KSB7XG5cdFx0cyA9IGMgLyAoMiAqIGwpO1xuXHR9IGVsc2Vcblx0aWYgKGwgPj0gMC41ICYmIGwgPCAxLjApIHtcblx0XHRzID0gYyAvICgyICogKDEgLSBsKSk7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5od2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblx0dmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0cmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xufTtcblxuY29udmVydC5od2IuaGNnID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgdyA9IGh3YlsxXSAvIDEwMDtcblx0dmFyIGIgPSBod2JbMl0gLyAxMDA7XG5cdHZhciB2ID0gMSAtIGI7XG5cdHZhciBjID0gdiAtIHc7XG5cdHZhciBnID0gMDtcblxuXHRpZiAoYyA8IDEpIHtcblx0XHRnID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuXHRyZXR1cm4gWyhhcHBsZVswXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzFdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMl0gLyA2NTUzNSkgKiAyNTVdO1xufTtcblxuY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHJldHVybiBbKHJnYlswXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsxXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsyXSAvIDI1NSkgKiA2NTUzNV07XG59O1xuXG5jb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oc2wgPSBjb252ZXJ0LmdyYXkuaHN2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFswLCAwLCBhcmdzWzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5od2IgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuY215ayA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkubGFiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFtncmF5WzBdLCAwLCAwXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oZXggPSBmdW5jdGlvbiAoZ3JheSkge1xuXHR2YXIgdmFsID0gTWF0aC5yb3VuZChncmF5WzBdIC8gMTAwICogMjU1KSAmIDB4RkY7XG5cdHZhciBpbnRlZ2VyID0gKHZhbCA8PCAxNikgKyAodmFsIDw8IDgpICsgdmFsO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5yZ2IuZ3JheSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHZhbCA9IChyZ2JbMF0gKyByZ2JbMV0gKyByZ2JbMl0pIC8gMztcblx0cmV0dXJuIFt2YWwgLyAyNTUgKiAxMDBdO1xufTtcbiIsInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcbnZhciByb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGUnKTtcblxudmFyIGNvbnZlcnQgPSB7fTtcblxudmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuXHR2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKGFyZ3MpO1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxuZnVuY3Rpb24gd3JhcFJvdW5kZWQoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHZhciByZXN1bHQgPSBmbihhcmdzKTtcblxuXHRcdC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSByZXN1bHQgaXMgYW4gYXJyYXkgaGVyZS5cblx0XHQvLyBzZWUgbm90aWNlIGluIGNvbnZlcnNpb25zLmpzOyBkb24ndCB1c2UgYm94IHR5cGVzXG5cdFx0Ly8gaW4gY29udmVyc2lvbiBmdW5jdGlvbnMuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKHZhciBsZW4gPSByZXN1bHQubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IE1hdGgucm91bmQocmVzdWx0W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxubW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHRjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHN9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHN9KTtcblxuXHR2YXIgcm91dGVzID0gcm91dGUoZnJvbU1vZGVsKTtcblx0dmFyIHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcblxuXHRyb3V0ZU1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uICh0b01vZGVsKSB7XG5cdFx0dmFyIGZuID0gcm91dGVzW3RvTW9kZWxdO1xuXG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuIiwidmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZSgnLi9jb252ZXJzaW9ucycpO1xuXG4vKlxuXHR0aGlzIGZ1bmN0aW9uIHJvdXRlcyBhIG1vZGVsIHRvIGFsbCBvdGhlciBtb2RlbHMuXG5cblx0YWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByb3V0ZWQgaGF2ZSBhIHByb3BlcnR5IGAuY29udmVyc2lvbmAgYXR0YWNoZWRcblx0dG8gdGhlIHJldHVybmVkIHN5bnRoZXRpYyBmdW5jdGlvbi4gVGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheVxuXHRvZiBzdHJpbmdzLCBlYWNoIHdpdGggdGhlIHN0ZXBzIGluIGJldHdlZW4gdGhlICdmcm9tJyBhbmQgJ3RvJ1xuXHRjb2xvciBtb2RlbHMgKGluY2x1c2l2ZSkuXG5cblx0Y29udmVyc2lvbnMgdGhhdCBhcmUgbm90IHBvc3NpYmxlIHNpbXBseSBhcmUgbm90IGluY2x1ZGVkLlxuKi9cblxuZnVuY3Rpb24gYnVpbGRHcmFwaCgpIHtcblx0dmFyIGdyYXBoID0ge307XG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9vYmplY3Qta2V5cy12cy1mb3ItaW4td2l0aC1jbG9zdXJlLzNcblx0dmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuXHRmb3IgKHZhciBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0Z3JhcGhbbW9kZWxzW2ldXSA9IHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tLzEtdnMtaW5maW5pdHlcblx0XHRcdC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuXHRcdFx0ZGlzdGFuY2U6IC0xLFxuXHRcdFx0cGFyZW50OiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcbmZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcblx0dmFyIGdyYXBoID0gYnVpbGRHcmFwaCgpO1xuXHR2YXIgcXVldWUgPSBbZnJvbU1vZGVsXTsgLy8gdW5zaGlmdCAtPiBxdWV1ZSAtPiBwb3BcblxuXHRncmFwaFtmcm9tTW9kZWxdLmRpc3RhbmNlID0gMDtcblxuXHR3aGlsZSAocXVldWUubGVuZ3RoKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcblx0XHR2YXIgYWRqYWNlbnRzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnNbY3VycmVudF0pO1xuXG5cdFx0Zm9yICh2YXIgbGVuID0gYWRqYWNlbnRzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIGFkamFjZW50ID0gYWRqYWNlbnRzW2ldO1xuXHRcdFx0dmFyIG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cblx0XHRcdGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuXHRcdFx0XHRub2RlLmRpc3RhbmNlID0gZ3JhcGhbY3VycmVudF0uZGlzdGFuY2UgKyAxO1xuXHRcdFx0XHRub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuZnVuY3Rpb24gbGluayhmcm9tLCB0bykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRyZXR1cm4gdG8oZnJvbShhcmdzKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG5cdHZhciBwYXRoID0gW2dyYXBoW3RvTW9kZWxdLnBhcmVudCwgdG9Nb2RlbF07XG5cdHZhciBmbiA9IGNvbnZlcnNpb25zW2dyYXBoW3RvTW9kZWxdLnBhcmVudF1bdG9Nb2RlbF07XG5cblx0dmFyIGN1ciA9IGdyYXBoW3RvTW9kZWxdLnBhcmVudDtcblx0d2hpbGUgKGdyYXBoW2N1cl0ucGFyZW50KSB7XG5cdFx0cGF0aC51bnNoaWZ0KGdyYXBoW2N1cl0ucGFyZW50KTtcblx0XHRmbiA9IGxpbmsoY29udmVyc2lvbnNbZ3JhcGhbY3VyXS5wYXJlbnRdW2N1cl0sIGZuKTtcblx0XHRjdXIgPSBncmFwaFtjdXJdLnBhcmVudDtcblx0fVxuXG5cdGZuLmNvbnZlcnNpb24gPSBwYXRoO1xuXHRyZXR1cm4gZm47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHR2YXIgZ3JhcGggPSBkZXJpdmVCRlMoZnJvbU1vZGVsKTtcblx0dmFyIGNvbnZlcnNpb24gPSB7fTtcblxuXHR2YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoZ3JhcGgpO1xuXHRmb3IgKHZhciBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIHRvTW9kZWwgPSBtb2RlbHNbaV07XG5cdFx0dmFyIG5vZGUgPSBncmFwaFt0b01vZGVsXTtcblxuXHRcdGlmIChub2RlLnBhcmVudCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gbm8gcG9zc2libGUgY29udmVyc2lvbiwgb3IgdGhpcyBub2RlIGlzIHRoZSBzb3VyY2UgbW9kZWwuXG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpO1xuXHR9XG5cblx0cmV0dXJuIGNvbnZlcnNpb247XG59O1xuXG4iLCIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcclxuIiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb2xvck5hbWVzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xudmFyIHN3aXp6bGUgPSByZXF1aXJlKCdzaW1wbGUtc3dpenpsZScpO1xuXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5cbi8vIGNyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWVzKSB7XG5cdGlmIChjb2xvck5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0cmV2ZXJzZU5hbWVzW2NvbG9yTmFtZXNbbmFtZV1dID0gbmFtZTtcblx0fVxufVxuXG52YXIgY3MgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0dG86IHt9LFxuXHRnZXQ6IHt9XG59O1xuXG5jcy5nZXQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdHZhciBwcmVmaXggPSBzdHJpbmcuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCk7XG5cdHZhciB2YWw7XG5cdHZhciBtb2RlbDtcblx0c3dpdGNoIChwcmVmaXgpIHtcblx0XHRjYXNlICdoc2wnOlxuXHRcdFx0dmFsID0gY3MuZ2V0LmhzbChzdHJpbmcpO1xuXHRcdFx0bW9kZWwgPSAnaHNsJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2h3Yic6XG5cdFx0XHR2YWwgPSBjcy5nZXQuaHdiKHN0cmluZyk7XG5cdFx0XHRtb2RlbCA9ICdod2InO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHZhbCA9IGNzLmdldC5yZ2Ioc3RyaW5nKTtcblx0XHRcdG1vZGVsID0gJ3JnYic7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmICghdmFsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4ge21vZGVsOiBtb2RlbCwgdmFsdWU6IHZhbH07XG59O1xuXG5jcy5nZXQucmdiID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHRpZiAoIXN0cmluZykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGFiYnIgPSAvXiMoW2EtZjAtOV17Myw0fSkkL2k7XG5cdHZhciBoZXggPSAvXiMoW2EtZjAtOV17Nn0pKFthLWYwLTldezJ9KT8kL2k7XG5cdHZhciByZ2JhID0gL15yZ2JhP1xcKFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC87XG5cdHZhciBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkLztcblx0dmFyIGtleXdvcmQgPSAvKFxcRCspLztcblxuXHR2YXIgcmdiID0gWzAsIDAsIDAsIDFdO1xuXHR2YXIgbWF0Y2g7XG5cdHZhciBpO1xuXHR2YXIgaGV4QWxwaGE7XG5cblx0aWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcblx0XHRoZXhBbHBoYSA9IG1hdGNoWzJdO1xuXHRcdG1hdGNoID0gbWF0Y2hbMV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHQvLyBodHRwczovL2pzcGVyZi5jb20vc2xpY2UtdnMtc3Vic3RyLXZzLXN1YnN0cmluZy1tZXRob2RzLWxvbmctc3RyaW5nLzE5XG5cdFx0XHR2YXIgaTIgPSBpICogMjtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkyLCBpMiArIDIpLCAxNik7XG5cdFx0fVxuXG5cdFx0aWYgKGhleEFscGhhKSB7XG5cdFx0XHRyZ2JbM10gPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpKSB7XG5cdFx0bWF0Y2ggPSBtYXRjaFsxXTtcblx0XHRoZXhBbHBoYSA9IG1hdGNoWzNdO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuXHRcdH1cblxuXHRcdGlmIChoZXhBbHBoYSkge1xuXHRcdFx0cmdiWzNdID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEgKyBoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdLCAwKTtcblx0XHR9XG5cblx0XHRpZiAobWF0Y2hbNF0pIHtcblx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1hdGNoW2kgKyAxXSkgKiAyLjU1KTtcblx0XHR9XG5cblx0XHRpZiAobWF0Y2hbNF0pIHtcblx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuXHRcdGlmIChtYXRjaFsxXSA9PT0gJ3RyYW5zcGFyZW50Jykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCAwLCAwXTtcblx0XHR9XG5cblx0XHRyZ2IgPSBjb2xvck5hbWVzW21hdGNoWzFdXTtcblxuXHRcdGlmICghcmdiKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZ2JbM10gPSAxO1xuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRyZ2JbaV0gPSBjbGFtcChyZ2JbaV0sIDAsIDI1NSk7XG5cdH1cblx0cmdiWzNdID0gY2xhbXAocmdiWzNdLCAwLCAxKTtcblxuXHRyZXR1cm4gcmdiO1xufTtcblxuY3MuZ2V0LmhzbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0aWYgKCFzdHJpbmcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dPyg/OlxcZCpcXC4pP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcblxuXHRpZiAobWF0Y2gpIHtcblx0XHR2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR2YXIgaCA9IChwYXJzZUZsb2F0KG1hdGNoWzFdKSArIDM2MCkgJSAzNjA7XG5cdFx0dmFyIHMgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKTtcblx0XHR2YXIgbCA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApO1xuXHRcdHZhciBhID0gY2xhbXAoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcblxuXHRcdHJldHVybiBbaCwgcywgbCwgYV07XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmNzLmdldC5od2IgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdGlmICghc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKltcXC5dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcblxuXHRpZiAobWF0Y2gpIHtcblx0XHR2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR2YXIgaCA9ICgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MDtcblx0XHR2YXIgdyA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApO1xuXHRcdHZhciBiID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCk7XG5cdFx0dmFyIGEgPSBjbGFtcChpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuXHRcdHJldHVybiBbaCwgdywgYiwgYV07XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmNzLnRvLmhleCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJnYmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0cmV0dXJuIChcblx0XHQnIycgK1xuXHRcdGhleERvdWJsZShyZ2JhWzBdKSArXG5cdFx0aGV4RG91YmxlKHJnYmFbMV0pICtcblx0XHRoZXhEb3VibGUocmdiYVsyXSkgK1xuXHRcdChyZ2JhWzNdIDwgMVxuXHRcdFx0PyAoaGV4RG91YmxlKE1hdGgucm91bmQocmdiYVszXSAqIDI1NSkpKVxuXHRcdFx0OiAnJylcblx0KTtcbn07XG5cbmNzLnRvLnJnYiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJnYmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0cmV0dXJuIHJnYmEubGVuZ3RoIDwgNCB8fCByZ2JhWzNdID09PSAxXG5cdFx0PyAncmdiKCcgKyBNYXRoLnJvdW5kKHJnYmFbMF0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsxXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzJdKSArICcpJ1xuXHRcdDogJ3JnYmEoJyArIE1hdGgucm91bmQocmdiYVswXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzFdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMl0pICsgJywgJyArIHJnYmFbM10gKyAnKSc7XG59O1xuXG5jcy50by5yZ2IucGVyY2VudCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJnYmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0dmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0gLyAyNTUgKiAxMDApO1xuXHR2YXIgZyA9IE1hdGgucm91bmQocmdiYVsxXSAvIDI1NSAqIDEwMCk7XG5cdHZhciBiID0gTWF0aC5yb3VuZChyZ2JhWzJdIC8gMjU1ICogMTAwKTtcblxuXHRyZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDFcblx0XHQ/ICdyZ2IoJyArIHIgKyAnJSwgJyArIGcgKyAnJSwgJyArIGIgKyAnJSknXG5cdFx0OiAncmdiYSgnICsgciArICclLCAnICsgZyArICclLCAnICsgYiArICclLCAnICsgcmdiYVszXSArICcpJztcbn07XG5cbmNzLnRvLmhzbCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGhzbGEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cdHJldHVybiBoc2xhLmxlbmd0aCA8IDQgfHwgaHNsYVszXSA9PT0gMVxuXHRcdD8gJ2hzbCgnICsgaHNsYVswXSArICcsICcgKyBoc2xhWzFdICsgJyUsICcgKyBoc2xhWzJdICsgJyUpJ1xuXHRcdDogJ2hzbGEoJyArIGhzbGFbMF0gKyAnLCAnICsgaHNsYVsxXSArICclLCAnICsgaHNsYVsyXSArICclLCAnICsgaHNsYVszXSArICcpJztcbn07XG5cbi8vIGh3YiBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiByZ2IoYSkgJiBoc2woYSkgc2luY2UgdGhlcmUgaXMgbm8gYWxwaGEgc3BlY2lmaWMgc3ludGF4XG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXG5jcy50by5od2IgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBod2JhID0gc3dpenpsZShhcmd1bWVudHMpO1xuXG5cdHZhciBhID0gJyc7XG5cdGlmIChod2JhLmxlbmd0aCA+PSA0ICYmIGh3YmFbM10gIT09IDEpIHtcblx0XHRhID0gJywgJyArIGh3YmFbM107XG5cdH1cblxuXHRyZXR1cm4gJ2h3YignICsgaHdiYVswXSArICcsICcgKyBod2JhWzFdICsgJyUsICcgKyBod2JhWzJdICsgJyUnICsgYSArICcpJztcbn07XG5cbmNzLnRvLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn07XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcblx0cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuXHR2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/ICcwJyArIHN0ciA6IHN0cjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbG9yU3RyaW5nID0gcmVxdWlyZSgnY29sb3Itc3RyaW5nJyk7XG52YXIgY29udmVydCA9IHJlcXVpcmUoJ2NvbG9yLWNvbnZlcnQnKTtcblxudmFyIF9zbGljZSA9IFtdLnNsaWNlO1xuXG52YXIgc2tpcHBlZE1vZGVscyA9IFtcblx0Ly8gdG8gYmUgaG9uZXN0LCBJIGRvbid0IHJlYWxseSBmZWVsIGxpa2Uga2V5d29yZCBiZWxvbmdzIGluIGNvbG9yIGNvbnZlcnQsIGJ1dCBlaC5cblx0J2tleXdvcmQnLFxuXG5cdC8vIGdyYXkgY29uZmxpY3RzIHdpdGggc29tZSBtZXRob2QgbmFtZXMsIGFuZCBoYXMgaXRzIG93biBtZXRob2QgZGVmaW5lZC5cblx0J2dyYXknLFxuXG5cdC8vIHNob3VsZG4ndCByZWFsbHkgYmUgaW4gY29sb3ItY29udmVydCBlaXRoZXIuLi5cblx0J2hleCdcbl07XG5cbnZhciBoYXNoZWRNb2RlbEtleXMgPSB7fTtcbk9iamVjdC5rZXlzKGNvbnZlcnQpLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsKSB7XG5cdGhhc2hlZE1vZGVsS2V5c1tfc2xpY2UuY2FsbChjb252ZXJ0W21vZGVsXS5sYWJlbHMpLnNvcnQoKS5qb2luKCcnKV0gPSBtb2RlbDtcbn0pO1xuXG52YXIgbGltaXRlcnMgPSB7fTtcblxuZnVuY3Rpb24gQ29sb3Iob2JqLCBtb2RlbCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmosIG1vZGVsKTtcblx0fVxuXG5cdGlmIChtb2RlbCAmJiBtb2RlbCBpbiBza2lwcGVkTW9kZWxzKSB7XG5cdFx0bW9kZWwgPSBudWxsO1xuXHR9XG5cblx0aWYgKG1vZGVsICYmICEobW9kZWwgaW4gY29udmVydCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZWw6ICcgKyBtb2RlbCk7XG5cdH1cblxuXHR2YXIgaTtcblx0dmFyIGNoYW5uZWxzO1xuXG5cdGlmICghb2JqKSB7XG5cdFx0dGhpcy5tb2RlbCA9ICdyZ2InO1xuXHRcdHRoaXMuY29sb3IgPSBbMCwgMCwgMF07XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0dGhpcy5tb2RlbCA9IG9iai5tb2RlbDtcblx0XHR0aGlzLmNvbG9yID0gb2JqLmNvbG9yLnNsaWNlKCk7XG5cdFx0dGhpcy52YWxwaGEgPSBvYmoudmFscGhhO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGNvbG9yU3RyaW5nLmdldChvYmopO1xuXHRcdGlmIChyZXN1bHQgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gc3RyaW5nOiAnICsgb2JqKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vZGVsID0gcmVzdWx0Lm1vZGVsO1xuXHRcdGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHR0aGlzLmNvbG9yID0gcmVzdWx0LnZhbHVlLnNsaWNlKDAsIGNoYW5uZWxzKTtcblx0XHR0aGlzLnZhbHBoYSA9IHR5cGVvZiByZXN1bHQudmFsdWVbY2hhbm5lbHNdID09PSAnbnVtYmVyJyA/IHJlc3VsdC52YWx1ZVtjaGFubmVsc10gOiAxO1xuXHR9IGVsc2UgaWYgKG9iai5sZW5ndGgpIHtcblx0XHR0aGlzLm1vZGVsID0gbW9kZWwgfHwgJ3JnYic7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBuZXdBcnIgPSBfc2xpY2UuY2FsbChvYmosIDAsIGNoYW5uZWxzKTtcblx0XHR0aGlzLmNvbG9yID0gemVyb0FycmF5KG5ld0FyciwgY2hhbm5lbHMpO1xuXHRcdHRoaXMudmFscGhhID0gdHlwZW9mIG9ialtjaGFubmVsc10gPT09ICdudW1iZXInID8gb2JqW2NoYW5uZWxzXSA6IDE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHQvLyB0aGlzIGlzIGFsd2F5cyBSR0IgLSBjYW4gYmUgY29udmVydGVkIGxhdGVyIG9uLlxuXHRcdG9iaiAmPSAweEZGRkZGRjtcblx0XHR0aGlzLm1vZGVsID0gJ3JnYic7XG5cdFx0dGhpcy5jb2xvciA9IFtcblx0XHRcdChvYmogPj4gMTYpICYgMHhGRixcblx0XHRcdChvYmogPj4gOCkgJiAweEZGLFxuXHRcdFx0b2JqICYgMHhGRlxuXHRcdF07XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMudmFscGhhID0gMTtcblxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRpZiAoJ2FscGhhJyBpbiBvYmopIHtcblx0XHRcdGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZignYWxwaGEnKSwgMSk7XG5cdFx0XHR0aGlzLnZhbHBoYSA9IHR5cGVvZiBvYmouYWxwaGEgPT09ICdudW1iZXInID8gb2JqLmFscGhhIDogMDtcblx0XHR9XG5cblx0XHR2YXIgaGFzaGVkS2V5cyA9IGtleXMuc29ydCgpLmpvaW4oJycpO1xuXHRcdGlmICghKGhhc2hlZEtleXMgaW4gaGFzaGVkTW9kZWxLZXlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vZGVsID0gaGFzaGVkTW9kZWxLZXlzW2hhc2hlZEtleXNdO1xuXG5cdFx0dmFyIGxhYmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0ubGFiZWxzO1xuXHRcdHZhciBjb2xvciA9IFtdO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbG9yLnB1c2gob2JqW2xhYmVsc1tpXV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuY29sb3IgPSB6ZXJvQXJyYXkoY29sb3IpO1xuXHR9XG5cblx0Ly8gcGVyZm9ybSBsaW1pdGF0aW9ucyAoY2xhbXBpbmcsIGV0Yy4pXG5cdGlmIChsaW1pdGVyc1t0aGlzLm1vZGVsXSkge1xuXHRcdGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuXHRcdFx0dmFyIGxpbWl0ID0gbGltaXRlcnNbdGhpcy5tb2RlbF1baV07XG5cdFx0XHRpZiAobGltaXQpIHtcblx0XHRcdFx0dGhpcy5jb2xvcltpXSA9IGxpbWl0KHRoaXMuY29sb3JbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRoaXMudmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy52YWxwaGEpKTtcblxuXHRpZiAoT2JqZWN0LmZyZWV6ZSkge1xuXHRcdE9iamVjdC5mcmVlemUodGhpcyk7XG5cdH1cbn1cblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnN0cmluZygpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzW3RoaXMubW9kZWxdKCk7XG5cdH0sXG5cblx0c3RyaW5nOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLm1vZGVsIGluIGNvbG9yU3RyaW5nLnRvID8gdGhpcyA6IHRoaXMucmdiKCk7XG5cdFx0c2VsZiA9IHNlbGYucm91bmQodHlwZW9mIHBsYWNlcyA9PT0gJ251bWJlcicgPyBwbGFjZXMgOiAxKTtcblx0XHR2YXIgYXJncyA9IHNlbGYudmFscGhhID09PSAxID8gc2VsZi5jb2xvciA6IHNlbGYuY29sb3IuY29uY2F0KHRoaXMudmFscGhhKTtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG9bc2VsZi5tb2RlbF0oYXJncyk7XG5cdH0sXG5cblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKHBsYWNlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcy5yZ2IoKS5yb3VuZCh0eXBlb2YgcGxhY2VzID09PSAnbnVtYmVyJyA/IHBsYWNlcyA6IDEpO1xuXHRcdHZhciBhcmdzID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogc2VsZi5jb2xvci5jb25jYXQodGhpcy52YWxwaGEpO1xuXHRcdHJldHVybiBjb2xvclN0cmluZy50by5yZ2IucGVyY2VudChhcmdzKTtcblx0fSxcblxuXHRhcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHBoYSA9PT0gMSA/IHRoaXMuY29sb3Iuc2xpY2UoKSA6IHRoaXMuY29sb3IuY29uY2F0KHRoaXMudmFscGhhKTtcblx0fSxcblxuXHRvYmplY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0dmFyIGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHR2YXIgbGFiZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5sYWJlbHM7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxzOyBpKyspIHtcblx0XHRcdHJlc3VsdFtsYWJlbHNbaV1dID0gdGhpcy5jb2xvcltpXTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJlc3VsdC5hbHBoYSA9IHRoaXMudmFscGhhO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0dW5pdEFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0cmdiWzBdIC89IDI1NTtcblx0XHRyZ2JbMV0gLz0gMjU1O1xuXHRcdHJnYlsyXSAvPSAyNTU7XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJnYi5wdXNoKHRoaXMudmFscGhhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9LFxuXG5cdHVuaXRPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5vYmplY3QoKTtcblx0XHRyZ2IuciAvPSAyNTU7XG5cdFx0cmdiLmcgLz0gMjU1O1xuXHRcdHJnYi5iIC89IDI1NTtcblxuXHRcdGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuXHRcdFx0cmdiLmFscGhhID0gdGhpcy52YWxwaGE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKHBsYWNlcykge1xuXHRcdHBsYWNlcyA9IE1hdGgubWF4KHBsYWNlcyB8fCAwLCAwKTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMuY29sb3IubWFwKHJvdW5kVG9QbGFjZShwbGFjZXMpKS5jb25jYXQodGhpcy52YWxwaGEpLCB0aGlzLm1vZGVsKTtcblx0fSxcblxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMuY29sb3IuY29uY2F0KE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbCkpKSwgdGhpcy5tb2RlbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudmFscGhhO1xuXHR9LFxuXG5cdC8vIHJnYlxuXHRyZWQ6IGdldHNldCgncmdiJywgMCwgbWF4Zm4oMjU1KSksXG5cdGdyZWVuOiBnZXRzZXQoJ3JnYicsIDEsIG1heGZuKDI1NSkpLFxuXHRibHVlOiBnZXRzZXQoJ3JnYicsIDIsIG1heGZuKDI1NSkpLFxuXG5cdGh1ZTogZ2V0c2V0KFsnaHNsJywgJ2hzdicsICdoc2wnLCAnaHdiJywgJ2hjZyddLCAwLCBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAoKHZhbCAlIDM2MCkgKyAzNjApICUgMzYwOyB9KSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG5cdHNhdHVyYXRpb25sOiBnZXRzZXQoJ2hzbCcsIDEsIG1heGZuKDEwMCkpLFxuXHRsaWdodG5lc3M6IGdldHNldCgnaHNsJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0c2F0dXJhdGlvbnY6IGdldHNldCgnaHN2JywgMSwgbWF4Zm4oMTAwKSksXG5cdHZhbHVlOiBnZXRzZXQoJ2hzdicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGNocm9tYTogZ2V0c2V0KCdoY2cnLCAxLCBtYXhmbigxMDApKSxcblx0Z3JheTogZ2V0c2V0KCdoY2cnLCAyLCBtYXhmbigxMDApKSxcblxuXHR3aGl0ZTogZ2V0c2V0KCdod2InLCAxLCBtYXhmbigxMDApKSxcblx0d2JsYWNrOiBnZXRzZXQoJ2h3YicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGN5YW46IGdldHNldCgnY215aycsIDAsIG1heGZuKDEwMCkpLFxuXHRtYWdlbnRhOiBnZXRzZXQoJ2NteWsnLCAxLCBtYXhmbigxMDApKSxcblx0eWVsbG93OiBnZXRzZXQoJ2NteWsnLCAyLCBtYXhmbigxMDApKSxcblx0YmxhY2s6IGdldHNldCgnY215aycsIDMsIG1heGZuKDEwMCkpLFxuXG5cdHg6IGdldHNldCgneHl6JywgMCwgbWF4Zm4oMTAwKSksXG5cdHk6IGdldHNldCgneHl6JywgMSwgbWF4Zm4oMTAwKSksXG5cdHo6IGdldHNldCgneHl6JywgMiwgbWF4Zm4oMTAwKSksXG5cblx0bDogZ2V0c2V0KCdsYWInLCAwLCBtYXhmbigxMDApKSxcblx0YTogZ2V0c2V0KCdsYWInLCAxKSxcblx0YjogZ2V0c2V0KCdsYWInLCAyKSxcblxuXHRrZXl3b3JkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29udmVydFt0aGlzLm1vZGVsXS5rZXl3b3JkKHRoaXMuY29sb3IpO1xuXHR9LFxuXG5cdGhleDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvLmhleCh0aGlzLnJnYigpLnJvdW5kKCkuY29sb3IpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHJldHVybiAoKHJnYlswXSAmIDB4RkYpIDw8IDE2KSB8ICgocmdiWzFdICYgMHhGRikgPDwgOCkgfCAocmdiWzJdICYgMHhGRik7XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblxuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXG5cdFx0aWYgKGx1bTEgPiBsdW0yKSB7XG5cdFx0XHRyZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0aXNEYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRpc0xpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzRGFyaygpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2IuY29sb3JbaV0gPSAyNTUgLSByZ2IuY29sb3JbaV07XG5cdFx0fVxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzJdICs9IGhzbC5jb2xvclsyXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMl0gLT0gaHNsLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzFdICs9IGhzbC5jb2xvclsxXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzFdIC09IGhzbC5jb2xvclsxXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy5od2IoKTtcblx0XHRod2IuY29sb3JbMV0gKz0gaHdiLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGh3Yjtcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy5od2IoKTtcblx0XHRod2IuY29sb3JbMl0gKz0gaHdiLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGh3Yjtcblx0fSxcblxuXHRncmF5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHRyZXR1cm4gQ29sb3IucmdiKHZhbCwgdmFsLCB2YWwpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhIC0gKHRoaXMudmFscGhhICogcmF0aW8pKTtcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHRyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSArICh0aGlzLnZhbHBoYSAqIHJhdGlvKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdHZhciBodWUgPSBoc2wuY29sb3JbMF07XG5cdFx0aHVlID0gKGh1ZSArIGRlZ3JlZXMpICUgMzYwO1xuXHRcdGh1ZSA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG5cdFx0aHNsLmNvbG9yWzBdID0gaHVlO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0Ly8gcG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdFx0dmFyIGNvbG9yMSA9IG1peGluQ29sb3IucmdiKCk7XG5cdFx0dmFyIGNvbG9yMiA9IHRoaXMucmdiKCk7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiBDb2xvci5yZ2IoXG5cdFx0XHRcdHcxICogY29sb3IxLnJlZCgpICsgdzIgKiBjb2xvcjIucmVkKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKCksXG5cdFx0XHRcdGNvbG9yMS5hbHBoYSgpICogcCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSBwKSk7XG5cdH1cbn07XG5cbi8vIG1vZGVsIGNvbnZlcnNpb24gbWV0aG9kcyBhbmQgc3RhdGljIGNvbnN0cnVjdG9yc1xuT2JqZWN0LmtleXMoY29udmVydCkuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcblx0aWYgKHNraXBwZWRNb2RlbHMuaW5kZXhPZihtb2RlbCkgIT09IC0xKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGNoYW5uZWxzID0gY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cblx0Ly8gY29udmVyc2lvbiBtZXRob2RzXG5cdENvbG9yLnByb3RvdHlwZVttb2RlbF0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMubW9kZWwgPT09IG1vZGVsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKGFyZ3VtZW50cywgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHZhciBuZXdBbHBoYSA9IHR5cGVvZiBhcmd1bWVudHNbY2hhbm5lbHNdID09PSAnbnVtYmVyJyA/IGNoYW5uZWxzIDogdGhpcy52YWxwaGE7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihhc3NlcnRBcnJheShjb252ZXJ0W3RoaXMubW9kZWxdW21vZGVsXS5yYXcodGhpcy5jb2xvcikpLmNvbmNhdChuZXdBbHBoYSksIG1vZGVsKTtcblx0fTtcblxuXHQvLyAnc3RhdGljJyBjb25zdHJ1Y3Rpb24gbWV0aG9kc1xuXHRDb2xvclttb2RlbF0gPSBmdW5jdGlvbiAoY29sb3IpIHtcblx0XHRpZiAodHlwZW9mIGNvbG9yID09PSAnbnVtYmVyJykge1xuXHRcdFx0Y29sb3IgPSB6ZXJvQXJyYXkoX3NsaWNlLmNhbGwoYXJndW1lbnRzKSwgY2hhbm5lbHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IENvbG9yKGNvbG9yLCBtb2RlbCk7XG5cdH07XG59KTtcblxuZnVuY3Rpb24gcm91bmRUbyhudW0sIHBsYWNlcykge1xuXHRyZXR1cm4gTnVtYmVyKG51bS50b0ZpeGVkKHBsYWNlcykpO1xufVxuXG5mdW5jdGlvbiByb3VuZFRvUGxhY2UocGxhY2VzKSB7XG5cdHJldHVybiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0cmV0dXJuIHJvdW5kVG8obnVtLCBwbGFjZXMpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRzZXQobW9kZWwsIGNoYW5uZWwsIG1vZGlmaWVyKSB7XG5cdG1vZGVsID0gQXJyYXkuaXNBcnJheShtb2RlbCkgPyBtb2RlbCA6IFttb2RlbF07XG5cblx0bW9kZWwuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuXHRcdChsaW1pdGVyc1ttXSB8fCAobGltaXRlcnNbbV0gPSBbXSkpW2NoYW5uZWxdID0gbW9kaWZpZXI7XG5cdH0pO1xuXG5cdG1vZGVsID0gbW9kZWxbMF07XG5cblx0cmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcblx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdGlmIChtb2RpZmllcikge1xuXHRcdFx0XHR2YWwgPSBtb2RpZmllcih2YWwpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQgPSB0aGlzW21vZGVsXSgpO1xuXHRcdFx0cmVzdWx0LmNvbG9yW2NoYW5uZWxdID0gdmFsO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cblx0XHRyZXN1bHQgPSB0aGlzW21vZGVsXSgpLmNvbG9yW2NoYW5uZWxdO1xuXHRcdGlmIChtb2RpZmllcikge1xuXHRcdFx0cmVzdWx0ID0gbW9kaWZpZXIocmVzdWx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufVxuXG5mdW5jdGlvbiBtYXhmbihtYXgpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICh2KSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgdikpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBcnJheSh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFt2YWxdO1xufVxuXG5mdW5jdGlvbiB6ZXJvQXJyYXkoYXJyLCBsZW5ndGgpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgYXJyW2ldICE9PSAnbnVtYmVyJykge1xuXHRcdFx0YXJyW2ldID0gMDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLy8gVGhpcyBmaWxlIGNhbiBiZSByZXF1aXJlZCBpbiBCcm93c2VyaWZ5IGFuZCBOb2RlLmpzIGZvciBhdXRvbWF0aWMgcG9seWZpbGxcbi8vIFRvIHVzZSBpdDogIHJlcXVpcmUoJ2VzNi1wcm9taXNlL2F1dG8nKTtcbid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKS5wb2x5ZmlsbCgpO1xuIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjUrN2YyYjUyNmRcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuXG4gIGlmIChfc3RhdGUpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IHsgZXJyb3I6IG51bGwgfTtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihwcm9taXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBUUllfQ0FUQ0hfRVJST1IuZXJyb3IpO1xuICAgICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDAsXG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgcmV0dXJuIFRSWV9DQVRDSF9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMCxcbiAgICAgIHN1Y2NlZWRlZCA9IHZvaWQgMCxcbiAgICAgIGZhaWxlZCA9IHZvaWQgMDtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgdmFsdWUuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbnZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuICB9XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIF9lbnVtZXJhdGUoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gX2VhY2hFbnRyeShlbnRyeSwgaSkge1xuICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuXG4gICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcbiIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xufVxuXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgIF07XG59XG5cbi8qKlxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG5cbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICAgIHZhciBsYXN0VG91Y2ggPSB7eDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WX07XG4gICAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WCwgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcblxuLyoqXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG59XG5cblRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAqL1xuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gICAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gICAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gICAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG59XG5cblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBkZWZhdWx0czoge30sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplcik7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJvcDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxuXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG5cbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG5cbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxuICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxuICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcblxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG59KTtcblxuLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxudmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbn0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG4iLCJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iLCJpbXBvcnQge2NyZWF0ZUZyYW1lLCBleHRlbmQsIHRvU3RyaW5nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHRIZWxwZXJzfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMC4xMic7XG5leHBvcnQgY29uc3QgQ09NUElMRVJfUkVWSVNJT04gPSA3O1xuXG5leHBvcnQgY29uc3QgUkVWSVNJT05fQ0hBTkdFUyA9IHtcbiAgMTogJzw9IDEuMC5yYy4yJywgLy8gMS4wLnJjLjIgaXMgYWN0dWFsbHkgcmV2MiBidXQgZG9lc24ndCByZXBvcnQgaXRcbiAgMjogJz09IDEuMC4wLXJjLjMnLFxuICAzOiAnPT0gMS4wLjAtcmMuNCcsXG4gIDQ6ICc9PSAxLngueCcsXG4gIDU6ICc9PSAyLjAuMC1hbHBoYS54JyxcbiAgNjogJz49IDIuMC4wLWJldGEuMScsXG4gIDc6ICc+PSA0LjAuMCdcbn07XG5cbmNvbnN0IG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZXhwb3J0IGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cbiAgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbiAgcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyh0aGlzKTtcbn1cblxuSGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcblxuICBsb2dnZXI6IGxvZ2dlcixcbiAgbG9nOiBsb2dnZXIubG9nLFxuXG4gIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSwgcGFydGlhbCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBleHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJHtuYW1lfVwiIGFzIHVuZGVmaW5lZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xuICB9XG59O1xuXG5leHBvcnQgbGV0IGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydCB7Y3JlYXRlRnJhbWUsIGxvZ2dlcn07XG4iLCJpbXBvcnQgcmVnaXN0ZXJJbmxpbmUgZnJvbSAnLi9kZWNvcmF0b3JzL2lubGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVySW5saW5lKGluc3RhbmNlKTtcbn1cblxuIiwiaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IHJldCA9IGZuO1xuICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcbiAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XG4gICAgICByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICBsZXQgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcbiAgICAgICAgbGV0IHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsIlxuY29uc3QgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbjtcbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGxvYykge1xuICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcblxuICAgICAgLy8gV29yayBhcm91bmQgaXNzdWUgdW5kZXIgc2FmYXJpIHdoZXJlIHdlIGNhbid0IGRpcmVjdGx5IHNldCB0aGUgY29sdW1uIHZhbHVlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcbiAgICAgICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKG5vcCkge1xuICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiIsImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgY3JlYXRlRnJhbWUsIGlzQXJyYXl9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6IGRhdGF9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7IGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTsgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7Zm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNofSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uKG9iaiwgZmllbGQpIHtcbiAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2luZGV4T2Z9IGZyb20gJy4vdXRpbHMnO1xuXG5sZXQgbG9nZ2VyID0ge1xuICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxuICBsb29rdXBMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGxldmVsTWFwID0gaW5kZXhPZihsb2dnZXIubWV0aG9kTWFwLCBsZXZlbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChsZXZlbE1hcCA+PSAwKSB7XG4gICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9LFxuXG4gIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIC4uLm1lc3NhZ2UpIHtcbiAgICBsZXZlbCA9IGxvZ2dlci5sb29rdXBMZXZlbChsZXZlbCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGxvZ2dlci5sb29rdXBMZXZlbChsb2dnZXIubGV2ZWwpIDw9IGxldmVsKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgbWV0aG9kID0gJ2xvZyc7XG4gICAgICB9XG4gICAgICBjb25zb2xlW21ldGhvZF0oLi4ubWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbG9nZ2VyO1xuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oSGFuZGxlYmFycykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBsZXQgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICAgICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGFuZGxlYmFycztcbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQgeyBDT01QSUxFUl9SRVZJU0lPTiwgUkVWSVNJT05fQ0hBTkdFUywgY3JlYXRlRnJhbWUgfSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXZpc2lvbihjb21waWxlckluZm8pIHtcbiAgY29uc3QgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcbiAgICAgICAgY3VycmVudFJldmlzaW9uID0gQ09NUElMRVJfUkVWSVNJT047XG5cbiAgaWYgKGNvbXBpbGVyUmV2aXNpb24gIT09IGN1cnJlbnRSZXZpc2lvbikge1xuICAgIGlmIChjb21waWxlclJldmlzaW9uIDwgY3VycmVudFJldmlzaW9uKSB7XG4gICAgICBjb25zdCBydW50aW1lVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXG4gICAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGFuIG9sZGVyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBydW50aW1lVmVyc2lvbnMgKyAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgKyBjb21waWxlclZlcnNpb25zICsgJykuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSB0aGUgZW1iZWRkZWQgdmVyc2lvbiBpbmZvIHNpbmNlIHRoZSBydW50aW1lIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHJldmlzaW9uIHlldFxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBjb21waWxlckluZm9bMV0gKyAnKS4nKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHRlbXBsYXRlU3BlYywgZW52KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghZW52KSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XG4gIH1cbiAgaWYgKCF0ZW1wbGF0ZVNwZWMgfHwgIXRlbXBsYXRlU3BlYy5tYWluKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5rbm93biB0ZW1wbGF0ZSBvYmplY3Q6ICcgKyB0eXBlb2YgdGVtcGxhdGVTcGVjKTtcbiAgfVxuXG4gIHRlbXBsYXRlU3BlYy5tYWluLmRlY29yYXRvciA9IHRlbXBsYXRlU3BlYy5tYWluX2Q7XG5cbiAgLy8gTm90ZTogVXNpbmcgZW52LlZNIHJlZmVyZW5jZXMgcmF0aGVyIHRoYW4gbG9jYWwgdmFyIHJlZmVyZW5jZXMgdGhyb3VnaG91dCB0aGlzIHNlY3Rpb24gdG8gYWxsb3dcbiAgLy8gZm9yIGV4dGVybmFsIHVzZXJzIHRvIG92ZXJyaWRlIHRoZXNlIGFzIHBzdWVkby1zdXBwb3J0ZWQgQVBJcy5cbiAgZW52LlZNLmNoZWNrUmV2aXNpb24odGVtcGxhdGVTcGVjLmNvbXBpbGVyKTtcblxuICBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsV3JhcHBlcihwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgICAgY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgY29udGV4dCwgb3B0aW9ucy5oYXNoKTtcbiAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICBvcHRpb25zLmlkc1swXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFydGlhbCA9IGVudi5WTS5yZXNvbHZlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIGxldCByZXN1bHQgPSBlbnYuVk0uaW52b2tlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIGVudi5jb21waWxlKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0gPSBlbnYuY29tcGlsZShwYXJ0aWFsLCB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJPcHRpb25zLCBlbnYpO1xuICAgICAgcmVzdWx0ID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICBsZXQgbGluZXMgPSByZXN1bHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICghbGluZXNbaV0gJiYgaSArIDEgPT09IGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpbmVzW2ldID0gb3B0aW9ucy5pbmRlbnQgKyBsaW5lc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjb21waWxlZCB3aGVuIHJ1bm5pbmcgaW4gcnVudGltZS1vbmx5IG1vZGUnKTtcbiAgICB9XG4gIH1cblxuICAvLyBKdXN0IGFkZCB3YXRlclxuICBsZXQgY29udGFpbmVyID0ge1xuICAgIHN0cmljdDogZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignXCInICsgbmFtZSArICdcIiBub3QgZGVmaW5lZCBpbiAnICsgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpbbmFtZV07XG4gICAgfSxcbiAgICBsb29rdXA6IGZ1bmN0aW9uKGRlcHRocywgbmFtZSkge1xuICAgICAgY29uc3QgbGVuID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBkZXB0aHNbaV1bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbWJkYTogZnVuY3Rpb24oY3VycmVudCwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnZnVuY3Rpb24nID8gY3VycmVudC5jYWxsKGNvbnRleHQpIDogY3VycmVudDtcbiAgICB9LFxuXG4gICAgZXNjYXBlRXhwcmVzc2lvbjogVXRpbHMuZXNjYXBlRXhwcmVzc2lvbixcbiAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcblxuICAgIGZuOiBmdW5jdGlvbihpKSB7XG4gICAgICBsZXQgcmV0ID0gdGVtcGxhdGVTcGVjW2ldO1xuICAgICAgcmV0LmRlY29yYXRvciA9IHRlbXBsYXRlU3BlY1tpICsgJ19kJ107XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBwcm9ncmFtczogW10sXG4gICAgcHJvZ3JhbTogZnVuY3Rpb24oaSwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgICAgbGV0IHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSxcbiAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICBpZiAoZGF0YSB8fCBkZXB0aHMgfHwgYmxvY2tQYXJhbXMgfHwgZGVjbGFyZWRCbG9ja1BhcmFtcykge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24odmFsdWUsIGRlcHRoKSB7XG4gICAgICB3aGlsZSAodmFsdWUgJiYgZGVwdGgtLSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLl9wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBtZXJnZTogZnVuY3Rpb24ocGFyYW0sIGNvbW1vbikge1xuICAgICAgbGV0IG9iaiA9IHBhcmFtIHx8IGNvbW1vbjtcblxuICAgICAgaWYgKHBhcmFtICYmIGNvbW1vbiAmJiAocGFyYW0gIT09IGNvbW1vbikpIHtcbiAgICAgICAgb2JqID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIC8vIEFuIGVtcHR5IG9iamVjdCB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIG51bGwtY29udGV4dHNcbiAgICBudWxsQ29udGV4dDogT2JqZWN0LnNlYWwoe30pLFxuXG4gICAgbm9vcDogZW52LlZNLm5vb3AsXG4gICAgY29tcGlsZXJJbmZvOiB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJcbiAgfTtcblxuICBmdW5jdGlvbiByZXQoY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG5cbiAgICByZXQuX3NldHVwKG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsICYmIHRlbXBsYXRlU3BlYy51c2VEYXRhKSB7XG4gICAgICBkYXRhID0gaW5pdERhdGEoY29udGV4dCwgZGF0YSk7XG4gICAgfVxuICAgIGxldCBkZXB0aHMsXG4gICAgICAgIGJsb2NrUGFyYW1zID0gdGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zID8gW10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMpIHtcbiAgICAgIGlmIChvcHRpb25zLmRlcHRocykge1xuICAgICAgICBkZXB0aHMgPSBjb250ZXh0ICE9IG9wdGlvbnMuZGVwdGhzWzBdID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBvcHRpb25zLmRlcHRocztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQvKiwgb3B0aW9ucyovKSB7XG4gICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIH1cbiAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnModGVtcGxhdGVTcGVjLm1haW4sIG1haW4sIGNvbnRhaW5lciwgb3B0aW9ucy5kZXB0aHMgfHwgW10sIGRhdGEsIGJsb2NrUGFyYW1zKTtcbiAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuaGVscGVycywgZW52LmhlbHBlcnMpO1xuXG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwgfHwgdGVtcGxhdGVTcGVjLnVzZURlY29yYXRvcnMpIHtcbiAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5kZWNvcmF0b3JzLCBlbnYuZGVjb3JhdG9ycyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3B0aW9ucy5wYXJ0aWFscztcbiAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gb3B0aW9ucy5kZWNvcmF0b3JzO1xuICAgIH1cbiAgfTtcblxuICByZXQuX2NoaWxkID0gZnVuY3Rpb24oaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgJiYgIWJsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgZnVuY3Rpb24gcHJvZyhjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY3VycmVudERlcHRocyA9IGRlcHRocztcbiAgICBpZiAoZGVwdGhzICYmIGNvbnRleHQgIT0gZGVwdGhzWzBdICYmICEoY29udGV4dCA9PT0gY29udGFpbmVyLm51bGxDb250ZXh0ICYmIGRlcHRoc1swXSA9PT0gbnVsbCkpIHtcbiAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGNvbnRhaW5lcixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscyxcbiAgICAgICAgb3B0aW9ucy5kYXRhIHx8IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zICYmIFtvcHRpb25zLmJsb2NrUGFyYW1zXS5jb25jYXQoYmxvY2tQYXJhbXMpLFxuICAgICAgICBjdXJyZW50RGVwdGhzKTtcbiAgfVxuXG4gIHByb2cgPSBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKTtcblxuICBwcm9nLnByb2dyYW0gPSBpO1xuICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XG4gIHByb2cuYmxvY2tQYXJhbXMgPSBkZWNsYXJlZEJsb2NrUGFyYW1zIHx8IDA7XG4gIHJldHVybiBwcm9nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAoIXBhcnRpYWwpIHtcbiAgICBpZiAob3B0aW9ucy5uYW1lID09PSAnQHBhcnRpYWwtYmxvY2snKSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFwYXJ0aWFsLmNhbGwgJiYgIW9wdGlvbnMubmFtZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkeW5hbWljIHBhcnRpYWwgdGhhdCByZXR1cm5lZCBhIHN0cmluZ1xuICAgIG9wdGlvbnMubmFtZSA9IHBhcnRpYWw7XG4gICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbcGFydGlhbF07XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gVXNlIHRoZSBjdXJyZW50IGNsb3N1cmUgY29udGV4dCB0byBzYXZlIHRoZSBwYXJ0aWFsLWJsb2NrIGlmIHRoaXMgcGFydGlhbFxuICBjb25zdCBjdXJyZW50UGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICBvcHRpb25zLmRhdGEuY29udGV4dFBhdGggPSBvcHRpb25zLmlkc1swXSB8fCBvcHRpb25zLmRhdGEuY29udGV4dFBhdGg7XG4gIH1cblxuICBsZXQgcGFydGlhbEJsb2NrO1xuICBpZiAob3B0aW9ucy5mbiAmJiBvcHRpb25zLmZuICE9PSBub29wKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAvLyBXcmFwcGVyIGZ1bmN0aW9uIHRvIGdldCBhY2Nlc3MgdG8gY3VycmVudFBhcnRpYWxCbG9jayBmcm9tIHRoZSBjbG9zdXJlXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcbiAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGZ1bmN0aW9uIHBhcnRpYWxCbG9ja1dyYXBwZXIoY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIHBhcnRpYWwtYmxvY2sgZnJvbSB0aGUgY2xvc3VyZSBmb3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgYmxvY2tcbiAgICAgIC8vIGkuZS4gdGhlIHBhcnQgaW5zaWRlIHRoZSBibG9jayBvZiB0aGUgcGFydGlhbCBjYWxsLlxuICAgICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgIG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gY3VycmVudFBhcnRpYWxCbG9jaztcbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmIChmbi5wYXJ0aWFscykge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFscyA9IFV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucy5wYXJ0aWFscywgZm4ucGFydGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XG4gICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgcmV0dXJuICcnOyB9XG5cbmZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICEoJ3Jvb3QnIGluIGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEgPyBjcmVhdGVGcmFtZShkYXRhKSA6IHt9O1xuICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpIHtcbiAgaWYgKGZuLmRlY29yYXRvcikge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIHByb2cgPSBmbi5kZWNvcmF0b3IocHJvZywgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGhzICYmIGRlcHRoc1swXSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgVXRpbHMuZXh0ZW5kKHByb2csIHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvZztcbn1cbiIsIi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBTYWZlU3RyaW5nLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcnICsgdGhpcy5zdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTYWZlU3RyaW5nO1xuIiwiY29uc3QgZXNjYXBlID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgJ2AnOiAnJiN4NjA7JyxcbiAgJz0nOiAnJiN4M0Q7J1xufTtcblxuY29uc3QgYmFkQ2hhcnMgPSAvWyY8PlwiJ2A9XS9nLFxuICAgICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XG5cbmZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XG4gIHJldHVybiBlc2NhcGVbY2hyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChvYmovKiAsIC4uLnNvdXJjZSAqLykge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGxldCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtc3R5bGUgKi9cbmxldCBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG59XG5leHBvcnQge2lzRnVuY3Rpb259O1xuLyogZXNsaW50LWVuYWJsZSBmdW5jLXN0eWxlICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XG59O1xuXG4vLyBPbGRlciBJRSB2ZXJzaW9ucyBkbyBub3QgZGlyZWN0bHkgc3VwcG9ydCBpbmRleE9mIHNvIHdlIG11c3QgaW1wbGVtZW50IG91ciBvd24sIHNhZGx5LlxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcbiAgICBpZiAoc3RyaW5nICYmIHN0cmluZy50b0hUTUwpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudG9IVE1MKCk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgc3RyaW5nIGNvbnZlcnNpb24gYXMgdGhpcyB3aWxsIGJlIGRvbmUgYnkgdGhlIGFwcGVuZCByZWdhcmRsZXNzIGFuZFxuICAgIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxuICAgIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHsgcmV0dXJuIHN0cmluZzsgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcmFtZShvYmplY3QpIHtcbiAgbGV0IGZyYW1lID0gZXh0ZW5kKHt9LCBvYmplY3QpO1xuICBmcmFtZS5fcGFyZW50ID0gb2JqZWN0O1xuICByZXR1cm4gZnJhbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibG9ja1BhcmFtcyhwYXJhbXMsIGlkcykge1xuICBwYXJhbXMucGF0aCA9IGlkcztcbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENvbnRleHRQYXRoKGNvbnRleHRQYXRoLCBpZCkge1xuICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcbn1cbiIsIi8vIENyZWF0ZSBhIHNpbXBsZSBwYXRoIGFsaWFzIHRvIGFsbG93IGJyb3dzZXJpZnkgdG8gcmVzb2x2ZVxuLy8gdGhlIHJ1bnRpbWUgb24gYSBzdXBwb3J0ZWQgcGF0aC5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Nqcy9oYW5kbGViYXJzLnJ1bnRpbWUnKVsnZGVmYXVsdCddO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaGFuZGxlYmFycy9ydW50aW1lXCIpW1wiZGVmYXVsdFwiXTtcbiIsInZhciBNdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXJcbiAgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMiBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJlbmVkIGJ5IGEgQlNELXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG4gKi9cblxudmFyIFdlYWtNYXAgPSB3aW5kb3cuV2Vha01hcDtcblxuaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcblxuICBXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uYW1lID0gJ19fc3QnICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApICsgKGNvdW50ZXIrKyArICdfXycpO1xuICB9O1xuXG4gIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSlcbiAgICAgICAgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHt2YWx1ZTogW2tleSwgdmFsdWVdLCB3cml0YWJsZTogdHJ1ZX0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID9cbiAgICAgICAgICBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGhhc1ZhbHVlID0gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIGVudHJ5WzBdID0gZW50cnlbMV0gPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gaGFzVmFsdWU7XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICBpZiAoIWVudHJ5KSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICB9XG4gIH07XG59XG5cbnZhciByZWdpc3RyYXRpb25zVGFibGUgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBXZSB1c2Ugc2V0SW1tZWRpYXRlIG9yIHBvc3RNZXNzYWdlIGZvciBvdXIgZnV0dXJlIGNhbGxiYWNrLlxudmFyIHNldEltbWVkaWF0ZSA9IHdpbmRvdy5tc1NldEltbWVkaWF0ZTtcblxuLy8gVXNlIHBvc3QgbWVzc2FnZSB0byBlbXVsYXRlIHNldEltbWVkaWF0ZS5cbmlmICghc2V0SW1tZWRpYXRlKSB7XG4gIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICB2YXIgcXVldWUgPSBzZXRJbW1lZGlhdGVRdWV1ZTtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgd2luZG93LnBvc3RNZXNzYWdlKHNlbnRpbmVsLCAnKicpO1xuICB9O1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgd2UgbmV2ZXIgc2NoZWR1bGUgMiBjYWxsYXMgdG8gc2V0SW1tZWRpYXRlXG52YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcblxuLy8gS2VlcCB0cmFjayBvZiBvYnNlcnZlcnMgdGhhdCBuZWVkcyB0byBiZSBub3RpZmllZCBuZXh0IHRpbWUuXG52YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG5cbi8qKlxuICogU2NoZWR1bGVzIHxkaXNwYXRjaENhbGxiYWNrfCB0byBiZSBjYWxsZWQgaW4gdGhlIGZ1dHVyZS5cbiAqIEBwYXJhbSB7TXV0YXRpb25PYnNlcnZlcn0gb2JzZXJ2ZXJcbiAqL1xuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmXG4gICAgICB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwud3JhcElmTmVlZGVkKG5vZGUpIHx8XG4gICAgICBub2RlO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgLy8gaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI211dGF0aW9uLW9ic2VydmVyc1xuXG4gIGlzU2NoZWR1bGVkID0gZmFsc2U7IC8vIFVzZWQgdG8gYWxsb3cgYSBuZXcgc2V0SW1tZWRpYXRlIGNhbGwgYWJvdmUuXG5cbiAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIC8vIFNvcnQgb2JzZXJ2ZXJzIGJhc2VkIG9uIHRoZWlyIGNyZWF0aW9uIFVJRCAoaW5jcmVtZW50YWwpLlxuICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gIH0pO1xuXG4gIHZhciBhbnlOb25FbXB0eSA9IGZhbHNlO1xuICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuXG4gICAgLy8gMi4xLCAyLjJcbiAgICB2YXIgcXVldWUgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgIC8vIDIuMy4gUmVtb3ZlIGFsbCB0cmFuc2llbnQgcmVnaXN0ZXJlZCBvYnNlcnZlcnMgd2hvc2Ugb2JzZXJ2ZXIgaXMgbW8uXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKTtcblxuICAgIC8vIDIuNFxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gMy5cbiAgaWYgKGFueU5vbkVtcHR5KVxuICAgIGRpc3BhdGNoQ2FsbGJhY2tzKCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgIGlmICghcmVnaXN0cmF0aW9ucylcbiAgICAgIHJldHVybjtcbiAgICByZWdpc3RyYXRpb25zLmZvckVhY2goZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcilcbiAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHRoZSBcIkZvciBlYWNoIHJlZ2lzdGVyZWQgb2JzZXJ2ZXIgb2JzZXJ2ZXIgKHdpdGhcbiAqIG9ic2VydmVyJ3Mgb3B0aW9ucyBhcyBvcHRpb25zKSBpbiB0YXJnZXQncyBsaXN0IG9mIHJlZ2lzdGVyZWQgb2JzZXJ2ZXJzLFxuICogcnVuIHRoZXNlIHN1YnN0ZXBzOlwiIGFuZCB0aGUgXCJGb3IgZWFjaCBhbmNlc3RvciBhbmNlc3RvciBvZiB0YXJnZXQsIGFuZCBmb3JcbiAqIGVhY2ggcmVnaXN0ZXJlZCBvYnNlcnZlciBvYnNlcnZlciAod2l0aCBvcHRpb25zIG9wdGlvbnMpIGluIGFuY2VzdG9yJ3MgbGlzdFxuICogb2YgcmVnaXN0ZXJlZCBvYnNlcnZlcnMsIHJ1biB0aGVzZSBzdWJzdGVwczpcIiBwYXJ0IG9mIHRoZSBhbGdvcml0aG1zLiBUaGVcbiAqIHxvcHRpb25zLnN1YnRyZWV8IGlzIGNoZWNrZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZFxuICogY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE11dGF0aW9uT2JzZXJ2ZXJJbml0KTpNdXRhdGlvblJlY29yZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgIHZhciBvcHRpb25zID0gcmVnaXN0cmF0aW9uLm9wdGlvbnM7XG5cbiAgICAgICAgLy8gT25seSB0YXJnZXQgaWdub3JlcyBzdWJ0cmVlLlxuICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVjb3JkKVxuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB1aWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBUaGUgY2xhc3MgdGhhdCBtYXBzIHRvIHRoZSBET00gTXV0YXRpb25PYnNlcnZlciBpbnRlcmZhY2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgdGhpcy5ub2Rlc18gPSBbXTtcbiAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG59XG5cbkpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuXG4gICAgLy8gMS4xXG4gICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHxcblxuICAgICAgICAvLyAxLjJcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8XG5cbiAgICAgICAgLy8gMS4zXG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgIW9wdGlvbnMuYXR0cmlidXRlcyB8fFxuXG4gICAgICAgIC8vIDEuNFxuICAgICAgICBvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSB7XG5cbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgIGlmICghcmVnaXN0cmF0aW9ucylcbiAgICAgIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQodGFyZ2V0LCByZWdpc3RyYXRpb25zID0gW10pO1xuXG4gICAgLy8gMlxuICAgIC8vIElmIHRhcmdldCdzIGxpc3Qgb2YgcmVnaXN0ZXJlZCBvYnNlcnZlcnMgYWxyZWFkeSBpbmNsdWRlcyBhIHJlZ2lzdGVyZWRcbiAgICAvLyBvYnNlcnZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbnRleHQgb2JqZWN0LCByZXBsYWNlIHRoYXQgcmVnaXN0ZXJlZFxuICAgIC8vIG9ic2VydmVyJ3Mgb3B0aW9ucyB3aXRoIG9wdGlvbnMuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLlxuICAgIC8vIE90aGVyd2lzZSwgYWRkIGEgbmV3IHJlZ2lzdGVyZWQgb2JzZXJ2ZXIgdG8gdGFyZ2V0J3MgbGlzdCBvZiByZWdpc3RlcmVkXG4gICAgLy8gb2JzZXJ2ZXJzIHdpdGggdGhlIGNvbnRleHQgb2JqZWN0IGFzIHRoZSBvYnNlcnZlciBhbmQgb3B0aW9ucyBhcyB0aGVcbiAgICAvLyBvcHRpb25zLCBhbmQgYWRkIHRhcmdldCB0byBjb250ZXh0IG9iamVjdCdzIGxpc3Qgb2Ygbm9kZXMgb24gd2hpY2ggaXRcbiAgICAvLyBpcyByZWdpc3RlcmVkLlxuICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2gocmVnaXN0cmF0aW9uKTtcbiAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgLy8gRWFjaCBub2RlIGNhbiBvbmx5IGhhdmUgb25lIHJlZ2lzdGVyZWQgb2JzZXJ2ZXIgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgICAgLy8gdGhpcyBvYnNlcnZlci5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgfSxcblxuICB0YWtlUmVjb3JkczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICByZXR1cm4gY29weU9mUmVjb3JkcztcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICB0aGlzLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG51bGw7XG4gIHRoaXMub2xkVmFsdWUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgdmFyIHJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZChvcmlnaW5hbC50eXBlLCBvcmlnaW5hbC50YXJnZXQpO1xuICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gb3JpZ2luYWwucHJldmlvdXNTaWJsaW5nO1xuICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZXNwYWNlO1xuICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgcmV0dXJuIHJlY29yZDtcbn07XG5cbi8vIFdlIGtlZXAgdHJhY2sgb2YgdGhlIHR3byAocG9zc2libHkgb25lKSByZWNvcmRzIHVzZWQgaW4gYSBzaW5nbGUgbXV0YXRpb24uXG52YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZWNvcmQgd2l0aG91dCB8b2xkVmFsdWV8IGFuZCBjYWNoZXMgaXQgYXMgfGN1cnJlbnRSZWNvcmR8IGZvclxuICogbGF0ZXIgdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IG9sZFZhbHVlXG4gKiBAcmV0dXJuIHtNdXRhdGlvblJlY29yZH1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIEdldHMgb3IgY3JlYXRlcyBhIHJlY29yZCB3aXRoIHxvbGRWYWx1ZXwgYmFzZWQgaW4gdGhlIHxjdXJyZW50UmVjb3JkfFxuICogQHBhcmFtIHtzdHJpbmd9IG9sZFZhbHVlXG4gKiBAcmV0dXJuIHtNdXRhdGlvblJlY29yZH1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKSB7XG4gIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpXG4gICAgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TXV0YXRpb25SZWNvcmR9IHJlY29yZFxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVjb3JkIHJlcHJlc2VudHMgYSByZWNvcmQgZnJvbSB0aGUgY3VycmVudFxuICogbXV0YXRpb24gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gIHJldHVybiByZWNvcmQgPT09IHJlY29yZFdpdGhPbGRWYWx1ZSB8fCByZWNvcmQgPT09IGN1cnJlbnRSZWNvcmQ7XG59XG5cbi8qKlxuICogU2VsZWN0cyB3aGljaCByZWNvcmQsIGlmIGFueSwgdG8gcmVwbGFjZSB0aGUgbGFzdCByZWNvcmQgaW4gdGhlIHF1ZXVlLlxuICogVGhpcyByZXR1cm5zIHxudWxsfCBpZiBubyByZWNvcmQgc2hvdWxkIGJlIHJlcGxhY2VkLlxuICpcbiAqIEBwYXJhbSB7TXV0YXRpb25SZWNvcmR9IGxhc3RSZWNvcmRcbiAqIEBwYXJhbSB7TXV0YXRpb25SZWNvcmR9IG5ld1JlY29yZFxuICogQHBhcmFtIHtNdXRhdGlvblJlY29yZH1cbiAqL1xuZnVuY3Rpb24gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIG5ld1JlY29yZCkge1xuICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKVxuICAgIHJldHVybiBsYXN0UmVjb3JkO1xuXG4gIC8vIENoZWNrIGlmIHRoZSB0aGUgcmVjb3JkIHdlIGFyZSBhZGRpbmcgcmVwcmVzZW50cyB0aGUgc2FtZSByZWNvcmQuIElmXG4gIC8vIHNvLCB3ZSBrZWVwIHRoZSBvbmUgd2l0aCB0aGUgb2xkVmFsdWUgaW4gaXQuXG4gIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSlcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENsYXNzIHVzZWQgdG8gcmVwcmVzZW50IGEgcmVnaXN0ZXJlZCBvYnNlcnZlci5cbiAqIEBwYXJhbSB7TXV0YXRpb25PYnNlcnZlcn0gb2JzZXJ2ZXJcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge011dGF0aW9uT2JzZXJ2ZXJJbml0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG59XG5cblJlZ2lzdHJhdGlvbi5wcm90b3R5cGUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICB2YXIgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7XG5cbiAgICAvLyBUaGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgcmVwbGFjZSB0aGUgbGFzdCByZWNvcmQgd2l0aCB0aGUgbmV3IHJlY29yZC5cbiAgICAvLyBGb3IgZXhhbXBsZSBpZiB0aGUgcmVjb3JkIHJlcHJlc2VudHMgdGhlIHNhbWUgbXV0YXRpb24gd2UgbmVlZCB0byB1c2VcbiAgICAvLyB0aGUgb25lIHdpdGggdGhlIG9sZFZhbHVlLiBJZiB3ZSBnZXQgc2FtZSByZWNvcmQgKHRoaXMgY2FuIGhhcHBlbiBhcyB3ZVxuICAgIC8vIHdhbGsgdXAgdGhlIHRyZWUpIHdlIGlnbm9yZSB0aGUgbmV3IHJlY29yZC5cbiAgICBpZiAocmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgaWYgKHJlY29yZFRvUmVwbGFjZUxhc3QpIHtcbiAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICB9XG5cbiAgICByZWNvcmRzW2xlbmd0aF0gPSByZWNvcmQ7XG4gIH0sXG5cbiAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICB9LFxuXG4gIGFkZExpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKVxuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdET01BdHRyTW9kaWZpZWQnLCB0aGlzLCB0cnVlKTtcblxuICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpXG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNoYXJhY3RlckRhdGFNb2RpZmllZCcsIHRoaXMsIHRydWUpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KVxuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aGlzLCB0cnVlKTtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpXG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgdGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICB9LFxuXG4gIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKVxuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdET01BdHRyTW9kaWZpZWQnLCB0aGlzLCB0cnVlKTtcblxuICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpXG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNoYXJhY3RlckRhdGFNb2RpZmllZCcsIHRoaXMsIHRydWUpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KVxuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aGlzLCB0cnVlKTtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpXG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgdGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cmFuc2llbnQgb2JzZXJ2ZXIgb24gbm9kZS4gVGhlIHRyYW5zaWVudCBvYnNlcnZlciBnZXRzIHJlbW92ZWRcbiAgICogbmV4dCB0aW1lIHdlIGRlbGl2ZXIgdGhlIGNoYW5nZSByZWNvcmRzLlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gRG9uJ3QgYWRkIHRyYW5zaWVudCBvYnNlcnZlcnMgb24gdGhlIHRhcmdldCBpdHNlbGYuIFdlIGFscmVhZHkgaGF2ZSBhbGxcbiAgICAvLyB0aGUgcmVxdWlyZWQgbGlzdGVuZXJzIHNldCB1cCBvbiB0aGUgdGFyZ2V0LlxuICAgIGlmIChub2RlID09PSB0aGlzLnRhcmdldClcbiAgICAgIHJldHVybjtcblxuICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgaWYgKCFyZWdpc3RyYXRpb25zKVxuICAgICAgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuXG4gICAgLy8gV2Uga25vdyB0aGF0IHJlZ2lzdHJhdGlvbnMgZG9lcyBub3QgY29udGFpbiB0aGlzIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAgIC8vIGNoZWNrZWQgaWYgbm9kZSA9PT0gdGhpcy50YXJnZXQuXG4gICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICB9LFxuXG4gIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG5cbiAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgLy8gVHJhbnNpZW50IG9ic2VydmVycyBhcmUgbmV2ZXIgYWRkZWQgdG8gdGhlIHRhcmdldC5cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgLy8gRWFjaCBub2RlIGNhbiBvbmx5IGhhdmUgb25lIHJlZ2lzdGVyZWQgb2JzZXJ2ZXIgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgICAgLy8gdGhpcyBvYnNlcnZlci5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgLy8gU3RvcCBwcm9wYWdhdGlvbiBzaW5jZSB3ZSBhcmUgbWFuYWdpbmcgdGhlIHByb3BhZ2F0aW9uIG1hbnVhbGx5LlxuICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBvdGhlciBtdXRhdGlvbiBldmVudHMgb24gdGhlIHBhZ2Ugd2lsbCBub3Qgd29ya1xuICAgIC8vIGNvcnJlY3RseSBidXQgdGhhdCBpcyBieSBkZXNpZ24uXG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdET01BdHRyTW9kaWZpZWQnOlxuICAgICAgICAvLyBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tby1xdWV1ZS1hdHRyaWJ1dGVzXG5cbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcblxuICAgICAgICAvLyAxLlxuICAgICAgICB2YXIgcmVjb3JkID0gbmV3IGdldFJlY29yZCgnYXR0cmlidXRlcycsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICAgICAgICAvLyAyLlxuICAgICAgICB2YXIgb2xkVmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgTXV0YXRpb25FdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OKSlcbiAgICAgICAgICBvbGRWYWx1ZSA9IGUucHJldlZhbHVlO1xuXG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAvLyAzLjEsIDQuMlxuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gMy4yLCA0LjNcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMy4zLCA0LjRcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuXG4gICAgICAgICAgLy8gMy40LCA0LjVcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkJzpcbiAgICAgICAgLy8gaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbW8tcXVldWUtY2hhcmFjdGVyZGF0YVxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgICAgLy8gMS5cbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZCgnY2hhcmFjdGVyRGF0YScsIHRhcmdldCk7XG5cbiAgICAgICAgLy8gMi5cbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG5cblxuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgLy8gMy4xLCA0LjJcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIC8vIDMuMiwgNC4zXG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAvLyAzLjMsIDQuNFxuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdET01Ob2RlUmVtb3ZlZCc6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdET01Ob2RlSW5zZXJ0ZWQnOlxuICAgICAgICAvLyBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tby1xdWV1ZS1jaGlsZGxpc3RcbiAgICAgICAgdmFyIHRhcmdldCA9IGUucmVsYXRlZE5vZGU7XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSAnRE9NTm9kZUluc2VydGVkJykge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbY2hhbmdlZE5vZGVdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFtjaGFuZ2VkTm9kZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IGNoYW5nZWROb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY2hhbmdlZE5vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgLy8gMS5cbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZCgnY2hpbGRMaXN0JywgdGFyZ2V0KTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcblxuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgLy8gMi4xLCAzLjJcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gMi4yLCAzLjNcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGNsZWFyUmVjb3JkcygpO1xuICB9XG59O1xuXG5pZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNdXRhdGlvbk9ic2VydmVyO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXlpc2ggPSByZXF1aXJlKCdpcy1hcnJheWlzaCcpO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxudmFyIHN3aXp6bGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN3aXp6bGUoYXJncykge1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIGFyZyA9IGFyZ3NbaV07XG5cblx0XHRpZiAoaXNBcnJheWlzaChhcmcpKSB7XG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9qYXZhc2NyaXB0LWFycmF5LWNvbmNhdC12cy1wdXNoLzk4XG5cdFx0XHRyZXN1bHRzID0gY29uY2F0LmNhbGwocmVzdWx0cywgc2xpY2UuY2FsbChhcmcpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0cy5wdXNoKGFyZyk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG5zd2l6emxlLndyYXAgPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZm4oc3dpenpsZShhcmd1bWVudHMpKTtcblx0fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJyYXlpc2gob2JqKSB7XG5cdGlmICghb2JqIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5IHx8IEFycmF5LmlzQXJyYXkob2JqKSB8fFxuXHRcdChvYmoubGVuZ3RoID49IDAgJiYgKG9iai5zcGxpY2UgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuXHRcdFx0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCAob2JqLmxlbmd0aCAtIDEpKSAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPT0gJ1N0cmluZycpKSk7XG59O1xuIiwidmFyIG1ha2VTdHJpbmcgPSByZXF1aXJlKCcuL2hlbHBlci9tYWtlU3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIsIGxvd2VyY2FzZVJlc3QpIHtcbiAgc3RyID0gbWFrZVN0cmluZyhzdHIpO1xuICB2YXIgcmVtYWluaW5nQ2hhcnMgPSAhbG93ZXJjYXNlUmVzdCA/IHN0ci5zbGljZSgxKSA6IHN0ci5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZW1haW5pbmdDaGFycztcbn07XG4iLCJ2YXIgdHJpbSA9IHJlcXVpcmUoJy4vdHJpbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcbiAgcmV0dXJuIHRyaW0oc3RyKS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS5yZXBsYWNlKC9bLV9cXHNdKy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG59O1xuIiwidmFyIGVzY2FwZVJlZ0V4cCA9IHJlcXVpcmUoJy4vZXNjYXBlUmVnRXhwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmYXVsdFRvV2hpdGVTcGFjZShjaGFyYWN0ZXJzKSB7XG4gIGlmIChjaGFyYWN0ZXJzID09IG51bGwpXG4gICAgcmV0dXJuICdcXFxccyc7XG4gIGVsc2UgaWYgKGNoYXJhY3RlcnMuc291cmNlKVxuICAgIHJldHVybiBjaGFyYWN0ZXJzLnNvdXJjZTtcbiAgZWxzZVxuICAgIHJldHVybiAnWycgKyBlc2NhcGVSZWdFeHAoY2hhcmFjdGVycykgKyAnXSc7XG59O1xuIiwidmFyIG1ha2VTdHJpbmcgPSByZXF1aXJlKCcuL21ha2VTdHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBtYWtlU3RyaW5nKHN0cikucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xufTtcbiIsIi8qKlxuICogRW5zdXJlIHNvbWUgb2JqZWN0IGlzIGEgY29lcmNlZCB0byBhIHN0cmluZ1xuICoqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYWtlU3RyaW5nKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuICcnICsgb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyUmVwZWF0KHN0ciwgcXR5KXtcbiAgaWYgKHF0eSA8IDEpIHJldHVybiAnJztcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB3aGlsZSAocXR5ID4gMCkge1xuICAgIGlmIChxdHkgJiAxKSByZXN1bHQgKz0gc3RyO1xuICAgIHF0eSA+Pj0gMSwgc3RyICs9IHN0cjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBwYWQgPSByZXF1aXJlKCcuL3BhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxwYWQoc3RyLCBsZW5ndGgsIHBhZFN0cikge1xuICByZXR1cm4gcGFkKHN0ciwgbGVuZ3RoLCBwYWRTdHIpO1xufTtcbiIsInZhciBtYWtlU3RyaW5nID0gcmVxdWlyZSgnLi9oZWxwZXIvbWFrZVN0cmluZycpO1xudmFyIHN0clJlcGVhdCA9IHJlcXVpcmUoJy4vaGVscGVyL3N0clJlcGVhdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZChzdHIsIGxlbmd0aCwgcGFkU3RyLCB0eXBlKSB7XG4gIHN0ciA9IG1ha2VTdHJpbmcoc3RyKTtcbiAgbGVuZ3RoID0gfn5sZW5ndGg7XG5cbiAgdmFyIHBhZGxlbiA9IDA7XG5cbiAgaWYgKCFwYWRTdHIpXG4gICAgcGFkU3RyID0gJyAnO1xuICBlbHNlIGlmIChwYWRTdHIubGVuZ3RoID4gMSlcbiAgICBwYWRTdHIgPSBwYWRTdHIuY2hhckF0KDApO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdyaWdodCc6XG4gICAgcGFkbGVuID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgICByZXR1cm4gc3RyICsgc3RyUmVwZWF0KHBhZFN0ciwgcGFkbGVuKTtcbiAgY2FzZSAnYm90aCc6XG4gICAgcGFkbGVuID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgICByZXR1cm4gc3RyUmVwZWF0KHBhZFN0ciwgTWF0aC5jZWlsKHBhZGxlbiAvIDIpKSArIHN0ciArIHN0clJlcGVhdChwYWRTdHIsIE1hdGguZmxvb3IocGFkbGVuIC8gMikpO1xuICBkZWZhdWx0OiAvLyAnbGVmdCdcbiAgICBwYWRsZW4gPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICAgIHJldHVybiBzdHJSZXBlYXQocGFkU3RyLCBwYWRsZW4pICsgc3RyO1xuICB9XG59O1xuIiwidmFyIHBhZCA9IHJlcXVpcmUoJy4vcGFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcnBhZChzdHIsIGxlbmd0aCwgcGFkU3RyKSB7XG4gIHJldHVybiBwYWQoc3RyLCBsZW5ndGgsIHBhZFN0ciwgJ3JpZ2h0Jyk7XG59O1xuIiwidmFyIG1ha2VTdHJpbmcgPSByZXF1aXJlKCcuL2hlbHBlci9tYWtlU3RyaW5nJyk7XG52YXIgZGVmYXVsdFRvV2hpdGVTcGFjZSA9IHJlcXVpcmUoJy4vaGVscGVyL2RlZmF1bHRUb1doaXRlU3BhY2UnKTtcbnZhciBuYXRpdmVUcmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyaW0oc3RyLCBjaGFyYWN0ZXJzKSB7XG4gIHN0ciA9IG1ha2VTdHJpbmcoc3RyKTtcbiAgaWYgKCFjaGFyYWN0ZXJzICYmIG5hdGl2ZVRyaW0pIHJldHVybiBuYXRpdmVUcmltLmNhbGwoc3RyKTtcbiAgY2hhcmFjdGVycyA9IGRlZmF1bHRUb1doaXRlU3BhY2UoY2hhcmFjdGVycyk7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGNoYXJhY3RlcnMgKyAnK3wnICsgY2hhcmFjdGVycyArICcrJCcsICdnJyksICcnKTtcbn07XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4zJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBwcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBwcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXy5maW5kS2V5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIGl0ZW0gKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCBpdGVtLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ICE9ICdudW1iZXInIHx8IGd1YXJkKSBmcm9tSW5kZXggPSAwO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCBpdGVtLCBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyBmdW5jIDogZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCBnZXRMZW5ndGgpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoMSk7XG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBpbmRleE9mIGFuZCBsYXN0SW5kZXhPZiBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgaSA9IGlkeCA+PSAwID8gaWR4IDogTWF0aC5tYXgoaWR4ICsgbGVuZ3RoLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBfID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHRzID0ge30sXG4gICAgICAgICAgY3VycmVudEtleTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBfLmNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIGlmIChwcm9wcykgXy5leHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IGZ1bmN0aW9uKCl7fSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8qIFdlYiBGb250IExvYWRlciB2MS42LjI4IC0gKGMpIEFkb2JlIFN5c3RlbXMsIEdvb2dsZS4gTGljZW5zZTogQXBhY2hlIDIuMCAqLyhmdW5jdGlvbigpe2Z1bmN0aW9uIGFhKGEsYixjKXtyZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCxhcmd1bWVudHMpfWZ1bmN0aW9uIGJhKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYyxkKTtyZXR1cm4gYS5hcHBseShiLGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHAoYSxiLGMpe3A9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQmJi0xIT1GdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKT9hYTpiYTtyZXR1cm4gcC5hcHBseShudWxsLGFyZ3VtZW50cyl9dmFyIHE9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfTtmdW5jdGlvbiBjYShhLGIpe3RoaXMuYT1hO3RoaXMubz1ifHxhO3RoaXMuYz10aGlzLm8uZG9jdW1lbnR9dmFyIGRhPSEhd2luZG93LkZvbnRGYWNlO2Z1bmN0aW9uIHQoYSxiLGMsZCl7Yj1hLmMuY3JlYXRlRWxlbWVudChiKTtpZihjKWZvcih2YXIgZSBpbiBjKWMuaGFzT3duUHJvcGVydHkoZSkmJihcInN0eWxlXCI9PWU/Yi5zdHlsZS5jc3NUZXh0PWNbZV06Yi5zZXRBdHRyaWJ1dGUoZSxjW2VdKSk7ZCYmYi5hcHBlbmRDaGlsZChhLmMuY3JlYXRlVGV4dE5vZGUoZCkpO3JldHVybiBifWZ1bmN0aW9uIHUoYSxiLGMpe2E9YS5jLmdldEVsZW1lbnRzQnlUYWdOYW1lKGIpWzBdO2F8fChhPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7YS5pbnNlcnRCZWZvcmUoYyxhLmxhc3RDaGlsZCl9ZnVuY3Rpb24gdihhKXthLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX1cbmZ1bmN0aW9uIHcoYSxiLGMpe2I9Ynx8W107Yz1jfHxbXTtmb3IodmFyIGQ9YS5jbGFzc05hbWUuc3BsaXQoL1xccysvKSxlPTA7ZTxiLmxlbmd0aDtlKz0xKXtmb3IodmFyIGY9ITEsZz0wO2c8ZC5sZW5ndGg7Zys9MSlpZihiW2VdPT09ZFtnXSl7Zj0hMDticmVha31mfHxkLnB1c2goYltlXSl9Yj1bXTtmb3IoZT0wO2U8ZC5sZW5ndGg7ZSs9MSl7Zj0hMTtmb3IoZz0wO2c8Yy5sZW5ndGg7Zys9MSlpZihkW2VdPT09Y1tnXSl7Zj0hMDticmVha31mfHxiLnB1c2goZFtlXSl9YS5jbGFzc05hbWU9Yi5qb2luKFwiIFwiKS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpLnJlcGxhY2UoL15cXHMrfFxccyskLyxcIlwiKX1mdW5jdGlvbiB5KGEsYil7Zm9yKHZhciBjPWEuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyksZD0wLGU9Yy5sZW5ndGg7ZDxlO2QrKylpZihjW2RdPT1iKXJldHVybiEwO3JldHVybiExfVxuZnVuY3Rpb24gZWEoYSl7cmV0dXJuIGEuby5sb2NhdGlvbi5ob3N0bmFtZXx8YS5hLmxvY2F0aW9uLmhvc3RuYW1lfWZ1bmN0aW9uIHooYSxiLGMpe2Z1bmN0aW9uIGQoKXttJiZlJiZmJiYobShnKSxtPW51bGwpfWI9dChhLFwibGlua1wiLHtyZWw6XCJzdHlsZXNoZWV0XCIsaHJlZjpiLG1lZGlhOlwiYWxsXCJ9KTt2YXIgZT0hMSxmPSEwLGc9bnVsbCxtPWN8fG51bGw7ZGE/KGIub25sb2FkPWZ1bmN0aW9uKCl7ZT0hMDtkKCl9LGIub25lcnJvcj1mdW5jdGlvbigpe2U9ITA7Zz1FcnJvcihcIlN0eWxlc2hlZXQgZmFpbGVkIHRvIGxvYWRcIik7ZCgpfSk6c2V0VGltZW91dChmdW5jdGlvbigpe2U9ITA7ZCgpfSwwKTt1KGEsXCJoZWFkXCIsYil9XG5mdW5jdGlvbiBBKGEsYixjLGQpe3ZhciBlPWEuYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07aWYoZSl7dmFyIGY9dChhLFwic2NyaXB0XCIse3NyYzpifSksZz0hMTtmLm9ubG9hZD1mLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2d8fHRoaXMucmVhZHlTdGF0ZSYmXCJsb2FkZWRcIiE9dGhpcy5yZWFkeVN0YXRlJiZcImNvbXBsZXRlXCIhPXRoaXMucmVhZHlTdGF0ZXx8KGc9ITAsYyYmYyhudWxsKSxmLm9ubG9hZD1mLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLFwiSEVBRFwiPT1mLnBhcmVudE5vZGUudGFnTmFtZSYmZS5yZW1vdmVDaGlsZChmKSl9O2UuYXBwZW5kQ2hpbGQoZik7c2V0VGltZW91dChmdW5jdGlvbigpe2d8fChnPSEwLGMmJmMoRXJyb3IoXCJTY3JpcHQgbG9hZCB0aW1lb3V0XCIpKSl9LGR8fDVFMyk7cmV0dXJuIGZ9cmV0dXJuIG51bGx9O2Z1bmN0aW9uIEIoKXt0aGlzLmE9MDt0aGlzLmM9bnVsbH1mdW5jdGlvbiBDKGEpe2EuYSsrO3JldHVybiBmdW5jdGlvbigpe2EuYS0tO0QoYSl9fWZ1bmN0aW9uIEUoYSxiKXthLmM9YjtEKGEpfWZ1bmN0aW9uIEQoYSl7MD09YS5hJiZhLmMmJihhLmMoKSxhLmM9bnVsbCl9O2Z1bmN0aW9uIEYoYSl7dGhpcy5hPWF8fFwiLVwifUYucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWIucHVzaChhcmd1bWVudHNbY10ucmVwbGFjZSgvW1xcV19dKy9nLFwiXCIpLnRvTG93ZXJDYXNlKCkpO3JldHVybiBiLmpvaW4odGhpcy5hKX07ZnVuY3Rpb24gRyhhLGIpe3RoaXMuYz1hO3RoaXMuZj00O3RoaXMuYT1cIm5cIjt2YXIgYz0oYnx8XCJuNFwiKS5tYXRjaCgvXihbbmlvXSkoWzEtOV0pJC9pKTtjJiYodGhpcy5hPWNbMV0sdGhpcy5mPXBhcnNlSW50KGNbMl0sMTApKX1mdW5jdGlvbiBmYShhKXtyZXR1cm4gSChhKStcIiBcIisoYS5mK1wiMDBcIikrXCIgMzAwcHggXCIrSShhLmMpfWZ1bmN0aW9uIEkoYSl7dmFyIGI9W107YT1hLnNwbGl0KC8sXFxzKi8pO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLnJlcGxhY2UoL1snXCJdL2csXCJcIik7LTEhPWQuaW5kZXhPZihcIiBcIil8fC9eXFxkLy50ZXN0KGQpP2IucHVzaChcIidcIitkK1wiJ1wiKTpiLnB1c2goZCl9cmV0dXJuIGIuam9pbihcIixcIil9ZnVuY3Rpb24gSihhKXtyZXR1cm4gYS5hK2EuZn1mdW5jdGlvbiBIKGEpe3ZhciBiPVwibm9ybWFsXCI7XCJvXCI9PT1hLmE/Yj1cIm9ibGlxdWVcIjpcImlcIj09PWEuYSYmKGI9XCJpdGFsaWNcIik7cmV0dXJuIGJ9XG5mdW5jdGlvbiBnYShhKXt2YXIgYj00LGM9XCJuXCIsZD1udWxsO2EmJigoZD1hLm1hdGNoKC8obm9ybWFsfG9ibGlxdWV8aXRhbGljKS9pKSkmJmRbMV0mJihjPWRbMV0uc3Vic3RyKDAsMSkudG9Mb3dlckNhc2UoKSksKGQ9YS5tYXRjaCgvKFsxLTldMDB8bm9ybWFsfGJvbGQpL2kpKSYmZFsxXSYmKC9ib2xkL2kudGVzdChkWzFdKT9iPTc6L1sxLTldMDAvLnRlc3QoZFsxXSkmJihiPXBhcnNlSW50KGRbMV0uc3Vic3RyKDAsMSksMTApKSkpO3JldHVybiBjK2J9O2Z1bmN0aW9uIGhhKGEsYil7dGhpcy5jPWE7dGhpcy5mPWEuby5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dGhpcy5oPWI7dGhpcy5hPW5ldyBGKFwiLVwiKTt0aGlzLmo9ITEhPT1iLmV2ZW50czt0aGlzLmc9ITEhPT1iLmNsYXNzZXN9ZnVuY3Rpb24gaWEoYSl7YS5nJiZ3KGEuZixbYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKV0pO0soYSxcImxvYWRpbmdcIil9ZnVuY3Rpb24gTChhKXtpZihhLmcpe3ZhciBiPXkoYS5mLGEuYS5jKFwid2ZcIixcImFjdGl2ZVwiKSksYz1bXSxkPVthLmEuYyhcIndmXCIsXCJsb2FkaW5nXCIpXTtifHxjLnB1c2goYS5hLmMoXCJ3ZlwiLFwiaW5hY3RpdmVcIikpO3coYS5mLGMsZCl9SyhhLFwiaW5hY3RpdmVcIil9ZnVuY3Rpb24gSyhhLGIsYyl7aWYoYS5qJiZhLmhbYl0paWYoYylhLmhbYl0oYy5jLEooYykpO2Vsc2UgYS5oW2JdKCl9O2Z1bmN0aW9uIGphKCl7dGhpcy5jPXt9fWZ1bmN0aW9uIGthKGEsYixjKXt2YXIgZD1bXSxlO2ZvcihlIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShlKSl7dmFyIGY9YS5jW2VdO2YmJmQucHVzaChmKGJbZV0sYykpfXJldHVybiBkfTtmdW5jdGlvbiBNKGEsYil7dGhpcy5jPWE7dGhpcy5mPWI7dGhpcy5hPXQodGhpcy5jLFwic3BhblwiLHtcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LHRoaXMuZil9ZnVuY3Rpb24gTihhKXt1KGEuYyxcImJvZHlcIixhLmEpfWZ1bmN0aW9uIE8oYSl7cmV0dXJuXCJkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotOTk5OXB4O2xlZnQ6LTk5OTlweDtmb250LXNpemU6MzAwcHg7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bztsaW5lLWhlaWdodDpub3JtYWw7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtdmFyaWFudDpub3JtYWw7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OlwiK0koYS5jKStcIjtcIisoXCJmb250LXN0eWxlOlwiK0goYSkrXCI7Zm9udC13ZWlnaHQ6XCIrKGEuZitcIjAwXCIpK1wiO1wiKX07ZnVuY3Rpb24gUChhLGIsYyxkLGUsZil7dGhpcy5nPWE7dGhpcy5qPWI7dGhpcy5hPWQ7dGhpcy5jPWM7dGhpcy5mPWV8fDNFMzt0aGlzLmg9Znx8dm9pZCAwfVAucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jLm8uZG9jdW1lbnQsYj10aGlzLGM9cSgpLGQ9bmV3IFByb21pc2UoZnVuY3Rpb24oZCxlKXtmdW5jdGlvbiBmKCl7cSgpLWM+PWIuZj9lKCk6YS5mb250cy5sb2FkKGZhKGIuYSksYi5oKS50aGVuKGZ1bmN0aW9uKGEpezE8PWEubGVuZ3RoP2QoKTpzZXRUaW1lb3V0KGYsMjUpfSxmdW5jdGlvbigpe2UoKX0pfWYoKX0pLGU9bnVsbCxmPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsZCl7ZT1zZXRUaW1lb3V0KGQsYi5mKX0pO1Byb21pc2UucmFjZShbZixkXSkudGhlbihmdW5jdGlvbigpe2UmJihjbGVhclRpbWVvdXQoZSksZT1udWxsKTtiLmcoYi5hKX0sZnVuY3Rpb24oKXtiLmooYi5hKX0pfTtmdW5jdGlvbiBRKGEsYixjLGQsZSxmLGcpe3RoaXMudj1hO3RoaXMuQj1iO3RoaXMuYz1jO3RoaXMuYT1kO3RoaXMucz1nfHxcIkJFU2Jzd3lcIjt0aGlzLmY9e307dGhpcy53PWV8fDNFMzt0aGlzLnU9Znx8bnVsbDt0aGlzLm09dGhpcy5qPXRoaXMuaD10aGlzLmc9bnVsbDt0aGlzLmc9bmV3IE0odGhpcy5jLHRoaXMucyk7dGhpcy5oPW5ldyBNKHRoaXMuYyx0aGlzLnMpO3RoaXMuaj1uZXcgTSh0aGlzLmMsdGhpcy5zKTt0aGlzLm09bmV3IE0odGhpcy5jLHRoaXMucyk7YT1uZXcgRyh0aGlzLmEuYytcIixzZXJpZlwiLEoodGhpcy5hKSk7YT1PKGEpO3RoaXMuZy5hLnN0eWxlLmNzc1RleHQ9YTthPW5ldyBHKHRoaXMuYS5jK1wiLHNhbnMtc2VyaWZcIixKKHRoaXMuYSkpO2E9TyhhKTt0aGlzLmguYS5zdHlsZS5jc3NUZXh0PWE7YT1uZXcgRyhcInNlcmlmXCIsSih0aGlzLmEpKTthPU8oYSk7dGhpcy5qLmEuc3R5bGUuY3NzVGV4dD1hO2E9bmV3IEcoXCJzYW5zLXNlcmlmXCIsSih0aGlzLmEpKTthPVxuTyhhKTt0aGlzLm0uYS5zdHlsZS5jc3NUZXh0PWE7Tih0aGlzLmcpO04odGhpcy5oKTtOKHRoaXMuaik7Tih0aGlzLm0pfXZhciBSPXtEOlwic2VyaWZcIixDOlwic2Fucy1zZXJpZlwifSxTPW51bGw7ZnVuY3Rpb24gVCgpe2lmKG51bGw9PT1TKXt2YXIgYT0vQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7Uz0hIWEmJig1MzY+cGFyc2VJbnQoYVsxXSwxMCl8fDUzNj09PXBhcnNlSW50KGFbMV0sMTApJiYxMT49cGFyc2VJbnQoYVsyXSwxMCkpfXJldHVybiBTfVEucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7dGhpcy5mLnNlcmlmPXRoaXMuai5hLm9mZnNldFdpZHRoO3RoaXMuZltcInNhbnMtc2VyaWZcIl09dGhpcy5tLmEub2Zmc2V0V2lkdGg7dGhpcy5BPXEoKTtVKHRoaXMpfTtcbmZ1bmN0aW9uIGxhKGEsYixjKXtmb3IodmFyIGQgaW4gUilpZihSLmhhc093blByb3BlcnR5KGQpJiZiPT09YS5mW1JbZF1dJiZjPT09YS5mW1JbZF1dKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIFUoYSl7dmFyIGI9YS5nLmEub2Zmc2V0V2lkdGgsYz1hLmguYS5vZmZzZXRXaWR0aCxkOyhkPWI9PT1hLmYuc2VyaWYmJmM9PT1hLmZbXCJzYW5zLXNlcmlmXCJdKXx8KGQ9VCgpJiZsYShhLGIsYykpO2Q/cSgpLWEuQT49YS53P1QoKSYmbGEoYSxiLGMpJiYobnVsbD09PWEudXx8YS51Lmhhc093blByb3BlcnR5KGEuYS5jKSk/VihhLGEudik6VihhLGEuQik6bWEoYSk6VihhLGEudil9ZnVuY3Rpb24gbWEoYSl7c2V0VGltZW91dChwKGZ1bmN0aW9uKCl7VSh0aGlzKX0sYSksNTApfWZ1bmN0aW9uIFYoYSxiKXtzZXRUaW1lb3V0KHAoZnVuY3Rpb24oKXt2KHRoaXMuZy5hKTt2KHRoaXMuaC5hKTt2KHRoaXMuai5hKTt2KHRoaXMubS5hKTtiKHRoaXMuYSl9LGEpLDApfTtmdW5jdGlvbiBXKGEsYixjKXt0aGlzLmM9YTt0aGlzLmE9Yjt0aGlzLmY9MDt0aGlzLm09dGhpcy5qPSExO3RoaXMucz1jfXZhciBYPW51bGw7Vy5wcm90b3R5cGUuZz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmE7Yi5nJiZ3KGIuZixbYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJhY3RpdmVcIildLFtiLmEuYyhcIndmXCIsYS5jLEooYSkudG9TdHJpbmcoKSxcImxvYWRpbmdcIiksYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJpbmFjdGl2ZVwiKV0pO0soYixcImZvbnRhY3RpdmVcIixhKTt0aGlzLm09ITA7bmEodGhpcyl9O1xuVy5wcm90b3R5cGUuaD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmE7aWYoYi5nKXt2YXIgYz15KGIuZixiLmEuYyhcIndmXCIsYS5jLEooYSkudG9TdHJpbmcoKSxcImFjdGl2ZVwiKSksZD1bXSxlPVtiLmEuYyhcIndmXCIsYS5jLEooYSkudG9TdHJpbmcoKSxcImxvYWRpbmdcIildO2N8fGQucHVzaChiLmEuYyhcIndmXCIsYS5jLEooYSkudG9TdHJpbmcoKSxcImluYWN0aXZlXCIpKTt3KGIuZixkLGUpfUsoYixcImZvbnRpbmFjdGl2ZVwiLGEpO25hKHRoaXMpfTtmdW5jdGlvbiBuYShhKXswPT0tLWEuZiYmYS5qJiYoYS5tPyhhPWEuYSxhLmcmJncoYS5mLFthLmEuYyhcIndmXCIsXCJhY3RpdmVcIildLFthLmEuYyhcIndmXCIsXCJsb2FkaW5nXCIpLGEuYS5jKFwid2ZcIixcImluYWN0aXZlXCIpXSksSyhhLFwiYWN0aXZlXCIpKTpMKGEuYSkpfTtmdW5jdGlvbiBvYShhKXt0aGlzLmo9YTt0aGlzLmE9bmV3IGphO3RoaXMuaD0wO3RoaXMuZj10aGlzLmc9ITB9b2EucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dGhpcy5jPW5ldyBjYSh0aGlzLmosYS5jb250ZXh0fHx0aGlzLmopO3RoaXMuZz0hMSE9PWEuZXZlbnRzO3RoaXMuZj0hMSE9PWEuY2xhc3NlcztwYSh0aGlzLG5ldyBoYSh0aGlzLmMsYSksYSl9O1xuZnVuY3Rpb24gcWEoYSxiLGMsZCxlKXt2YXIgZj0wPT0tLWEuaDsoYS5mfHxhLmcpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGE9ZXx8bnVsbCxtPWR8fG51bGx8fHt9O2lmKDA9PT1jLmxlbmd0aCYmZilMKGIuYSk7ZWxzZXtiLmYrPWMubGVuZ3RoO2YmJihiLmo9Zik7dmFyIGgsbD1bXTtmb3IoaD0wO2g8Yy5sZW5ndGg7aCsrKXt2YXIgaz1jW2hdLG49bVtrLmNdLHI9Yi5hLHg9aztyLmcmJncoci5mLFtyLmEuYyhcIndmXCIseC5jLEooeCkudG9TdHJpbmcoKSxcImxvYWRpbmdcIildKTtLKHIsXCJmb250bG9hZGluZ1wiLHgpO3I9bnVsbDtpZihudWxsPT09WClpZih3aW5kb3cuRm9udEZhY2Upe3ZhciB4PS9HZWNrby4qRmlyZWZveFxcLyhcXGQrKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkseGE9L09TIFguKlZlcnNpb25cXC8xMFxcLi4qU2FmYXJpLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSYmL0FwcGxlLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudmVuZG9yKTtcblg9eD80MjxwYXJzZUludCh4WzFdLDEwKTp4YT8hMTohMH1lbHNlIFg9ITE7WD9yPW5ldyBQKHAoYi5nLGIpLHAoYi5oLGIpLGIuYyxrLGIucyxuKTpyPW5ldyBRKHAoYi5nLGIpLHAoYi5oLGIpLGIuYyxrLGIucyxhLG4pO2wucHVzaChyKX1mb3IoaD0wO2g8bC5sZW5ndGg7aCsrKWxbaF0uc3RhcnQoKX19LDApfWZ1bmN0aW9uIHBhKGEsYixjKXt2YXIgZD1bXSxlPWMudGltZW91dDtpYShiKTt2YXIgZD1rYShhLmEsYyxhLmMpLGY9bmV3IFcoYS5jLGIsZSk7YS5oPWQubGVuZ3RoO2I9MDtmb3IoYz1kLmxlbmd0aDtiPGM7YisrKWRbYl0ubG9hZChmdW5jdGlvbihiLGQsYyl7cWEoYSxmLGIsZCxjKX0pfTtmdW5jdGlvbiByYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifVxucmEucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2lmKGZbXCJfX210aV9mbnRMc3RcIitkXSl7dmFyIGM9ZltcIl9fbXRpX2ZudExzdFwiK2RdKCksZT1bXSxoO2lmKGMpZm9yKHZhciBsPTA7bDxjLmxlbmd0aDtsKyspe3ZhciBrPWNbbF0uZm9udGZhbWlseTt2b2lkIDAhPWNbbF0uZm9udFN0eWxlJiZ2b2lkIDAhPWNbbF0uZm9udFdlaWdodD8oaD1jW2xdLmZvbnRTdHlsZStjW2xdLmZvbnRXZWlnaHQsZS5wdXNoKG5ldyBHKGssaCkpKTplLnB1c2gobmV3IEcoaykpfWEoZSl9ZWxzZSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YigpfSw1MCl9dmFyIGM9dGhpcyxkPWMuYS5wcm9qZWN0SWQsZT1jLmEudmVyc2lvbjtpZihkKXt2YXIgZj1jLmMubztBKHRoaXMuYywoYy5hLmFwaXx8XCJodHRwczovL2Zhc3QuZm9udHMubmV0L2pzYXBpXCIpK1wiL1wiK2QrXCIuanNcIisoZT9cIj92PVwiK2U6XCJcIiksZnVuY3Rpb24oZSl7ZT9hKFtdKTooZltcIl9fTW9ub3R5cGVDb25maWd1cmF0aW9uX19cIitcbmRdPWZ1bmN0aW9uKCl7cmV0dXJuIGMuYX0sYigpKX0pLmlkPVwiX19Nb25vdHlwZUFQSVNjcmlwdF9fXCIrZH1lbHNlIGEoW10pfTtmdW5jdGlvbiBzYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifXNhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZD10aGlzLmEudXJsc3x8W10sZT10aGlzLmEuZmFtaWxpZXN8fFtdLGY9dGhpcy5hLnRlc3RTdHJpbmdzfHx7fSxnPW5ldyBCO2I9MDtmb3IoYz1kLmxlbmd0aDtiPGM7YisrKXoodGhpcy5jLGRbYl0sQyhnKSk7dmFyIG09W107Yj0wO2ZvcihjPWUubGVuZ3RoO2I8YztiKyspaWYoZD1lW2JdLnNwbGl0KFwiOlwiKSxkWzFdKWZvcih2YXIgaD1kWzFdLnNwbGl0KFwiLFwiKSxsPTA7bDxoLmxlbmd0aDtsKz0xKW0ucHVzaChuZXcgRyhkWzBdLGhbbF0pKTtlbHNlIG0ucHVzaChuZXcgRyhkWzBdKSk7RShnLGZ1bmN0aW9uKCl7YShtLGYpfSl9O2Z1bmN0aW9uIHRhKGEsYil7YT90aGlzLmM9YTp0aGlzLmM9dWE7dGhpcy5hPVtdO3RoaXMuZj1bXTt0aGlzLmc9Ynx8XCJcIn12YXIgdWE9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzc1wiO2Z1bmN0aW9uIHZhKGEsYil7Zm9yKHZhciBjPWIubGVuZ3RoLGQ9MDtkPGM7ZCsrKXt2YXIgZT1iW2RdLnNwbGl0KFwiOlwiKTszPT1lLmxlbmd0aCYmYS5mLnB1c2goZS5wb3AoKSk7dmFyIGY9XCJcIjsyPT1lLmxlbmd0aCYmXCJcIiE9ZVsxXSYmKGY9XCI6XCIpO2EuYS5wdXNoKGUuam9pbihmKSl9fVxuZnVuY3Rpb24gd2EoYSl7aWYoMD09YS5hLmxlbmd0aCl0aHJvdyBFcnJvcihcIk5vIGZvbnRzIHRvIGxvYWQhXCIpO2lmKC0xIT1hLmMuaW5kZXhPZihcImtpdD1cIikpcmV0dXJuIGEuYztmb3IodmFyIGI9YS5hLmxlbmd0aCxjPVtdLGQ9MDtkPGI7ZCsrKWMucHVzaChhLmFbZF0ucmVwbGFjZSgvIC9nLFwiK1wiKSk7Yj1hLmMrXCI/ZmFtaWx5PVwiK2Muam9pbihcIiU3Q1wiKTswPGEuZi5sZW5ndGgmJihiKz1cIiZzdWJzZXQ9XCIrYS5mLmpvaW4oXCIsXCIpKTswPGEuZy5sZW5ndGgmJihiKz1cIiZ0ZXh0PVwiK2VuY29kZVVSSUNvbXBvbmVudChhLmcpKTtyZXR1cm4gYn07ZnVuY3Rpb24geWEoYSl7dGhpcy5mPWE7dGhpcy5hPVtdO3RoaXMuYz17fX1cbnZhciB6YT17bGF0aW46XCJCRVNic3d5XCIsXCJsYXRpbi1leHRcIjpcIlxcdTAwZTdcXHUwMGY2XFx1MDBmY1xcdTAxMWZcXHUwMTVmXCIsY3lyaWxsaWM6XCJcXHUwNDM5XFx1MDQ0ZlxcdTA0MTZcIixncmVlazpcIlxcdTAzYjFcXHUwM2IyXFx1MDNhM1wiLGtobWVyOlwiXFx1MTc4MFxcdTE3ODFcXHUxNzgyXCIsSGFudW1hbjpcIlxcdTE3ODBcXHUxNzgxXFx1MTc4MlwifSxBYT17dGhpbjpcIjFcIixleHRyYWxpZ2h0OlwiMlwiLFwiZXh0cmEtbGlnaHRcIjpcIjJcIix1bHRyYWxpZ2h0OlwiMlwiLFwidWx0cmEtbGlnaHRcIjpcIjJcIixsaWdodDpcIjNcIixyZWd1bGFyOlwiNFwiLGJvb2s6XCI0XCIsbWVkaXVtOlwiNVwiLFwic2VtaS1ib2xkXCI6XCI2XCIsc2VtaWJvbGQ6XCI2XCIsXCJkZW1pLWJvbGRcIjpcIjZcIixkZW1pYm9sZDpcIjZcIixib2xkOlwiN1wiLFwiZXh0cmEtYm9sZFwiOlwiOFwiLGV4dHJhYm9sZDpcIjhcIixcInVsdHJhLWJvbGRcIjpcIjhcIix1bHRyYWJvbGQ6XCI4XCIsYmxhY2s6XCI5XCIsaGVhdnk6XCI5XCIsbDpcIjNcIixyOlwiNFwiLGI6XCI3XCJ9LEJhPXtpOlwiaVwiLGl0YWxpYzpcImlcIixuOlwiblwiLG5vcm1hbDpcIm5cIn0sXG5DYT0vXih0aGlufCg/Oig/OmV4dHJhfHVsdHJhKS0/KT9saWdodHxyZWd1bGFyfGJvb2t8bWVkaXVtfCg/Oig/OnNlbWl8ZGVtaXxleHRyYXx1bHRyYSktPyk/Ym9sZHxibGFja3xoZWF2eXxsfHJ8YnxbMS05XTAwKT8obnxpfG5vcm1hbHxpdGFsaWMpPyQvO1xuZnVuY3Rpb24gRGEoYSl7Zm9yKHZhciBiPWEuZi5sZW5ndGgsYz0wO2M8YjtjKyspe3ZhciBkPWEuZltjXS5zcGxpdChcIjpcIiksZT1kWzBdLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSxmPVtcIm40XCJdO2lmKDI8PWQubGVuZ3RoKXt2YXIgZzt2YXIgbT1kWzFdO2c9W107aWYobSlmb3IodmFyIG09bS5zcGxpdChcIixcIiksaD1tLmxlbmd0aCxsPTA7bDxoO2wrKyl7dmFyIGs7az1tW2xdO2lmKGsubWF0Y2goL15bXFx3LV0rJC8pKXt2YXIgbj1DYS5leGVjKGsudG9Mb3dlckNhc2UoKSk7aWYobnVsbD09bilrPVwiXCI7ZWxzZXtrPW5bMl07az1udWxsPT1rfHxcIlwiPT1rP1wiblwiOkJhW2tdO249blsxXTtpZihudWxsPT1ufHxcIlwiPT1uKW49XCI0XCI7ZWxzZSB2YXIgcj1BYVtuXSxuPXI/cjppc05hTihuKT9cIjRcIjpuLnN1YnN0cigwLDEpO2s9W2ssbl0uam9pbihcIlwiKX19ZWxzZSBrPVwiXCI7ayYmZy5wdXNoKGspfTA8Zy5sZW5ndGgmJihmPWcpOzM9PWQubGVuZ3RoJiYoZD1kWzJdLGc9W10sZD1kP2Quc3BsaXQoXCIsXCIpOlxuZywwPGQubGVuZ3RoJiYoZD16YVtkWzBdXSkmJihhLmNbZV09ZCkpfWEuY1tlXXx8KGQ9emFbZV0pJiYoYS5jW2VdPWQpO2ZvcihkPTA7ZDxmLmxlbmd0aDtkKz0xKWEuYS5wdXNoKG5ldyBHKGUsZltkXSkpfX07ZnVuY3Rpb24gRWEoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn12YXIgRmE9e0FyaW1vOiEwLENvdXNpbmU6ITAsVGlub3M6ITB9O0VhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBCLGM9dGhpcy5jLGQ9bmV3IHRhKHRoaXMuYS5hcGksdGhpcy5hLnRleHQpLGU9dGhpcy5hLmZhbWlsaWVzO3ZhKGQsZSk7dmFyIGY9bmV3IHlhKGUpO0RhKGYpO3ooYyx3YShkKSxDKGIpKTtFKGIsZnVuY3Rpb24oKXthKGYuYSxmLmMsRmEpfSl9O2Z1bmN0aW9uIEdhKGEsYil7dGhpcy5jPWE7dGhpcy5hPWJ9R2EucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hLmlkLGM9dGhpcy5jLm87Yj9BKHRoaXMuYywodGhpcy5hLmFwaXx8XCJodHRwczovL3VzZS50eXBla2l0Lm5ldFwiKStcIi9cIitiK1wiLmpzXCIsZnVuY3Rpb24oYil7aWYoYilhKFtdKTtlbHNlIGlmKGMuVHlwZWtpdCYmYy5UeXBla2l0LmNvbmZpZyYmYy5UeXBla2l0LmNvbmZpZy5mbil7Yj1jLlR5cGVraXQuY29uZmlnLmZuO2Zvcih2YXIgZT1bXSxmPTA7ZjxiLmxlbmd0aDtmKz0yKWZvcih2YXIgZz1iW2ZdLG09YltmKzFdLGg9MDtoPG0ubGVuZ3RoO2grKyllLnB1c2gobmV3IEcoZyxtW2hdKSk7dHJ5e2MuVHlwZWtpdC5sb2FkKHtldmVudHM6ITEsY2xhc3NlczohMSxhc3luYzohMH0pfWNhdGNoKGwpe31hKGUpfX0sMkUzKTphKFtdKX07ZnVuY3Rpb24gSGEoYSxiKXt0aGlzLmM9YTt0aGlzLmY9Yjt0aGlzLmE9W119SGEucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5mLmlkLGM9dGhpcy5jLm8sZD10aGlzO2I/KGMuX193ZWJmb250Zm9udGRlY2ttb2R1bGVfX3x8KGMuX193ZWJmb250Zm9udGRlY2ttb2R1bGVfXz17fSksYy5fX3dlYmZvbnRmb250ZGVja21vZHVsZV9fW2JdPWZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBnPTAsbT1jLmZvbnRzLmxlbmd0aDtnPG07KytnKXt2YXIgaD1jLmZvbnRzW2ddO2QuYS5wdXNoKG5ldyBHKGgubmFtZSxnYShcImZvbnQtd2VpZ2h0OlwiK2gud2VpZ2h0K1wiO2ZvbnQtc3R5bGU6XCIraC5zdHlsZSkpKX1hKGQuYSl9LEEodGhpcy5jLCh0aGlzLmYuYXBpfHxcImh0dHBzOi8vZi5mb250ZGVjay5jb20vcy9jc3MvanMvXCIpK2VhKHRoaXMuYykrXCIvXCIrYitcIi5qc1wiLGZ1bmN0aW9uKGIpe2ImJmEoW10pfSkpOmEoW10pfTt2YXIgWT1uZXcgb2Eod2luZG93KTtZLmEuYy5jdXN0b209ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHNhKGIsYSl9O1kuYS5jLmZvbnRkZWNrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBIYShiLGEpfTtZLmEuYy5tb25vdHlwZT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgcmEoYixhKX07WS5hLmMudHlwZWtpdD1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgR2EoYixhKX07WS5hLmMuZ29vZ2xlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBFYShiLGEpfTt2YXIgWj17bG9hZDpwKFkubG9hZCxZKX07XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gWn0pOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1aOih3aW5kb3cuV2ViRm9udD1aLHdpbmRvdy5XZWJGb250Q29uZmlnJiZZLmxvYWQod2luZG93LldlYkZvbnRDb25maWcpKTt9KCkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL0FwcFxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuY29uc29sZS5pbmZvKGBQb3J0Zm9saW8gQXBwIHN0YXJ0ZWQgJHtHSVRfUkVWfWApO1xuXG4vLyBpZiAoIURFQlVHKSB7XG4vLyBcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXYpIHtcbi8vIFx0XHRjb25zb2xlLmVycm9yKFwiVW5jYXVnaHQgRXJyb3JcIiwgZXYpO1xuLy8gXHR9KTtcbi8vIH1cblxuaWYgKERFQlVHKSB7XG5cdHJlcXVpcmUoXCJNb2Rlcm5penJcIik7XG59XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xucmVxdWlyZShcImVzNi1wcm9taXNlL2F1dG9cIik7XG5yZXF1aXJlKFwiY2xhc3NsaXN0LXBvbHlmaWxsXCIpO1xucmVxdWlyZShcInJhZi1wb2x5ZmlsbFwiKTtcbnJlcXVpcmUoXCJtYXRjaGVzLXBvbHlmaWxsXCIpO1xucmVxdWlyZShcImZ1bGxzY3JlZW4tcG9seWZpbGxcIik7XG5yZXF1aXJlKFwibWF0aC1zaWduLXBvbHlmaWxsXCIpO1xuLy8gcmVxdWlyZShcInBhdGgyZC1wb2x5ZmlsbFwiKTtcbnJlcXVpcmUoXCJtdXRhdGlvbi1vYnNlcnZlclwiKTtcblxucmVxdWlyZShcImJhY2tib25lXCIpLiQgPSByZXF1aXJlKFwiYmFja2JvbmUubmF0aXZlXCIpO1xucmVxdWlyZShcImJhY2tib25lLmJhYnlzaXR0ZXJcIik7XG5yZXF1aXJlKFwiQmFja2JvbmUuTXV0YXRvcnNcIik7XG5yZXF1aXJlKFwiaGFtbWVyanNcIik7XG5cbi8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbihldikge1xuLy8gXHRjb25zb2xlLmxvZyhcIiVzOltldmVudCAlc11cIiwgZXYudGFyZ2V0LCBldi50eXBlKTtcbi8vIH0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oZXYpIHtcblx0Y29uc29sZS5sb2coXCIlczpbZXZlbnQgJXNdXCIsIGV2LnRhcmdldCwgZXYudHlwZSk7XG5cblx0Ly8gcHJvY2VzcyBib290c3RyYXAgZGF0YSwgbGV0IGVycm9ycyBnbyB1cCB0aGUgc3RhY2tcblx0dHJ5IHtcblx0XHRyZXF1aXJlKFwiYXBwL21vZGVsL2hlbHBlci9ib290c3RyYXBcIikod2luZG93LmJvb3RzdHJhcCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYXBwXCIpO1xuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJhcHAtaW5pdGlhbFwiKTtcblx0XHRlbC5jbGFzc0xpc3QuYWRkKFwiYXBwLWVycm9yXCIpO1xuXHRcdHRocm93IG5ldyBFcnJvcihcImJvb3RzdHJhcCBkYXRhIGVycm9yIChcIiArIGVyci5tZXNzYWdlICsgXCIpXCIsIGVyci5maWxlTmFtZSwgZXJyLmxpbmVOdW1iZXIpO1xuXHR9IGZpbmFsbHkgeyAvLyBkZXRlbGUgZ2xvYmFsIHZhclxuXHRcdGRlbGV0ZSB3aW5kb3cuYm9vdHN0cmFwO1xuXHR9XG5cblx0cmVxdWlyZShcImFwcC92aWV3L3RlbXBsYXRlL19oZWxwZXJzXCIpO1xuXG5cdC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2hlbHBlci9jcmVhdGVDb2xvclN0eWxlU2hlZXR9ICovXG5cdHJlcXVpcmUoXCJhcHAvdmlldy9oZWxwZXIvY3JlYXRlQ29sb3JTdHlsZVNoZWV0XCIpLmNhbGwoKTsgLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvQXBwVmlld30gKi9cblx0dmFyIEFwcFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvQXBwVmlld1wiKTtcblx0Ly8gdmFyIHN0YXJ0QXBwID0gQXBwVmlldy5nZXRJbnN0YW5jZS5iaW5kKEFwcFZpZXcpO1xuXG5cdC8qKiBAdHlwZSB7bW9kdWxlOndlYmZvbnRsb2FkZXJ9ICovXG5cdHZhciBXZWJGb250ID0gcmVxdWlyZShcIndlYmZvbnRsb2FkZXJcIik7XG5cdHZhciBsb2FkT3B0cyA9IHtcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z3JvdXBOYW1lOiBcIlwiLFxuXHRcdGNsYXNzZXM6IGZhbHNlLFxuXHRcdGxvYWRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJXZWJGb250OiVzOmxvYWRpbmdcIiwgdGhpcy5ncm91cE5hbWUpO1xuXHRcdH0sXG5cdFx0YWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUuaW5mbyhcIldlYkZvbnQ6JXM6YWN0aXZlXCIsIHRoaXMuZ3JvdXBOYW1lKTtcblx0XHR9LFxuXHRcdGluYWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIldlYkZvbnQ6JXM6aW5hY3RpdmVcIiwgdGhpcy5ncm91cE5hbWUpO1xuXHRcdH0sXG5cdFx0Zm9udGFjdGl2ZTogZnVuY3Rpb24oZmFtaWx5TmFtZSwgdmFyaWFudEZ2ZCkge1xuXHRcdFx0Y29uc29sZS5pbmZvKFwiV2ViRm9udDolczpmb250YWN0aXZlICclcycgKCVzKVwiLCB0aGlzLmdyb3VwTmFtZSwgZmFtaWx5TmFtZSwgdmFyaWFudEZ2ZCk7XG5cdFx0fSxcblx0XHRmb250aW5hY3RpdmU6IGZ1bmN0aW9uKGZhbWlseU5hbWUsIHZhcmlhbnRGdmQpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIldlYkZvbnQ6JXM6Zm9udGluYWN0aXZlICclcycgKCVzKVwiLCB0aGlzLmdyb3VwTmFtZSwgZmFtaWx5TmFtZSwgdmFyaWFudEZ2ZCk7XG5cdFx0fSxcblx0XHQvLyBmb250bG9hZGluZzogZnVuY3Rpb24oZmFtaWx5TmFtZSwgdmFyaWFudERlc2MpIHtcblx0XHQvLyBcdGNvbnNvbGUubG9nKFwiV2ViRm9udDo6Zm9udGxvYWRpbmdcIiwgZmFtaWx5TmFtZSwgSlNPTi5zdHJpbmdpZnkodmFyaWFudERlc2MsIG51bGwsIFwiIFwiKSk7XG5cdFx0Ly8gfSxcblx0fTtcblxuXHRXZWJGb250LmxvYWQoXy5kZWZhdWx0cyh7XG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdyb3VwTmFtZTogXCJyZXF1aXJlZFwiLFxuXHRcdGN1c3RvbToge1xuXHRcdFx0ZmFtaWxpZXM6IFtcblx0XHRcdFx0XCJGcmFua2xpbkdvdGhpY0ZTOm40LG42XCIsXG5cdFx0XHRcdC8vIFwiRnJhbmtsaW5Hb3RoaWNGUzppNCxpNlwiXG5cdFx0XHRcdFwiRm9saW9GaWd1cmVzOm40XCIsXG5cdFx0XHRdLFxuXHRcdFx0dGVzdFN0cmluZ3M6IHtcblx0XHRcdFx0XCJGb2xpb0ZpZ3VyZXNcIjogXCJobXNcIlxuXHRcdFx0fSxcblx0XHR9LFxuXHRcdGFjdGl2ZTogKCkgPT4gQXBwVmlldy5nZXRJbnN0YW5jZSgpLFxuXHRcdGluYWN0aXZlOiAoKSA9PiBBcHBWaWV3LmdldEluc3RhbmNlKCksXG5cdH0sIGxvYWRPcHRzKSk7XG5cblx0V2ViRm9udC5sb2FkKF8uZGVmYXVsdHMoe30sIGxvYWRPcHRzKSk7XG5cblx0Ly8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHRzdGFtcCkge1xuXHQvLyBcdEFwcFZpZXcuZ2V0SW5zdGFuY2UoKTtcblx0Ly8gfSk7XG59KTtcblxuXG5pZiAoREVCVUcpIHtcblx0Ly8gLyoqIEB0eXBlIHttb2R1bGU6dW5kZXJzY29yZX0gKi9cblx0Ly8gdmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblxuXHQvLyB2YXIgaXNGRiA9IC9GaXJlZm94Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcblx0Ly8gdmFyIGlzSU9TID0gL2lQYWR8aVBob25lLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcblx0Lypcblx0aWYgKC9GaXJlZm94Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdGNvbnNvbGUucHJlZml4ID0gXCIjIFwiO1xuXHRcdHZhciBzaGlmdCA9IFtdLnNoaWZ0O1xuXHRcdHZhciBsb2dXcmFwRm4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09IFwic3RyaW5nXCIpIGFyZ3VtZW50c1sxXSA9IGNvbnNvbGUucHJlZml4ICsgYXJndW1lbnRzWzFdO1xuXHRcdFx0cmV0dXJuIHNoaWZ0LmFwcGx5KGFyZ3VtZW50cykuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdGNvbnNvbGUuZ3JvdXAgPSBfLndyYXAoY29uc29sZS5ncm91cCwgbG9nV3JhcEZuKTtcblx0XHRjb25zb2xlLmxvZyA9IF8ud3JhcChjb25zb2xlLmxvZywgbG9nV3JhcEZuKTtcblx0XHRjb25zb2xlLmluZm8gPSBfLndyYXAoY29uc29sZS5pbmZvLCBsb2dXcmFwRm4pO1xuXHRcdGNvbnNvbGUud2FybiA9IF8ud3JhcChjb25zb2xlLndhcm4sIGxvZ1dyYXBGbik7XG5cdFx0Y29uc29sZS5lcnJvciA9IF8ud3JhcChjb25zb2xlLmVycm9yLCBsb2dXcmFwRm4pO1xuXHR9XG5cdCovXG5cdC8qXG5cdHZhciBzYXZlTG9ncyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2dXcmFwRm4gPSBmdW5jdGlvbihuYW1lLCBmbiwgbXNnKSB7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoXG5cdFx0XHRcdGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJbXCIgKyBuYW1lICsgXCJdIFwiICsgbXNnKSk7XG5cdFx0fTtcblx0XHRjb25zb2xlLmdyb3VwID0gXy53cmFwKGNvbnNvbGUuZ3JvdXAsIF8ucGFydGlhbChsb2dXcmFwRm4sIFwiZ3JvdXBcIikpO1xuXHRcdGNvbnNvbGUubG9nID0gXy53cmFwKGNvbnNvbGUubG9nLCBfLnBhcnRpYWwobG9nV3JhcEZuLCBcImxvZ1wiKSk7XG5cdFx0Y29uc29sZS5pbmZvID0gXy53cmFwKGNvbnNvbGUuaW5mbywgXy5wYXJ0aWFsKGxvZ1dyYXBGbiwgXCJpbmZvXCIpKTtcblx0XHRjb25zb2xlLndhcm4gPSBfLndyYXAoY29uc29sZS53YXJuLCBfLnBhcnRpYWwobG9nV3JhcEZuLCBcIndhcm5cIikpO1xuXHRcdGNvbnNvbGUuZXJyb3IgPSBfLndyYXAoY29uc29sZS5lcnJvciwgXy5wYXJ0aWFsKGxvZ1dyYXBGbiwgXCJlcnJvclwiKSk7XG5cdH07XG5cdCovXG5cblx0Ly8gaGFuZGxlIGVycm9yIGV2ZW50cyBvbiBzb21lIHBsYXRmb3JtcyBhbmQgcHJvZHVjdGlvblxuXHQvKlxuXHRpZiAoaXNJT1MpIHtcblx0XHQvLyBzYXZlTG9ncygpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpLFxuXHRcdFx0XHRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRcdGh0bWwgPSBcIlwiO1xuXHRcdFx0Xy5leHRlbmQoZWwuc3R5bGUsIHtcblx0XHRcdFx0Zm9udGZhbWlseTogXCJtb25vc3BhY2VcIixcblx0XHRcdFx0ZGlzcGxheTogXCJibG9ja1wiLFxuXHRcdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHR6SW5kZXg6IFwiOTk5XCIsXG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiLFxuXHRcdFx0XHRjb2xvcjogXCJibGFja1wiLFxuXHRcdFx0XHR3aWR0aDogXCJjYWxjKDEwMCUgLSAzZW0pXCIsXG5cdFx0XHRcdGJvdHRvbTogXCIwXCIsXG5cdFx0XHRcdG1hcmdpbjogXCIxZW0gMS41ZW1cIixcblx0XHRcdFx0cGFkZGluZzogXCIxZW0gMS41ZW1cIixcblx0XHRcdFx0b3V0bGluZTogXCIwLjVlbSBzb2xpZCByZWRcIixcblx0XHRcdFx0b3V0bGluZU9mZnNldDogXCIwLjVlbVwiLFxuXHRcdFx0XHRib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRvdmVyZmxvdzogXCJoaWRkZW5cIixcblx0XHRcdH0pO1xuXHRcdFx0aHRtbCArPSBcIjxwcmU+PGI+bG9jYXRpb246PGI+IFwiICsgd2luZG93LmxvY2F0aW9uICsgXCI8L3ByZT5cIjtcblx0XHRcdGh0bWwgKz0gXCI8cHJlPjxiPmV2ZW50OjxiPiBcIiArIEpTT04uc3RyaW5naWZ5KGFyZ3Muc2hpZnQoKSwgbnVsbCwgXCIgXCIpICsgXCI8L3ByZT5cIjtcblx0XHRcdGlmIChhcmdzLmxlbmd0aCkgaHRtbCArPSBcIjxwcmU+PGI+cmVzdDo8Yj4gXCIgKyBKU09OLnN0cmluZ2lmeShhcmdzLCBudWxsLCBcIiBcIikgKyBcIjwvcHJlPlwiO1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gaHRtbDtcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdH0pO1xuXHR9Ki9cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC9jb250cm9sL0NvbnRyb2xsZXJcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTpiYWNrYm9uZX0gKi9cbmNvbnN0IEJhY2tib25lID0gcmVxdWlyZShcImJhY2tib25lXCIpO1xuXG4vLyAvKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvY29sbGVjdGlvbi9UeXBlQ29sbGVjdGlvbn0gKi9cbi8vIHZhciB0eXBlcyA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvY29sbGVjdGlvbi9UeXBlQ29sbGVjdGlvblwiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0tleXdvcmRDb2xsZWN0aW9ufSAqL1xuLy8gdmFyIGtleXdvcmRzID0gcmVxdWlyZShcImFwcC9tb2RlbC9jb2xsZWN0aW9uL0tleXdvcmRDb2xsZWN0aW9uXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQXJ0aWNsZUNvbGxlY3Rpb259ICovXG5jb25zdCBhcnRpY2xlcyA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvY29sbGVjdGlvbi9BcnRpY2xlQ29sbGVjdGlvblwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0J1bmRsZUNvbGxlY3Rpb259ICovXG5jb25zdCBidW5kbGVzID0gcmVxdWlyZShcImFwcC9tb2RlbC9jb2xsZWN0aW9uL0J1bmRsZUNvbGxlY3Rpb25cIik7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4vKiBTdGF0aWMgcHJpdmF0ZVxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuLyogQGNvbnN0cnVjdG9yXG4vKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0NvbnRyb2xsZXJ9XG4vKi9cbnZhciBDb250cm9sbGVyID0gQmFja2JvbmUuUm91dGVyLmV4dGVuZCh7XG5cblx0Ly8gLyoqIEBvdmVycmlkZSAqL1xuXHQvLyByb3V0ZXM6IHt9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG5cdFx0aWYgKERFQlVHKSB7XG5cdFx0XHR0aGlzLl9yb3V0ZU5hbWVzID0gW107XG5cdFx0XHR0aGlzLnJvdXRlID0gZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMuX3JvdXRlTmFtZXMucHVzaChfLmlzU3RyaW5nKG5hbWUpID8gbmFtZSA6ICcnKTtcblx0XHRcdFx0cmV0dXJuIEJhY2tib25lLlJvdXRlci5wcm90b3R5cGUucm91dGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLm9uKFwicm91dGVcIiwgZnVuY3Rpb24ocm91dGVOYW1lLCBhcmdzKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiY29udHJvbGxlcjpbcm91dGVdICVzIFslc11cIiwgcm91dGVOYW1lLCBhcmdzLmpvaW4oKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIFByZWZpeGVkIGFydGljbGUgcmVnZXhwOiAvXmFydGljbGUoPzpcXC8oW15cXC9dKykpXFwvPyQvXG5cdFx0ICogU2luZ2xlIGJ1bmRsZSByZWdleHA6IC9eYnVuZGxlcyg/OlxcLyhbXlxcL10rKSg/OlxcLyhcXGQrKSk/KT9cXC8/JC9cblx0XHQgKi9cblx0XHR0aGlzLnJvdXRlKC8oLiopLyxcblx0XHRcdFwibm90Zm91bmRcIiwgdGhpcy50b05vdEZvdW5kKTtcblx0XHR0aGlzLnJvdXRlKC9eKFthLXpdW2EtejAtOVxcLV0qKVxcLz8kLyxcblx0XHRcdFwiYXJ0aWNsZS1pdGVtXCIsIHRoaXMudG9BcnRpY2xlSXRlbSk7XG5cdFx0dGhpcy5yb3V0ZSgvXig/OmJ1bmRsZXMpP1xcLz8kLyxcblx0XHRcdFwicm9vdFwiLCB0aGlzLnRvUm9vdCk7XG5cdFx0Ly8gdGhpcy5yb3V0ZSgvXmJ1bmRsZXNcXC8/JC8sXG5cdFx0Ly8gXHRcImJ1bmRsZS1saXN0XCIsIHRoaXMudG9CdW5kbGVMaXN0KTtcblx0XHQvLyB0aGlzLnJvdXRlKC9eYnVuZGxlc1xcLyhbXlxcL10rKVxcLz8kLyxcblx0XHQvLyBcdFwiYnVuZGxlLWl0ZW1cIiwgdGhpcy50b0J1bmRsZUl0ZW0pO1xuXHRcdC8vIHRoaXMucm91dGUoL15idW5kbGVzXFwvKFteXFwvXSspXFwvKFxcZCspXFwvPyQvLFxuXHRcdC8vIFx0XCJtZWRpYS1pdGVtXCIsIHRoaXMudG9NZWRpYUl0ZW0pO1xuXG5cdFx0Ly8gdGhpcy5yb3V0ZSgvXmJ1bmRsZXMoPzpcXC8oW15cXC9dKykoPzpcXC8oXFxkKykpPyk/XFwvPyQvLFxuXHRcdHRoaXMucm91dGUoL15idW5kbGVzXFwvKFteXFwvXSspKD86XFwvKFxcZCspPyk/XFwvPyQvLFxuXHRcdFx0XCJtZWRpYS1pdGVtXCIsIHRoaXMudG9NZWRpYUl0ZW0pO1xuXG5cdFx0aWYgKERFQlVHKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOjppbml0aWFsaXplIHJvdXRlczogJW9cIiwgXCJjb250cm9sbGVyXCIsIHRoaXMuX3JvdXRlTmFtZXMpO1xuXHRcdH1cblx0fSxcblxuXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIEpTIHRvIFVSTDogcHVibGljIGNvbW1hbmQgbWV0aG9kc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRzZWxlY3RNZWRpYTogZnVuY3Rpb24obWVkaWEpIHtcblx0XHR0aGlzLl9nb1RvTG9jYXRpb24obWVkaWEuZ2V0KFwiYnVuZGxlXCIpLCBtZWRpYSk7XG5cdH0sXG5cblx0c2VsZWN0QnVuZGxlOiBmdW5jdGlvbihidW5kbGUpIHtcblx0XHRpZiAoYnVuZGxlLmF0dHIoXCJAbm8tZGVzY1wiKSkge1xuXHRcdFx0dGhpcy5fZ29Ub0xvY2F0aW9uKGJ1bmRsZSwgYnVuZGxlLmdldChcIm1lZGlhXCIpLmF0KDApKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZ29Ub0xvY2F0aW9uKGJ1bmRsZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRlc2VsZWN0TWVkaWE6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2dvVG9Mb2NhdGlvbihidW5kbGVzLnNlbGVjdGVkKTtcblx0fSxcblxuXHRkZXNlbGVjdEJ1bmRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fZ29Ub0xvY2F0aW9uKCk7XG5cdH0sXG5cblx0c2VsZWN0QXJ0aWNsZTogZnVuY3Rpb24oYXJ0aWNsZSkge1xuXHRcdHRoaXMubmF2aWdhdGUoYXJ0aWNsZS5nZXQoXCJoYW5kbGVcIiksIHsgdHJpZ2dlcjogdHJ1ZSB9KTtcblx0fSxcblxuXHRkZXNlbGVjdEFydGljbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubmF2aWdhdGUoXCJcIiwgeyB0cmlnZ2VyOiB0cnVlIH0pO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBKUyB0byBVUkw6IHByaXZhdGUgaGVscGVyc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogVXBkYXRlIGxvY2F0aW9uIHdoZW4gbmF2aWdhdGlvbiBoYXBwZW5zIGludGVybmFsbHkgKi9cblx0LypfdXBkYXRlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBidW5kbGUsIG1lZGlhO1xuXHRcdGJ1bmRsZSA9IGJ1bmRsZXMuc2VsZWN0ZWQ7XG5cdFx0aWYgKGJ1bmRsZSkge1xuXHRcdFx0bWVkaWEgPSBidW5kbGUuZ2V0KFwibWVkaWFcIikuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMubmF2aWdhdGUodGhpcy5fZ2V0TG9jYXRpb24oYnVuZGxlLCBtZWRpYSksIHtcblx0XHRcdHRyaWdnZXI6IGZhbHNlXG5cdFx0fSk7XG5cdH0sKi9cblxuXHRfZ2V0TG9jYXRpb246IGZ1bmN0aW9uKGJ1bmRsZSwgbWVkaWEpIHtcblx0XHR2YXIgbWVkaWFJbmRleCwgbG9jYXRpb24gPSBbXTtcblx0XHRpZiAoYnVuZGxlKSB7XG5cdFx0XHRsb2NhdGlvbi5wdXNoKFwiYnVuZGxlc1wiKTtcblx0XHRcdGxvY2F0aW9uLnB1c2goYnVuZGxlLmdldChcImhhbmRsZVwiKSk7XG5cdFx0XHRpZiAobWVkaWEpIHtcblx0XHRcdFx0bWVkaWFJbmRleCA9IGJ1bmRsZS5nZXQoXCJtZWRpYVwiKS5pbmRleE9mKG1lZGlhKTtcblx0XHRcdFx0aWYgKG1lZGlhSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdGxvY2F0aW9uLnB1c2gobWVkaWFJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gbG9jYXRpb24ucHVzaChcIlwiKTtcblx0XHRyZXR1cm4gbG9jYXRpb24uam9pbihcIi9cIik7XG5cdH0sXG5cblx0X2dvVG9Mb2NhdGlvbjogZnVuY3Rpb24oYnVuZGxlLCBtZWRpYSkge1xuXHRcdHRoaXMubmF2aWdhdGUodGhpcy5fZ2V0TG9jYXRpb24oYnVuZGxlLCBtZWRpYSksIHtcblx0XHRcdHRyaWdnZXI6IHRydWVcblx0XHR9KTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiBVUkwgdG8gSlM6IHJvdXRlciBoYW5kbGVyc1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHR0b1Jvb3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZTpiZWZvcmVcIik7XG5cdFx0aWYgKGJ1bmRsZXMuc2VsZWN0ZWQpIHtcblx0XHRcdC8vIGJ1bmRsZXMuc2VsZWN0ZWQuZ2V0KFwibWVkaWFcIikuZGVzZWxlY3QoKTtcblx0XHRcdGJ1bmRsZXMuZGVzZWxlY3QoKTtcblx0XHR9XG5cdFx0Ly8ga2V5d29yZHMuZGVzZWxlY3QoKTtcblx0XHRhcnRpY2xlcy5kZXNlbGVjdCgpO1xuXHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZTphZnRlclwiKTtcblx0fSxcblxuXHR0b05vdEZvdW5kOiBmdW5jdGlvbihzbHVnKSB7XG5cdFx0Y29uc29sZS5pbmZvKFwicm91dGU6Wyo6JXNdXCIsIHNsdWcpO1xuXHR9LFxuXG5cdC8vIHRvQnVuZGxlTGlzdDogZnVuY3Rpb24oKSB7XG5cdC8vIFx0dGhpcy5uYXZpZ2F0ZShcIlwiLCB7XG5cdC8vIFx0XHR0cmlnZ2VyOiB0cnVlLFxuXHQvLyBcdFx0cmVwbGFjZTogdHJ1ZVxuXHQvLyBcdH0pO1xuXHQvLyB9LFxuXG5cdHRvQnVuZGxlSXRlbTogZnVuY3Rpb24oYnVuZGxlSGFuZGxlKSB7XG5cdFx0dmFyIGJ1bmRsZSA9IGJ1bmRsZXMuZmluZFdoZXJlKHtcblx0XHRcdGhhbmRsZTogYnVuZGxlSGFuZGxlXG5cdFx0fSk7XG5cdFx0aWYgKCFidW5kbGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGJ1bmRsZSB3aXRoIGhhbmRsZSBcXFwiXCIgKyBidW5kbGVIYW5kbGUgKyBcIlxcXCJcIik7XG5cdFx0XHQvLyB9IGVsc2UgaWYgKGJ1bmRsZS5hdHRyKFwiQG5vLWRlc2NcIikpIHtcblx0XHRcdC8vIHRoaXMuX2NoYW5nZVNlbGVjdGlvbihidW5kbGUsIGJ1bmRsZS5nZXQoXCJtZWRpYVwiKS5hdCgwKSk7XG5cdFx0XHQvLyB0aGlzLm5hdmlnYXRlKHRoaXMuX2dldExvY2F0aW9uKGJ1bmRsZSwgYnVuZGxlLmdldChcIm1lZGlhXCIpLmF0KDApKSwgeyB0cmlnZ2VyOiB0cnVlLCByZXBsYWNlOiBmYWxzZSB9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2hhbmdlU2VsZWN0aW9uKGJ1bmRsZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRvTWVkaWFJdGVtOiBmdW5jdGlvbihidW5kbGVIYW5kbGUsIG1lZGlhSW5kZXgpIHtcblx0XHR2YXIgYnVuZGxlLCBtZWRpYTtcblx0XHQvLyBpZiAoYnVuZGxlSGFuZGxlKSB7XG5cdFx0YnVuZGxlID0gYnVuZGxlcy5maW5kV2hlcmUoeyBoYW5kbGU6IGJ1bmRsZUhhbmRsZSB9KTtcblx0XHRpZiAoIWJ1bmRsZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm8gYnVuZGxlIHdpdGggaGFuZGxlIFxcXCJcIiArIGJ1bmRsZUhhbmRsZSArIFwiXFxcIiBmb3VuZFwiKTtcblx0XHR9XG5cdFx0bWVkaWEgPSBidW5kbGUuZ2V0KFwibWVkaWFcIikuYXQobWVkaWFJbmRleCA/IG1lZGlhSW5kZXggOiAwKTtcblx0XHRpZiAoIW1lZGlhKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJObyBtZWRpYSBhdCBpbmRleCBcIiArIG1lZGlhSW5kZXggKyBcIiBpbiBidW5kbGUgd2l0aCBoYW5kbGUgXFxcIlwiICsgYnVuZGxlSGFuZGxlICsgXCJcXFwiIGZvdW5kXCIpO1xuXHRcdH1cblx0XHQvLyB9XG5cdFx0Ly8gfVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbihidW5kbGUsIG1lZGlhKTtcblx0fSxcblxuXHR0b0FydGljbGVJdGVtOiBmdW5jdGlvbihhcnRpY2xlSGFuZGxlKSB7XG5cdFx0dmFyIGFydGljbGUgPSBhcnRpY2xlcy5maW5kV2hlcmUoeyBoYW5kbGU6IGFydGljbGVIYW5kbGUgfSk7XG5cdFx0aWYgKCFhcnRpY2xlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhcnRpY2xlIHdpdGggaGFuZGxlIFxcXCJcIiArIGFydGljbGVIYW5kbGUgKyBcIlxcXCJcIik7XG5cdFx0fVxuXHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZTpiZWZvcmVcIiwgYXJ0aWNsZSk7XG5cdFx0YnVuZGxlcy5kZXNlbGVjdCgpO1xuXHRcdGFydGljbGVzLnNlbGVjdChhcnRpY2xlKTtcblx0XHR0aGlzLnRyaWdnZXIoXCJjaGFuZ2U6YWZ0ZXJcIiwgYXJ0aWNsZSk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBVUkwgdG8gSlM6IHByaXZhdGUgaGVscGVyc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Lypcblx0LyogTk9URTogU2VsZWN0aW9uIG9yZGVyXG5cdC8qIC0gQXBwbHkgbWVkaWEgc2VsZWN0aW9uIHRvICppbmNvbWluZyBidW5kbGUqLCBhcyBub3QgdG8gdHJpZ2dlclxuXHQvKlx0dW5uZWNjZXNhcnkgZXZlbnRzIG9uIGFuIG91dGdvaW5nIGJ1bmRsZS4gT3V0Z29pbmcgYnVuZGxlIG1lZGlhIHNlbGVjdGlvblxuXHQvKlx0cmVtYWlucyB1bnRvdWNoZWQuXG5cdC8qIC0gQXBwbHkgbWVkaWEgc2VsZWN0aW9uICpiZWZvcmUqIHNlbGVjdGluZyB0aGUgaW5jb21pbmcgYnVuZGxlLiBWaWV3c1xuXHQvKlx0bm9ybWFsbHkgbGlzdGVuIHRvIHRoZSBzZWxlY3RlZCBidW5kbGUgb25seSwgc28gaWYgdGhlIGJ1bmRsZSBpcyBjaGFuZ2luZyxcblx0LypcdHRoZXkgd2lsbCBub3QgYmUgbGlzdGVuaW5nIHRvIG1lZGlhIHNlbGVjdGlvbiBjaGFuZ2VzIHlldC5cblx0LyovXG5cdF9jaGFuZ2VTZWxlY3Rpb246IGZ1bmN0aW9uKGJ1bmRsZSwgbWVkaWEpIHtcblx0XHR2YXIgbGFzdEJ1bmRsZSwgbGFzdE1lZGlhO1xuXHRcdGlmIChidW5kbGUgPT09IHZvaWQgMCkgYnVuZGxlID0gbnVsbDtcblx0XHRpZiAobWVkaWEgPT09IHZvaWQgMCkgbWVkaWEgPSBudWxsO1xuXG5cdFx0Ly8gaWYgKGJ1bmRsZSAhPT0gbnVsbCAmJiBtZWRpYSA9PT0gbnVsbCAmJiBidW5kbGUuYXR0cihcIkBuby1kZXNjXCIpKSB7XG5cdFx0Ly8gXHRtZWRpYSA9IGJ1bmRsZS5nZXQoXCJtZWRpYVwiKS5hdCgwKTtcblx0XHQvLyBcdHRoaXMuX2dvVG9Mb2NhdGlvbihidW5kbGUsIG1lZGlhKTtcblx0XHQvLyBcdHJldHVybjtcblx0XHQvLyB9XG5cblx0XHRsYXN0QnVuZGxlID0gYnVuZGxlcy5zZWxlY3RlZDtcblx0XHRsYXN0TWVkaWEgPSBsYXN0QnVuZGxlID8gbGFzdEJ1bmRsZS5nZXQoXCJtZWRpYVwiKS5zZWxlY3RlZCA6IG51bGw7XG5cdFx0Y29uc29sZS5sb2coXCJjb250cm9sbGVyOjpfY2hhbmdlU2VsZWN0aW9uIGJ1bmRsZTpbJXMgLT4gJXNdIG1lZGlhOlslcyAtPiAlc11cIixcblx0XHRcdChsYXN0QnVuZGxlID8gbGFzdEJ1bmRsZS5jaWQgOiBsYXN0QnVuZGxlKSwgKGJ1bmRsZSA/IGJ1bmRsZS5jaWQgOiBidW5kbGUpLFxuXHRcdFx0KGxhc3RNZWRpYSA/IGxhc3RNZWRpYS5jaWQgOiBsYXN0TWVkaWEpLCAobWVkaWEgPyBtZWRpYS5jaWQgOiBtZWRpYSlcblx0XHQpO1xuXG5cdFx0aWYgKCFhcnRpY2xlcy5zZWxlY3RlZCAmJiAobGFzdEJ1bmRsZSA9PT0gYnVuZGxlKSAmJiAobGFzdE1lZGlhID09PSBtZWRpYSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXIoXCJjaGFuZ2U6YmVmb3JlXCIsIGJ1bmRsZSwgbWVkaWEpO1xuXHRcdGJ1bmRsZSAmJiBidW5kbGUuZ2V0KFwibWVkaWFcIikuc2VsZWN0KG1lZGlhKTtcblx0XHRidW5kbGVzLnNlbGVjdChidW5kbGUpO1xuXHRcdGFydGljbGVzLmRlc2VsZWN0KCk7XG5cdFx0dGhpcy50cmlnZ2VyKFwiY2hhbmdlOmFmdGVyXCIsIGJ1bmRsZSwgbWVkaWEpO1xuXHR9LFxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29udHJvbGxlcigpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL2NvbnRyb2wvR2xvYmFsc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXHQvLyByZXVzYWJsZSB2YXJzXG5cdHZhciBvLCBzLCBzbztcblx0Ly8gZ2xvYmFsIGhhc2hcblx0dmFyIGcgPSB7fTtcblx0Ly8gU0FTUyA8LS0+IEpTIHNoYXJlZCBoYXNoXG5cdHZhciBzYXNzID0gcmVxdWlyZShcIi4uLy4uLy4uL3Nhc3MvdmFyaWFibGVzLmpzb25cIik7XG5cblx0Ly8gSlVOSyBGSVJTVDogU29tZSBhcHAtd2lkZSBkZWZhdWx0c1xuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0Zy5WUEFOX0RSQUcgPSAwLjk1OyAvLyBhcyBmYWN0b3Igb2YgcG9pbnRlciBkZWx0YVxuXHRnLkhQQU5fT1VUX0RSQUcgPSAwLjQ7IC8vIGZhY3RvclxuXHRnLlZQQU5fT1VUX0RSQUcgPSAwLjE7IC8vIGZhY3RvclxuXHRnLlBBTl9USFJFU0hPTEQgPSAxNTsgLy8gcHhcblx0Zy5DT0xMQVBTRV9USFJFU0hPTEQgPSA3NTsgLy8gcHhcblx0Zy5DT0xMQVBTRV9PRkZTRVQgPSBwYXJzZUludChzYXNzLnRlbXBbXCJjb2xsYXBzZV9vZmZzZXRcIl0pO1xuXHQvLyBnLkNMSUNLX0VWRU5UID0gXCJjbGlja1wiOyAvL3dpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIm9ucG9pbnRlcnVwXCIpID8gXCJwb2ludGVydXBcIiA6IFwibW91c2V1cFwiO1xuXHRnLlZJREVPX0NST1BfUFggPSBwYXJzZUludChzYXNzW1widmlkZW9fY3JvcF9weFwiXSk7XG5cblx0Ly8gYnJlYWtwb2ludHNcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdGcuQlJFQUtQT0lOVFMgPSB7fTtcblx0Zm9yIChzIGluIHNhc3MuYnJlYWtwb2ludHMpIHtcblx0XHRvID0gc2Fzcy5icmVha3BvaW50c1tzXTtcblx0XHQvKmlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHRnLkJSRUFLUE9JTlRTW3NdID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIHtcblx0XHRcdFx0XCJtYXRjaGVzXCI6IHtcblx0XHRcdFx0XHRnZXQ6IF8ucGFydGlhbChfLnNvbWUsIG8ubWFwKHdpbmRvdy5tYXRjaE1lZGlhKSwgXy5wcm9wZXJ0eShcIm1hdGNoZXNcIikpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwibWVkaWFcIjoge1xuXHRcdFx0XHRcdHZhbHVlOiBvLmpvaW4oXCIsIFwiKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInF1ZXJpZXNcIjoge1xuXHRcdFx0XHRcdHZhbHVlOiBvLm1hcCh3aW5kb3cubWF0Y2hNZWRpYSlcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnLkJSRUFLUE9JTlRTW3NdID0gd2luZG93Lm1hdGNoTWVkaWEobyk7XG5cdFx0fSovXG5cdFx0byA9IEFycmF5LmlzQXJyYXkobykgPyBvLmpvaW4oXCIsIFwiKSA6IG87XG5cdFx0byA9IG8ucmVwbGFjZSgvW1xcJ1xcXCJdL2csIFwiXCIpO1xuXHRcdG8gPSB3aW5kb3cubWF0Y2hNZWRpYShvKTtcblx0XHRvLmNsYXNzTmFtZSA9IHM7XG5cdFx0Zy5CUkVBS1BPSU5UU1tzXSA9IG87XG5cdH1cblx0aWYgKERFQlVHKSB7XG5cdFx0Y29uc29sZS5ncm91cENvbGxhcHNlZChcIkJyZWFrcG9pbnRzXCIpO1xuXHRcdGZvciAocyBpbiBnLkJSRUFLUE9JTlRTKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOiAlb1wiLCBzLCBnLkJSRUFLUE9JTlRTW3NdLm1lZGlhKTtcblx0XHR9XG5cdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHR9XG5cblx0Ly8gYmFzZSBjb2xvcnMsIGRpbWVuc2lvbnNcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdGcuREVGQVVMVF9DT0xPUlMgPSBfLmNsb25lKHNhc3MuZGVmYXVsdF9jb2xvcnMpO1xuXHQvLyBnLkhPUklaT05UQUxfU1RFUCA9IHBhcnNlRmxvYXQoc2Fzcy51bml0c1tcImh1X3B4XCJdKTtcblx0Ly8gZy5WRVJUSUNBTF9TVEVQID0gcGFyc2VGbG9hdChzYXNzLnVuaXRzW1widnVfcHhcIl0pO1xuXG5cblx0Ly8gcGF0aHMsIG5ldHdvcmtpbmdcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdC8vIHZhciB0b0Fic29sdXRlVVJMID0gKGZ1bmN0aW9uKCkge1xuXHQvLyBcdHZhciBhID0gbnVsbDtcblx0Ly8gXHRyZXR1cm4gZnVuY3Rpb24odXJsKSB7XG5cdC8vIFx0XHRhID0gYSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdC8vIFx0XHRhLmhyZWYgPSB1cmw7XG5cdC8vIFx0XHRyZXR1cm4gYS5ocmVmO1xuXHQvLyBcdH07XG5cdC8vIH0pKCk7XG5cdC8vIGcuQVBQX1JPT1QgPSB0b0Fic29sdXRlVVJMKHdpbmRvdy5hcHByb290KTtcblx0Ly8gZy5NRURJQV9ESVIgPSB0b0Fic29sdXRlVVJMKHdpbmRvdy5tZWRpYWRpcik7XG5cblx0Zy5BUFBfUk9PVCA9IHdpbmRvdy5hcHByb290O1xuXHRnLk1FRElBX0RJUiA9IHdpbmRvdy5tZWRpYWRpcjtcblxuXHRkZWxldGUgd2luZG93LmFwcHJvb3Q7XG5cdGRlbGV0ZSB3aW5kb3cubWVkaWFkaXI7XG5cblx0Ly8gaGFyZGNvZGVkIGZvbnQgZGF0YVxuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0Zy5GT05UX01FVFJJQ1MgPSB7XG5cdFx0XCJGcmFua2xpbkdvdGhpY0ZTXCI6IHtcblx0XHRcdFwidW5pdHNQZXJFbVwiOiAxMDAwLFxuXHRcdFx0XCJhc2NlbnRcIjogODI3LFxuXHRcdFx0XCJkZXNjZW50XCI6IC0xNzNcblx0XHR9LFxuXHRcdFwiSVRDRnJhbmtsaW5Hb3RoaWNTdGRcIjoge1xuXHRcdFx0XCJ1bml0c1BlckVtXCI6IDEwMDAsXG5cdFx0XHRcImFzY2VudFwiOiA2ODYsXG5cdFx0XHRcImRlc2NlbnRcIjogLTMxNFxuXHRcdH0sXG5cdFx0XCJGb2xpb0ZpZ3VyZXNcIjoge1xuXHRcdFx0XCJ1bml0c1BlckVtXCI6IDEwMjQsXG5cdFx0XHRcImFzY2VudFwiOiA5MzksXG5cdFx0XHRcImRlc2NlbnRcIjogLTI1NlxuXHRcdH0sXG5cdH07XG5cblx0Zy5QQVVTRV9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDIzRjgpO1xuXHRnLlBMQVlfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHgyM0Y1KTtcblx0Zy5TVE9QX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MjNGOSk7XG5cblx0Ly8gdHJhbnNsYXRlIGNvbW1vbiB0ZW1wbGF0ZVxuXHRpZiAoc2Fzcy50cmFuc2Zvcm1fdHlwZSA9PSBcIjNkXCIpIHtcblx0XHRnLlRSQU5TTEFURV9URU1QTEFURSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRcdHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDBweClcIjtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGcuVFJBTlNMQVRFX1RFTVBMQVRFID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdFx0cmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCI7XG5cdFx0fTtcblx0fVxuXG5cdGcuVFJBTlNMQVRFX1RFTVBMQVRFID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiO1xuXHRcdC8vIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHggLDBweClcIjtcblx0fTtcblx0Ly8gdGltaW5nLCBlYXNpbmdcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdHZhciBlYXNlID0gZy5UUkFOU0lUSU9OX0VBU0UgPSBzYXNzLnRyYW5zaXRpb25zW1wiZWFzZVwiXTtcblx0dmFyIGR1cmF0aW9uID0gZy5UUkFOU0lUSU9OX0RVUkFUSU9OID0gcGFyc2VGbG9hdChzYXNzLnRyYW5zaXRpb25zW1wiZHVyYXRpb25fbXNcIl0pO1xuXHR2YXIgZGVsYXlJbnRlcnZhbCA9IGcuVFJBTlNJVElPTl9ERUxBWV9JTlRFUlZBTCA9IHBhcnNlRmxvYXQoc2Fzcy50cmFuc2l0aW9uc1tcImRlbGF5X2ludGVydmFsX21zXCJdKTtcblx0dmFyIG1pbkRlbGF5ID0gZy5UUkFOU0lUSU9OX01JTl9ERUxBWSA9IHBhcnNlRmxvYXQoc2Fzcy50cmFuc2l0aW9uc1tcIm1pbl9kZWxheV9tc1wiXSk7XG5cdHZhciBkZWxheSA9IGcuVFJBTlNJVElPTl9ERUxBWSA9IGcuVFJBTlNJVElPTl9EVVJBVElPTiArIGcuVFJBTlNJVElPTl9ERUxBWV9JTlRFUlZBTDtcblxuXHQvLyBjc3MgdHJhbnNpdGlvbnNcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdG8gPSB7fTtcblxuXHQvLyBtYXRjaCB0eCgpIGluIF90cmFuc2l0aW9ucy5zY3NzXG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRvLnR4ID0gZnVuY3Rpb24gdHgoZHVyYXRpb25Db3VudCwgZGVsYXlDb3VudCwgZWFzZVZhbCkge1xuXHRcdF8uaXNOdW1iZXIoZHVyYXRpb25Db3VudCkgfHwgKGR1cmF0aW9uQ291bnQgPSAxKTtcblx0XHRfLmlzTnVtYmVyKGRlbGF5Q291bnQpIHx8IChkZWxheUNvdW50ID0gLTEpO1xuXHRcdF8uaXNTdHJpbmcoZWFzZVZhbCkgfHwgKGVhc2VWYWwgPSBlYXNlKTtcblxuXHRcdHZhciBvID0ge307XG5cdFx0aWYgKGRlbGF5Q291bnQgPCAwKSB7XG5cdFx0XHRvLmR1cmF0aW9uID0gKGR1cmF0aW9uICogZHVyYXRpb25Db3VudCkgK1xuXHRcdFx0XHQoZGVsYXlJbnRlcnZhbCAqIChkdXJhdGlvbkNvdW50IC0gMSkpO1xuXHRcdFx0by5kZWxheSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG8uZHVyYXRpb24gPSAoZHVyYXRpb24gKiBkdXJhdGlvbkNvdW50KSArXG5cdFx0XHRcdChkZWxheUludGVydmFsICogKGR1cmF0aW9uQ291bnQgLSAxKSkgLSBtaW5EZWxheTtcblx0XHRcdG8uZGVsYXkgPSAoZGVsYXkgKiBkZWxheUNvdW50KSAtIG1pbkRlbGF5O1xuXHRcdH1cblx0XHRvLmVhc2VpbmcgPSBlYXNlVmFsO1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Ly8gdHJhbnNpdGlvbiBwcmVzZXRzXG5cdC8vIFRPRE86IGdldCByaWQgb2YgdGhpc1xuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblxuXHRvLk5PTkUgPSB7XG5cdFx0ZGVsYXk6IDAsXG5cdFx0ZHVyYXRpb246IDAsXG5cdFx0ZWFzaW5nOiBcInN0ZXAtc3RhcnRcIlxuXHR9O1xuXHRvLk5PVyA9IHtcblx0XHRkZWxheTogMCxcblx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBlYXNlXG5cdH07XG5cdG8uVU5TRVQgPSBfLmRlZmF1bHRzKHtcblx0XHRjc3NUZXh0OiBcIlwiXG5cdH0sIG8uTk9ORSk7XG5cblx0dmFyIHR4QWxpZ25lZCA9IF8uZGVmYXVsdHMoe1xuXHRcdGR1cmF0aW9uOiBkdXJhdGlvbiAtIG1pbkRlbGF5XG5cdH0sIG8uTk9XKTtcblx0by5GSVJTVCA9IF8uZGVmYXVsdHMoe1xuXHRcdGRlbGF5OiBkZWxheSAqIDAuMCArIG1pbkRlbGF5XG5cdH0sIHR4QWxpZ25lZCk7XG5cdG8uQkVUV0VFTiA9IF8uZGVmYXVsdHMoe1xuXHRcdGRlbGF5OiBkZWxheSAqIDEuMCArIG1pbkRlbGF5XG5cdH0sIHR4QWxpZ25lZCk7XG5cdG8uTEFTVCA9IF8uZGVmYXVsdHMoe1xuXHRcdGRlbGF5OiBkZWxheSAqIDIuMCArIG1pbkRlbGF5XG5cdH0sIHR4QWxpZ25lZCk7XG5cdG8uQUZURVIgPSBfLmRlZmF1bHRzKHtcblx0XHRkZWxheTogZGVsYXkgKiAyLjAgKyBtaW5EZWxheVxuXHR9LCB0eEFsaWduZWQpO1xuXG5cdG8uQkVUV0VFTl9FQVJMWSA9IF8uZGVmYXVsdHMoe1xuXHRcdGRlbGF5OiBkZWxheSAqIDEuMCArIG1pbkRlbGF5IC0gNjBcblx0fSwgdHhBbGlnbmVkKTtcblx0by5CRVRXRUVOX0xBVEUgPSBfLmRlZmF1bHRzKHtcblx0XHRkZWxheTogZGVsYXkgKiAxLjAgKyBtaW5EZWxheSArIDYwXG5cdH0sIHR4QWxpZ25lZCk7XG5cblx0by5GSVJTVF9MQVRFID0gXy5kZWZhdWx0cyh7XG5cdFx0ZGVsYXk6IGRlbGF5ICogMC41ICsgbWluRGVsYXlcblx0fSwgdHhBbGlnbmVkKTtcblx0by5MQVNUX0VBUkxZID0gXy5kZWZhdWx0cyh7XG5cdFx0ZGVsYXk6IGRlbGF5ICogMS41ICsgbWluRGVsYXlcblx0fSwgdHhBbGlnbmVkKTtcblx0Ly8gby5GSVJTVF9MQVRFID0gXHRcdF8uZGVmYXVsdHMoe2RlbGF5OiB0eERlbGF5KjAuMCArIHR4TWluRGVsYXkqMn0sIHR4QWxpZ25lZCk7XG5cdC8vIG8uTEFTVF9FQVJMWSA9IFx0XHRfLmRlZmF1bHRzKHtkZWxheTogdHhEZWxheSoyLjAgKyB0eE1pbkRlbGF5KjB9LCB0eEFsaWduZWQpO1xuXHQvLyBvLkFGVEVSID0gXHRcdFx0Xy5kZWZhdWx0cyh7ZGVsYXk6IHR4RGVsYXkqMi4wICsgdHhNaW5EZWxheX0sIHR4QWxpZ25lZCk7XG5cblx0Y29uc29sZS5ncm91cENvbGxhcHNlZChcIlRyYW5zaXRpb25zXCIpO1xuXHRmb3IgKHMgaW4gbykge1xuXHRcdGlmICghXy5pc0Z1bmN0aW9uKG9bc10pKSB7XG5cdFx0XHRzbyA9IG9bc107XG5cdFx0XHRzby5uYW1lID0gcztcblx0XHRcdHNvLmNsYXNzTmFtZSA9IFwidHgtXCIgKyBzLnJlcGxhY2UoXCJfXCIsIFwiLVwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKCFzby5oYXNPd25Qcm9wZXJ0eShcImNzc1RleHRcIikpIHtcblx0XHRcdFx0c28uY3NzVGV4dCA9IHNvLmR1cmF0aW9uIC8gMTAwMCArIFwicyBcIiArIHNvLmVhc2luZyArIFwiIFwiICsgc28uZGVsYXkgLyAxMDAwICsgXCJzXCI7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOiAlc1wiLCBzby5uYW1lLCBzby5jc3NUZXh0KTtcblx0XHR9XG5cdH1cblx0Y29uc29sZS5ncm91cEVuZCgpO1xuXHRnLnRyYW5zaXRpb25zID0gbztcblxuXHRyZXR1cm4gZztcbn0oKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9EZWJ1Z1Rvb2xiYXJcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTpjb29raWVzLWpzfSAqL1xuY29uc3QgQ29va2llcyA9IHJlcXVpcmUoXCJjb29raWVzLWpzXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTptb2Rlcm5penJ9ICovXG5jb25zdCBNb2Rlcm5penIgPSByZXF1aXJlKFwiTW9kZXJuaXpyXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuY29uc3QgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvQ29udHJvbGxlcn0gKi9cbi8vIHZhciBjb250cm9sbGVyID0gcmVxdWlyZShcImFwcC9jb250cm9sL0NvbnRyb2xsZXJcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld30gKi9cbmNvbnN0IFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3XCIpO1xuXG4vKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuY29uc3Qgdmlld1RlbXBsYXRlID0gcmVxdWlyZShcIi4vdGVtcGxhdGUvRGVidWdUb29sYmFyLmhic1wiKTtcblxuLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbmNvbnN0IGdyaWRUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL3RlbXBsYXRlL0RlYnVnVG9vbGJhci5TVkdHcmlkLmhic1wiKTtcblxuLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbmNvbnN0IHNpemVUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCI8JT0gdyAlPiBcXHUwMEQ3IDwlPSBoICU+XCIpO1xuXG4vLyB2YXIgYXBwU3RhdGVTeW1ib2xzID0geyB3aXRoQnVuZGxlOiBcImJcIiwgd2l0aE1lZGlhOiBcIm1cIiwgY29sbGFwc2VkOiBcImNcIn07XG4vLyB2YXIgYXBwU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoYXBwU3RhdGVTeW1ib2xzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjaWRQcmVmaXg6IFwiZGVidWdUb29sYmFyXCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0dGFnTmFtZTogXCJkaXZcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjbGFzc05hbWU6IFwidG9vbGJhclwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRlbXBsYXRlOiB2aWV3VGVtcGxhdGUsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRwcm9wZXJ0aWVzOiB7XG5cdFx0Z3JpZDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2dyaWQgfHwgKHRoaXMuX2dyaWQgPSB0aGlzLmNyZWF0ZUdyaWRFbGVtZW50KCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0Q29va2llcy5kZWZhdWx0cyA9IHtcblx0XHRcdGV4cGlyZXM6IG5ldyBEYXRlKDB4N2ZmZmZmZmYgKiAxZTMpLFxuXHRcdFx0ZG9tYWluOiBTdHJpbmcod2luZG93LmxvY2F0aW9uKVxuXHRcdFx0XHQubWF0Y2goL15odHRwcz9cXDpcXC9cXC8oW15cXC86PyNdKykoPzpbXFwvOj8jXXwkKS9pKVsxXVxuXHRcdH07XG5cblx0XHR0aGlzLmVsLmlubmVySFRNTCA9IHRoaXMudGVtcGxhdGUoe1xuXHRcdFx0dGVzdHM6IE1vZGVybml6cixcblx0XHRcdG5hdmlnYXRvcjogd2luZG93Lm5hdmlnYXRvclxuXHRcdH0pO1xuXG5cdFx0LyogdG9nZ2xlJ3MgdGFyZ2V0OiBjb250YWluZXJcblx0XHQvKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtICovXG5cdFx0dmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udGFpbmVyXCIpOyAvLy5xdWVyeVNlbGVjdG9yKFwiI2NvbnRhaW5lclwiKTtcblxuXHRcdC8qIGNyZWF0ZS9hdHRhY2ggc3ZnIGdyaWQgZWxlbWVudFxuXHRcdC8qIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gKi9cblx0XHRjb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuY3JlYXRlR3JpZEVsZW1lbnQoKSwgY29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkKTtcblxuXHRcdC8qIGluZm8gZWxlbWVudHNcblx0XHQvKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtICovXG5cdFx0dGhpcy5iYWNrZW5kRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIjZWRpdC1iYWNrZW5kIGFcIik7XG5cdFx0dGhpcy5tZWRpYUluZm9FbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIiNtZWRpYS1pbmZvIHNwYW5cIik7XG5cdFx0dGhpcy5hcHBTdGF0ZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiI2FwcC1zdGF0ZVwiKTtcblxuXHRcdC8qIHRvZ2dsZSB2aXNpYmlsaXR5XG5cdFx0LyogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAqL1xuXHRcdHRoaXMuaW5pdGlhbGl6ZUNsYXNzVG9nZ2xlKFwic2hvdy1saW5rc1wiLCB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIjbGlua3MtdG9nZ2xlXCIpLCB0aGlzLmVsLFxuXHRcdFx0ZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJub3QtXCIgKyBrZXksICF2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0KTtcblx0XHR0aGlzLmluaXRpYWxpemVDbGFzc1RvZ2dsZShcInNob3ctdGVzdHNcIiwgdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiI3RvZ2dsZS10ZXN0cyBhXCIpLCB0aGlzLmVsKTtcblx0XHR0aGlzLmluaXRpYWxpemVDbGFzc1RvZ2dsZShcImhpZGUtcGFzc2VkXCIsIHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIiN0b2dnbGUtcGFzc2VkXCIpLCB0aGlzLmVsKTtcblxuXHRcdC8qIHRvZ2dsZSBjb250YWluZXIgY2xhc3Nlc1xuXHRcdC8qIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gKi9cblx0XHR0aGlzLmluaXRpYWxpemVDbGFzc1RvZ2dsZShcImRlYnVnLXN0YXRlXCIsXG5cdFx0XHR0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIjdG9nZ2xlLXN0YXRlIGFcIiksIGNvbnRhaW5lcik7XG5cdFx0dGhpcy5pbml0aWFsaXplQ2xhc3NUb2dnbGUoXCJkZWJ1Zy1ibG9ja3MtbmF2XCIsXG5cdFx0XHR0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIjdG9nZ2xlLWJsb2Nrcy1uYXYgYVwiKSwgY29udGFpbmVyKTtcblx0XHR0aGlzLmluaXRpYWxpemVDbGFzc1RvZ2dsZShcImRlYnVnLWJsb2Nrcy1jb250ZW50XCIsXG5cdFx0XHR0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIjdG9nZ2xlLWJsb2Nrcy1jb250ZW50IGFcIiksIGNvbnRhaW5lcik7XG5cdFx0dGhpcy5pbml0aWFsaXplQ2xhc3NUb2dnbGUoXCJkZWJ1Zy1tZG93blwiLFxuXHRcdFx0dGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiI3RvZ2dsZS1tZG93biBhXCIpLCBjb250YWluZXIpO1xuXHRcdHRoaXMuaW5pdGlhbGl6ZUNsYXNzVG9nZ2xlKFwiZGVidWctdHhcIixcblx0XHRcdHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIiN0b2dnbGUtdHggYVwiKSwgY29udGFpbmVyLFxuXHRcdFx0ZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJzaG93LXR4XCIsIHZhbHVlKTtcblx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwibm90LXNob3ctdHhcIiwgIXZhbHVlKTtcblx0XHRcdH1cblx0XHQpO1xuXHRcdHRoaXMuaW5pdGlhbGl6ZUNsYXNzVG9nZ2xlKFwiZGVidWctZ3JhcGhcIixcblx0XHRcdHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIiN0b2dnbGUtZ3JhcGggYVwiKSwgY29udGFpbmVyKTtcblx0XHR0aGlzLmluaXRpYWxpemVDbGFzc1RvZ2dsZShcImRlYnVnLWxvZ3NcIixcblx0XHRcdHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIiN0b2dnbGUtbG9ncyBhXCIpLCBjb250YWluZXIpO1xuXHRcdHRoaXMuaW5pdGlhbGl6ZUNsYXNzVG9nZ2xlKFwiZGVidWctZ3JpZC1iZ1wiLFxuXHRcdFx0dGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiI3RvZ2dsZS1ncmlkLWJnIGFcIiksIGRvY3VtZW50LmJvZHkpO1xuXG5cdFx0dGhpcy5pbml0aWFsaXplVmlld3BvcnRJbmZvKCk7XG5cblx0XHQvLyB0aGlzLmluaXRpYWxpemVMYXlvdXRTZWxlY3QoKTtcblxuXHRcdHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJjaGFuZ2VcIiwgdGhpcy5fb25Nb2RlbENoYW5nZSk7XG5cdFx0dGhpcy5fb25Nb2RlbENoYW5nZSgpO1xuXHR9LFxuXG5cdGluaXRpYWxpemVWaWV3cG9ydEluZm86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3cG9ydEluZm9FbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIiN2aWV3cG9ydC1pbmZvIHNwYW5cIik7XG5cdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2aWV3cG9ydEluZm9FbC50ZXh0Q29udGVudCA9IHNpemVUZW1wbGF0ZSh7IHc6IHdpbmRvdy5pbm5lcldpZHRoLCBoOiB3aW5kb3cuaW5uZXJIZWlnaHQgfSk7XG5cdFx0fTtcblx0XHRjYWxsYmFjay5jYWxsKCk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgXy5kZWJvdW5jZShjYWxsYmFjaywgMTAwLCBmYWxzZSwgZmFsc2UpKTtcblx0fSxcblxuXHRpbml0aWFsaXplVG9nZ2xlOiBmdW5jdGlvbihrZXksIHRvZ2dsZUVsLCBjYWxsYmFjaykge1xuXHRcdGlmICghdG9nZ2xlRWwpIHJldHVybjtcblxuXHRcdHZhciBjdHggPSB0aGlzO1xuXHRcdHZhciB0b2dnbGVWYWx1ZSA9IENvb2tpZXMuZ2V0KGtleSkgPT09IFwidHJ1ZVwiO1xuXHRcdGNhbGxiYWNrLmNhbGwoY3R4LCBrZXksIHRvZ2dsZVZhbHVlKTtcblxuXHRcdHRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldikge1xuXHRcdFx0aWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblx0XHRcdGVsc2UgZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRvZ2dsZVZhbHVlID0gIXRvZ2dsZVZhbHVlO1xuXHRcdFx0Q29va2llcy5zZXQoa2V5LCB0b2dnbGVWYWx1ZSA/IFwidHJ1ZVwiIDogXCJcIik7XG5cdFx0XHRjYWxsYmFjay5jYWxsKGN0eCwga2V5LCB0b2dnbGVWYWx1ZSk7XG5cdFx0fSwgZmFsc2UpO1xuXHR9LFxuXG5cdGluaXRpYWxpemVDbGFzc1RvZ2dsZTogZnVuY3Rpb24oa2V5LCB0b2dnbGVFbCwgdGFyZ2V0RWwsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGhhc0NhbGxiYWNrID0gXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKTtcblxuXHRcdHRoaXMuaW5pdGlhbGl6ZVRvZ2dsZShrZXksIHRvZ2dsZUVsLCBmdW5jdGlvbihrZXksIHRvZ2dsZVZhbHVlKSB7XG5cdFx0XHR0YXJnZXRFbC5jbGFzc0xpc3QudG9nZ2xlKGtleSwgdG9nZ2xlVmFsdWUpO1xuXHRcdFx0dG9nZ2xlRWwuY2xhc3NMaXN0LnRvZ2dsZShcInRvZ2dsZS1lbmFibGVkXCIsIHRvZ2dsZVZhbHVlKTtcblx0XHRcdHRvZ2dsZUVsLmNsYXNzTGlzdC50b2dnbGUoXCJjb2xvci1yZXZlcnNlXCIsIHRvZ2dsZVZhbHVlKTtcblx0XHRcdGhhc0NhbGxiYWNrICYmIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X29uTW9kZWxDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6Ol9vbk1vZGVsQ2hhbmdlIGNoYW5nZWRBdHRyaWJ1dGVzOiAlb1wiLCB0aGlzLmNpZCwgdGhpcy5tb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpKTtcblx0XHR2YXIgaSwgaWksIHByb3AsIGVsLCBlbHMgPSB0aGlzLmFwcFN0YXRlRWwuY2hpbGRyZW47XG5cdFx0Zm9yIChpID0gMCwgaWkgPSBlbHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0ZWwgPSBlbHNbaV07XG5cdFx0XHRwcm9wID0gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1wcm9wXCIpO1xuXHRcdFx0ZWwuY2xhc3NMaXN0LnRvZ2dsZShcImhhcy12YWx1ZVwiLCB0aGlzLm1vZGVsLmdldChwcm9wKSk7XG5cdFx0XHRlbC5jbGFzc0xpc3QudG9nZ2xlKFwiaGFzLWNoYW5nZWRcIiwgdGhpcy5tb2RlbC5oYXNDaGFuZ2VkKHByb3ApKTtcblx0XHRcdGVsLmNsYXNzTGlzdC50b2dnbGUoXCJjb2xvci1yZXZlcnNlXCIsIHRoaXMubW9kZWwuaGFzQ2hhbmdlZChwcm9wKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTk9URTogQWx3YXlzIGJ1dCByZXdyaXRlIENNUyBocmVmLlxuXHRcdC8vIE9ubHkgY29sbGFwc2VkIG1heSBoYXZlIGNoYW5nZWQsIGJ1dCBub3Qgd29ydGggYWxsIHRoZSBsb2dpY1xuXHRcdHZhciBhdHRyVmFsID0gR2xvYmFscy5BUFBfUk9PVCArIFwic3ltcGhvbnkvXCI7XG5cdFx0c3dpdGNoICh0aGlzLm1vZGVsLmdldChcInJvdXRlTmFtZVwiKSkge1xuXHRcdFx0Y2FzZSBcImFydGljbGUtaXRlbVwiOlxuXHRcdFx0XHRhdHRyVmFsICs9IFwicHVibGlzaC9hcnRpY2xlcy9lZGl0L1wiICsgdGhpcy5tb2RlbC5nZXQoXCJhcnRpY2xlXCIpLmlkO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJidW5kbGUtaXRlbVwiOlxuXHRcdFx0XHRhdHRyVmFsICs9IFwicHVibGlzaC9idW5kbGVzL2VkaXQvXCIgKyB0aGlzLm1vZGVsLmdldChcImJ1bmRsZVwiKS5pZDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibWVkaWEtaXRlbVwiOlxuXHRcdFx0XHRhdHRyVmFsICs9IFwicHVibGlzaC9tZWRpYS9lZGl0L1wiICsgdGhpcy5tb2RlbC5nZXQoXCJtZWRpYVwiKS5pZDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicm9vdFwiOlxuXHRcdFx0XHRhdHRyVmFsICs9IFwicHVibGlzaC9idW5kbGVzXCI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLmJhY2tlbmRFbC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGF0dHJWYWwpO1xuXG5cdFx0aWYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcInJvdXRlTmFtZVwiKSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJsYXN0LXJvdXRlXCIsIHRoaXMubW9kZWwucHJldmlvdXMoXCJyb3V0ZU5hbWVcIikpO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoXCJjdXJyZW50LXJvdXRlXCIsIHRoaXMubW9kZWwuZ2V0KFwicm91dGVOYW1lXCIpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5tb2RlbC5oYXNDaGFuZ2VkKFwibWVkaWFcIikpIHtcblx0XHRcdGlmICh0aGlzLm1vZGVsLmhhcyhcIm1lZGlhXCIpKSB7XG5cdFx0XHRcdHRoaXMubWVkaWFJbmZvRWwudGV4dENvbnRlbnQgPSBzaXplVGVtcGxhdGUodGhpcy5tb2RlbC5nZXQoXCJtZWRpYVwiKS5nZXQoXCJzb3VyY2VcIikudG9KU09OKCkpO1xuXHRcdFx0XHR0aGlzLm1lZGlhSW5mb0VsLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5tZWRpYUluZm9FbC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHRcdHRoaXMubWVkaWFJbmZvRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjcmVhdGVHcmlkRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRlbC5pZCA9IFwiZ3JpZC13cmFwcGVyXCI7XG5cdFx0ZWwuaW5uZXJIVE1MID0gZ3JpZFRlbXBsYXRlKCk7XG5cdFx0cmV0dXJuIGVsO1xuXHR9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzLnByb3RvdHlwZS5fbG9nRmxhZ3MgPSBcIlwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPHN2ZyBpZD1cXFwiZGVidWctZ3JpZFxcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWF4WU1pZCBzbGljZVxcXCIgdmlld3BvcnQtZmlsbD1cXFwiaHNsKDAsMCUsMTAwJSlcXFwiIHZpZXdwb3J0LWZpbGwtb3BhY2l0eT1cXFwiMVxcXCIgc3R5bGU9XFxcImZpbGw6bm9uZTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MXB4O2ZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtcXFwiPlxcbjxkZWZzPlxcblx0PHBhdHRlcm4gaWQ9XFxcInBhdC1iYXNlbGluZS0xMnB4XFxcIiBjbGFzcz1cXFwiYmFzZWxpbmUgYmFzZTEyXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPlxcblx0XHQ8bGluZSB4MT1cXFwiMFxcXCIgeDI9XFxcIjEwMCVcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMFxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjEuMFxcXCIvPlxcblx0XHQ8bGluZSB4MT1cXFwiMFxcXCIgeDI9XFxcIjEwMCVcXFwiIHkxPVxcXCIzXFxcIiB5Mj1cXFwiM1xcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjAuMTI1XFxcIi8+XFxuXHRcdDxsaW5lIHgxPVxcXCIwXFxcIiB4Mj1cXFwiMTAwJVxcXCIgeTE9XFxcIjZcXFwiIHkyPVxcXCI2XFxcIiBzdHJva2Utb3BhY2l0eT1cXFwiMC4zNzVcXFwiLz5cXG5cdFx0PGxpbmUgeDE9XFxcIjBcXFwiIHgyPVxcXCIxMDAlXFxcIiB5MT1cXFwiOVxcXCIgeTI9XFxcIjlcXFwiIHN0cm9rZS1vcGFjaXR5PVxcXCIwLjEyNVxcXCIvPlxcblx0PC9wYXR0ZXJuPlxcblxcblx0PHBhdHRlcm4gaWQ9XFxcInBhdC1iYXNlbGluZS0yNHB4XFxcIiBjbGFzcz1cXFwiYmFzZWxpbmUgYmFzZTEyXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPlxcblx0XHQ8bGluZSB4MT1cXFwiMFxcXCIgeDI9XFxcIjEwMCVcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMFxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjEuMFxcXCIvPlxcblx0PC9wYXR0ZXJuPlxcblxcblx0PHBhdHRlcm4gaWQ9XFxcInBhdC1iYXNlbGluZS0xMHB4XFxcIiBjbGFzcz1cXFwiYmFzZWxpbmUgYmFzZTEwXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPlxcblx0XHQ8bGluZSB4MT1cXFwiMFxcXCIgeDI9XFxcIjEwMCVcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMFxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjEuMDBcXFwiLz5cXG5cdFx0PGxpbmUgeDE9XFxcIjBcXFwiIHgyPVxcXCIxMDAlXFxcIiB5MT1cXFwiNVxcXCIgeTI9XFxcIjVcXFwiIHN0cm9rZS1vcGFjaXR5PVxcXCIwLjc1XFxcIi8+XFxuXHQ8L3BhdHRlcm4+XFxuXHQ8cGF0dGVybiBpZD1cXFwicGF0LWJhc2VsaW5lLTIwcHhcXFwiIGNsYXNzPVxcXCJiYXNlbGluZSBiYXNlMTBcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgcGF0dGVyblVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCI+XFxuXHRcdDxsaW5lIHgxPVxcXCIwXFxcIiB4Mj1cXFwiMTAwJVxcXCIgeTE9XFxcIjBcXFwiIHkyPVxcXCIwXFxcIiBzdHJva2Utb3BhY2l0eT1cXFwiMS4wXFxcIi8+XFxuXHQ8L3BhdHRlcm4+XFxuXHQ8cGF0dGVybiBpZD1cXFwicGF0LWNvbHMtMjIwcHhcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHdpZHRoPVxcXCIyMjBcXFwiIGhlaWdodD1cXFwiMzZcXFwiIHBhdHRlcm5Vbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPlxcblx0XHQ8cmVjdCB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgwLDApXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgZmlsbD1cXFwiaHNsKDMzNiw1MCUsNDAlKVxcXCIgZmlsbC1vcGFjaXR5PVxcXCIwLjFcXFwiLz5cXG5cdFx0PHJlY3QgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjAwLDApXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCIwXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIgZmlsbD1cXFwiaHNsKDMzNiw1MCUsNDAlKVxcXCIgZmlsbC1vcGFjaXR5PVxcXCIwLjFcXFwiLz5cXG5cdFx0PGxpbmUgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjAgMClcXFwiIHgxPVxcXCIwXFxcIiB4Mj1cXFwiMFxcXCIgeTE9XFxcIjBcXFwiIHkyPVxcXCIxMDAlXFxcIiBzdHJva2U9XFxcImhzbCgzMzYsNTAlLDYwJSlcXFwiIHN0cm9rZS1vcGFjaXR5PVxcXCIwLjJcXFwiLz5cXG5cdFx0PGxpbmUgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjAwIDApXFxcIiB4MT1cXFwiMFxcXCIgeDI9XFxcIjBcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMTAwJVxcXCIgc3Ryb2tlPVxcXCJoc2woMzM2LDUwJSw0MCUpXFxcIiBzdHJva2Utb3BhY2l0eT1cXFwiMC4yXFxcIi8+XFxuXFxuXHRcdDxsaW5lIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDE0MCAwKVxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIwXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjEwMCVcXFwiIHN0cm9rZT1cXFwiaHNsKDMzNiw1MCUsNDAlKVxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjAuM1xcXCIvPlxcblx0XHQ8bGluZSB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSg4MCAwKVxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIwXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjEwMCVcXFwiIHN0cm9rZT1cXFwiaHNsKDMzNiw1MCUsNDAlKVxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcIjAuM1xcXCIvPlxcblxcblx0XHQ8bGluZSB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgwIDApXFxcIiB4MT1cXFwiMFxcXCIgeDI9XFxcIjBcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMTAwJVxcXCIgc3Ryb2tlPVxcXCJoc2woMjM2LDUwJSw0MCUpXFxcIiBzdHJva2Utb3BhY2l0eT1cXFwiMC40XFxcIiBzdHJva2Utd2lkdGg9XFxcIjFcXFwiLz5cXG5cdFx0PGxpbmUgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMjIwIDApXFxcIiB4MT1cXFwiMFxcXCIgeDI9XFxcIjBcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMTAwJVxcXCIgc3Ryb2tlPVxcXCJoc2woMjM2LDUwJSw0MCUpXFxcIiBzdHJva2Utb3BhY2l0eT1cXFwiMC40XFxcIiBzdHJva2Utd2lkdGg9XFxcIjFcXFwiLz5cXG5cdDwvcGF0dGVybj5cXG48L2RlZnM+XFxuPGcgaWQ9XFxcImRlYnVnLWdyaWQtYm9keVxcXCIgdHJhbnNmb3JtPVxcXCJ0cmFuc2xhdGUoMCAwLjUpXFxcIj5cXG5cdDxyZWN0IGlkPVxcXCJiYXNlbGluZVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIvPlxcblx0PGcgaWQ9XFxcImRlYnVnLWdyaWQtY29udGFpbmVyXFxcIj5cXG5cdFx0PGcgaWQ9XFxcImRlYnVnLWdyaWQtY29udGVudFxcXCI+XFxuXHRcdFx0PHJlY3QgaWQ9XFxcImJhc2VsaW5lLWNvbnRlbnRcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjBcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIiBoZWlnaHQ9XFxcIjEwMCVcXFwiLz5cXG5cdFx0XHQ8bGluZSBpZD1cXFwiZ2N0MFxcXCIgY2xhc3M9XFxcImhndWlkZVxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIxMDAlXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjBcXFwiLz5cXG5cdFx0XHQ8bGluZSBpZD1cXFwiZ2N0MVxcXCIgY2xhc3M9XFxcImhndWlkZVxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIxMDAlXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjBcXFwiLz5cXG5cdFx0PC9nPlxcblx0XHQ8bGluZSBpZD1cXFwiZ252MFxcXCIgY2xhc3M9XFxcImhndWlkZVxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIxMDAlXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjBcXFwiLz5cXG5cdFx0PGxpbmUgaWQ9XFxcImdudjFcXFwiIGNsYXNzPVxcXCJoZ3VpZGVcXFwiIHgxPVxcXCIwXFxcIiB4Mj1cXFwiMTAwJVxcXCIgeTE9XFxcIjBcXFwiIHkyPVxcXCIwXFxcIi8+XFxuXHQ8L2c+XFxuXFxuXHQ8ZyBpZD1cXFwiYWJzLWNvbHNcXFwiPlxcblx0XHQ8cmVjdCBpZD1cXFwiY29sdW1uc1xcXCIgeD1cXFwiMFxcXCIgeT1cXFwiMFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGhlaWdodD1cXFwiMTAwJVxcXCIvPlxcblx0PC9nPlxcblxcblx0PGcgaWQ9XFxcInJlbC1jb2xzXFxcIj5cXG5cdFx0PGxpbmUgaWQ9XFxcImxlXFxcIiBjbGFzcz1cXFwidmd1aWRlIGVkZ2VcXFwiIHgxPVxcXCIwXFxcIiB4Mj1cXFwiMFxcXCIgeTE9XFxcIjBcXFwiIHkyPVxcXCIxMDAlXFxcIi8+XFxuXHRcdDxsaW5lIGlkPVxcXCJyZVxcXCIgY2xhc3M9XFxcInZndWlkZSBlZGdlXFxcIiB4MT1cXFwiMTAwJVxcXCIgeDI9XFxcIjEwMCVcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMTAwJVxcXCIvPlxcblxcblx0XHQ8bGluZSBpZD1cXFwiZ2wwXFxcIiBjbGFzcz1cXFwidmd1aWRlIG1hcmdpblxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIwXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjEwMCVcXFwiLz5cXG5cdFx0PGxpbmUgaWQ9XFxcImdsMVxcXCIgY2xhc3M9XFxcInZndWlkZSBndXR0ZXJcXFwiIHgxPVxcXCIwXFxcIiB4Mj1cXFwiMFxcXCIgeTE9XFxcIjBcXFwiIHkyPVxcXCIxMDAlXFxcIi8+XFxuXFxuXHRcdDxsaW5lIGlkPVxcXCJncjBcXFwiIGNsYXNzPVxcXCJ2Z3VpZGUgbWFyZ2luXFxcIiB4MT1cXFwiMFxcXCIgeDI9XFxcIjBcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMTAwJVxcXCIvPlxcblx0XHQ8bGluZSBpZD1cXFwiZ3IxXFxcIiBjbGFzcz1cXFwidmd1aWRlIGd1dHRlclxcXCIgeDE9XFxcIjBcXFwiIHgyPVxcXCIwXFxcIiB5MT1cXFwiMFxcXCIgeTI9XFxcIjEwMCVcXFwiLz5cXG5cXG5cdFx0PGxpbmUgaWQ9XFxcImdtXFxcIiBjbGFzcz1cXFwidmd1aWRlXFxcIiB4MT1cXFwiMFxcXCIgeDI9XFxcIjBcXFwiIHkxPVxcXCIwXFxcIiB5Mj1cXFwiMTAwJVxcXCIvPlxcblx0PC9nPlxcbjwvZz5cXG48L3N2Zz5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xudmFyIHBhcnRpYWwkMCA9IHJlcXVpcmUoJy4uLy4uL3ZpZXcvdGVtcGxhdGUvc3ZnL0NvZ1N5bWJvbC5oYnMnKTtcbkhhbmRsZWJhcnNDb21waWxlci5yZWdpc3RlclBhcnRpYWwoJy4uLy4uL3ZpZXcvdGVtcGxhdGUvc3ZnL0NvZ1N5bWJvbC5oYnMnLCBwYXJ0aWFsJDApO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCJcdDxkZCBpZD1cXFwic2VsZWN0LWxheW91dFxcXCI+XFxuXHRcdDxzZWxlY3Qgc2l6ZT0xPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmxheW91dHMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMiwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXHRcdDwvc2VsZWN0Plxcblx0PC9kZD5cXG5cIjtcbn0sXCIyXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgYWxpYXMxPWNvbnRhaW5lci5sYW1iZGEsIGFsaWFzMj1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCJcdFx0XHQ8b3B0aW9uIHZhbHVlPVxcXCJcIlxuICAgICsgYWxpYXMyKGFsaWFzMShkZXB0aDAsIGRlcHRoMCkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArIGFsaWFzMihhbGlhczEoZGVwdGgwLCBkZXB0aDApKVxuICAgICsgXCI8L29wdGlvbj5cXG5cIjtcbn0sXCI0XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pO1xuXG4gIHJldHVybiBcIlx0XHQ8bGkgY2xhc3M9XFxcIlwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSxkZXB0aDAse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCksXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiXFxcIj5cIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5rZXkgfHwgKGRhdGEgJiYgZGF0YS5rZXkpKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImtleVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2xpPlxcblwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcInBhc3NlZFwiO1xufSxcIjdcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcImZhaWxlZFwiO1xufSxcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRsIGNsYXNzPVxcXCJkZWJ1Zy1saW5rcyBjb2xvci1iZ1xcXCI+XFxuXHQ8ZHQgaWQ9XFxcImxpbmtzLXRvZ2dsZVxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gY29udGFpbmVyLmludm9rZVBhcnRpYWwocGFydGlhbHNbXCIuLi8uLi92aWV3L3RlbXBsYXRlL3N2Zy9Db2dTeW1ib2wuaGJzXCJdLGRlcHRoMCx7XCJuYW1lXCI6XCIuLi8uLi92aWV3L3RlbXBsYXRlL3N2Zy9Db2dTeW1ib2wuaGJzXCIsXCJkYXRhXCI6ZGF0YSxcImluZGVudFwiOlwiXFx0XFx0XCIsXCJoZWxwZXJzXCI6aGVscGVycyxcInBhcnRpYWxzXCI6cGFydGlhbHMsXCJkZWNvcmF0b3JzXCI6Y29udGFpbmVyLmRlY29yYXRvcnN9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlx0PC9kdD5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzW1wiaWZcIl0uY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmxheW91dHMgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlx0PGRkIGlkPVxcXCJlZGl0LWJhY2tlbmRcXFwiPlxcblx0XHQ8YSBocmVmPVxcXCJcIlxuICAgICsgYWxpYXMyKChoZWxwZXJzLmdsb2JhbCB8fCAoZGVwdGgwICYmIGRlcHRoMC5nbG9iYWwpIHx8IGhlbHBlcnMuaGVscGVyTWlzc2luZykuY2FsbChhbGlhczEsXCJBUFBfUk9PVFwiLHtcIm5hbWVcIjpcImdsb2JhbFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSlcbiAgICArIFwic3ltcGhvbnkvXFxcIiBjbGFzcz1cXFwiY29sb3ItZmcgY29sb3ItYmdcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5DTVM8L2E+XFxuXHQ8L2RkPlxcblx0PGRkIGlkPVxcXCJ0b2dnbGUtdGVzdHNcXFwiPlxcblx0XHQ8YSBocmVmPVxcXCIjdG9nZ2xlLXRlc3RzXFxcIiBjbGFzcz1cXFwiY29sb3ItZmcgY29sb3ItYmdcXFwiPlRlc3RzPC9hPlxcblx0PC9kZD5cXG5cdDxkZCBpZD1cXFwidG9nZ2xlLXN0YXRlXFxcIj5cXG5cdFx0PGEgaHJlZj1cXFwiI3RvZ2dsZS1zdGF0ZVxcXCIgY2xhc3M9XFxcImNvbG9yLWZnIGNvbG9yLWJnXFxcIj5Sb3V0ZTwvYT5cXG5cdDwvZGQ+XFxuXHQ8ZGQgaWQ9XFxcInRvZ2dsZS1ibG9ja3MtbmF2XFxcIj5cXG5cdFx0PGEgaHJlZj1cXFwiI3RvZ2dsZS1ibG9ja3MtbmF2XFxcIiBjbGFzcz1cXFwiY29sb3ItZmcgY29sb3ItYmdcXFwiPk5hdjwvYT5cXG5cdDwvZGQ+XFxuXHQ8ZGQgaWQ9XFxcInRvZ2dsZS1ibG9ja3MtY29udGVudFxcXCI+XFxuXHRcdDxhIGhyZWY9XFxcIiN0b2dnbGUtYmxvY2tzLWNvbnRlbnRcXFwiIGNsYXNzPVxcXCJjb2xvci1mZyBjb2xvci1iZ1xcXCI+Q29udGVudDwvYT5cXG5cdDwvZGQ+XFxuXHQ8ZGQgaWQ9XFxcInRvZ2dsZS1tZG93blxcXCI+XFxuXHRcdDxhIGhyZWY9XFxcIiN0b2dnbGUtbWRvd25cXFwiIGNsYXNzPVxcXCJjb2xvci1mZyBjb2xvci1iZ1xcXCI+TWFya2Rvd248L2E+XFxuXHQ8L2RkPlxcblx0PGRkIGlkPVxcXCJ0b2dnbGUtdHhcXFwiPlxcblx0XHQ8YSBocmVmPVxcXCIjdG9nZ2xlLXR4XFxcIiBjbGFzcz1cXFwiY29sb3ItZmcgY29sb3ItYmdcXFwiPlRYL0ZYPC9hPlxcblx0PC9kZD5cXG5cdDxkZCBpZD1cXFwidG9nZ2xlLWdyaWQtYmdcXFwiPlxcblx0XHQ8YSBocmVmPVxcXCIjdG9nZ2xlLWdyaWQtYmdcXFwiIGNsYXNzPVxcXCJjb2xvci1mZyBjb2xvci1iZ1xcXCI+R3JpZDwvYT5cXG5cdDwvZGQ+XFxuXHQ8ZGQgaWQ9XFxcInRvZ2dsZS1ncmFwaFxcXCI+XFxuXHRcdDxhIGhyZWY9XFxcIiN0b2dnbGUtZ3JhcGhcXFwiIGNsYXNzPVxcXCJjb2xvci1mZyBjb2xvci1iZ1xcXCI+R3JhcGg8L2E+XFxuXHQ8L2RkPlxcblx0PGRkIGlkPVxcXCJ0b2dnbGUtbG9nc1xcXCI+XFxuXHRcdDxhIGhyZWY9XFxcIiN0b2dnbGUtbG9nc1xcXCIgY2xhc3M9XFxcImNvbG9yLWZnIGNvbG9yLWJnXFxcIj5Mb2dzPC9hPlxcblx0PC9kZD5cXG5cdDxkZCBpZD1cXFwibWVkaWEtaW5mb1xcXCI+XFxuXHRcdDxzcGFuPjwvc3Bhbj5cXG5cdDwvZGQ+XFxuXHQ8ZGQgaWQ9XFxcInZpZXdwb3J0LWluZm9cXFwiPlxcblx0XHQ8c3Bhbj48L3NwYW4+XFxuXHQ8L2RkPlxcblx0PGRkIGlkPVxcXCJhcHAtc3RhdGVcXFwiPlxcblx0XHQ8c3BhbiBjbGFzcz1cXFwiY29sb3ItZmcgY29sb3ItYmdcXFwiIGRhdGEtcHJvcD1cXFwiY29sbGFwc2VkXFxcIj5jPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJjb2xvci1mZyBjb2xvci1iZ1xcXCIgZGF0YS1wcm9wPVxcXCJ3aXRoQnVuZGxlXFxcIj5iPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJjb2xvci1mZyBjb2xvci1iZ1xcXCIgZGF0YS1wcm9wPVxcXCJ3aXRoTWVkaWFcXFwiPm08L3NwYW4+PHNwYW4gY2xhc3M9XFxcImNvbG9yLWZnIGNvbG9yLWJnXFxcIiBkYXRhLXByb3A9XFxcIndpdGhBcnRpY2xlXFxcIj5hPC9zcGFuPlxcblx0PC9kZD5cXG48L2RsPlxcbjxkaXYgaWQ9XFxcInRlc3QtcmVzdWx0c1xcXCI+XFxuXHQ8aDY+VGVzdHMgPGEgaWQ9XFxcInRvZ2dsZS1wYXNzZWRcXFwiIGhyZWY9XFxcIiN0b2dnbGUtcGFzc2VkXFxcIj5QYXNzZWQ8L2E+PC9oNj5cXG5cdDxwPlwiXG4gICAgKyBhbGlhczIoY29udGFpbmVyLmxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYXZpZ2F0b3IgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnVzZXJBZ2VudCA6IHN0YWNrMSksIGRlcHRoMCkpXG4gICAgKyBcIjwvcD5cXG5cdDx1bD5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRlc3RzIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDQsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGF9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlx0PC91bD5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VQYXJ0aWFsXCI6dHJ1ZSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvQmFzZUl0ZW1cbiAqIEByZXF1aXJlcyBtb2R1bGU6YmFja2JvbmVcbiAqLy8qKiBAdHlwZSB7bW9kdWxlOmJhY2tib25lfSAqL1xuY29uc3QgQmFzZU1vZGVsID0gcmVxdWlyZShcImJhY2tib25lXCIpLk1vZGVsO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL0Jhc2VNb2RlbH0gKi9cbi8vIHZhciBCYXNlTW9kZWwgPSByZXF1aXJlKFwiYXBwL21vZGVsL0Jhc2VNb2RlbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlTW9kZWwuZXh0ZW5kKHtcblxuXHRkZWZhdWx0czoge1xuXHRcdGNvbGxhcHNlZDogZmFsc2UsXG5cdFx0cm91dGVOYW1lOiBcImluaXRpYWxcIixcblx0XHRhcnRpY2xlOiBudWxsLFxuXHRcdGJ1bmRsZTogbnVsbCxcblx0XHRtZWRpYTogbnVsbCxcblx0XHRmcm9tUm91dGVOYW1lOiBcIlwiLFxuXHRcdHdpdGhBcnRpY2xlOiBmYWxzZSxcblx0XHR3aXRoQnVuZGxlOiBmYWxzZSxcblx0XHR3aXRoTWVkaWE6IGZhbHNlLFxuXHR9LFxuXG5cdGdldHRlcnM6IFtcblx0XHRcImNvbGxhcHNlZFwiLFxuXHRcdFwicm91dGVOYW1lXCIsXG5cdFx0XCJhcnRpY2xlXCIsXG5cdFx0XCJidW5kbGVcIixcblx0XHRcIm1lZGlhXCIsXG5cdFx0XCJmcm9tUm91dGVOYW1lXCIsXG5cdFx0XCJ3aXRoQXJ0aWNsZVwiLFxuXHRcdFwid2l0aEJ1bmRsZVwiLFxuXHRcdFwid2l0aE1lZGlhXCJcblx0XSxcblxuXHQvLyBtdXRhdG9yczoge1xuXHQvLyBcdHJvdXRlTmFtZToge1xuXHQvLyBcdFx0c2V0OiBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRzLCBzZXQpIHtcblx0Ly8gXHRcdFx0Ly8gU2V0IGZyb21Sb3V0ZSB0byBhdm9pZCBsb3NpbmcgY3VycmVudCBcImNoYW5naW5nXCIgc3RhdGVcblx0Ly8gXHRcdFx0dGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW1wiZnJvbVJvdXRlTmFtZVwiXSA9IHRoaXMuYXR0cmlidXRlc1tcImZyb21Sb3V0ZU5hbWVcIl07XG5cdC8vIFx0XHRcdHRoaXMuY2hhbmdlZFtcImZyb21Sb3V0ZU5hbWVcIl0gPSB0aGlzLmF0dHJpYnV0ZXNbXCJmcm9tUm91dGVOYW1lXCJdID0gdGhpcy5wcmV2aW91cyhcInJvdXRlTmFtZVwiKTtcblx0Ly8gXHRcdFx0Ly8gc2V0KFwiZnJvbVJvdXRlTmFtZVwiLCB0aGlzLnByZXZpb3VzKFwicm91dGVOYW1lXCIpLCB7XG5cdC8vIFx0XHRcdC8vIFx0c2lsZW50OiB0cnVlXG5cdC8vIFx0XHRcdC8vIH0pO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gfSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0aGlzLmxpc3RlblRvKHRoaXMsIHtcblx0XHQvLyBcdFwiY2hhbmdlOnJvdXRlTmFtZVwiOiBmdW5jdGlvbigpIHtcblx0XHQvLyBcdFx0dGhpcy5zZXQoXCJmcm9tUm91dGVOYW1lXCIsIHRoaXMucHJldmlvdXMoXCJyb3V0ZU5hbWVcIikpO1xuXHRcdC8vIFx0fSxcblx0XHQvLyBcdFwiY2hhbmdlOmFydGljbGVcIjogZnVuY3Rpb24odmFsKSB7XG5cdFx0Ly8gXHRcdGNvbnNvbGUubG9nKFwiJXM6W2NoYW5nZV0gJW9cIiwgdGhpcy5jaWQsIGFyZ3VtZW50cyk7XG5cdFx0Ly8gXHRcdHRoaXMuc2V0KFwid2l0aEFydGljbGVcIiwgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIFx0XCJjaGFuZ2U6YnVuZGxlXCI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdC8vIFx0XHRjb25zb2xlLmxvZyhcIiVzOltjaGFuZ2VdICVvXCIsIHRoaXMuY2lkLCBhcmd1bWVudHMpO1xuXHRcdC8vIFx0XHR0aGlzLnNldChcIndpdGhCdW5kbGVcIiwgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIFx0XCJjaGFuZ2U6bWVkaWFcIjogZnVuY3Rpb24odmFsKSB7XG5cdFx0Ly8gXHRcdGNvbnNvbGUubG9nKFwiJXM6W2NoYW5nZV0gJW9cIiwgdGhpcy5jaWQsIGFyZ3VtZW50cyk7XG5cdFx0Ly8gXHRcdHRoaXMuc2V0KFwid2l0aE1lZGlhXCIsICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JykpO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9KTtcblxuXHRcdC8vIHRoaXMuc2V0KHtcblx0XHQvLyBcdGZyb21Sb3V0ZU5hbWU6IFwiXCIsXG5cdFx0Ly8gXHRcdHdpdGhBcnRpY2xlOiBmYWxzZSxcblx0XHQvLyBcdFx0d2l0aEJ1bmRsZTogZmFsc2UsXG5cdFx0Ly8gXHRcdHdpdGhNZWRpYTogZmFsc2Vcblx0XHQvLyB9KTtcblx0XHR2YXIgb3B0cyA9IHsgc2lsZW50OiBmYWxzZSB9O1xuXG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcImNoYW5nZVwiLCBmdW5jdGlvbihhdHRycykge1xuXHRcdFx0Ly8gdmFyIG9wdHMgPSB7IHNpbGVudDogZmFsc2UgfTtcblx0XHRcdGlmICh0aGlzLmhhc0NoYW5nZWQoXCJyb3V0ZU5hbWVcIikpIHtcblx0XHRcdFx0dGhpcy5zZXQoXCJmcm9tUm91dGVOYW1lXCIsIHRoaXMucHJldmlvdXMoXCJyb3V0ZU5hbWVcIiksIG9wdHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuaGFzQ2hhbmdlZChcImFydGljbGVcIikpIHtcblx0XHRcdFx0dGhpcy5zZXQoXCJ3aXRoQXJ0aWNsZVwiLCB0aGlzLmhhcyhcImFydGljbGVcIiksIG9wdHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuaGFzQ2hhbmdlZChcImJ1bmRsZVwiKSkge1xuXHRcdFx0XHR0aGlzLnNldChcIndpdGhCdW5kbGVcIiwgdGhpcy5oYXMoXCJidW5kbGVcIiksIG9wdHMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuaGFzQ2hhbmdlZChcIm1lZGlhXCIpKSB7XG5cdFx0XHRcdHRoaXMuc2V0KFwid2l0aE1lZGlhXCIsIHRoaXMuaGFzKFwibWVkaWFcIiksIG9wdHMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcImNoYW5nZTpyb3V0ZU5hbWVcIixcblx0XHRcdGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIiVzOltjaGFuZ2U6cm91dGVOYW1lXSAlb1wiLCB0aGlzLmNpZCwgdmFsKTtcblx0XHRcdFx0Ly8gdGhpcy5zZXQoXCJmcm9tUm91dGVOYW1lXCIsIHRoaXMucHJldmlvdXMoXCJyb3V0ZU5hbWVcIikpO1xuXHRcdFx0fSk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcImNoYW5nZTphcnRpY2xlXCIsXG5cdFx0XHRmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCIlczpbY2hhbmdlOmFydGljbGVdICVvXCIsIHRoaXMuY2lkLCB2YWwpO1xuXHRcdFx0XHQvLyB0aGlzLnNldChcIndpdGhBcnRpY2xlXCIsIF8uaXNPYmplY3QodmFsKSk7XG5cdFx0XHR9KTtcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMsIFwiY2hhbmdlOmJ1bmRsZVwiLFxuXHRcdFx0ZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6W2NoYW5nZTpidW5kbGVdICVvXCIsIHRoaXMuY2lkLCB2YWwpO1xuXHRcdFx0XHQvLyB0aGlzLnNldChcIndpdGhCdW5kbGVcIiwgXy5pc09iamVjdCh2YWwpKTtcblx0XHRcdH0pO1xuXHRcdHRoaXMubGlzdGVuVG8odGhpcywgXCJjaGFuZ2U6bWVkaWFcIixcblx0XHRcdGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIiVzOltjaGFuZ2U6bWVkaWFdICVvXCIsIHRoaXMuY2lkLCB2YWwpO1xuXHRcdFx0XHQvLyB0aGlzLnNldChcIndpdGhNZWRpYVwiLCBfLmlzT2JqZWN0KHZhbCkpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0aGFzQW55UHJldmlvdXM6IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2aW91cyhhdHRyKSAhPSBudWxsO1xuXHR9LFxuXG5cdGhhc0FueUNoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRyZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKGF0dHIpICYmICh0aGlzLmhhcyhhdHRyKSAhPSB0aGlzLmhhc0FueVByZXZpb3VzKGF0dHIpKTtcblx0fVxuXG5cdC8vIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0Ly8gXHRPYmplY3Qua2V5cyh0aGlzLmRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uKGdldHRlck5hbWUpIHtcblx0Ly8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBnZXR0ZXJOYW1lLCB7XG5cdC8vIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdC8vIFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdC8vIFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0KGdldHRlck5hbWUpO1xuXHQvLyBcdFx0XHR9XG5cdC8vIFx0XHR9KTtcblx0Ly8gXHR9KTtcblx0Ly8gXHRCYXNlTW9kZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0Ly8gfVxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvQmFzZUl0ZW1cbiAqIEByZXF1aXJlcyBtb2R1bGU6YmFja2JvbmVcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvQmFzZU1vZGVsfSAqL1xuY29uc3QgQmFzZU1vZGVsID0gcmVxdWlyZShcImFwcC9tb2RlbC9CYXNlTW9kZWxcIik7XG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0dsb2JhbHN9ICovXG4vLyB2YXIgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL3V0aWxzL3N0cmluZ3Mvc3RyaXBUYWdzfSAqL1xuLy8gdmFyIHN0cmlwVGFncyA9IHJlcXVpcmUoXCJ1dGlscy9zdHJpbmdzL3N0cmlwVGFnc1wiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9wYXJzZVN5bUF0dHJzfSAqL1xuLy92YXIgcGFyc2VTeW1BdHRycyA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvcGFyc2VTeW1BdHRyc1wiKTtcblxudmFyIHBhcnNlU3ltQXR0cnMgPSBmdW5jdGlvbihzKSB7XG5cdHJldHVybiBzLnJlcGxhY2UoLyhcXCx8XFw7KS9nLCBmdW5jdGlvbihtKSB7XG5cdFx0cmV0dXJuIChtID09IFwiLFwiKSA/IFwiO1wiIDogXCIsXCI7XG5cdH0pO1xufTtcbnZhciB0b0F0dHJzSGFzaCA9IGZ1bmN0aW9uKG9iaiwgYXR0cikge1xuXHRpZiAoXy5pc1N0cmluZyhhdHRyKSkge1xuXHRcdHZhciBpZHggPSBhdHRyLmluZGV4T2YoXCI6XCIpO1xuXHRcdGlmIChpZHggPiAwKSB7XG5cdFx0XHRvYmpbYXR0ci5zdWJzdHJpbmcoMCwgaWR4KV0gPSBwYXJzZVN5bUF0dHJzKGF0dHIuc3Vic3RyaW5nKGlkeCArIDEpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2JqW2F0dHJdID0gYXR0cjsgLy8gdG8gbWF0Y2ggSFRNTDU8PlhIVE1MIHZhbHVlbGVzcyBhdHRyaWJ1dGVzXG5cdFx0fVxuXHR9IC8vIGVsc2UgaWdub3JlIG5vbi1zdHJpbmcgdmFsdWVzXG5cdHJldHVybiBvYmo7XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL0Jhc2VJdGVtfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VNb2RlbC5leHRlbmQoe1xuXG5cdF9kb21QcmVmaXg6IFwiX1wiLFxuXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdC8vIGF0dHJzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9LFxuXHRcdGdldCBhdHRycygpIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9LFxuXHR9LFxuXG5cdGdldHRlcnM6IFtcImRvbWlkXCJdLFxuXG5cdG11dGF0b3JzOiB7XG5cdFx0ZG9taWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLmhhc093blByb3BlcnR5KFwiX2RvbUlkXCIpKVxuXHRcdFx0XHR0aGlzLl9kb21JZCA9IHRoaXMuX2RvbVByZWZpeCArIHRoaXMuaWQ7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZG9tSWQ7XG5cdFx0fSxcblx0XHRhdHRyczoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRpb25zLCBzZXQpIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZWR1Y2UodG9BdHRyc0hhc2gsIHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV8uaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIiVzOjphdHRycyB2YWx1ZSBub3QgYW4gb2JqZWN0IG9yIHN0cmluZyBhcnJheVwiLCB0aGlzLmNpZCwgdmFsdWUpO1xuXHRcdFx0XHRcdHZhbHVlID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH0sXG5cblx0YXR0cjogZnVuY3Rpb24oYXR0cikge1xuXHRcdHJldHVybiB0aGlzLmF0dHJzKClbYXR0cl07XG5cdH0sXG5cblx0YXR0cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldChcImF0dHJzXCIpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXQoXCJkb21pZFwiKTtcblx0fSxcblxuXHRnZXREaXN0YW5jZVRvU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmNvbGxlY3Rpb24gJiYgdGhpcy5jb2xsZWN0aW9uLnNlbGVjdGVkSW5kZXggPiAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmluZGV4T2YodGhpcykgLSB0aGlzLmNvbGxlY3Rpb24uc2VsZWN0ZWRJbmRleDtcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5jb2xsZWN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2xsZWN0aW9uLmluZGV4T2YodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fVxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvQmFzZU1vZGVsXG4gKiBAcmVxdWlyZXMgbW9kdWxlOmJhY2tib25lXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG5jb25zdCBCYWNrYm9uZSA9IHJlcXVpcmUoXCJiYWNrYm9uZVwiKTtcblxudmFyIEJhc2VNb2RlbFByb3RvID0ge1xuXHQvLyBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG5cdC8vIFx0aWYgKHRoaXMucHJvcGVydGllcykge1xuXHQvLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgdGhpcy5wcm9wZXJ0aWVzKTtcblx0Ly8gXHR9XG5cdC8vIFx0QmFja2JvbmUuTW9kZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0Ly8gfVxufTtcblxudmFyIEJhc2VNb2RlbCA9IHtcblx0ZXh0ZW5kOiBmdW5jdGlvbihwcm90bywgb2JqKSB7XG5cdFx0dmFyIGNvbnN0ciwgcHJvcE5hbWU7IC8vLCBwcm9wRGVmO1xuXHRcdGZvciAocHJvcE5hbWUgaW4gcHJvdG8pIHtcblx0XHRcdGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgXy5pc09iamVjdChwcm90b1twcm9wTmFtZV0pKSB7IC8vKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b1twcm9wTmFtZV0pID09PSBPYmplY3QucHJvdG90eXBlKSkge1xuXHRcdFx0XHRwcm90b1twcm9wTmFtZV0gPSBfLmRlZmF1bHRzKHByb3RvW3Byb3BOYW1lXSwgdGhpcy5wcm90b3R5cGVbcHJvcE5hbWVdKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJCYXNlTW9kZWw6OmV4dGVuZCAnJXM6JXMnIGlzIE9iamVjdFxcbiVzXCIsIHByb3RvLl9kb21QcmVmaXgsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShwcm90b1twcm9wTmFtZV0pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiAoXy5pc09iamVjdChwcm90by5wcm9wZXJ0aWVzKSkge1xuXHRcdC8vIFx0aWYgKEFycmF5LmlzQXJyYXkocHJvdG8uZ2V0dGVycykpIHtcblx0XHQvLyBcdFx0cHJvdG8ucHJvcGVydGllcyA9IF8ub21pdChwcm90by5wcm9wZXJ0aWVzLCBwcm90by5nZXR0ZXJzKTtcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cdFx0Ly8gaWYgKHByb3RvLnByb3BlcnRpZXMgJiYgdGhpcy5wcm90b3R5cGUucHJvcGVydGllcykge1xuXHRcdC8vIFx0Xy5kZWZhdWx0cyhwcm90by5wcm9wZXJ0aWVzLCB0aGlzLnByb3RvdHlwZS5wcm9wZXJ0aWVzKTtcblx0XHQvLyB9XG5cblx0XHRjb25zdHIgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KGNvbnN0ci5wcm90b3R5cGUuZ2V0dGVycykpIHtcblx0XHRcdGNvbnN0ci5wcm90b3R5cGUuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uKGdldHRlck5hbWUpIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0ci5wcm90b3R5cGUsIGdldHRlck5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXQoZ2V0dGVyTmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyBpZiAoQXJyYXkuaXNBcnJheShjb25zdHIucHJvdG90eXBlLnByb3BlcnRpZXMpKSB7XG5cdFx0Ly8gfVxuXG5cdFx0Ly8gaWYgKF8uaXNPYmplY3QocHJvdG8ucHJvcGVydGllcykpIHtcblx0XHQvLyBcdGZvciAocHJvcE5hbWUgaW4gcHJvdG8ucHJvcGVydGllcykge1xuXHRcdC8vIFx0XHRpZiAocHJvdG8ucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcblx0XHQvLyBcdFx0XHRwcm9wRGVmID0gcHJvdG8ucHJvcGVydGllc1twcm9wTmFtZV07XG5cdFx0Ly8gXHRcdFx0aWYgKF8uaXNGdW5jdGlvbihwcm9wRGVmKSkge1xuXHRcdC8vIFx0XHRcdFx0cHJvdG8ucHJvcGVydGllc1twcm9wTmFtZV0gPSB7XG5cdFx0Ly8gXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsIGdldDogcHJvcERlZlxuXHRcdC8vIFx0XHRcdFx0fTtcblx0XHQvLyBcdFx0XHR9IGVsc2UgaWYgKF8uaXNPYmplY3QocHJvcERlZikpe1xuXHRcdC8vIFx0XHRcdFx0cHJvcERlZi5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0XHQvLyBcdFx0XHR9IGVsc2Uge1xuXHRcdC8vIFx0XHRcdFx0ZGVsZXRlIHByb3RvLnByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXHRcdC8vIFx0XHRcdH1cblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0fVxuXHRcdC8vIFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG8sIHByb3RvLnByb3BlcnRpZXMpO1xuXHRcdC8vIFx0ZGVsZXRlIHByb3RvLnByb3BlcnRpZXM7XG5cdFx0Ly8gfVxuXHRcdHJldHVybiBjb25zdHI7XG5cdH1cbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9CYXNlTW9kZWx9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kLmNhbGwoQmFja2JvbmUuTW9kZWwsIEJhc2VNb2RlbFByb3RvLCBCYXNlTW9kZWwpO1xuLy8gbW9kdWxlLmV4cG9ydHMgPSBNb2RlbC5leHRlbmQoQmFzZU1vZGVsUHJvdG8sIEJhc2VNb2RlbCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb25cbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTpiYWNrYm9uZX0gKi9cbmNvbnN0IEJhY2tib25lID0gcmVxdWlyZShcImJhY2tib25lXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb259XG4gKi9cbnZhciBTZWxlY3RhYmxlQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgb3B0aW9ucywge1xuXHRcdFx0aW5pdGlhbFNlbGVjdGlvbjogXCJub25lXCIsXG5cdFx0XHRzaWxlbnRJbml0aWFsOiB0cnVlXG5cdFx0fSk7XG5cdFx0dGhpcy5pbml0aWFsU2VsZWN0aW9uID0gb3B0aW9ucy5pbml0aWFsU2VsZWN0aW9uO1xuXHRcdHRoaXMuaW5pdGlhbE9wdGlvbnMgPSB7XG5cdFx0XHRzaWxlbnQ6IG9wdGlvbnMuc2lsZW50SW5pdGlhbFxuXHRcdH07XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuXHRcdHRoaXMuZGVzZWxlY3QodGhpcy5pbml0aWFsT3B0aW9ucyk7XG5cdFx0QmFja2JvbmUuQ29sbGVjdGlvbi5wcm90b3R5cGUucmVzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5pbml0aWFsU2VsZWN0aW9uID09PSBcImZpcnN0XCIgJiYgdGhpcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuc2VsZWN0KHRoaXMuYXQoMCksIHRoaXMuaW5pdGlhbE9wdGlvbnMpO1xuXHRcdH1cblx0fSxcblxuXHRzZWxlY3Q6IGZ1bmN0aW9uKG5ld01vZGVsLCBvcHRpb25zKSB7XG5cdFx0aWYgKG5ld01vZGVsID09PSB2b2lkIDApIHtcblx0XHRcdG5ld01vZGVsID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2VsZWN0ZWQgPT09IG5ld01vZGVsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB0cmlnZ2VyRXZlbnRzID0gIShvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50KTtcblx0XHR2YXIgb2xkTW9kZWwgPSB0aGlzLnNlbGVjdGVkO1xuXG5cdFx0dGhpcy5sYXN0U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuXHRcdHRoaXMubGFzdFNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXg7XG5cdFx0dGhpcy5zZWxlY3RlZCA9IG5ld01vZGVsO1xuXHRcdHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuaW5kZXhPZihuZXdNb2RlbCk7XG5cblx0XHRpZiAob2xkTW9kZWwpIHtcblx0XHRcdGlmIChfLmlzRnVuY3Rpb24ob2xkTW9kZWwuZGVzZWxlY3QpKSB7XG5cdFx0XHRcdG9sZE1vZGVsLmRlc2VsZWN0KG9wdGlvbnMpO1xuXHRcdFx0fSBlbHNlIGlmICh0cmlnZ2VyRXZlbnRzKSB7XG5cdFx0XHRcdG9sZE1vZGVsLnNlbGVjdGVkID0gdm9pZCAwO1xuXHRcdFx0XHRvbGRNb2RlbC50cmlnZ2VyKFwiZGVzZWxlY3RlZFwiLCBuZXdNb2RlbCwgb2xkTW9kZWwpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRyaWdnZXJFdmVudHMpIHRoaXMudHJpZ2dlcihcImRlc2VsZWN0Om9uZVwiLCBvbGRNb2RlbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0cmlnZ2VyRXZlbnRzKSB0aGlzLnRyaWdnZXIoXCJkZXNlbGVjdDpub25lXCIsIG51bGwpO1xuXHRcdH1cblxuXHRcdGlmIChuZXdNb2RlbCkge1xuXHRcdFx0aWYgKF8uaXNGdW5jdGlvbihuZXdNb2RlbC5zZWxlY3QpKSB7XG5cdFx0XHRcdG5ld01vZGVsLnNlbGVjdChvcHRpb25zKTtcblx0XHRcdH0gZWxzZSBpZiAodHJpZ2dlckV2ZW50cykge1xuXHRcdFx0XHRuZXdNb2RlbC5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdG5ld01vZGVsLnRyaWdnZXIoXCJzZWxlY3RlZFwiLCBuZXdNb2RlbCwgb2xkTW9kZWwpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRyaWdnZXJFdmVudHMpIHRoaXMudHJpZ2dlcihcInNlbGVjdDpvbmVcIiwgbmV3TW9kZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHJpZ2dlckV2ZW50cykgdGhpcy50cmlnZ2VyKFwic2VsZWN0Om5vbmVcIiwgbnVsbCk7XG5cdFx0fVxuXHR9LFxuXG5cdGRlc2VsZWN0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5zZWxlY3QobnVsbCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0c2VsZWN0QXQ6IGZ1bmN0aW9uKGluZGV4LCBvcHRpb25zKSB7XG5cdFx0aWYgKDAgPiBpbmRleCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuXHRcdFx0bmV3IFJhbmdlRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgYm91bmRzXCIpO1xuXHRcdH1cblx0XHR0aGlzLnNlbGVjdCh0aGlzLmF0KGluZGV4KSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHR2YXIgYUlkeCwgYklkeDtcblxuXHRcdGlmICghYSkgcmV0dXJuIE5hTjtcblx0XHRhSWR4ID0gdGhpcy5pbmRleE9mKGEpO1xuXHRcdGlmIChhSWR4ID09IC0xKSByZXR1cm4gTmFOO1xuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHRcdFx0YklkeCA9IHRoaXMuc2VsZWN0ZWRJbmRleDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFiKSByZXR1cm4gTmFOO1xuXHRcdFx0YklkeCA9IHRoaXMuaW5kZXhPZihiKTtcblx0XHRcdGlmIChiSWR4ID09IC0xKSByZXR1cm4gTmFOO1xuXHRcdH1cblx0XHRyZXR1cm4gTWF0aC5hYnMoYklkeCAtIGFJZHgpO1xuXHR9LFxuXG5cdC8qIFRPRE86IE1PVkUgSU5UTyBNSVhJTiAqL1xuXG5cdC8qKiBAcmV0dXJuIGJvb2xlYW5cdC8qL1xuXHRoYXNGb2xsb3dpbmc6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdFx0bW9kZWwgfHwgKG1vZGVsID0gdGhpcy5zZWxlY3RlZCk7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZXhPZihtb2RlbCkgPCAodGhpcy5sZW5ndGggLSAxKTtcblx0fSxcblxuXHQvKiogQHJldHVybiBuZXh0IG1vZGVsXHQqL1xuXHRmb2xsb3dpbmc6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdFx0bW9kZWwgfHwgKG1vZGVsID0gdGhpcy5zZWxlY3RlZCk7XG5cdFx0cmV0dXJuIHRoaXMuaGFzRm9sbG93aW5nKG1vZGVsKSA/IHRoaXMuYXQodGhpcy5pbmRleE9mKG1vZGVsKSArIDEpIDogbnVsbDtcblx0fSxcblxuXHQvKiogQHJldHVybiBuZXh0IG1vZGVsIG9yIHRoZSBiZWdpbm5pbmcgaWYgYXQgdGhlIGVuZCAqL1xuXHRmb2xsb3dpbmdPckZpcnN0OiBmdW5jdGlvbihtb2RlbCkge1xuXHRcdG1vZGVsIHx8IChtb2RlbCA9IHRoaXMuc2VsZWN0ZWQpO1xuXHRcdHJldHVybiB0aGlzLmF0KCh0aGlzLmluZGV4T2YobW9kZWwpICsgMSkgJSB0aGlzLmxlbmd0aCk7XG5cdH0sXG5cblx0LyoqIEByZXR1cm4gYm9vbGVhblx0LyovXG5cdGhhc1ByZWNlZGluZzogZnVuY3Rpb24obW9kZWwpIHtcblx0XHRtb2RlbCB8fCAobW9kZWwgPSB0aGlzLnNlbGVjdGVkKTtcblx0XHRyZXR1cm4gdGhpcy5pbmRleE9mKG1vZGVsKSA+IDA7XG5cdH0sXG5cblx0LyoqIEByZXR1cm4gdGhlIHByZXZpb3VzIG1vZGVsICovXG5cdHByZWNlZGluZzogZnVuY3Rpb24obW9kZWwpIHtcblx0XHRtb2RlbCB8fCAobW9kZWwgPSB0aGlzLnNlbGVjdGVkKTtcblx0XHRyZXR1cm4gdGhpcy5oYXNQcmVjZWRpbmcobW9kZWwpID8gdGhpcy5hdCh0aGlzLmluZGV4T2YobW9kZWwpIC0gMSkgOiBudWxsO1xuXHR9LFxuXG5cdC8qKiBAcmV0dXJuIHRoZSBwcmV2aW91cyBtb2RlbCBvciB0aGUgZW5kIGlmIGF0IHRoZSBiZWdpbm5pbmcgKi9cblx0cHJlY2VkaW5nT3JMYXN0OiBmdW5jdGlvbihtb2RlbCkge1xuXHRcdG1vZGVsIHx8IChtb2RlbCA9IHRoaXMuc2VsZWN0ZWQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCkgLSAxO1xuXHRcdHJldHVybiB0aGlzLmF0KGluZGV4ID4gLTEgPyBpbmRleCA6IHRoaXMubGVuZ3RoIC0gMSk7XG5cdH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGFibGVDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL21vZGVsL2NvbGxlY3Rpb24vQXJ0aWNsZUNvbGxlY3Rpb25cbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb259ICovXG5jb25zdCBTZWxlY3RhYmxlQ29sbGVjdGlvbiA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb25cIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL0FydGljbGVJdGVtfSAqL1xuY29uc3QgQXJ0aWNsZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL2l0ZW0vQXJ0aWNsZUl0ZW1cIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0FydGljbGVDb2xsZWN0aW9ufVxuICovXG52YXIgQXJ0aWNsZUNvbGxlY3Rpb24gPSBTZWxlY3RhYmxlQ29sbGVjdGlvbi5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7QmFja2JvbmUuTW9kZWx9ICovXG5cdG1vZGVsOiBBcnRpY2xlSXRlbVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQXJ0aWNsZUNvbGxlY3Rpb24oKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC9tb2RlbC9jb2xsZWN0aW9uL0J1bmRsZUNvbGxlY3Rpb25cbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb259ICovXG5jb25zdCBTZWxlY3RhYmxlQ29sbGVjdGlvbiA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb25cIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL0J1bmRsZUl0ZW19ICovXG5jb25zdCBCdW5kbGVJdGVtID0gcmVxdWlyZShcImFwcC9tb2RlbC9pdGVtL0J1bmRsZUl0ZW1cIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0J1bmRsZUNvbGxlY3Rpb259XG4gKi9cbnZhciBCdW5kbGVDb2xsZWN0aW9uID0gU2VsZWN0YWJsZUNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge0JhY2tib25lLk1vZGVsfSAqL1xuXHRtb2RlbDogQnVuZGxlSXRlbSxcblxuXHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuXHRjb21wYXJhdG9yOiBmdW5jdGlvbihvYSwgb2IpIHtcblx0XHR2YXIgYSA9IG9hLmdldChcImNvbXBsZXRlZFwiKTtcblx0XHR2YXIgYiA9IG9iLmdldChcImNvbXBsZXRlZFwiKTtcblx0XHRpZiAoYSA+IGIpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9IGVsc2UgaWYgKGEgPCBiKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xuXHR1cmw6IFwiL2pzb24vYnVuZGxlcy9cIixcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEJ1bmRsZUNvbGxlY3Rpb24oKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC9tb2RlbC9jb2xsZWN0aW9uL0tleXdvcmRDb2xsZWN0aW9uXG4gKiBAcmVxdWlyZXMgbW9kdWxlOmJhY2tib25lXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL1NlbGVjdGFibGVDb2xsZWN0aW9ufSAqL1xuY29uc3QgU2VsZWN0YWJsZUNvbGxlY3Rpb24gPSByZXF1aXJlKFwiYXBwL21vZGVsL1NlbGVjdGFibGVDb2xsZWN0aW9uXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9LZXl3b3JkSXRlbX0gKi9cbmNvbnN0IEtleXdvcmRJdGVtID0gcmVxdWlyZShcImFwcC9tb2RlbC9pdGVtL0tleXdvcmRJdGVtXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvY29sbGVjdGlvbi9LZXl3b3JkQ29sbGVjdGlvbn1cbiAqL1xudmFyIEtleXdvcmRDb2xsZWN0aW9uID0gU2VsZWN0YWJsZUNvbGxlY3Rpb24uZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge0JhY2tib25lLk1vZGVsfSAqL1xuXHRtb2RlbDogS2V5d29yZEl0ZW1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEtleXdvcmRDb2xsZWN0aW9uKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvY29sbGVjdGlvbi9UeXBlQ29sbGVjdGlvblxuICogQHJlcXVpcmVzIG1vZHVsZTpiYWNrYm9uZVxuICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmJhY2tib25lfSAqL1xuY29uc3QgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL1R5cGVJdGVtfSAqL1xuY29uc3QgVHlwZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL2l0ZW0vVHlwZUl0ZW1cIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL1R5cGVDb2xsZWN0aW9ufVxuICovXG52YXIgVHlwZUNvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG5cblx0LyoqIEB0eXBlIHtCYWNrYm9uZS5Nb2RlbH0gKi9cblx0bW9kZWw6IFR5cGVJdGVtXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlQ29sbGVjdGlvbigpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJvb3RzdHJhcCkge1xuXG5cdC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0dsb2JhbHN9ICovXG5cdHZhciBHbG9iYWxzID0gcmVxdWlyZShcImFwcC9jb250cm9sL0dsb2JhbHNcIik7XG5cblx0Ly8gR2xvYmFscy5HQV9UQUdTID0gYm9vdHN0cmFwW1wiZ2EtdGFnc1wiXTtcblx0Ly8gR2xvYmFscy5QQVJBTVMgPSBib290c3RyYXBbXCJwYXJhbXNcIl07XG5cdC8vIEdsb2JhbHMuQVBQX1JPT1QgPSBib290c3RyYXBbXCJwYXJhbXNcIl1bXCJyb290XCJdO1xuXHQvLyBHbG9iYWxzLk1FRElBX0RJUiA9IGJvb3RzdHJhcFtcInBhcmFtc1wiXVtcInVwbG9hZHNcIl07XG5cdEdsb2JhbHMuQVBQX05BTUUgPSBib290c3RyYXBbXCJwYXJhbXNcIl1bXCJ3ZWJzaXRlLW5hbWVcIl07XG5cblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vVHlwZUNvbGxlY3Rpb259ICovXG5cdHZhciB0eXBlTGlzdCA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvY29sbGVjdGlvbi9UeXBlQ29sbGVjdGlvblwiKTtcblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vS2V5d29yZENvbGxlY3Rpb259ICovXG5cdHZhciBrZXl3b3JkTGlzdCA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvY29sbGVjdGlvbi9LZXl3b3JkQ29sbGVjdGlvblwiKTtcblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvbn0gKi9cblx0dmFyIGJ1bmRsZUxpc3QgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvblwiKTtcblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQXJ0aWNsZUNvbGxlY3Rpb259ICovXG5cdHZhciBhcnRpY2xlTGlzdCA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvY29sbGVjdGlvbi9BcnRpY2xlQ29sbGVjdGlvblwiKTtcblxuXHQvLyBGaXgtdXBzIHRvIGJvb3RzdHJhcCBkYXRhLlxuXHR2YXIgYXJ0aWNsZXMgPSBib290c3RyYXBbXCJhcnRpY2xlcy1hbGxcIl07XG5cdHZhciB0eXBlcyA9IGJvb3RzdHJhcFtcInR5cGVzLWFsbFwiXTtcblx0dmFyIGtleXdvcmRzID0gYm9vdHN0cmFwW1wia2V5d29yZHMtYWxsXCJdO1xuXHR2YXIgYnVuZGxlcyA9IGJvb3RzdHJhcFtcImJ1bmRsZXMtYWxsXCJdO1xuXHR2YXIgbWVkaWEgPSBib290c3RyYXBbXCJtZWRpYS1hbGxcIl07XG5cblx0Ly8gQXR0YWNoIG1lZGlhIHRvIHRoZWlyIGJ1bmRsZXNcblx0dmFyIG1lZGlhQnlCdW5kbGUgPSBfLmdyb3VwQnkobWVkaWEsIFwiYklkXCIpO1xuXG5cdC8vIEZpbGwtaW4gYmFjay1yZWZlcmVuY2VzOlxuXHQvLyBDcmVhdGUgS2V5d29yZC5idW5kbGVJZHMgZnJvbSBleGlzdGluZyBCdW5kbGUua2V5d29yZElkcyxcblx0Ly8gdGhlbiBCdW5kbGUudHlwZUlkcyBmcm9tIHVuaXF1ZSBLZXl3b3JkLnR5cGVJZFxuXG5cdC8vIF8uZWFjaChidW5kbGVzLCBmdW5jdGlvbiAoYm8sIGJpLCBiYSkge1xuXHRidW5kbGVzLmZvckVhY2goZnVuY3Rpb24oYm8sIGJpLCBiYSkge1xuXHRcdGJvLnRJZHMgPSBbXTtcblx0XHRiby5tZWRpYSA9IG1lZGlhQnlCdW5kbGVbYm8uaWRdO1xuXHRcdC8vIF8uZWFjaChrZXl3b3JkcywgZnVuY3Rpb24gKGtvLCBraSwga2EpIHtcblx0XHRrZXl3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKGtvLCBraSwga2EpIHtcblx0XHRcdGlmIChiaSA9PT0gMCkge1xuXHRcdFx0XHRrby5iSWRzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiAoXy5jb250YWlucyhiby5rSWRzLCBrby5pZCkpIHtcblx0XHRcdGlmIChiby5rSWRzLmluZGV4T2Yoa28uaWQpICE9IC0xKSB7XG5cdFx0XHRcdGtvLmJJZHMucHVzaChiby5pZCk7XG5cdFx0XHRcdC8vIGlmICghXy5jb250YWlucyhiby50SWRzLCBrby50SWQpKSB7XG5cdFx0XHRcdGlmIChiby50SWRzLmluZGV4T2Yoa28udElkKSA9PSAtMSkge1xuXHRcdFx0XHRcdGJvLnRJZHMucHVzaChrby50SWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vIEZpbGwgY29sbGVjdGlvbiBzaW5nbGV0b25zXG5cdGFydGljbGVMaXN0LnJlc2V0KGFydGljbGVzKTtcblx0dHlwZUxpc3QucmVzZXQodHlwZXMpO1xuXHRrZXl3b3JkTGlzdC5yZXNldChrZXl3b3Jkcyk7XG5cdGJ1bmRsZUxpc3QucmVzZXQoYnVuZGxlcyk7XG5cblx0Ly8gYm9vdHN0cmFwW1wicGFyYW1zXCJdID0gYm9vdHN0cmFwW1wiYXJ0aWNsZXMtYWxsXCJdID0gYm9vdHN0cmFwW1widHlwZXMtYWxsXCJdID0gYm9vdHN0cmFwW1wia2V5d29yZHMtYWxsXCJdID0gYm9vdHN0cmFwW1wiYnVuZGxlcy1hbGxcIl0gPSBib290c3RyYXBbXCJtZWRpYS1hbGxcIl0gPSBudWxsO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC9tb2RlbC9pdGVtL0FydGljbGVJdGVtXG4gKi9cblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9Tb3VyY2VJdGVtfSAqL1xuY29uc3QgQmFzZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL0Jhc2VJdGVtXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9BcnRpY2xlSXRlbX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlSXRlbS5leHRlbmQoe1xuXG5cdF9kb21QcmVmaXg6IFwiYVwiLFxuXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdG5hbWU6IFwiXCIsXG5cdFx0aGFuZGxlOiBcIlwiLFxuXHRcdHRleHQ6IFwiXCJcblx0fSxcblxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvaXRlbS9CdW5kbGVJdGVtXG4gKiBAcmVxdWlyZXMgbW9kdWxlOmJhY2tib25lXG4gKi9cblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7LyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbmNvbnN0IENvbG9yID0gcmVxdWlyZShcImNvbG9yXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9Tb3VyY2VJdGVtfSAqL1xuY29uc3QgQmFzZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL0Jhc2VJdGVtXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2l0ZW0vTWVkaWFJdGVtfSAqL1xuY29uc3QgTWVkaWFJdGVtID0gcmVxdWlyZShcImFwcC9tb2RlbC9pdGVtL01lZGlhSXRlbVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9TZWxlY3RhYmxlQ29sbGVjdGlvbn0gKi9cbmNvbnN0IFNlbGVjdGFibGVDb2xsZWN0aW9uID0gcmVxdWlyZShcImFwcC9tb2RlbC9TZWxlY3RhYmxlQ29sbGVjdGlvblwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvR2xvYmFsc30gKi9cbmNvbnN0IEdsb2JhbHMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC91dGlscy9zdHJpbmdzL3N0cmlwVGFnc30gKi9cbmNvbnN0IHN0cmlwVGFncyA9IHJlcXVpcmUoXCJ1dGlscy9zdHJpbmdzL3N0cmlwVGFnc1wiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC91dGlscy9zdHJpbmdzL3BhcnNlVGFnbGlzdH0gKi9cbi8vIHZhciBwYXJzZVN5bUF0dHJzID0gcmVxdWlyZShcImFwcC9tb2RlbC9wYXJzZVN5bUF0dHJzXCIpO1xuXG4vLyAvKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvY29sbGVjdGlvbi9LZXl3b3JkQ29sbGVjdGlvbn0gKi9cbi8vIHZhciBrZXl3b3JkcyA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvY29sbGVjdGlvbi9LZXl3b3JkQ29sbGVjdGlvblwiKTtcblxuLy8gR2xvYmFscy5ERUZBVUxUX0NPTE9SU1tcImNvbG9yXCJdO1xuLy8gR2xvYmFscy5ERUZBVUxUX0NPTE9SU1tcImJhY2tncm91bmQtY29sb3JcIl07XG52YXIgYXR0cnNEZWZhdWx0ID0gXy5kZWZhdWx0cyh7XG5cdFwiaGFzLWNvbG9yc1wiOiBcImRlZmF1bHRzXCJcbn0sIEdsb2JhbHMuREVGQVVMVF9DT0xPUlMpO1xuXG4vKiogQHByaXZhdGUgKi9cbnZhciBNZWRpYUNvbGxlY3Rpb24gPSBTZWxlY3RhYmxlQ29sbGVjdGlvbi5leHRlbmQoe1xuXHRtb2RlbDogTWVkaWFJdGVtLFxuXHRjb21wYXJhdG9yOiBcIm9cIlxufSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL0J1bmRsZUl0ZW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFzZUl0ZW0uZXh0ZW5kKHtcblxuXHRfZG9tUHJlZml4OiBcImJcIixcblxuXHQvKiogQHR5cGUge09iamVjdHxGdW5jdGlvbn0gKi9cblx0Ly8gZGVmYXVsdHM6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdHJldHVybiB7XG5cdC8vIFx0XHRuYW1lOiBcIlwiLFxuXHQvLyBcdFx0aGFuZGxlOiBcIlwiLFxuXHQvLyBcdFx0ZGVzYzogXCJcIixcblx0Ly8gXHRcdGNvbXBsZXRlZDogMCxcblx0Ly8gXHRcdGtJZHM6IFtdLFxuXHQvLyBcdH07XG5cdC8vIH0sXG5cdGRlZmF1bHRzOiB7XG5cdFx0bmFtZTogXCJcIixcblx0XHRoYW5kbGU6IFwiXCIsXG5cdFx0ZGVzYzogXCJcIixcblx0XHRjb21wbGV0ZWQ6IDAsXG5cdFx0Z2V0IGtJZHMoKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblx0XHQvLyBnZXQga2V5d29yZHMoKSB7IHJldHVybiBbXTsgfSxcblx0fSxcblxuXHRnZXR0ZXJzOiBbXCJuYW1lXCIsIFwibWVkaWFcIl0sXG5cblx0bXV0YXRvcnM6IHtcblx0XHR0ZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzdHJpcFRhZ3ModGhpcy5nZXQoXCJkZXNjXCIpKTtcblx0XHR9LFxuXHRcdC8vIGtJZHM6IHtcblx0XHQvLyBcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIHNldCkge1xuXHRcdC8vIFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHQvLyBcdFx0XHRzZXQoXCJrZXl3b3Jkc1wiLCB2YWx1ZS5tYXAoZnVuY3Rpb24oaWQpIHtcblx0XHQvLyBcdFx0XHRcdHZhciBvYmogPSBrZXl3b3Jkcy5nZXQoaWQpO1xuXHRcdC8vIFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHQvLyBcdFx0XHR9LCB0aGlzKSwgb3B0aW9ucztcblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0XHRzZXQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0bWVkaWE6IHtcblx0XHRcdHRyYW5zaWVudDogdHJ1ZSxcblx0XHRcdHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0aW9ucywgc2V0KSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdFx0by5idW5kbGUgPSB0aGlzO1xuXHRcdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XHRcdHZhbHVlID0gbmV3IE1lZGlhQ29sbGVjdGlvbih2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5jb2xvcnMgPSB7XG5cdFx0XHRmZ0NvbG9yOiBuZXcgQ29sb3IodGhpcy5hdHRyKFwiY29sb3JcIikpLFxuXHRcdFx0YmdDb2xvcjogbmV3IENvbG9yKHRoaXMuYXR0cihcImJhY2tncm91bmQtY29sb3JcIikpLFxuXHRcdFx0bG5Db2xvcjogbmV3IENvbG9yKHRoaXMuYXR0cihcImxpbmstY29sb3JcIikpLFxuXHRcdH07XG5cdFx0dGhpcy5jb2xvcnMuaGFzRGFya0JnID0gdGhpcy5jb2xvcnMuZmdDb2xvci5sdW1pbm9zaXR5KCkgPiB0aGlzLmNvbG9ycy5iZ0NvbG9yLmx1bWlub3NpdHkoKTtcblx0fSxcblxuXHRhdHRyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2F0dHJzIHx8ICh0aGlzLl9hdHRycyA9IF8uZGVmYXVsdHMoe30sIHRoaXMuZ2V0KFwiYXR0cnNcIiksIGF0dHJzRGVmYXVsdCkpO1xuXHR9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvaXRlbS9LZXl3b3JkSXRlbVxuICogQHJlcXVpcmVzIG1vZHVsZTphcHAvbW9kZWwvQmFzZUl0ZW1cbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvQmFzZUl0ZW19ICovXG5jb25zdCBCYXNlSXRlbSA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvQmFzZUl0ZW1cIik7XG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL1R5cGVDb2xsZWN0aW9ufSAqL1xuLy8gdmFyIHR5cGVzID0gcmVxdWlyZShcImFwcC9tb2RlbC9jb2xsZWN0aW9uL1R5cGVDb2xsZWN0aW9uXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9LZXl3b3JkSXRlbX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlSXRlbS5leHRlbmQoe1xuXG5cdF9kb21QcmVmaXg6IFwia1wiLFxuXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdG5hbWU6IFwiXCIsXG5cdFx0aGFuZGxlOiBcIlwiLFxuXHRcdHRJZDogLTEsXG5cdH0sXG5cblx0Ly8gbXV0YXRvcnM6IHtcblx0Ly8gXHR0SWQ6IHtcblx0Ly8gXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIHNldCkge1xuXHQvLyBcdFx0XHR2YXIgdHlwZSA9IHR5cGVzLmdldCh2YWx1ZSk7XG5cdC8vIFx0XHRcdGlmICh0eXBlKSB7XG5cdC8vIFx0XHRcdFx0dHlwZS5nZXQoXCJrZXl3b3Jkc1wiKS5wdXNoKHRoaXMpO1xuXHQvLyBcdFx0XHRcdHNldChcInR5cGVcIiwgdHlwZSwgb3B0aW9ucyk7XG5cdC8vIFx0XHRcdH1cblx0Ly8gXHRcdFx0c2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH0sXG5cdC8vIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL21vZGVsL2l0ZW0vTWVkaWFJdGVtXG4gKiBAcmVxdWlyZXMgbW9kdWxlOmJhY2tib25lXG4gKi9cblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7LyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbmNvbnN0IENvbG9yID0gcmVxdWlyZShcImNvbG9yXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9Tb3VyY2VJdGVtfSAqL1xuY29uc3QgQmFzZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL0Jhc2VJdGVtXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2l0ZW0vU291cmNlSXRlbX0gKi9cbmNvbnN0IFNvdXJjZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL2l0ZW0vU291cmNlSXRlbVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9TZWxlY3RhYmxlQ29sbGVjdGlvbn0gKi9cbmNvbnN0IFNlbGVjdGFibGVDb2xsZWN0aW9uID0gcmVxdWlyZShcImFwcC9tb2RlbC9TZWxlY3RhYmxlQ29sbGVjdGlvblwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvR2xvYmFsc30gKi9cbmNvbnN0IEdsb2JhbHMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC91dGlscy9zdHJpbmdzL3N0cmlwVGFnc30gKi9cbmNvbnN0IHN0cmlwVGFncyA9IHJlcXVpcmUoXCJ1dGlscy9zdHJpbmdzL3N0cmlwVGFnc1wiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9wYXJzZVN5bUF0dHJzfSAqL1xuLy8gdmFyIHBhcnNlU3ltQXR0cnMgPSByZXF1aXJlKFwiYXBwL21vZGVsL3BhcnNlU3ltQXR0cnNcIik7XG5cbi8vIGNvbnNvbGUubG9nKEdsb2JhbHMuUEFSQU1TKTtcblxudmFyIHVybFRlbXBsYXRlcyA9IHtcblx0XCJvcmlnaW5hbFwiOiBfLnRlbXBsYXRlKEdsb2JhbHMuTUVESUFfRElSICsgXCIvPCU9IHNyYyAlPlwiKSxcblx0XCJjb25zdHJhaW4td2lkdGhcIjogXy50ZW1wbGF0ZShHbG9iYWxzLkFQUF9ST09UICsgXCJpbWFnZS8xLzwlPSB3aWR0aCAlPi8wL3VwbG9hZHMvPCU9IHNyYyAlPlwiKSxcblx0XCJjb25zdHJhaW4taGVpZ2h0XCI6IF8udGVtcGxhdGUoR2xvYmFscy5BUFBfUk9PVCArIFwiaW1hZ2UvMS8wLzwlPSBoZWlnaHQgJT4vdXBsb2Fkcy88JT0gc3JjICU+XCIpLFxuXHRcImRlYnVnLWJhbmR3aWR0aFwiOiBfLnRlbXBsYXRlKEdsb2JhbHMuTUVESUFfRElSLnJlcGxhY2UoLyhodHRwcz9cXDpcXC9cXC9bXlxcL10rKS8sIFwiJDEvc2xvdy88JT0ga2JwcyAlPlwiKSArIFwiLzwlPSBzcmMgJT5cIiksXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9NZWRpYUl0ZW0uU291cmNlQ29sbGVjdGlvbn1cbiAqL1xudmFyIFNvdXJjZUNvbGxlY3Rpb24gPSBTZWxlY3RhYmxlQ29sbGVjdGlvbi5leHRlbmQoe1xuXHRtb2RlbDogU291cmNlSXRlbVxufSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL01lZGlhSXRlbX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlSXRlbS5leHRlbmQoe1xuXG5cdF9kb21QcmVmaXg6IFwibVwiLFxuXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdG5hbWU6IFwiPHA+PGVtPlVudGl0bGVkPC9lbT48L3A+XCIsXG5cdFx0c3ViOiBcIlwiLFxuXHRcdG86IDAsXG5cdFx0YklkOiAtMSxcblx0XHRzcmNJZHg6IDAsXG5cdFx0Z2V0IHNyY3NldCgpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXHRcdGdldCBzb3VyY2VzKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTb3VyY2VDb2xsZWN0aW9uKCk7XG5cdFx0fSxcblx0fSxcblxuXHRnZXR0ZXJzOiBbXCJuYW1lXCIsIFwiYnVuZGxlXCIsIFwic291cmNlXCIsIFwic291cmNlc1wiXSxcblxuXHRtdXRhdG9yczoge1xuXHRcdC8vIGRlc2M6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0cmV0dXJuIHRoaXMuZ2V0KFwibmFtZVwiKTtcblx0XHQvLyB9LFxuXHRcdGhhbmRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoXCJzcmNcIik7XG5cdFx0fSxcblx0XHR0ZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShcIl90ZXh0XCIpKVxuXHRcdFx0XHR0aGlzLl90ZXh0ID0gXy51bmVzY2FwZShzdHJpcFRhZ3ModGhpcy5nZXQoXCJuYW1lXCIpKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdGV4dDtcblx0XHR9LFxuXHRcdGF0dHJzOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdHMsIHNldCkge1xuXHRcdFx0XHR0aGlzLl9hdHRycyA9IG51bGw7XG5cdFx0XHRcdEJhc2VJdGVtLnByb3RvdHlwZS5tdXRhdG9ycy5hdHRycy5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlU291cmNlcygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3Jjc2V0OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdHMsIHNldCkge1xuXHRcdFx0XHRzZXQoa2V5LCB2YWx1ZSwgb3B0cyk7XG5cdFx0XHRcdHRoaXMuZ2V0KFwic291cmNlc1wiKS5yZXNldCh2YWx1ZSwgb3B0cyk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNvdXJjZXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNvdXJjZToge1xuXHRcdFx0dHJhbnNpZW50OiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0KFwic291cmNlc1wiKS5hdCh0aGlzLmdldChcInNyY0lkeFwiKSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdXBkYXRlQ29sb3JzKCk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcImNoYW5nZTphdHRycyBjaGFuZ2U6YnVuZGxlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fYXR0cnMgPSBudWxsO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGF0dHJzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXR0cnMgfHwgKHRoaXMuX2F0dHJzID0gXy5kZWZhdWx0cyh7fSwgdGhpcy5nZXQoXCJidW5kbGVcIikuYXR0cnMoKSwgdGhpcy5nZXQoXCJhdHRyc1wiKSkpO1xuXHR9LFxuXG5cdF91cGRhdGVDb2xvcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sb3JzID0ge1xuXHRcdFx0ZmdDb2xvcjogbmV3IENvbG9yKHRoaXMuYXR0cihcImNvbG9yXCIpKSxcblx0XHRcdGJnQ29sb3I6IG5ldyBDb2xvcih0aGlzLmF0dHIoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpKVxuXHRcdH07XG5cdFx0dGhpcy5jb2xvcnMuaGFzRGFya0JnID0gdGhpcy5jb2xvcnMuZmdDb2xvci5sdW1pbm9zaXR5KCkgPiB0aGlzLmNvbG9ycy5iZ0NvbG9yLmx1bWlub3NpdHkoKTtcblx0fSxcblxuXHRfdXBkYXRlU291cmNlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNyY09iaiA9IHtcblx0XHRcdGticHM6IHRoaXMuYXR0cihcIkBkZWJ1Zy1iYW5kd2lkdGhcIilcblx0XHR9O1xuXHRcdHZhciBzcmNUcGwgPSB1cmxUZW1wbGF0ZXNbc3JjT2JqLmticHMgPyBcImRlYnVnLWJhbmR3aWR0aFwiIDogXCJvcmlnaW5hbFwiXTtcblx0XHR0aGlzLmdldChcInNvdXJjZXNcIikuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRzcmNPYmouc3JjID0gaXRlbS5nZXQoXCJzcmNcIik7XG5cdFx0XHRpdGVtLnNldChcIm9yaWdpbmFsXCIsIHNyY1RwbChzcmNPYmopKTtcblx0XHR9KTtcblx0fSxcblxuXHQvLyBfdXBkYXRlU291cmNlc0FycjogZnVuY3Rpb24oKSB7XG5cdC8vIFx0dmFyIHNyY3NldCA9IHRoaXMuZ2V0KFwic3Jjc2V0XCIpO1xuXHQvLyBcdGlmIChBcnJheS5pc0FycmF5KHNyY3NldCkpIHtcblx0Ly8gXHRcdHZhciBzcmNPYmogPSB7IGticHM6IHRoaXMuYXR0cihcIkBkZWJ1Zy1iYW5kd2lkdGhcIikgfTtcblx0Ly8gXHRcdHZhciBzcmNUcGwgPSBHbG9iYWxzLk1FRElBX1NSQ19UUExbc3JjT2JqLmticHM/IFwiZGVidWctYmFuZHdpZHRoXCIgOiBcIm9yaWdpbmFsXCJdO1xuXHQvLyBcdFx0c3Jjc2V0LmZvckVhY2goZnVuY3Rpb24obykge1xuXHQvLyBcdFx0XHRzcmNPYmouc3JjID0gby5zcmM7XG5cdC8vIFx0XHRcdG8ub3JpZ2luYWwgPSBzcmNUcGwoc3JjT2JqKTtcblx0Ly8gXHRcdH0sIHRoaXMpO1xuXHQvLyBcdH1cblx0Ly8gXHR0aGlzLmdldChcInNvdXJjZXNcIikucmVzZXQoc3Jjc2V0KTtcblx0Ly8gfSxcblxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvbW9kZWwvaXRlbS9Tb3VyY2VJdGVtXG4gKiBAcmVxdWlyZXMgbW9kdWxlOmJhY2tib25lXG4gKi9cblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XG4vLyAvKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuLy8gdmFyIEdsb2JhbHMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL1NvdXJjZUl0ZW19ICovXG5jb25zdCBCYXNlSXRlbSA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvQmFzZUl0ZW1cIik7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSAqL1xudmFyIG5vQ2FjaGVTdWZmaXggPSBcIj9cIiArIERhdGUubm93KCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL1NvdXJjZUl0ZW19XG4gKi9cbi8vIG1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbm1vZHVsZS5leHBvcnRzID0gQmFzZUl0ZW0uZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge09iamVjdH0gKi9cblx0ZGVmYXVsdHM6IHtcblx0XHRzcmM6IG51bGwsXG5cdFx0bWltZTogbnVsbCxcblx0XHR3OiBudWxsLFxuXHRcdGg6IG51bGwsXG5cdH0sXG5cblx0Z2V0dGVyczogW1wic3JjXCIsIFwib3JpZ2luYWxcIl0sXG5cblx0bXV0YXRvcnM6IHtcblx0XHRzcmM6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0aW9ucywgc2V0KSB7XG5cdFx0XHRcdGlmIChERUJVRykge1xuXHRcdFx0XHRcdHZhbHVlICs9IG5vQ2FjaGVTdWZmaXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gb3JpZ2luYWw6IHsgXG5cdFx0Ly8gXHR0cmFuc2llbnQ6IHRydWUsXG5cdFx0Ly8gXHRnZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zLCBzZXQpIHtcblx0XHQvLyBcdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5vcmlnaW5hbCB8fCAodGhpcy5hdHRyaWJ1dGVzLm9yaWdpbmFsID0gdGhpcy5fY29tcG9zZU9yaWdpbmFsU3JjKCkpO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRcdC8vIG1lZGlhOiB7XG5cdFx0Ly8gXHR0cmFuc2llbnQ6IHRydWUsXG5cdFx0Ly8gXHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBcdFx0dmFyIHJldHZhbDtcblx0XHQvLyBcdFx0aWYgKHRoaXMuX25vUmVjdXNpb24pIHtcblx0XHQvLyBcdFx0XHRjb25zb2xlLmxvZyhcIiVzOjptZWRpYSByZXR1cm5pbmcgbnVsbFwiLCB0aGlzLmNpZCk7XG5cdFx0Ly8gXHRcdFx0cmV0dmFsID0gbnVsbDsvL3RoaXMuaWQ7XG5cdFx0Ly8gXHRcdH0gZWxzZSB7XG5cdFx0Ly8gXHRcdFx0Y29uc29sZS5sb2coXCIlczo6bWVkaWEgcmV0dXJuaW5nIE9iamVjdFwiLCB0aGlzLmNpZCk7XG5cdFx0Ly8gXHRcdFx0dGhpcy5fbm9SZWN1c2lvbiA9IHRydWU7XG5cdFx0Ly8gXHRcdFx0cmV0dmFsID0gdGhpcy5hdHRyaWJ1dGVzLm1lZGlhO1xuXHRcdC8vIFx0XHRcdHRoaXMuX25vUmVjdXNpb24gPSBmYWxzZTtcblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0XHRyZXR1cm4gcmV0dmFsO1xuXHRcdC8vIFx0fSxcblx0XHQvLyBcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUsIG9wdGlvbnMsIHNldCkge1xuXHRcdC8vIFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBCYXNlSXRlbSkge1xuXHRcdC8vIFx0XHRcdHNldChrZXksIHZhbHVlLCBvcHRpb25zKTtcblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHR9LFxuXG5cdC8vIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdGlmIChERUJVRykge1xuXHQvLyBcdFx0dmFyIGNiID0gZnVuY3Rpb24oKSB7XG5cdC8vIFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiQGRlYnVnLWJhbmR3aWR0aDpcIiwgSlNPTi5zdHJpbmdpZnkodGhpcy5nZXQoXCJtZWRpYVwiKS5hdHRyKFwiQGRlYnVnLWJhbmR3aWR0aFwiKSkpO1xuXHQvLyBcdFx0XHRjb25zb2xlLmxvZyhcIm1lZGlhOlwiLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSk7XG5cdC8vIFx0XHRcdC8vIGlmICgodGhpcy5nZXQoXCJtZWRpYVwiKSBpbnN0YW5jZW9mIEJhc2VJdGVtKSAmJiB0aGlzLmdldChcIm1lZGlhXCIpLmF0dHIoXCJAZGVidWctYmFuZHdpZHRoXCIpKSB7XG5cdC8vIFx0XHRcdC8vIFx0Y29uc29sZS5sb2coXCJvcmlnaW5hbFwiLCB0aGlzLmdldChcIm9yaWdpbmFsXCIpKTtcblx0Ly8gXHRcdFx0Ly8gXHRjb25zb2xlLmxvZyhcIm1lZGlhOlwiLCBKU09OLnN0cmluZ2lmeSh0aGlzLmdldChcIm1lZGlhXCIpLnRvSlNPTigpKSk7XG5cdC8vIFx0XHRcdC8vIH1cblx0Ly8gXHRcdH0uYmluZCh0aGlzKTtcblx0Ly8gXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuXHQvLyBcdH1cblx0Ly8gfSxcblx0Ly8gXG5cdC8vIF9jb21wb3NlT3JpZ2luYWxTcmM6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdHZhciB2YWx1ZXMgPSB7IHNyYzogdGhpcy5nZXQoXCJzcmNcIikgfTtcblx0Ly8gXHRpZiAodGhpcy5oYXMoXCJtZWRpYVwiKSAmJiAodmFsdWVzLmticHMgPSB0aGlzLmdldChcIm1lZGlhXCIpLmF0dHIoXCJAZGVidWctYmFuZHdpZHRoXCIpKSkge1xuXHQvLyBcdC8vIGlmICh0aGlzLmhhcyhcIm1lZGlhXCIpICYmIHRoaXMuZ2V0KFwibWVkaWFcIikuYXR0cnMoKS5oYXNPd25Qcm9wZXJ0eShcIkBkZWJ1Zy1iYW5kd2lkdGhcIikpIHtcblx0Ly8gXHQvLyBcdHZhbHVlcy5rYnBzID0gdGhpcy5nZXQoXCJtZWRpYVwiKS5hdHRycygpW1wiQGRlYnVnLWJhbmR3aWR0aFwiXTtcblx0Ly8gXHRcdHJldHVybiBHbG9iYWxzLk1FRElBX1NSQ19UUExbXCJkZWJ1Zy1iYW5kd2lkdGhcIl0odmFsdWVzKTtcblx0Ly8gXHR9XG5cdC8vIFx0cmV0dXJuIEdsb2JhbHMuTUVESUFfU1JDX1RQTFtcIm9yaWdpbmFsXCJdKHZhbHVlcyk7XG5cdC8vIH0sXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC9tb2RlbC9pdGVtL1R5cGVJdGVtXG4gKi9cblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9Tb3VyY2VJdGVtfSAqL1xuY29uc3QgQmFzZUl0ZW0gPSByZXF1aXJlKFwiYXBwL21vZGVsL0Jhc2VJdGVtXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvaXRlbS9UeXBlSXRlbX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlSXRlbS5leHRlbmQoe1xuXG5cdF9kb21QcmVmaXg6IFwidFwiLFxuXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdG5hbWU6IFwiXCIsXG5cdFx0aGFuZGxlOiBcIlwiLFxuXHRcdC8vIGdldCBrSWRzKCkgeyByZXR1cm4gW107IH0sXG5cdFx0Ly8gZ2V0IGtleXdvcmRzKCkgeyByZXR1cm4gW107IH0sXG5cdH0sXG5cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvQXBwVmlld1xuICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmJhY2tib25lfSAqL1xuY29uc3QgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC91dGlscy9kZWJ1Zy90cmFjZUFyZ3N9ICovXG5jb25zdCBzdHJpcFRhZ3MgPSByZXF1aXJlKFwidXRpbHMvc3RyaW5ncy9zdHJpcFRhZ3NcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0dsb2JhbHN9ICovXG5jb25zdCBHbG9iYWxzID0gcmVxdWlyZShcImFwcC9jb250cm9sL0dsb2JhbHNcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9Db250cm9sbGVyfSAqL1xuY29uc3QgY29udHJvbGxlciA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9Db250cm9sbGVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL0FwcFN0YXRlfSAqL1xuY29uc3QgQXBwU3RhdGUgPSByZXF1aXJlKFwiYXBwL21vZGVsL0FwcFN0YXRlXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvbn0gKi9cbmNvbnN0IGJ1bmRsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvblwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0FydGljbGVDb2xsZWN0aW9ufSAqL1xuY29uc3QgYXJ0aWNsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQXJ0aWNsZUNvbGxlY3Rpb25cIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld30gKi9cbmNvbnN0IFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3XCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvTmF2aWdhdGlvblZpZXd9ICovXG5jb25zdCBOYXZpZ2F0aW9uVmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9OYXZpZ2F0aW9uVmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L0NvbnRlbnRWaWV3fSAqL1xuY29uc3QgQ29udGVudFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvQ29udGVudFZpZXdcIik7XG5cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9Ub3VjaE1hbmFnZXJ9ICovXG5jb25zdCBUb3VjaE1hbmFnZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9Ub3VjaE1hbmFnZXJcIik7XG4vLyAvKiogQHR5cGUge21vZHVsZTpoYW1tZXJqc30gKi9cbi8vIGNvbnN0IEhhbW1lciA9IHJlcXVpcmUoXCJoYW1tZXJqc1wiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3RvdWNoL1Ntb290aFBhblJlY29nbml6ZXJ9ICovXG4vLyBjb25zdCBQYW4gPSByZXF1aXJlKFwidXRpbHMvdG91Y2gvU21vb3RoUGFuUmVjb2duaXplclwiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmhhbW1lcmpzLlRhcH0gKi9cbi8vIGNvbnN0IFRhcCA9IEhhbW1lci5UYXA7XG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2RlYnVnL3RyYWNlRWxlbWVudH0gKi9cbi8vIGNvbnN0IHRyYWNlRWxlbWVudCA9IHJlcXVpcmUoXCJ1dGlscy9kZWJ1Zy90cmFjZUVsZW1lbnRcIik7XG4vL1xuLy8gY29uc3QgdnBhbkxvZ0ZuID0gXy5kZWJvdW5jZShjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLCAxMDAsIGZhbHNlKTtcbi8vIGNvbnN0IGhwYW5Mb2dGbiA9IF8uZGVib3VuY2UoY29uc29sZS5sb2cuYmluZChjb25zb2xlKSwgMTAwLCBmYWxzZSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L0FwcFZpZXd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2lkUHJlZml4OiBcImFwcFwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGVsOiBcImh0bWxcIixcblx0Ly8gLyoqIEBvdmVycmlkZSAqL1xuXHRjbGFzc05hbWU6IFwiYXBwXCIsIC8vIHdpdGhvdXQtYnVuZGxlIHdpdGhvdXQtbWVkaWEgd2l0aG91dC1hcnRpY2xlXCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0bW9kZWw6IEFwcFN0YXRlLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0ZXZlbnRzOiB7XG5cdFx0XCJ2aXNpYmlsaXR5Y2hhbmdlXCI6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOlslc11cIiwgdGhpcy5jaWQsIGV2LnR5cGUpO1xuXHRcdH0sXG5cdFx0XCJmdWxsc2NyZWVuY2hhbmdlXCI6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOlslc10gZnVsbHNjcmVlbjogJW9cIiwgdGhpcy5jaWQsIGV2LnR5cGUsIChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCAhPT0gbnVsbCksIGRvY3VtZW50LmZ1bGxzY3JlZW4pO1xuXHRcdH0sXG5cdFx0XCJkcmFnc3RhcnRcIjogZnVuY3Rpb24oZXYpIHtcblx0XHRcdGlmIChldi50YXJnZXQubm9kZU5hbWUgPT0gXCJJTUdcIiB8fCBldi50YXJnZXQubm9kZU5hbWUgPT0gXCJBXCIpIHtcblx0XHRcdFx0ZXYuZGVmYXVsdFByZXZlbnRlZCB8fCBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gXCJ0b3VjaG1vdmUgYm9keVwiOiBmdW5jdGlvbihldikge1xuXHRcdC8vIFx0ZXYuZGVmYXVsdFByZXZlbnRlZCB8fCBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIH0sXG5cdH0sXG5cblx0cHJvcGVydGllczoge1xuXHRcdGNvbnRhaW5lcjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lciB8fFxuXHRcdFx0XHRcdCh0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRhaW5lclwiKSk7XG5cdFx0XHRcdC8vICh0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5ib2R5KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG5hdmlnYXRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9uYXZpZ2F0aW9uIHx8XG5cdFx0XHRcdFx0KHRoaXMuX25hdmlnYXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5hdmlnYXRpb25cIikpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29udGVudDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgfHxcblx0XHRcdFx0XHQodGhpcy5fY29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udGVudFwiKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHQvKiBlbGVtZW50cyAqL1xuXHRcdC8vIHRoaXMucm91dGVFbCA9IHRoaXMuZWw7XG5cdFx0Ly8gdGhpcy5zdGF0ZUVsID0gdGhpcy5lbFxuXHRcdHRoaXMuYnJlYWtwb2ludEVsID0gdGhpcy5lbDtcblxuXHRcdC8qIGluaXQgSGFtbWVySlMgaGFuZGxlcnMgKi9cblx0XHR2YXIgdnRvdWNoLCBodG91Y2gsIHRvdWNoRWw7XG5cdFx0Ly8gdmFyIHZwYW4sIGhwYW4sIHRhcDtcblxuXHRcdC8vIHRoaXMuX3ZwYW5FbmFibGVGbiA9IGZ1bmN0aW9uKG1jLCBldikge1xuXHRcdC8vIFx0dmFyIHJldHZhbCA9ICF0aGlzLl9oYXNPdmVyZmxvd1kodGhpcy5jb250YWluZXIpO1xuXHRcdC8vIFx0dnBhbkxvZ0ZuKFwiJXM6Ol92cGFuRW5hYmxlRm4gLT4gJW9cXG4lb1wiLCB0aGlzLmNpZCwgcmV0dmFsLCBhcmd1bWVudHMpO1xuXHRcdC8vIFx0cmV0dXJuIHJldHZhbDtcblx0XHQvLyB9LmJpbmQodGhpcyk7XG5cdFx0Ly9cblx0XHQvLyB0aGlzLl9ocGFuRW5hYmxlRm4gPSBmdW5jdGlvbihtYywgZXYpIHtcblx0XHQvLyBcdHZhciByZXR2YWwgPSB0aGlzLm1vZGVsLmdldChcIndpdGhCdW5kbGVcIikgJiYgdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIik7XG5cdFx0Ly8gXHRocGFuTG9nRm4oXCIlczo6X2hwYW5FbmFibGVGbiAtPiAlb1xcbiVvXCIsIHRoaXMuY2lkLCByZXR2YWwsIGFyZ3VtZW50cyk7XG5cdFx0Ly8gXHRyZXR1cm4gISFyZXR2YWw7XG5cdFx0Ly8gfS5iaW5kKHRoaXMpO1xuXG5cdFx0dG91Y2hFbCA9IHRoaXMuY29udGVudDtcblx0XHQvLyB0b3VjaEVsID0gZG9jdW1lbnQuYm9keTtcblx0XHR2dG91Y2ggPSBodG91Y2ggPSBUb3VjaE1hbmFnZXIuaW5pdCh0b3VjaEVsKTtcblxuXHRcdC8vIHZ0b3VjaC5nZXQoXCJ2cGFuXCIpLnNldCh7IGVuYWJsZTogdGhpcy5fdnBhbkVuYWJsZUZuIH0pO1xuXHRcdC8vIGh0b3VjaC5nZXQoXCJocGFuXCIpLnNldCh7IGVuYWJsZTogdGhpcy5faHBhbkVuYWJsZUZuIH0pO1xuXHRcdC8vIFx0XHR2dG91Y2guc2V0KHtcblx0XHQvLyBcdFx0XHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHRcdFx0Y29uc29sZS5sb2coXCJhcHAxOjpoYW1tZXJqcyBlbmFibGVcIiwgYXJndW1lbnRzKTtcblx0XHQvLyBcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdC8vIFx0XHRcdH1cblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gaHBhbiA9IHZwYW47XG5cblx0XHQvLyB0aGlzLmVsLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7IC8vXCJwYW4teCBwYW4teVwiO1xuXG5cdFx0Ly8gdGFwID0gbmV3IEhhbW1lci5UYXAoKTtcblx0XHQvLyBocGFuID0gbmV3IFBhbih7XG5cdFx0Ly8gXHRldmVudDogXCJocGFuXCIsXG5cdFx0Ly8gXHRkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTFxuXHRcdC8vIH0pO1xuXHRcdC8vIGhwYW4uc2V0KHtcblx0XHQvLyBcdGVuYWJsZTogdGhpcy5faHBhbkVuYWJsZUZuXG5cdFx0Ly8gfSk7XG5cdFx0Ly8gdnBhbiA9IG5ldyBQYW4oe1xuXHRcdC8vIFx0ZXZlbnQ6IFwidnBhblwiLFxuXHRcdC8vIFx0ZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX1ZFUlRJQ0FMXG5cdFx0Ly8gfSk7XG5cdFx0Ly8gdnBhbi5zZXQoe1xuXHRcdC8vIFx0ZW5hYmxlOiB0aGlzLl92cGFuRW5hYmxlRm5cblx0XHQvLyB9KTtcblx0XHQvLyBocGFuLnJlcXVpcmVGYWlsdXJlKHZwYW4pO1xuXHRcdC8vIHZwYW4ucmVxdWlyZUZhaWx1cmUoaHBhbik7XG5cdFx0Ly8gdnRvdWNoLmFkZChbXSk7XG5cblx0XHQvLyBodG91Y2ggPSB2dG91Y2ggPSBuZXcgSGFtbWVyLk1hbmFnZXIodGhpcy5jb250ZW50KTtcblx0XHQvLyBodG91Y2guYWRkKFt0YXAsIGhwYW4sIHZwYW5dKTtcblx0XHQvLyBodG91Y2guYWRkKFtocGFuLCB2cGFuXSk7XG5cdFx0Ly8gaHRvdWNoLnNldCh7IHRvdWNoQWN0aW9uOiBcInBhbi14IHBhbi15XCIgfSk7XG5cblx0XHQvLyB2cGFuID0gbmV3IEhhbW1lcih0aGlzLm5hdmlnYXRpb24sIHtcblx0XHQvLyBcdHJlY29nbml6ZXJzOiBbXG5cdFx0Ly8gXHRcdFtQYW4sIHtcblx0XHQvLyBcdFx0XHRldmVudDogJ3ZwYW4nLFxuXHRcdC8vIFx0XHRcdHRvdWNoQWN0aW9uOiBcInBhbi15XCIsXG5cdFx0Ly8gXHRcdFx0ZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX1ZFUlRJQ0FMLFxuXHRcdC8vIFx0XHRcdGVuYWJsZTogdnBhbkVuYWJsZUZuXG5cdFx0Ly8gXHRcdH1dLFxuXHRcdC8vIFx0XVxuXHRcdC8vIH0pO1xuXHRcdC8vIGhwYW4gPSBuZXcgSGFtbWVyKHRoaXMuY29udGVudCwge1xuXHRcdC8vIFx0cmVjb2duaXplcnM6IFtcblx0XHQvLyBcdFx0W1Bhbiwge1xuXHRcdC8vIFx0XHRcdGV2ZW50OiAnaHBhbicsXG5cdFx0Ly8gXHRcdFx0dG91Y2hBY3Rpb246IFwicGFuLXhcIixcblx0XHQvLyBcdFx0XHRkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCxcblx0XHQvLyBcdFx0XHRlbmFibGU6IGhwYW5FbmFibGVGblxuXHRcdC8vIFx0XHR9XSxcblx0XHQvLyBcdFx0W1RhcF1cblx0XHQvLyBcdF1cblx0XHQvLyB9KTtcblx0XHQvLyBocGFuLmdldChcImhwYW5cIikucmVxdWlyZUZhaWx1cmUodnBhbi5nZXQoXCJ2cGFuXCIpKTtcblxuXHRcdC8vIHRoaXMuX2FmdGVyUmVuZGVyID0gdGhpcy5fYWZ0ZXJSZW5kZXIuYmluZCh0aGlzKTtcblx0XHR0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG5cblx0XHQvKiByZW5kZXIgb24gcmVzaXplLCBvbm9yaWVudGF0aW9uY2hhbmdlLCB2aXNpYmlsaXR5Y2hhbmdlICovXG5cdFx0Ly8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vblJlc2l6ZSwgZmFsc2UpO1xuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIF8uZGVib3VuY2UodGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSwgMzAsIGZhbHNlKSwgZmFsc2UpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX29uUmVzaXplLCBmYWxzZSk7XG5cblx0XHQvLyB2YXIgaCA9IGZ1bmN0aW9uKGV2KSB7IGNvbnNvbGUubG9nKGV2LnR5cGUsIGV2KSB9O1xuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGgsIGZhbHNlKTtcblx0XHQvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGgsIGZhbHNlKTtcblxuXHRcdC8qIFRPRE86IHJlcGxhY2UgcmVzaXplIHcvIG1lZGlhcXVlcnkgbGlzdGVuZXJzLiBDYXZlYXQ6IHNvbWUgY29tcG9uZW50c1xuXHRcdCh2Zy4gQ2Fyb3VzZWwpIHJlcXVpcmUgdXBkYXRlIG9uIHJlc2l6ZSAqL1xuXHRcdC8vIHRoaXMuX29uQnJlYWtwb2ludENoYW5nZSA9IHRoaXMuX29uQnJlYWtwb2ludENoYW5nZS5iaW5kKHRoaXMpO1xuXHRcdC8vIE9iamVjdC5rZXlzKEdsb2JhbHMuQlJFQUtQT0lOVFMpLmZvckVhY2goZnVuY3Rpb24ocykge1xuXHRcdC8vIFx0R2xvYmFscy5CUkVBS1BPSU5UU1tzXS5hZGRMaXN0ZW5lcnModGhpcy5fb25CcmVha3BvaW50Q2hhbmdlKTtcblx0XHQvLyB9LCB0aGlzKTtcblxuXG5cdFx0LyogaW5pdGlhbGl6ZSBjb250cm9sbGVyL21vZGVsIGxpc3RlbmVycyBCRUZPUkUgdmlld3MgcmVnaXN0ZXIgdGhlaXIgb3duICovXG5cdFx0dGhpcy5saXN0ZW5Ubyhjb250cm9sbGVyLCBcInJvdXRlXCIsIHRoaXMuX29uUm91dGUpO1xuXHRcdC8vIHRoaXMubGlzdGVuVG8oY29udHJvbGxlciwgXCJjaGFuZ2U6YWZ0ZXJcIiwgdGhpcy5fYWZ0ZXJDb250cm9sbGVyQ2hhbmdlZCk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcImNoYW5nZVwiLCB0aGlzLl9vbk1vZGVsQ2hhbmdlKTsgLyogRklYTUUgKi9cblxuXHRcdC8qIGluaXRpYWxpemUgdmlld3MgKi9cblx0XHR0aGlzLm5hdmlnYXRpb25WaWV3ID0gbmV3IE5hdmlnYXRpb25WaWV3KHtcblx0XHRcdGVsOiB0aGlzLm5hdmlnYXRpb24sXG5cdFx0XHRtb2RlbDogdGhpcy5tb2RlbCxcblx0XHRcdHZwYW46IHZ0b3VjaCxcblx0XHRcdGhwYW46IGh0b3VjaFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5jb250ZW50VmlldyA9IG5ldyBDb250ZW50Vmlldyh7XG5cdFx0XHRlbDogdGhpcy5jb250ZW50LFxuXHRcdFx0bW9kZWw6IHRoaXMubW9kZWwsXG5cdFx0XHR2cGFuOiB2dG91Y2gsXG5cdFx0XHRocGFuOiBodG91Y2gsXG5cdFx0fSk7XG5cblx0XHQvKiBUb3VjaEV2ZW50cyBmaXh1cHNcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdFx0Ly8gdmFyIHRyYWNlVG91Y2hFdmVudCA9IChtc2csIHRyYWNlT2JqKSA9PiB7XG5cdFx0Ly8gXHRpZiAobXNnLmhhc093blByb3BlcnR5KFwidHlwZVwiKSkge1xuXHRcdC8vIFx0XHRtc2cgPSBtc2cudHlwZSArIFwiIDogXCIgK1xuXHRcdC8vIFx0XHRcdChtc2cuZGVmYXVsdFByZXZlbnRlZCA/IFwicHJldmVudGVkXCIgOiBcIm5vdCBwcmV2ZW50ZWRcIik7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHR2YXIgc3ksIHNoLCBjaDtcblx0XHQvLyBcdHN5ID0gdGhpcy5lbC5zY3JvbGxUb3A7XG5cdFx0Ly8gXHRzaCA9IHRoaXMuZWwuc2Nyb2xsSGVpZ2h0IC0gMTtcblx0XHQvLyBcdGNoID0gdGhpcy5lbC5jbGllbnRIZWlnaHQ7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhcIiVzOlslc10gXCIgK1xuXHRcdC8vIFx0XHRcInN5OlsxPiVvPj0lcyA9ICVvXSBcIiArXG5cdFx0Ly8gXHRcdFwic2g6WyVvPD0lbyA9ICVvXSBcIiArXG5cdFx0Ly8gXHRcdFwibmF2Oltjc3M6JW8gdmFsOiVvXVwiLFxuXHRcdC8vIFx0XHR0aGlzLmNpZCwgbXNnLFxuXHRcdC8vIFx0XHRzeSwgc2ggLSBjaCwgKDEgPD0gc3kgPD0gKHNoIC0gY2gpKSxcblx0XHQvLyBcdFx0c2gsIGNoLCAoc2ggPD0gY2gpLFxuXHRcdC8vIFx0XHR0aGlzLm5hdmlnYXRpb25WaWV3LmVsLnN0eWxlLmhlaWdodCxcblx0XHQvLyBcdFx0dGhpcy5uYXZpZ2F0aW9uVmlldy5lbC5zY3JvbGxIZWlnaHQsXG5cdFx0Ly8gXHRcdHRyYWNlT2JqIHx8IFwiXCJcblx0XHQvLyBcdCk7XG5cdFx0Ly8gfTtcblxuXG5cdFx0Ly8gdmFyIHNjcm9sbHRvdWNoID0gbmV3IEhhbW1lci5NYW5hZ2VyKHRoaXMuZWwpO1xuXHRcdC8vIHNjcm9sbHRvdWNoLmFkZChuZXcgSGFtbWVyLlBhbih7IGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCwgdGhyZXNob2xkOiAwIH0pKTtcblx0XHQvLyBzY3JvbGx0b3VjaC5vbihcInBhbm1vdmVcIiwgZnVuY3Rpb24oZXYpIHtcblx0XHQvL1xuXHRcdC8vIFx0Ly8gdmFyIHN5LCBzaCwgY2g7XG5cdFx0Ly8gXHQvLyBzeSA9IHRoaXMuZWwuc2Nyb2xsVG9wO1xuXHRcdC8vIFx0Ly8gc2ggPSB0aGlzLmVsLnNjcm9sbEhlaWdodCAtIDE7XG5cdFx0Ly8gXHQvLyBjaCA9IHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuXHRcdC8vIFx0Ly9cblx0XHQvLyBcdC8vIGlmICgoMSA+IHN5KSAmJiAoZXYuZGlyZWN0aW9uIHwgSGFtbWVyLkRJUkVDVElPTl9ET1dOKSkge1xuXHRcdC8vIFx0Ly8gXHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIFx0Ly8gXHRjb25zb2xlLmxvZyhcIiVzOltwYW5tb3ZlXSAlc1wiLCB0aGlzLmNpZCwgXCJwcmV2ZW50IGF0IHRvcFwiKTtcblx0XHQvLyBcdC8vIH0gZWxzZVxuXHRcdC8vIFx0Ly8gaWYgKChzeSA+IChzaCAtIGNoKSkgJiYgKGV2LmRpcmVjdGlvbiB8IEhhbW1lci5ESVJFQ1RJT05fVVApKSB7XG5cdFx0Ly8gXHQvLyBcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gXHQvLyBcdGNvbnNvbGUubG9nKFwiJXM6W3Bhbm1vdmVdICVzXCIsIHRoaXMuY2lkLCBcInByZXZlbnQgYXQgYm90dG9tXCIpO1xuXHRcdC8vIFx0Ly8gfVxuXHRcdC8vIFx0aWYgKCh0aGlzLmVsLnNjcm9sbEhlaWdodCAtIDEpIDw9IHRoaXMuZWwuY2xpZW50SGVpZ2h0KSB7XG5cdFx0Ly8gXHRcdGV2LnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHQvLyB0cmFjZVRvdWNoRXZlbnQoZXYpO1xuXHRcdC8vIH0uYmluZCh0aGlzKSk7XG5cblx0XHR2YXIgdG91Y2hPcHRzID0geyBjYXB0dXJlOiBmYWxzZSwgcGFzc2l2ZTogZmFsc2UgfTtcblx0XHR2YXIgb25Ub3VjaFN0YXJ0ID0gKGV2KSA9PiB7XG5cdFx0XHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25Ub3VjaE1vdmUsIHRvdWNoT3B0cyk7XG5cdFx0XHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCB0b3VjaE9wdHMpO1xuXHRcdFx0dGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgb25Ub3VjaEVuZCwgdG91Y2hPcHRzKTtcblx0XHR9O1xuXG5cdFx0dmFyIG9uVG91Y2hNb3ZlID0gKGV2KSA9PiB7XG5cdFx0XHRpZiAoIWV2LmRlZmF1bHRQcmV2ZW50ZWQgJiYgKHRoaXMuZWwuc2Nyb2xsSGVpZ2h0IC0gMSkgPD0gdGhpcy5lbC5jbGllbnRIZWlnaHQpIHtcblx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdC8vdHJhY2VUb3VjaEV2ZW50KGV2KTtcblx0XHR9O1xuXG5cdFx0dmFyIG9uVG91Y2hFbmQgPSAoZXYpID0+IHtcblx0XHRcdHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvblRvdWNoTW92ZSwgdG91Y2hPcHRzKTtcblx0XHRcdHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uVG91Y2hFbmQsIHRvdWNoT3B0cyk7XG5cdFx0XHR0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBvblRvdWNoRW5kLCB0b3VjaE9wdHMpO1xuXHRcdH07XG5cblx0XHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uVG91Y2hTdGFydCk7XG5cblx0XHR2YXIgb25NZWFzdXJlZCA9ICh2aWV3KSA9PiB7XG5cdFx0XHR0aGlzLnNldEltbWVkaWF0ZSgoKSA9PiB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoKHRoaXMuZWwuc2Nyb2xsSGVpZ2h0IC0gMSkgPD0gdGhpcy5lbC5jbGllbnRIZWlnaHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuZWwuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5lbC5zdHlsZS5vdmVyZmxvd1kgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmVsLnNjcm9sbFRvcCA9IDE7XG5cdFx0XHRcdFx0Ly90cmFjZVRvdWNoRXZlbnQoXCJ2aWV3OmNvbGxhcHNlZDptZWFzdXJlZFwiKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHRoaXMubGlzdGVuVG8odGhpcy5uYXZpZ2F0aW9uVmlldywgXCJ2aWV3OmNvbGxhcHNlZDptZWFzdXJlZFwiLCBvbk1lYXN1cmVkKTtcblxuXG5cdFx0LyogR29vZ2xlIEFuYWx5dGljc1xuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0XHRpZiAod2luZG93LmdhICYmIHdpbmRvdy5HQV9JRCkge1xuXHRcdFx0Y29udHJvbGxlclxuXHRcdFx0XHQub25jZShcInJvdXRlXCIsICgpID0+IHtcblx0XHRcdFx0XHR3aW5kb3cuZ2EoXCJjcmVhdGVcIiwgd2luZG93LkdBX0lELCBcImF1dG9cIik7XG5cdFx0XHRcdFx0Ly8gaWYgbG9jYWxob3N0IG9yIGR1bW15IElELCBkaXNhYmxlIGFuYWx5dGljc1xuXHRcdFx0XHRcdGlmICgvKD86KGxvY2FsaG9zdHxcXC5sb2NhbCkpJC8udGVzdChsb2NhdGlvbi5ob3N0bmFtZSlcblx0XHRcdFx0XHRcdHx8IHdpbmRvdy5HQV9JRCA9PSBcIlVBLTAwMDAwMDAtMFwiKSB7XG5cdFx0XHRcdFx0XHR3aW5kb3cuZ2EoXCJzZXRcIiwgXCJzZW5kSGl0VGFza1wiLCBudWxsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiR0EgZW5hYmxlZCB0YWcgJyVzJ1wiLCB3aW5kb3cuR0FfSUQpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJyb3V0ZVwiLCAobmFtZSkgPT4ge1xuXHRcdFx0XHRcdHZhciBwYWdlID0gQmFja2JvbmUuaGlzdG9yeS5nZXRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdC8vIEFkZCBhIHNsYXNoIGlmIG5lY2Nlc2FyeVxuXHRcdFx0XHRcdGlmIChwYWdlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG5cdFx0XHRcdFx0XHRwYWdlID0gJy8nICsgcGFnZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcGFnZS5yZXBsYWNlKC9eKD8hXFwvKS8sIFwiL1wiKTtcblx0XHRcdFx0XHR3aW5kb3cuZ2EoXCJzZXRcIiwgXCJwYWdlXCIsIHBhZ2UpO1xuXHRcdFx0XHRcdHdpbmRvdy5nYShcInNlbmRcIiwgXCJwYWdldmlld1wiKTtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcIkdBIHBhZ2Ugc2V0IHRvICclcydcIiwgcGFnZSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJHQSBub3QgZW5hYmxlZCAoTElCOiAlcywgR0FfRU5BQkxFRDogJXMsIEdBX0lEOiAlcylcIiwgISF3aW5kb3cuZ2EsIHdpbmRvdy5HQV9FTkFCTEVELCB3aW5kb3cuR0FfSUQpO1xuXHRcdH1cblxuXHRcdC8qIFN0YXJ0dXAgbGlzdGVuZXIsIGFkZGVkIGxhc3QgKi9cblx0XHR0aGlzLmxpc3RlblRvT25jZShjb250cm9sbGVyLCBcInJvdXRlXCIsIHRoaXMuX2FwcFN0YXJ0KTtcblxuXHRcdC8qIHN0YXJ0IHJvdXRlciwgd2hpY2ggd2lsbCByZXF1ZXN0IGFwcHJvcGlhdGUgc3RhdGUgKi9cblx0XHRCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KHtcblx0XHRcdHB1c2hTdGF0ZTogZmFsc2UsXG5cdFx0XHRoYXNoQ2hhbmdlOiB0cnVlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogX2FwcFN0YXJ0XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfYXBwU3RhcnQ6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcblx0XHRjb25zb2xlLmluZm8oXCIlczo6X2FwcFN0YXJ0KCVzLCAlcylcIiwgdGhpcy5jaWQsIG5hbWUsIGFyZ3Muam9pbigpKTtcblx0XHR0aGlzLnNraXBUcmFuc2l0aW9ucyA9IHRydWU7XG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwic2tpcC10cmFuc2l0aW9uc1wiKTtcblxuXHRcdHRoaXMucmVxdWVzdFJlbmRlcihWaWV3Lk1PREVMX0lOVkFMSUQgfCBWaWV3LlNJWkVfSU5WQUxJRClcblx0XHRcdC5yZXF1ZXN0Q2hpbGRyZW5SZW5kZXIoVmlldy5NT0RFTF9JTlZBTElEIHwgVmlldy5TSVpFX0lOVkFMSUQpXG5cdFx0XHQubGlzdGVuVG9PbmNlKHRoaXMsIFwidmlldzpyZW5kZXI6YWZ0ZXJcIiwgZnVuY3Rpb24odmlldywgZmxhZ3MpIHtcblx0XHRcdFx0Ly8gdGhpcy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9hcHBTdGFydFt2aWV3OnJlbmRlcjphZnRlcl1bcmFmXVwiLCB0aGlzLmNpZCk7XG5cdFx0XHRcdFx0dGhpcy5za2lwVHJhbnNpdGlvbnMgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJza2lwLXRyYW5zaXRpb25zXCIpO1xuXHRcdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImFwcC1pbml0aWFsXCIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHJvdXRlIGNoYW5nZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uUm91dGU6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcblx0XHRjb25zb2xlLmluZm8oXCIlczo6X29uUm91dGUgJW8gLT4gJW9cIiwgdGhpcy5jaWQsIHRoaXMubW9kZWwuZ2V0KFwicm91dGVOYW1lXCIpLCBuYW1lKTtcblx0XHQvLyB2YXIgbyA9IF8uZGVmYXVsdHMoeyByb3V0ZU5hbWU6IG5hbWUgfSwgQXBwU3RhdGUucHJvdG90eXBlLmRlZmF1bHRzKTtcblx0XHR2YXIgbyA9IHtcblx0XHRcdHJvdXRlTmFtZTogbmFtZSxcblx0XHRcdGJ1bmRsZTogbnVsbCxcblx0XHRcdG1lZGlhOiBudWxsLFxuXHRcdFx0YXJ0aWNsZTogbnVsbFxuXHRcdH07XG5cdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRjYXNlIFwibWVkaWEtaXRlbVwiOlxuXHRcdFx0XHRvLmJ1bmRsZSA9IGJ1bmRsZXMuc2VsZWN0ZWQ7XG5cdFx0XHRcdC8vIG8ud2l0aEJ1bmRsZSA9IHRydWU7XG5cdFx0XHRcdG8ubWVkaWEgPSBvLmJ1bmRsZS5tZWRpYS5zZWxlY3RlZDtcblx0XHRcdFx0Ly8gby53aXRoTWVkaWEgPSB0cnVlO1xuXHRcdFx0XHRvLmNvbGxhcHNlZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImJ1bmRsZS1pdGVtXCI6XG5cdFx0XHRcdG8uYnVuZGxlID0gYnVuZGxlcy5zZWxlY3RlZDtcblx0XHRcdFx0Ly8gby53aXRoQnVuZGxlID0gdHJ1ZTtcblx0XHRcdFx0by5jb2xsYXBzZWQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJhcnRpY2xlLWl0ZW1cIjpcblx0XHRcdFx0by5hcnRpY2xlID0gYXJ0aWNsZXMuc2VsZWN0ZWQ7XG5cdFx0XHRcdC8vIG8ud2l0aEFydGljbGUgPSB0cnVlO1xuXHRcdFx0XHRvLmNvbGxhcHNlZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImJ1bmRsZS1saXN0XCI6XG5cdFx0XHRjYXNlIFwibm90Zm91bmRcIjpcblx0XHRcdGNhc2UgXCJyb290XCI6XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRvLmNvbGxhcHNlZCA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Ly8gY29uc29sZS5sb2coXCIlczo6X29uUm91dGUgYXJnczogJW9cIiwgdGhpcy5jaWQsIG5hbWUsIGFyZ3MpO1xuXHRcdHRoaXMubW9kZWwuc2V0KG8pO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIG1vZGVsIGNoYW5nZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uTW9kZWxDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChERUJVRykge1xuXHRcdFx0Y29uc29sZS5ncm91cENvbGxhcHNlZCh0aGlzLmNpZCArIFwiOjpfb25Nb2RlbENoYW5nZVwiKTtcblx0XHRcdGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJjaGFuZ2VzXCIpO1xuXHRcdFx0T2JqZWN0LmtleXModGhpcy5tb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRjb25zb2xlLmluZm8oXCIlczo6X29uTW9kZWxDaGFuZ2UgJXM6ICVzIC0+ICVzXCIsIHRoaXMuY2lkLCBrZXksXG5cdFx0XHRcdFx0dGhpcy5tb2RlbC5wcmV2aW91cyhrZXkpLFxuXHRcdFx0XHRcdHRoaXMubW9kZWwuZ2V0KGtleSkpO1xuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFtcIkFydGljbGVcIiwgXCJCdW5kbGVcIiwgXCJNZWRpYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dmFyIGtleSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0Y29uc29sZVt0aGlzLmhhc0NoYW5nZWQoXCJ3aXRoXCIgKyBuYW1lKSA9PSB0aGlzLmhhc0FueUNoYW5nZWQoa2V5KSA/IFwibG9nXCIgOiBcIndhcm5cIl0uY2FsbChjb25zb2xlLCBcIiVzOjpfb25Nb2RlbENoYW5nZSB3aXRoJXM6ICVvIHdpdGglc0NoYW5nZWQ6ICVvXCIsIHRoaXMuY2lkLFxuXHRcdFx0XHRcdG5hbWUsIHRoaXMuaGFzKGtleSksXG5cdFx0XHRcdFx0bmFtZSwgdGhpcy5oYXNBbnlDaGFuZ2VkKGtleSlcblx0XHRcdFx0KTtcblx0XHRcdH0sIHRoaXMubW9kZWwpO1xuXHRcdFx0Y29uc29sZS5ncm91cEVuZCgpO1xuXG5cdFx0XHR0aGlzLm9uY2UoXCJ2aWV3OnJlbmRlcjphZnRlclwiLCBmdW5jdGlvbih2aWV3LCBmbGFncykge1xuXHRcdFx0XHRjb25zb2xlLmluZm8oXCIlczo6X29uTW9kZWxDaGFuZ2UgW3ZpZXc6cmVuZGVyOmFmdGVyXVwiLCB2aWV3LmNpZCk7XG5cdFx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMucmVxdWVzdFJlbmRlcihWaWV3Lk1PREVMX0lOVkFMSUQpO1xuXHRcdC8vIHRoaXMucmVxdWVzdENoaWxkcmVuUmVuZGVyKFZpZXcuTU9ERUxfSU5WQUxJRCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiByZXNpemVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24oZXYpIHtcblx0XHRjb25zb2xlLmdyb3VwKHRoaXMuY2lkICsgXCI6Ol9vblJlc2l6ZSBbZXZlbnRdXCIpO1xuXHRcdHRoaXMuc2tpcFRyYW5zaXRpb25zID0gdHJ1ZTtcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJza2lwLXRyYW5zaXRpb25zXCIpO1xuXG5cdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKFZpZXcuU0laRV9JTlZBTElEKVxuXHRcdFx0Ly8gLndoZW5SZW5kZXJlZCgpLnRoZW4oZnVuY3Rpb24odmlldykge1xuXHRcdFx0Lm9uY2UoXCJ2aWV3OnJlbmRlcjphZnRlclwiLCBmdW5jdGlvbih2aWV3LCBmbGFncykge1xuXHRcdFx0XHQvLyB0aGlzLnJlcXVlc3RDaGlsZHJlblJlbmRlcihWaWV3LlNJWkVfSU5WQUxJRCwgdHJ1ZSk7XG5cdFx0XHRcdC8vIHRoaXMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjb25zb2xlLmluZm8oXCIlczo6X29uUmVzaXplIFt2aWV3OnJlbmRlcjphZnRlcl1bcmFmXVwiLCB2aWV3LmNpZCk7XG5cdFx0XHRcdFx0dmlldy5za2lwVHJhbnNpdGlvbnMgPSBmYWxzZTtcblx0XHRcdFx0XHR2aWV3LmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJza2lwLXRyYW5zaXRpb25zXCIpO1xuXHRcdFx0XHRcdHRoaXMuZWwuc2Nyb2xsVG9wID0gMTtcblx0XHRcdFx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9KTtcblx0XHRpZiAoZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgPT09IG51bGwpIHRoaXMucmVuZGVyTm93KCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiByZW5kZXJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHJlbmRlckZyYW1lOiBmdW5jdGlvbih0c3RhbXAsIGZsYWdzKSB7XG5cdFx0Y29uc29sZS5sb2coXCIlczo6cmVuZGVyRnJhbWUgWyVzXVwiLCB0aGlzLmNpZCwgVmlldy5mbGFnc1RvU3RyaW5nKGZsYWdzKSk7XG5cblx0XHQvKiBtb2RlbDogc2V0IHJvdXRlICYgbW9kZWwgaWQgY2xhc3NlcyAqL1xuXHRcdGlmIChmbGFncyAmIFZpZXcuTU9ERUxfSU5WQUxJRCkge1xuXHRcdFx0dGhpcy5yZW5kZXJNb2RlbENoYW5nZShmbGFncyk7XG5cdFx0fVxuXG5cdFx0Lyogc2l6ZTogY2hlY2sgYnJlYWtwb2ludHMgYW5kIHNldCBjbGFzc2VzKi9cblx0XHRpZiAoZmxhZ3MgJiBWaWV3LlNJWkVfSU5WQUxJRCkge1xuXHRcdFx0Xy5lYWNoKEdsb2JhbHMuQlJFQUtQT0lOVFMsIGZ1bmN0aW9uKG8sIHMpIHtcblx0XHRcdFx0dGhpcy50b2dnbGUocywgby5tYXRjaGVzKTtcblx0XHRcdH0sIHRoaXMuYnJlYWtwb2ludEVsLmNsYXNzTGlzdCk7XG5cdFx0fVxuXHRcdC8qIHJlcXVlc3QgY2hpbGRyZW4gcmVuZGVyOiAgYWx3YXlzIHJlbmRlciBub3cgKi9cblx0XHR0aGlzLnJlcXVlc3RDaGlsZHJlblJlbmRlcihmbGFncywgdHJ1ZSk7XG5cdFx0LyogcmVxdWVzdCBjaGlsZHJlbiByZW5kZXI6ICBzZXQgJ25vdycgZmxhZyBpZiBzaXplIGlzIGludmFsaWQgKi9cblx0XHQvLyB0aGlzLnJlcXVlc3RDaGlsZHJlblJlbmRlcihmbGFncywgZmxhZ3MgJiBWaWV3LlNJWkVfSU5WQUxJRCk7XG5cblx0XHQvLyBpZiAoKHRoaXMuZWwuc2Nyb2xsSGVpZ2h0IC0gMSkgPD0gdGhpcy5lbC5jbGllbnRIZWlnaHQpIHtcblx0XHQvLyBcdHRoaXMuZWwuc2Nyb2xsVG9wID0gMTtcblx0XHQvLyBcdHRoaXMuZWwuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcblx0XHQvLyB9IGVsc2Uge1xuXHRcdC8vIFx0dGhpcy5lbC5zdHlsZS5vdmVyZmxvd1kgPSBcIlwiO1xuXHRcdC8vIH1cblx0XHQvLyB0aGlzLm5hdmlnYXRpb25WaWV3LndoZW5SZW5kZXJlZCgpLnRoZW4oZnVuY3Rpb24odmlldykge1xuXHRcdC8vIFx0dGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0Ly8gXHRcdGNvbnNvbGUubG9nKFwiJXM6OnJlbmRlckZyYW1lIFtyYWZdIGNzczolbyB2YWw6JW9cIixcblx0XHQvLyBcdFx0XHR0aGlzLmNpZCxcblx0XHQvLyBcdFx0XHR0aGlzLm5hdmlnYXRpb25WaWV3LmVsLnN0eWxlLmhlaWdodCxcblx0XHQvLyBcdFx0XHR0aGlzLm5hdmlnYXRpb25WaWV3LmVsLnNjcm9sbEhlaWdodCxcblx0XHQvLyBcdFx0XHR0aGlzLmVsLnNjcm9sbFRvcCxcblx0XHQvLyBcdFx0XHR0aGlzLmVsLnNjcm9sbEhlaWdodCAtIDEsXG5cdFx0Ly8gXHRcdFx0dGhpcy5lbC5jbGllbnRIZWlnaHQsXG5cdFx0Ly8gXHRcdFx0KHRoaXMuZWwuc2Nyb2xsSGVpZ2h0IC0gMSkgPD0gdGhpcy5lbC5jbGllbnRIZWlnaHQsXG5cdFx0Ly8gXHRcdFx0dGhpcy5lbC5zdHlsZS5vdmVyZmxvd1lcblx0XHQvLyBcdFx0KTtcblx0XHQvLyBcdH0pO1xuXHRcdC8vIH0uYmluZCh0aGlzKSk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBib2R5IGNsYXNzZXMgZXRjXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRyZW5kZXJNb2RlbENoYW5nZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgY2xzID0gdGhpcy5lbC5jbGFzc0xpc3Q7XG5cdFx0dmFyIHByZXZBdHRyID0gbnVsbDtcblx0XHR2YXIgZG9jVGl0bGUgPSBbXTtcblx0XHR2YXIgaGFzRGFya0JnID0gZmFsc2U7XG5cblx0XHRkb2NUaXRsZS5wdXNoKEdsb2JhbHMuQVBQX05BTUUpO1xuXHRcdGlmICh0aGlzLm1vZGVsLmdldChcImJ1bmRsZVwiKSkge1xuXHRcdFx0ZG9jVGl0bGUucHVzaChzdHJpcFRhZ3ModGhpcy5tb2RlbC5nZXQoXCJidW5kbGVcIikuZ2V0KFwibmFtZVwiKSkpO1xuXHRcdFx0aWYgKHRoaXMubW9kZWwuZ2V0KFwibWVkaWFcIikpIHtcblx0XHRcdFx0ZG9jVGl0bGUucHVzaChzdHJpcFRhZ3ModGhpcy5tb2RlbC5nZXQoXCJtZWRpYVwiKS5nZXQoXCJuYW1lXCIpKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm1vZGVsLmdldChcImFydGljbGVcIikpIHtcblx0XHRcdGRvY1RpdGxlLnB1c2goc3RyaXBUYWdzKHRoaXMubW9kZWwuZ2V0KFwiYXJ0aWNsZVwiKS5nZXQoXCJuYW1lXCIpKSk7XG5cdFx0fVxuXHRcdGRvY3VtZW50LnRpdGxlID0gXy51bmVzY2FwZShkb2NUaXRsZS5qb2luKFwiIC8gXCIpKTtcblxuXHRcdC8qIFNldCByb3V0ZSBjbGFzcyAqL1xuXHRcdGlmICh0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJyb3V0ZU5hbWVcIikpIHtcblxuXHRcdFx0cHJldkF0dHIgPSB0aGlzLm1vZGVsLnByZXZpb3VzKFwiZnJvbVJvdXRlTmFtZVwiKTtcblx0XHRcdGlmIChwcmV2QXR0cikge1xuXHRcdFx0XHRjbHMucmVtb3ZlKFwiZnJvbS1yb3V0ZS1cIiArIHByZXZBdHRyKTtcblx0XHRcdH1cblx0XHRcdGNscy5hZGQoXCJmcm9tLXJvdXRlLVwiICsgdGhpcy5tb2RlbC5nZXQoXCJmcm9tUm91dGVOYW1lXCIpKTtcblxuXHRcdFx0cHJldkF0dHIgPSB0aGlzLm1vZGVsLnByZXZpb3VzKFwicm91dGVOYW1lXCIpO1xuXHRcdFx0aWYgKHByZXZBdHRyKSB7XG5cdFx0XHRcdGNscy5yZW1vdmUoXCJyb3V0ZS1cIiArIHByZXZBdHRyKTtcblx0XHRcdFx0Ly8gdGhpcy5lbC5zZXRBdHRyaWJ1dGUoXCJmcm9tLXJvdXRlXCIsIHByZXZBdHRyKTtcblx0XHRcdH1cblx0XHRcdC8vIHRoaXMuZWwuc2V0QXR0cmlidXRlKFwidG8tcm91dGVcIiwgdGhpcy5tb2RlbC5nZXQoXCJyb3V0ZU5hbWVcIikpO1xuXHRcdFx0Y2xzLmFkZChcInJvdXRlLVwiICsgdGhpcy5tb2RlbC5nZXQoXCJyb3V0ZU5hbWVcIikpO1xuXHRcdH1cblxuXHRcdC8qIFNldCBtb2RlbCBpZCBjbGFzc2VzIGZvciBjb2xvciBzdHlsZXMgKi9cblx0XHRbXCJhcnRpY2xlXCIsIFwiYnVuZGxlXCIsIFwibWVkaWFcIl0uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMubW9kZWwuZ2V0KHByb3ApO1xuXHRcdFx0aWYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChwcm9wKSkge1xuXHRcdFx0XHRwcmV2QXR0ciA9IHRoaXMubW9kZWwucHJldmlvdXMocHJvcCk7XG5cdFx0XHRcdGlmIChwcmV2QXR0cikge1xuXHRcdFx0XHRcdGNscy5yZW1vdmUocHJldkF0dHIuZ2V0KFwiZG9taWRcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpdGVtKSB7XG5cdFx0XHRcdFx0Y2xzLmFkZChpdGVtLmdldChcImRvbWlkXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2xzLnRvZ2dsZShcIndpdGgtXCIgKyBwcm9wLCAhIWl0ZW0pO1xuXHRcdFx0Y2xzLnRvZ2dsZShcIndpdGhvdXQtXCIgKyBwcm9wLCAhaXRlbSk7XG5cdFx0XHRoYXNEYXJrQmcgfD0gKGl0ZW0gJiYgaXRlbS5jb2xvcnMgJiYgaXRlbS5jb2xvcnMuaGFzRGFya0JnKTtcblx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0LyogZmxhZyBkYXJrIGJhY2tncm91bmQgKi9cblx0XHRjbHMudG9nZ2xlKFwiY29sb3ItZGFya1wiLCBoYXNEYXJrQmcpO1xuXHR9LFxufSwge1xuXHRnZXRJbnN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCEod2luZG93LmFwcCBpbnN0YW5jZW9mIHRoaXMpKSB7XG5cdFx0XHR3aW5kb3cuYXBwID0gbmV3KHRoaXMpKHtcblx0XHRcdFx0bW9kZWw6IG5ldyBBcHBTdGF0ZSgpXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHdpbmRvdy5hcHA7XG5cdH1cbn0pO1xuXG5pZiAoREVCVUcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oQXBwVmlldykge1xuXHRcdC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9kZWJ1Zy9EZWJ1Z1Rvb2xiYXJ9ICovXG5cdFx0dmFyIERlYnVnVG9vbGJhciA9IHJlcXVpcmUoXCJhcHAvZGVidWcvRGVidWdUb29sYmFyXCIpO1xuXG5cdFx0cmV0dXJuIEFwcFZpZXcuZXh0ZW5kKHtcblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmV0dmFsO1xuXHRcdFx0XHR2YXIgdmlldyA9IG5ldyBEZWJ1Z1Rvb2xiYXIoe1xuXHRcdFx0XHRcdGlkOiBcImRlYnVnLXRvb2xiYXJcIixcblx0XHRcdFx0XHRtb2RlbDogdGhpcy5tb2RlbFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWV3LnJlbmRlcigpLmVsKTtcblx0XHRcdFx0cmV0dmFsID0gQXBwVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLl9sb2dGbGFnc1tcInZpZXcudHJhY2VcIl0gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLm5hdmlnYXRpb25WaWV3Ll9sb2dGbGFnc1tcInZpZXcudHJhY2VcIl0gPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gcmV0dmFsO1xuXHRcdFx0fSxcblx0XHR9KVxuXHR9KShtb2R1bGUuZXhwb3J0cyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9Db250ZW50Vmlld1xuICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0dsb2JhbHN9ICovXG5jb25zdCBHbG9iYWxzID0gcmVxdWlyZShcImFwcC9jb250cm9sL0dsb2JhbHNcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9UcmFuc2Zvcm1IZWxwZXJ9ICovXG5jb25zdCBUcmFuc2Zvcm1IZWxwZXIgPSByZXF1aXJlKFwidXRpbHMvVHJhbnNmb3JtSGVscGVyXCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9Ub3VjaE1hbmFnZXJ9ICovXG4vLyB2YXIgVG91Y2hNYW5hZ2VyID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVG91Y2hNYW5hZ2VyXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9Db250cm9sbGVyfSAqL1xuY29uc3QgY29udHJvbGxlciA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9Db250cm9sbGVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvbn0gKi9cbmNvbnN0IGJ1bmRsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvblwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0FydGljbGVDb2xsZWN0aW9ufSAqL1xuY29uc3QgYXJ0aWNsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQXJ0aWNsZUNvbGxlY3Rpb25cIik7XG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0J1bmRsZUl0ZW19ICovXG4vLyB2YXIgQnVuZGxlSXRlbSA9IHJlcXVpcmUoXCJhcHAvbW9kZWwvaXRlbS9CdW5kbGVJdGVtXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9BcnRpY2xlVmlld30gKi9cbmNvbnN0IEFydGljbGVWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9BcnRpY2xlVmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9Db2xsZWN0aW9uU3RhY2t9ICovXG5jb25zdCBDb2xsZWN0aW9uU3RhY2sgPSByZXF1aXJlKFwiYXBwL3ZpZXcvY29tcG9uZW50L0NvbGxlY3Rpb25TdGFja1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9Db2xsZWN0aW9uU3RhY2t9ICovXG5jb25zdCBTZWxlY3RhYmxlTGlzdFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvY29tcG9uZW50L1NlbGVjdGFibGVMaXN0Vmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3JlbmRlci9Eb3ROYXZpZ2F0aW9uUmVuZGVyZXJ9ICovXG5jb25zdCBEb3ROYXZpZ2F0aW9uUmVuZGVyZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcmVuZGVyL0RvdE5hdmlnYXRpb25SZW5kZXJlclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9DYXJvdXNlbH0gKi9cbmNvbnN0IENhcm91c2VsID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9DYXJvdXNlbFwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL0Nhcm91c2VsUmVuZGVyZXJ9ICovXG5jb25zdCBDYXJvdXNlbFJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9DYXJvdXNlbFJlbmRlcmVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL0ltYWdlUmVuZGVyZXJ9ICovXG5jb25zdCBJbWFnZVJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9JbWFnZVJlbmRlcmVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL1ZpZGVvUmVuZGVyZXJ9ICovXG5jb25zdCBWaWRlb1JlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9WaWRlb1JlbmRlcmVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL1NlcXVlbmNlUmVuZGVyZXJ9ICovXG5jb25zdCBTZXF1ZW5jZVJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9TZXF1ZW5jZVJlbmRlcmVyXCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0NhbnZhc1Byb2dyZXNzTWV0ZXJ9ICovXG4vLyB2YXIgUHJvZ3Jlc3NNZXRlciA9IHJlcXVpcmUoXCJhcHAvdmlldy9jb21wb25lbnQvQ2FudmFzUHJvZ3Jlc3NNZXRlclwiKTtcblxuLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbmNvbnN0IGNhcm91c2VsRW1wdHlUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL3RlbXBsYXRlL0Nhcm91c2VsLkVtcHR5UmVuZGVyZXIuQnVuZGxlLmhic1wiKTtcbi8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5jb25zdCBtZWRpYVN0YWNrVGVtcGxhdGUgPSByZXF1aXJlKFwiLi90ZW1wbGF0ZS9Db2xsZWN0aW9uU3RhY2suTWVkaWEuaGJzXCIpO1xuXG4vLyB2YXIgdHJhbnNpdGlvbkVuZCA9IFZpZXcucHJlZml4ZWRFdmVudChcInRyYW5zaXRpb25lbmRcIik7XG52YXIgdHJhbnNmb3JtUHJvcCA9IFZpZXcucHJlZml4ZWRQcm9wZXJ0eShcInRyYW5zZm9ybVwiKTtcbnZhciB0cmFuc2l0aW9uUHJvcCA9IFZpZXcucHJlZml4ZWRQcm9wZXJ0eShcInRyYW5zaXRpb25cIik7XG5cbnZhciB0eCA9IEdsb2JhbHMudHJhbnNpdGlvbnM7XG5cblxuLy8gdmFyIGNsaWNrRXZlbnQgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJvbnBvaW50ZXJ1cFwiKSA/IFwicG9pbnRlcnVwXCIgOiBcIm1vdXNldXBcIixcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvQ29udGVudFZpZXd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2lkUHJlZml4OiBcImNvbnRlbnRWaWV3XCIsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjbGFzc05hbWU6IFwiY29udGFpbmVyLWV4cGFuZGVkXCIsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRldmVudHM6IHtcblx0XHRcInRyYW5zaXRpb25lbmQgLmFkZGluZy1jaGlsZFwiOiBcIl9vbkFkZGVkVHJhbnNpdGlvbkVuZFwiLFxuXHRcdFwidHJhbnNpdGlvbmVuZCAucmVtb3ZpbmctY2hpbGRcIjogXCJfb25SZW1vdmVkVHJhbnNpdGlvbkVuZFwiLFxuXHRcdC8vIFwidHJhbnNpdGlvbmVuZFwiOiBcIl9vblRyYW5zaXRpb25FbmRcIixcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRfLmJpbmRBbGwodGhpcywgXCJfb25WUGFuU3RhcnRcIiwgXCJfb25WUGFuTW92ZVwiLCBcIl9vblZQYW5GaW5hbFwiLCBcIl9vbkNvbGxhcHNlZEV2ZW50XCIpO1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gbmV3IFRyYW5zZm9ybUhlbHBlcigpO1xuXHRcdC8vIHRoaXMudG91Y2ggPSBvcHRpb25zLnRvdWNoIHx8IG5ldyBFcnJvcihcIm5vIHRvdWNoXCIpOyAvL1RvdWNoTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHRcdHRoaXMudnBhbiA9IG9wdGlvbnMudnBhbiB8fCBuZXcgRXJyb3IoXCJubyB2cGFuXCIpO1xuXHRcdHRoaXMuaHBhbiA9IG9wdGlvbnMuaHBhbiB8fCBuZXcgRXJyb3IoXCJubyBocGFuXCIpO1xuXG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcImNoYW5nZVwiLCB0aGlzLl9vbk1vZGVsQ2hhbmdlKTtcblxuXHRcdC8vIGRpc2Nvbm5lY3QgY2hpbGRyZW4gYmVmb3JlIGxhc3QgY2hhbmdlXG5cdFx0Ly8gdGhpcy5saXN0ZW5UbyhidW5kbGVzLCBcImRlc2VsZWN0Om9uZVwiLCB0aGlzLl9vbkRlc2VsZWN0T25lQnVuZGxlKTtcblxuXHRcdHRoaXMuc2tpcFRyYW5zaXRpb25zID0gdHJ1ZTtcblx0XHR0aGlzLml0ZW1WaWV3cyA9IFtdO1xuXG5cdFx0Ly8gdGhpcy5wcm9ncmVzc1dyYXBwZXIgPSB0aGlzLmNyZWF0ZVByb2dyZXNzV3JhcHBlcigpLFxuXHRcdC8vIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcm9ncmVzc1dyYXBwZXIuZWwpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIFJlbmRlclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRyZW5kZXJGcmFtZTogZnVuY3Rpb24odHN0YW1wLCBmbGFncykge1xuXHRcdC8vIHZhbHVlc1xuXHRcdHZhciBjb2xsYXBzZWQgPSB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKTtcblx0XHR2YXIgY29sbGFwc2VkQ2hhbmdlZCA9IChmbGFncyAmIFZpZXcuTU9ERUxfSU5WQUxJRClcblx0XHRcdCYmIHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImNvbGxhcHNlZFwiKTtcblx0XHR2YXIgY2hpbGRyZW5DaGFuZ2VkID0gKGZsYWdzICYgVmlldy5NT0RFTF9JTlZBTElEKVxuXHRcdFx0JiYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImJ1bmRsZVwiKSB8fCB0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJhcnRpY2xlXCIpKTtcblxuXHRcdC8vIGZsYWdzXG5cdFx0dmFyIHNpemVDaGFuZ2VkID0gISEoZmxhZ3MgJiBWaWV3LlNJWkVfSU5WQUxJRCk7XG5cdFx0dmFyIHRyYW5zZm9ybXNDaGFuZ2VkID0gISEoZmxhZ3MgJiAoVmlldy5NT0RFTF9JTlZBTElEIHwgVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKSk7XG5cdFx0dHJhbnNmb3Jtc0NoYW5nZWQgPSB0cmFuc2Zvcm1zQ2hhbmdlZCB8fCB0aGlzLl90cmFuc2Zvcm1zQ2hhbmdlZCB8fCB0aGlzLnNraXBUcmFuc2l0aW9ucztcblxuXHRcdC8vIGRlYnVnXG5cdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdFx0Ly8gaWYgKGZsYWdzICYgVmlldy5NT0RFTF9JTlZBTElEKSB7XG5cdFx0Ly8gXHRjb25zb2xlLmdyb3VwKHRoaXMuY2lkICsgXCI6OnJlbmRlckZyYW1lIG1vZGVsIGNoYW5nZWQ6XCIpO1xuXHRcdC8vIFx0T2JqZWN0LmtleXModGhpcy5tb2RlbC5jaGFuZ2VkKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdC8vIFx0XHRjb25zb2xlLmxvZyhcIlxcdCVzOiAlcyAtPiAlc1wiLCBrZXksIHRoaXMubW9kZWwuX3ByZXZpb3VzQXR0cmlidXRlc1trZXldLCB0aGlzLm1vZGVsLmNoYW5nZWRba2V5XSk7XG5cdFx0Ly8gXHR9LCB0aGlzKTtcblx0XHQvLyBcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHQvLyB9XG5cblx0XHQvLyBtb2RlbDpjaGlsZHJlblxuXHRcdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcdGlmIChjaGlsZHJlbkNoYW5nZWQpIHtcblx0XHRcdHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHRcdGlmIChidW5kbGVzLnNlbGVjdGVkKSB7XG5cdFx0XHRcdHRoaXMuY3JlYXRlQ2hpbGRyZW4oYnVuZGxlcy5zZWxlY3RlZCk7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmIChhcnRpY2xlcy5zZWxlY3RlZCkge1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUNoaWxkcmVuKGFydGljbGVzLnNlbGVjdGVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBtb2RlbDpjb2xsYXBzZWRcblx0XHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XHRpZiAoY29sbGFwc2VkQ2hhbmdlZCkge1xuXHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiY29udGFpbmVyLWNvbGxhcHNlZFwiLCBjb2xsYXBzZWQpO1xuXHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiY29udGFpbmVyLWV4cGFuZGVkXCIsICFjb2xsYXBzZWQpO1xuXHRcdH1cblxuXHRcdC8vIHNpemVcblx0XHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XHRpZiAoc2l6ZUNoYW5nZWQpIHtcblx0XHRcdHRoaXMudHJhbnNmb3Jtcy5jbGVhckFsbENhcHR1cmVzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNmb3Jtc1xuXHRcdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcdGlmICh0cmFuc2Zvcm1zQ2hhbmdlZCkge1xuXHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyLWNoYW5naW5nXCIpO1xuXHRcdFx0aWYgKHRoaXMuc2tpcFRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5zdG9wQWxsVHJhbnNpdGlvbnMoKTtcblx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyLWNoYW5nZWRcIik7XG5cdFx0XHRcdGlmICghY2hpbGRyZW5DaGFuZ2VkKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcy50cmFuc2Zvcm1zLmNsZWFyQWxsT2Zmc2V0cygpO1xuXHRcdFx0XHRcdGlmIChjb2xsYXBzZWRDaGFuZ2VkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRDaGlsZHJlbkVuYWJsZWQoY29sbGFwc2VkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghY2hpbGRyZW5DaGFuZ2VkKSB7XG5cdFx0XHRcdFx0aWYgKGNvbGxhcHNlZENoYW5nZWQpIHtcblx0XHRcdFx0XHRcdHZhciBhZnRlclRyYW5zaXRpb25zRm47XG5cdFx0XHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJjb250YWluZXItY2hhbmdlZFwiKTtcblx0XHRcdFx0XHRcdC8vIHRoaXMudHJhbnNmb3Jtcy5jbGVhckFsbE9mZnNldHMoKTtcblx0XHRcdFx0XHRcdGlmIChjb2xsYXBzZWQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udGFpbmVyLWNvbGxhcHNlZCwgZW5hYmxlIGxhc3Rcblx0XHRcdFx0XHRcdFx0YWZ0ZXJUcmFuc2l0aW9uc0ZuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2V0Q2hpbGRyZW5FbmFibGVkKHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbnRhaW5lci1jaGFuZ2VkXCIpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMucnVuQWxsVHJhbnNpdGlvbnModHguTEFTVCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBjb250YWluZXItZXhwYW5kZWQsIGRpc2FibGUgZmlyc3Rcblx0XHRcdFx0XHRcdFx0YWZ0ZXJUcmFuc2l0aW9uc0ZuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyLWNoYW5nZWRcIik7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldENoaWxkcmVuRW5hYmxlZChmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5ydW5BbGxUcmFuc2l0aW9ucyh0eC5GSVJTVCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhZnRlclRyYW5zaXRpb25zRm4gPSBhZnRlclRyYW5zaXRpb25zRm4uYmluZCh0aGlzKTtcblx0XHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy53aGVuQWxsVHJhbnNpdGlvbnNFbmQoKS50aGVuKGFmdGVyVHJhbnNpdGlvbnNGbiwgYWZ0ZXJUcmFuc2l0aW9uc0ZuKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLml0ZW1zLmZvckVhY2goZnVuY3Rpb24obykge1xuXHRcdFx0XHRcdFx0XHRpZiAoby5oYXNPZmZzZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRvLnJ1blRyYW5zaXRpb24odHguTk9XKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBvLmNsZWFyT2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFjaGlsZHJlbkNoYW5nZWQpIHtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLmNsZWFyQWxsT2Zmc2V0cygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50cmFuc2Zvcm1zLnZhbGlkYXRlKCk7XG5cdFx0fVxuXHRcdGlmIChzaXplQ2hhbmdlZCkge1xuXHRcdFx0dGhpcy5pdGVtVmlld3MuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRcdHZpZXcuc2tpcFRyYW5zaXRpb25zID0gdGhpcy5za2lwVHJhbnNpdGlvbnM7XG5cdFx0XHRcdHZpZXcucmVxdWVzdFJlbmRlcihWaWV3LlNJWkVfSU5WQUxJRCkucmVuZGVyTm93KCk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdC8qUHJvbWlzZS5hbGwodGhpcy5pdGVtVmlld3MubWFwKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdFx0XHR2aWV3LnNraXBUcmFuc2l0aW9ucyA9IHRoaXMuc2tpcFRyYW5zaXRpb25zO1xuXHRcdFx0XHRcdHJldHVybiB2aWV3LnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQpLndoZW5SZW5kZXJlZCgpO1xuXHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24odmlld3MpIHtcblx0XHRcdFx0XHRcdHZhciBuaCA9IHRoaXMuZWwub2Zmc2V0UGFyZW50Lm9mZnNldEhlaWdodCAtIHRoaXMuZWwub2Zmc2V0VG9wO1xuXHRcdFx0XHRcdFx0Ly8gdmFyIG9oID0gdmlld3MucmVkdWNlKGZ1bmN0aW9uKGgsIHZpZXcpIHtcblx0XHRcdFx0XHRcdC8vIFx0cmV0dXJuIE1hdGgubWF4KGgsIHZpZXcuZWwub2Zmc2V0SGVpZ2h0KTtcblx0XHRcdFx0XHRcdC8vIH0sIG5oKTtcblx0XHRcdFx0XHRcdC8vIG9oKys7XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOlt3aGVuUmVuZGVyZWRdIFtyZXN1bHQ6ICVzICVzXSAlb1wiLCB0aGlzLmNpZCxcblx0XHRcdFx0XHRcdC8vIFx0bmgsIG9oLCB0aGlzLmVsLnBhcmVudCwgdmlld3MpO1xuXHRcdFx0XHRcdFx0dGhpcy5lbC5zdHlsZS5taW5IZWlnaHQgPSBuaCArIFwicHhcIjtcblx0XHRcdFx0XHRcdHJldHVybiB2aWV3cztcblx0XHRcdFx0XHR9LmJpbmQodGhpcyksXG5cdFx0XHRcdFx0ZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCIlczpbd2hlblJlbmRlcmVkXSBbcmVqZWN0ZWRdICVvXCIsIHRoaXMuY2lkLCByZWFzb24pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlYXNvbjtcblx0XHRcdFx0XHR9LmJpbmQodGhpcylcblx0XHRcdFx0KTsqL1xuXHRcdH1cblx0XHR0aGlzLnNraXBUcmFuc2l0aW9ucyA9IHRoaXMuX3RyYW5zZm9ybXNDaGFuZ2VkID0gZmFsc2U7XG5cdH0sXG5cblx0X3NldENoaWxkcmVuRW5hYmxlZDogZnVuY3Rpb24oZW5hYmxlZCkge1xuXHRcdC8vIGlmIChlbmFibGVkKSB7XG5cdFx0Ly8gXHR0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNvbGxhcHNlZENsaWNrLCBmYWxzZSk7XG5cdFx0Ly8gfSBlbHNlIHtcblx0XHQvLyBcdHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ29sbGFwc2VkQ2xpY2ssIGZhbHNlKTtcblx0XHQvLyB9XG5cdFx0dGhpcy5pdGVtVmlld3MuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHR2aWV3LnNldEVuYWJsZWQoZW5hYmxlZCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBDb2xsYXBzZSBVSSBnZXN0dXJlcy9ldmVudHNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9vbkNvbGxhcHNlZEV2ZW50OiBmdW5jdGlvbihldikge1xuXHRcdGNvbnNvbGUubG9nKFwiJXM6WyVzIC0+IF9vbkNvbGxhcHNlZEV2ZW50XSB0YXJnZXQ6ICVzXCIsIHRoaXMuY2lkLCBldi50eXBlLCBldi50YXJnZXQpO1xuXHRcdGlmICghZXYuZGVmYXVsdFByZXZlbnRlZCAmJlxuXHRcdFx0dGhpcy5tb2RlbC5oYXMoXCJidW5kbGVcIikgJiZcblx0XHRcdCF0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSAmJlxuXHRcdFx0IXRoaXMuZW5hYmxlZCkge1xuXHRcdFx0Ly8gdGhpcy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBpZiAoZXYudHlwZSA9PSBcImNsaWNrXCIpIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBpZiAoZXYudHlwZSA9PSBcImNsaWNrXCIpIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0aGlzLm1vZGVsLnNldChcImNvbGxhcHNlZFwiLCB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdFx0Ly8gfSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIG1vZGVsIGNoYW5nZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uTW9kZWxDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLm1vZGVsLmhhc0FueUNoYW5nZWQoXCJidW5kbGVcIikpIHtcblx0XHRcdGlmICh0aGlzLm1vZGVsLmhhcyhcImJ1bmRsZVwiKSkge1xuXHRcdFx0XHR0aGlzLnZwYW4ub24oXCJ2cGFuc3RhcnRcIiwgdGhpcy5fb25WUGFuU3RhcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy52cGFuLm9mZihcInZwYW5zdGFydFwiLCB0aGlzLl9vblZQYW5TdGFydCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qXG5cdFx0aWYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcIndpdGhCdW5kbGVcIikgfHxcblx0XHRcdHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImNvbGxhcHNlZFwiKSkge1xuXHRcdFx0aWYgKHRoaXMubW9kZWwuZ2V0KFwid2l0aEJ1bmRsZVwiKSAmJlxuXHRcdFx0XHQhdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHRcdFx0dGhpcy5ocGFuLm9uKFwiaHBhbmxlZnQgaHBhbnJpZ2h0XCIsIHRoaXMuX29uQ29sbGFwc2VkRXZlbnQpO1xuXHRcdFx0XHR0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoVmlldy5DTElDS19FVkVOVCwgdGhpcy5fb25Db2xsYXBzZWRFdmVudCwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ocGFuLm9mZihcImhwYW5sZWZ0IGhwYW5yaWdodFwiLCB0aGlzLl9vbkNvbGxhcHNlZEV2ZW50KTtcblx0XHRcdFx0dGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKFZpZXcuQ0xJQ0tfRVZFTlQsIHRoaXMuX29uQ29sbGFwc2VkRXZlbnQsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ki9cblx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoVmlldy5NT0RFTF9JTlZBTElEKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIFZlcnRpY2FsIHRvdWNoL21vdmUgKF9vblZQYW4qKVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X2NvbGxhcHNlZE9mZnNldFk6IEdsb2JhbHMuQ09MTEFQU0VfT0ZGU0VULFxuXG5cdF9vblZQYW5TdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnZwYW4ub24oXCJ2cGFubW92ZVwiLCB0aGlzLl9vblZQYW5Nb3ZlKTtcblx0XHR0aGlzLnZwYW4ub24oXCJ2cGFuZW5kIHZwYW5jYW5jZWxcIiwgdGhpcy5fb25WUGFuRmluYWwpO1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1zLnN0b3BBbGxUcmFuc2l0aW9ucygpO1xuXHRcdC8vIHRoaXMudHJhbnNmb3Jtcy5jbGVhckFsbE9mZnNldHMoKTtcblx0XHQvLyB0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblx0XHR0aGlzLnRyYW5zZm9ybXMuY2xlYXJBbGxDYXB0dXJlcygpO1xuXG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiY29udGFpbmVyLWNoYW5naW5nXCIpO1xuXHRcdHRoaXMuX29uVlBhbk1vdmUoZXYpO1xuXHR9LFxuXG5cdF9vblZQYW5Nb3ZlOiBmdW5jdGlvbihldikge1xuXHRcdHZhciBjb2xsYXBzZWQgPSB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKTtcblx0XHR2YXIgZGVsdGEgPSBldi5kZWx0YVk7IC8vZXYudGhyZXNob2xkRGVsdGFZO1xuXHRcdHZhciBtYXhEZWx0YSA9IHRoaXMuX2NvbGxhcHNlZE9mZnNldFk7IC8vICsgTWF0aC5hYnMoZXYudGhyZXNob2xkT2Zmc2V0WSk7XG5cblx0XHQvLyBjaGVjayBpZiBkaXJlY3Rpb24gaXMgYWxpZ25lZCB3aXRoIGNvbGxhcHNlZC9leHBhbmRcblx0XHR2YXIgaXNWYWxpZERpciA9IGNvbGxhcHNlZCA/IChkZWx0YSA+IDApIDogKGRlbHRhIDwgMCk7XG5cdFx0dmFyIG1vdmVGYWN0b3IgPSBjb2xsYXBzZWQgPyBHbG9iYWxzLlZQQU5fRFJBRyA6IDEgLSBHbG9iYWxzLlZQQU5fRFJBRztcblxuXHRcdGRlbHRhID0gTWF0aC5hYnMoZGVsdGEpOyAvLyByZW1vdmUgc2lnblxuXHRcdGRlbHRhICo9IG1vdmVGYWN0b3I7XG5cdFx0bWF4RGVsdGEgKj0gbW92ZUZhY3RvcjtcblxuXHRcdGlmIChpc1ZhbGlkRGlyKSB7XG5cdFx0XHRpZiAoZGVsdGEgPiBtYXhEZWx0YSkgeyAvLyBvdmVyc2hvb3Rpbmdcblx0XHRcdFx0ZGVsdGEgPSAoKGRlbHRhIC0gbWF4RGVsdGEpICogR2xvYmFscy5WUEFOX09VVF9EUkFHKSArIG1heERlbHRhO1xuXHRcdFx0fSBlbHNlIHsgLy8gbm8gb3ZlcnNob290aW5nXG5cdFx0XHRcdC8vIGRlbHRhID0gZGVsdGE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbHRhID0gKC1kZWx0YSkgKiBHbG9iYWxzLlZQQU5fT1VUX0RSQUc7IC8vIGRlbHRhIGlzIG9wcG9zaXRlXG5cdFx0fVxuXHRcdGRlbHRhICo9IGNvbGxhcHNlZCA/IDEgOiAtMTsgLy8gcmVhcHBseSBzaWduXG5cblx0XHR0aGlzLnRyYW5zZm9ybXMub2Zmc2V0QWxsKDAsIGRlbHRhKTtcblx0XHR0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblx0fSxcblxuXHRfb25WUGFuRmluYWw6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy52cGFuLm9mZihcInZwYW5tb3ZlXCIsIHRoaXMuX29uVlBhbk1vdmUpO1xuXHRcdHRoaXMudnBhbi5vZmYoXCJ2cGFuZW5kIHZwYW5jYW5jZWxcIiwgdGhpcy5fb25WUGFuRmluYWwpO1xuXG5cdFx0Ly8gRklYTUU6IG1vZGVsLmNvbGxhcHNlZCBtYXkgaGF2ZSBhbHJlYWR5IGNoYW5nZWQsIF9vblZQYW5Nb3ZlIHdvdWxkIHJ1biB3aXRoIHdyb25nIHZhbHVlczpcblx0XHQvLyBtb2RlbC5jb2xsYXBzZWQgaXMgY2hhbmdlZCBpbiBhIHNldEltbWVkaWF0ZSBjYWxsYmFjayBmcm9tIE5hdmlnYXRpb25WaWV3LlxuXG5cdFx0dGhpcy5fb25WUGFuTW92ZShldik7XG5cdFx0dGhpcy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl90cmFuc2Zvcm1zQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoKTtcblx0XHR9KTtcblx0fSxcblxuXHQvLyB3aWxsQ29sbGFwc2VkQ2hhbmdlOiBmdW5jdGlvbihldikge1xuXHQvLyBcdHZhciBjb2xsYXBzZWQgPSB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKTtcblx0Ly8gXHRyZXR1cm4gZXYudHlwZSA9PSBcInZwYW5lbmRcIj8gY29sbGFwc2VkP1xuXHQvLyBcdFx0ZXYudGhyZXNob2xkRGVsdGFZID4gR2xvYmFscy5DT0xMQVBTRV9USFJFU0hPTEQgOlxuXHQvLyBcdFx0ZXYudGhyZXNob2xkRGVsdGFZIDwgLUdsb2JhbHMuQ09MTEFQU0VfVEhSRVNIT0xEIDpcblx0Ly8gXHRcdGZhbHNlO1xuXHQvLyB9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogY3JlYXRlL3JlbW92ZSBjaGlsZHJlbiBvbiBidW5kbGUgc2VsZWN0aW9uXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQ3JlYXRlIGNoaWxkcmVuIG9uIGJ1bmRsZSBzZWxlY3QgKi9cblx0Y3JlYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdFx0dmFyIHZpZXc7XG5cdFx0aWYgKG1vZGVsLl9fcHJvdG9fXy5jb25zdHJ1Y3RvciA9PT0gYnVuZGxlcy5tb2RlbCkge1xuXHRcdFx0Ly8gd2lsbCBiZSBhdHRhY2hlZCB0byBkb20gaW4gdGhpcyBvcmRlclxuXHRcdFx0dmlldyA9IHRoaXMuY3JlYXRlTWVkaWFDYXB0aW9uU3RhY2sobW9kZWwpO1xuXHRcdFx0dGhpcy5pdGVtVmlld3MucHVzaCh2aWV3KTtcblx0XHRcdHRoaXMudHJhbnNmb3Jtcy5hZGQodmlldy5lbCk7XG5cdFx0XHR2aWV3ID0gdGhpcy5jcmVhdGVNZWRpYUNhcm91c2VsKG1vZGVsKTtcblx0XHRcdHRoaXMuaXRlbVZpZXdzLnB1c2godmlldyk7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybXMuYWRkKHZpZXcuZWwpO1xuXHRcdFx0dmlldyA9IHRoaXMuY3JlYXRlTWVkaWFEb3ROYXZpZ2F0aW9uKG1vZGVsKTtcblx0XHRcdHRoaXMuaXRlbVZpZXdzLnB1c2godmlldyk7XG5cdFx0fSBlbHNlXG5cdFx0aWYgKG1vZGVsLl9fcHJvdG9fXy5jb25zdHJ1Y3RvciA9PT0gYXJ0aWNsZXMubW9kZWwpIHtcblx0XHRcdHZpZXcgPSB0aGlzLmNyZWF0ZUFydGljbGVWaWV3KG1vZGVsKTtcblx0XHRcdHRoaXMuaXRlbVZpZXdzLnB1c2godmlldyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pdGVtVmlld3MuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRpZiAoIXRoaXMuc2tpcFRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdHZpZXcuZWwuY2xhc3NMaXN0LmFkZChcImFkZGluZy1jaGlsZFwiKTtcblx0XHRcdFx0dmlldy5lbC5zdHlsZS5vcGFjaXR5ID0gMDtcblx0XHRcdH1cblx0XHRcdHRoaXMuZWwuYXBwZW5kQ2hpbGQodmlldy5lbCk7XG5cdFx0XHR2aWV3LnJlbmRlcigpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLnNraXBUcmFuc2l0aW9ucykge1xuXHRcdFx0dGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6OmNyZWF0ZUNoaWxkcmVuOjpbY2FsbGJhY2s6cmVxdWVzdEFuaW1hdGlvbkZyYW1lXVwiLCB0aGlzLmNpZCk7XG5cdFx0XHRcdHRoaXMuaXRlbVZpZXdzLmZvckVhY2goZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHRcdGlmICghdGhpcy5za2lwVHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0XHRcdHZpZXcuZWwuc3R5bGVbdHJhbnNpdGlvblByb3BdID0gXCJvcGFjaXR5IFwiICsgdHguTEFTVC5jc3NUZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aWV3LmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwib3BhY2l0eVwiKTtcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXRlbVZpZXdzLmZvckVhY2goZnVuY3Rpb24odmlldywgaSwgYXJyKSB7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybXMucmVtb3ZlKHZpZXcuZWwpO1xuXHRcdFx0aWYgKHRoaXMuc2tpcFRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdHZpZXcucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXcuZWwpO1xuXHRcdFx0XHRpZiAocy5vcGFjaXR5ID09IFwiMFwiIHx8IHMudmlzaWJpbGl0eSA9PSBcImhpZGRlblwiKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCIlczo6cmVtb3ZlQ2hpbGRyZW4gW3ZpZXc6JXNdIHJlbW92ZWQgaW1tZWRpYXRlbHkgKGludmlzaWJsZSlcIiwgdGhpcy5jaWQsIHZpZXcuY2lkKTtcblx0XHRcdFx0XHR2aWV3LnJlbW92ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZpZXcuZWwuY2xhc3NMaXN0LmFkZChcInJlbW92aW5nLWNoaWxkXCIpO1xuXHRcdFx0XHRcdGlmIChzW3RyYW5zZm9ybVByb3BdKSB2aWV3LmVsLnN0eWxlW3RyYW5zZm9ybVByb3BdID0gc1t0cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdFx0XHR2aWV3LmVsLnN0eWxlW3RyYW5zaXRpb25Qcm9wXSA9IFwib3BhY2l0eSBcIiArIHR4LkZJUlNULmNzc1RleHQ7XG5cdFx0XHRcdFx0dmlldy5lbC5zdHlsZS5vcGFjaXR5ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YXJyW2ldID0gbnVsbDtcblx0XHR9LCB0aGlzKTtcblx0XHR0aGlzLml0ZW1WaWV3cy5sZW5ndGggPSAwO1xuXHR9LFxuXG5cdF9vbkFkZGVkVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoZXYudGFyZ2V0LmNpZCAmJiB0aGlzLmNoaWxkVmlld3MuaGFzT3duUHJvcGVydHkoZXYudGFyZ2V0LmNpZCkpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9vbkFkZGVkVHJhbnNpdGlvbkVuZCBbdmlldzolc10gW3Byb3A6JXNdIFtldjolc11cIiwgdGhpcy5jaWQsIGV2LnRhcmdldC5jaWQsIGV2LnByb3BlcnR5TmFtZSwgZXYudHlwZSk7XG5cdFx0XHR2YXIgdmlldyA9IHRoaXMuY2hpbGRWaWV3c1tldi50YXJnZXQuY2lkXTtcblx0XHRcdHZpZXcuZWwuY2xhc3NMaXN0LnJlbW92ZShcImFkZGluZy1jaGlsZFwiKTtcblx0XHRcdHZpZXcuZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkodHJhbnNpdGlvblByb3ApO1xuXHRcdH1cblx0fSxcblxuXHRfb25SZW1vdmVkVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoZXYudGFyZ2V0LmNpZCAmJiB0aGlzLmNoaWxkVmlld3MuaGFzT3duUHJvcGVydHkoZXYudGFyZ2V0LmNpZCkpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9vblJlbW92ZWRUcmFuc2l0aW9uRW5kIFt2aWV3OiVzXSBbcHJvcDolc10gW2V2OiVzXVwiLCB0aGlzLmNpZCwgZXYudGFyZ2V0LmNpZCwgZXYucHJvcGVydHlOYW1lLCBldi50eXBlKTtcblx0XHRcdHZhciB2aWV3ID0gdGhpcy5jaGlsZFZpZXdzW2V2LnRhcmdldC5jaWRdO1xuXHRcdFx0dmlldy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwicmVtb3ZpbmctY2hpbGRcIik7XG5cdFx0XHR2aWV3LnJlbW92ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBwdXJnZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0Ly8gXHR2YXIgaSwgZWwsIGVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcIi5yZW1vdmluZy1jaGlsZFwiKTtcblx0Ly8gXHRmb3IgKGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG5cdC8vIFx0XHRlbCA9IGVscy5pdGVtKGkpO1xuXHQvLyBcdFx0aWYgKGVsLnBhcmVudEVsZW1lbnQgPT09IHRoaXMuZWwpIHtcblx0Ly8gXHRcdFx0dHJ5IHtcblx0Ly8gXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiJXM6OnB1cmdlQ2hpbGRyZW5cIiwgdGhpcy5jaWQsIGVsLmdldEF0dHJpYnV0ZShcImRhdGEtY2lkXCIpKTtcblx0Ly8gXHRcdFx0XHRWaWV3LmZpbmRCeUVsZW1lbnQoZWwpLnJlbW92ZSgpO1xuXHQvLyBcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0Ly8gXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiczo6cHVyZ2VDaGlsZHJlblwiLCB0aGlzLmNpZCwgXCJvcnBoYW5lZCBlbGVtZW50XCIsIGVycik7XG5cdC8vIFx0XHRcdFx0dGhpcy5lbC5yZW1vdmVDaGlsZChlbCk7XG5cdC8vIFx0XHRcdH1cblx0Ly8gXHRcdH1cblx0Ly8gXHR9XG5cdC8vIH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBDb21wb25lbnRzXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5cdC8qKlxuXHQgKiBtZWRpYS1jYXJvdXNlbFxuXHQgKi9cblx0Y3JlYXRlTWVkaWFDYXJvdXNlbDogZnVuY3Rpb24oYnVuZGxlKSB7XG5cdFx0Ly8gQ3JlYXRlIGNhcm91c2VsXG5cdFx0dmFyIEVtcHR5UmVuZGVyZXIgPSBDYXJvdXNlbFJlbmRlcmVyLmV4dGVuZCh7XG5cdFx0XHRjbGFzc05hbWU6IFwiY2Fyb3VzZWwtaXRlbSBlbXB0eS1pdGVtXCIsXG5cdFx0XHRtb2RlbDogYnVuZGxlLFxuXHRcdFx0dGVtcGxhdGU6IGNhcm91c2VsRW1wdHlUZW1wbGF0ZSxcblx0XHR9KTtcblx0XHR2YXIgcmVuZGVyZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4LCBhcnIpIHtcblx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIEVtcHR5UmVuZGVyZXI7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKGl0ZW0uYXR0cihcIkByZW5kZXJlclwiKSkge1xuXHRcdFx0XHRjYXNlIFwidmlkZW9cIjpcblx0XHRcdFx0XHRyZXR1cm4gVmlkZW9SZW5kZXJlcjtcblx0XHRcdFx0Y2FzZSBcInNlcXVlbmNlXCI6XG5cdFx0XHRcdFx0cmV0dXJuIFNlcXVlbmNlUmVuZGVyZXI7XG5cdFx0XHRcdGNhc2UgXCJpbWFnZVwiOlxuXHRcdFx0XHRcdHJldHVybiBJbWFnZVJlbmRlcmVyO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBJbWFnZVJlbmRlcmVyO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0dmFyIHZpZXcgPSBuZXcgQ2Fyb3VzZWwoe1xuXHRcdFx0Y2xhc3NOYW1lOiBcIm1lZGlhLWNhcm91c2VsIFwiICsgYnVuZGxlLmdldChcImRvbWlkXCIpLFxuXHRcdFx0Y29sbGVjdGlvbjogYnVuZGxlLmdldChcIm1lZGlhXCIpLFxuXHRcdFx0cmVuZGVyZXJGdW5jdGlvbjogcmVuZGVyZXJGdW5jdGlvbixcblx0XHRcdHJlcXVpcmVTZWxlY3Rpb246ICEhKGJ1bmRsZS5hdHRyKFwiQG5vLWRlc2NcIikpLFxuXHRcdFx0Ly8gZGlyZWN0aW9uOiBDYXJvdXNlbC5ESVJFQ1RJT05fSE9SSVpPTlRBTCxcblx0XHRcdHRvdWNoOiB0aGlzLmhwYW4sXG5cdFx0fSk7XG5cdFx0Y29udHJvbGxlci5saXN0ZW5Ubyh2aWV3LCB7XG5cdFx0XHRcInZpZXc6c2VsZWN0Om9uZVwiOiAobW9kZWwpID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCIlczpbdmlldzpzZWxlY3Q6b25lXSAlc1wiLCB2aWV3LmNpZCwgbW9kZWwuY2lkKTtcblx0XHRcdFx0Y29udHJvbGxlci5zZWxlY3RNZWRpYShtb2RlbCk7XG5cdFx0XHR9LFxuXHRcdFx0XCJ2aWV3OnNlbGVjdDpub25lXCI6IGNvbnRyb2xsZXIuZGVzZWxlY3RNZWRpYSxcblx0XHRcdC8vIFwidmlldzpyZW1vdmVkXCI6IGNvbnRyb2xsZXIuc3RvcExpc3RlbmluZ1xuXHRcdH0pO1xuXHRcdHZpZXcubGlzdGVuVG8oYnVuZGxlLCBcImRlc2VsZWN0ZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcy5jb2xsZWN0aW9uKTtcblx0XHRcdGNvbnRyb2xsZXIuc3RvcExpc3RlbmluZyh0aGlzKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHQvKipcblx0ICogbWVkaWEtY2FwdGlvbi1zdGFja1xuXHQgKi9cblx0Y3JlYXRlTWVkaWFDYXB0aW9uU3RhY2s6IGZ1bmN0aW9uKGJ1bmRsZSkge1xuXHRcdHZhciB2aWV3ID0gbmV3IENvbGxlY3Rpb25TdGFjayh7XG5cdFx0XHRjbGFzc05hbWU6IFwibWVkaWEtY2FwdGlvbi1zdGFja1wiLFxuXHRcdFx0Y29sbGVjdGlvbjogYnVuZGxlLmdldChcIm1lZGlhXCIpLFxuXHRcdFx0dGVtcGxhdGU6IG1lZGlhU3RhY2tUZW1wbGF0ZVxuXHRcdH0pO1xuXHRcdHZpZXcubGlzdGVuVG8oYnVuZGxlLCBcImRlc2VsZWN0ZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcy5jb2xsZWN0aW9uKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHQvKipcblx0ICogbWVkaWEtZG90bmF2XG5cdCAqL1xuXHRjcmVhdGVNZWRpYURvdE5hdmlnYXRpb246IGZ1bmN0aW9uKGJ1bmRsZSkge1xuXHRcdHZhciB2aWV3ID0gbmV3IFNlbGVjdGFibGVMaXN0Vmlldyh7XG5cdFx0XHRjbGFzc05hbWU6IFwibWVkaWEtZG90bmF2IGRvdHMtZm9udGZhY2UgY29sb3ItZmcwNVwiLFxuXHRcdFx0Y29sbGVjdGlvbjogYnVuZGxlLmdldChcIm1lZGlhXCIpLFxuXHRcdFx0cmVuZGVyZXI6IERvdE5hdmlnYXRpb25SZW5kZXJlclxuXHRcdH0pO1xuXHRcdGNvbnRyb2xsZXIubGlzdGVuVG8odmlldywge1xuXHRcdFx0XCJ2aWV3OnNlbGVjdDpvbmVcIjogY29udHJvbGxlci5zZWxlY3RNZWRpYSxcblx0XHRcdFwidmlldzpzZWxlY3Q6bm9uZVwiOiBjb250cm9sbGVyLmRlc2VsZWN0TWVkaWEsXG5cdFx0XHQvLyBcInZpZXc6cmVtb3ZlZFwiOiBjb250cm9sbGVyLnN0b3BMaXN0ZW5pbmdcblx0XHR9KTtcblx0XHR2aWV3Lmxpc3RlblRvKGJ1bmRsZSwgXCJkZXNlbGVjdGVkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMuY29sbGVjdGlvbik7XG5cdFx0XHRjb250cm9sbGVyLnN0b3BMaXN0ZW5pbmcodGhpcyk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHZpZXc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSBlbCB7bW9kdWxlOmFwcC9tb2RlbC9pdGVtL0FydGljbGVWaWV3fVxuXHQgKiBAcmV0dXJuIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9WaWV3fVxuXHQgKi9cblx0Y3JlYXRlQXJ0aWNsZVZpZXc6IGZ1bmN0aW9uKGFydGljbGUpIHtcblx0XHR2YXIgdmlldyA9IG5ldyBBcnRpY2xlVmlldyh7XG5cdFx0XHRtb2RlbDogYXJ0aWNsZSxcblx0XHR9KTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHQvLyBjcmVhdGVQcm9ncmVzc1dyYXBwZXI6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdC8vIHZhciB2aWV3ID0gbmV3IFByb2dyZXNzTWV0ZXIoe1xuXHQvLyBcdC8vIFx0aWQ6IFwibWVkaWEtcHJvZ3Jlc3Mtd3JhcHBlclwiLFxuXHQvLyBcdC8vIFx0Ly8gY2xhc3NOYW1lOiBcImNvbG9yLWJnIGNvbG9yLWZnMDVcIixcblx0Ly8gXHQvLyBcdHVzZU9wYXF1ZTogZmFsc2UsXG5cdC8vIFx0Ly8gXHRsYWJlbEZuOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiMCVcIjsgfVxuXHQvLyBcdC8vIH0pO1xuXHQvLyBcdC8vIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcm9ncmVzc1dyYXBwZXIuZWwpO1xuXHQvLyBcdC8vIHJldHVybiB2aWV3O1xuXHQvLyBcdHJldHVybiBudWxsO1xuXHQvLyB9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9OYXZpZ2F0aW9uVmlld1xuICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmhhbW1lcmpzfSAqL1xuY29uc3QgSGFtbWVyID0gcmVxdWlyZShcImhhbW1lcmpzXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuY29uc3QgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvVHJhbnNmb3JtSGVscGVyfSAqL1xuY29uc3QgVHJhbnNmb3JtSGVscGVyID0gcmVxdWlyZShcInV0aWxzL1RyYW5zZm9ybUhlbHBlclwiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVG91Y2hNYW5hZ2VyfSAqL1xuLy8gdmFyIFRvdWNoTWFuYWdlciA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL1RvdWNoTWFuYWdlclwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvQ29udHJvbGxlcn0gKi9cbmNvbnN0IGNvbnRyb2xsZXIgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvQ29udHJvbGxlclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL1R5cGVDb2xsZWN0aW9ufSAqL1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vVHlwZUNvbGxlY3Rpb25cIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvY29sbGVjdGlvbi9LZXl3b3JkQ29sbGVjdGlvbn0gKi9cbmNvbnN0IGtleXdvcmRzID0gcmVxdWlyZShcImFwcC9tb2RlbC9jb2xsZWN0aW9uL0tleXdvcmRDb2xsZWN0aW9uXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvbn0gKi9cbmNvbnN0IGJ1bmRsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvblwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9jb2xsZWN0aW9uL0FydGljbGVDb2xsZWN0aW9ufSAqL1xuY29uc3QgYXJ0aWNsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQXJ0aWNsZUNvbGxlY3Rpb25cIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld30gKi9cbmNvbnN0IFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3XCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0ZpbHRlcmFibGVMaXN0Vmlld30gKi9cbmNvbnN0IEZpbHRlcmFibGVMaXN0VmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9jb21wb25lbnQvRmlsdGVyYWJsZUxpc3RWaWV3XCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0dyb3VwaW5nTGlzdFZpZXd9ICovXG5jb25zdCBHcm91cGluZ0xpc3RWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9Hcm91cGluZ0xpc3RWaWV3XCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0NvbGxlY3Rpb25QYWdlcn0gKi9cbi8vIHZhciBDb2xsZWN0aW9uUGFnZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvY29tcG9uZW50L0NvbGxlY3Rpb25QYWdlclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9HcmFwaFZpZXd9ICovXG5jb25zdCBHcmFwaFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvY29tcG9uZW50L0dyYXBoVmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9BcnRpY2xlQnV0dG9ufSAqL1xuY29uc3QgQXJ0aWNsZUJ1dHRvbiA9IHJlcXVpcmUoXCJhcHAvdmlldy9jb21wb25lbnQvQXJ0aWNsZUJ1dHRvblwiKTtcblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZWRQcm9wZXJ0eX0gKi9cbi8vIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkUHJvcGVydHlcIik7XG5cbi8vIHZhciB0cmFjZUVsZW1lbnQgPSByZXF1aXJlKFwidXRpbHMvZGVidWcvdHJhY2VFbGVtZW50XCIpO1xuXG52YXIgdHggPSBHbG9iYWxzLnRyYW5zaXRpb25zO1xuXG52YXIgdHhOb3cgPSBfLmNsb25lKHR4Lk5PVyk7XG50eE5vdy5lYXNpbmcgPSBcImVhc2VcIjtcbi8vIHZhciBoVHggPSBfLmNsb25lKGNvbGxhcHNlZCA/IHR4LkxBU1QgOiB0eC5GSVJTVCk7XG4vLyBoVHguZWFzaW5nID0gXCJlYXNlXCI7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L05hdmlnYXRpb25WaWV3fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuXHQvLyAvKiogQG92ZXJyaWRlICovXG5cdC8vIHRhZ05hbWU6IFwiZGl2XCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2lkUHJlZml4OiBcIm5hdmlnYXRpb25WaWV3XCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2xhc3NOYW1lOiBcIm5hdmlnYXRpb24gY29udGFpbmVyLWV4cGFuZGVkXCIsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0Xy5iaW5kQWxsKHRoaXMsIFwiX29uVlBhblN0YXJ0XCIsIFwiX29uVlBhbk1vdmVcIiwgXCJfb25WUGFuRmluYWxcIik7XG5cdFx0Xy5iaW5kQWxsKHRoaXMsIFwiX29uSFBhblN0YXJ0XCIsIFwiX29uSFBhbk1vdmVcIiwgXCJfb25IUGFuRmluYWxcIik7XG5cdFx0Xy5iaW5kQWxsKHRoaXMsIFwiX29uTmF2aWdhdGlvbkNsaWNrXCIpO1xuXHRcdC8vIF8uYmluZEFsbCh0aGlzLCBcIl93aGVuVHJhbnNpdGlvbnNFbmRcIiwgXCJfd2hlblRyYW5zaXRpb25zQWJvcnRcIik7XG5cdFx0Ly8gXy5iaW5kQWxsKHRoaXMsIFwiX3doZW5MaXN0c1JlbmRlcmVkXCIpO1xuXG5cdFx0Ly8gdGhpcy5fbWV0cmljcyA9IHtcblx0XHQvLyBcdG1pbkhlaWdodDogMFxuXHRcdC8vIH07XG5cdFx0dGhpcy5pdGVtVmlld3MgPSBbXTtcblx0XHR0aGlzLnRyYW5zZm9ybXMgPSBuZXcgVHJhbnNmb3JtSGVscGVyKCk7XG5cdFx0Ly8gdGhpcy50b3VjaCA9IG9wdGlvbnMudG91Y2ggfHwgbmV3IEVycm9yKFwibm8gdG91Y2hcIik7IC8vVG91Y2hNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdFx0dGhpcy52cGFuID0gb3B0aW9ucy52cGFuIHx8IG5ldyBFcnJvcihcIm5vIHZwYW5cIik7XG5cdFx0dGhpcy5ocGFuID0gb3B0aW9ucy5ocGFuIHx8IG5ldyBFcnJvcihcIm5vIGhwYW5cIik7XG5cblx0XHR0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwiY2hhbmdlXCIsIHRoaXMuX29uTW9kZWxDaGFuZ2UpO1xuXHRcdHRoaXMubGlzdGVuVG8oa2V5d29yZHMsIFwic2VsZWN0Om9uZSBzZWxlY3Q6bm9uZVwiLCB0aGlzLl9vbktleXdvcmRTZWxlY3QpO1xuXHRcdC8vIHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJ3aXRoQnVuZGxlOmNoYW5nZVwiLCB0aGlzLl9vbndpdGhCdW5kbGVDaGFuZ2UpO1xuXG5cdFx0dGhpcy52cGFuR3JvdXAgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIjdnBhbi1ncm91cFwiKTtcblx0XHQvLyB0aGlzLmVsLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7XG5cdFx0Ly8gdGhpcy5lbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XG5cdFx0Ly8gdGhpcy5lbC5zdHlsZS53ZWJraXRVc2VyRHJhZyA9IFwibm9uZVwiO1xuXG5cdFx0dGhpcy5rZXl3b3JkTGlzdCA9IHRoaXMuY3JlYXRlS2V5d29yZExpc3QoKTtcblx0XHR0aGlzLmJ1bmRsZUxpc3QgPSB0aGlzLmNyZWF0ZUJ1bmRsZUxpc3QoKTtcblx0XHR0aGlzLml0ZW1WaWV3cy5wdXNoKHRoaXMua2V5d29yZExpc3QpO1xuXHRcdHRoaXMuaXRlbVZpZXdzLnB1c2godGhpcy5idW5kbGVMaXN0KTtcblxuXHRcdHRoaXMuZ3JhcGggPSB0aGlzLmNyZWF0ZUdyYXBoVmlldyh0aGlzLmJ1bmRsZUxpc3QsXG5cdFx0XHR0aGlzLmtleXdvcmRMaXN0LCB0aGlzLnZwYW5Hcm91cCk7XG5cblx0XHR0aGlzLnNpdGVuYW1lID0gdGhpcy5jcmVhdGVTaXRlbmFtZUJ1dHRvbigpO1xuXHRcdHRoaXMuYWJvdXQgPSB0aGlzLmNyZWF0ZUFib3V0QnV0dG9uKCk7XG5cblx0XHQvKiBOT1RFOiAubGlzdC1ncm91cCAubGFiZWwgbW92ZXMgaG9yaXpvbnRhbGx5IChjZi4gc2Fzcy9sYXlvdXRzLyouc2NzcykgKi9cblx0XHR0aGlzLmhHcm91cGluZ3MgPSB0aGlzLmtleXdvcmRMaXN0LmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGlzdC1ncm91cCAubGFiZWxcIik7XG5cblx0XHR0aGlzLnRyYW5zZm9ybXMuYWRkKFxuXHRcdFx0dGhpcy52cGFuR3JvdXAsXG5cdFx0XHR0aGlzLmJ1bmRsZUxpc3Qud3JhcHBlcixcblx0XHRcdHRoaXMua2V5d29yZExpc3Qud3JhcHBlcixcblx0XHRcdHRoaXMuYnVuZGxlTGlzdC5lbCxcblx0XHRcdHRoaXMua2V5d29yZExpc3QuZWwsXG5cdFx0XHR0aGlzLmhHcm91cGluZ3MsXG5cdFx0XHR0aGlzLnNpdGVuYW1lLndyYXBwZXIsXG5cdFx0XHR0aGlzLmFib3V0LndyYXBwZXIsXG5cdFx0XHR0aGlzLnNpdGVuYW1lLmVsLFxuXHRcdFx0dGhpcy5hYm91dC5lbCxcblx0XHRcdHRoaXMuZ3JhcGguZWxcblx0XHQpO1xuXHRcdC8vIHRoaXMuaXRlbVZpZXdzLnB1c2godGhpcy5ncmFwaCk7XG5cdFx0Ly8gdGhpcy5saXN0ZW5Ubyh0aGlzLmdyYXBoLCB7XG5cdFx0Ly8gXHRcImNhbnZhczp1cGRhdGVcIjogdGhpcy5fb25HcmFwaFVwZGF0ZSxcblx0XHQvLyBcdFwiY2FudmFzOnJlZHJhd1wiOiB0aGlzLl9vbkdyYXBoUmVkcmF3LFxuXHRcdC8vIH0pO1xuXG5cdFx0Lyp0aGlzLmxpc3RlblRvKHRoaXMuZ3JhcGgsIFwidmlldzpyZW5kZXI6YmVmb3JlXCIsIGZ1bmN0aW9uKHZpZXcsIGZsYWdzKSB7XG5cdFx0XHR2YXIgdm1heDtcblx0XHRcdGlmICghdmlldy5lbC5zdHlsZS5oZWlnaHQpIHtcblx0XHRcdFx0Ly8gaWYgKGZsYWdzICYgKFZpZXcuU0laRV9JTlZBTElEIHwgVmlldy5NT0RFTF9JTlZBTElEKSkge1xuXHRcdFx0XHQvLyBpZiAoKHRoaXMuYnVuZGxlTGlzdC5yZW5kZXJGbGFncyB8IFZpZXcuU0laRV9JTlZBTElEKSB8fFxuXHRcdFx0XHQvLyBcdCh0aGlzLmtleXdvcmRMaXN0LnJlbmRlckZsYWdzIHwgVmlldy5TSVpFX0lOVkFMSUQpKSB7XG5cdFx0XHRcdC8vIH1cblx0XHRcdFx0dm1heCA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdHRoaXMuYnVuZGxlTGlzdC5fbWV0cmljcy5oZWlnaHQsXG5cdFx0XHRcdFx0dGhpcy5rZXl3b3JkTGlzdC5fbWV0cmljcy5oZWlnaHRcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKF8uaXNOdW1iZXIodm1heCkpIHtcblx0XHRcdFx0XHR2aWV3LmVsLnN0eWxlLmhlaWdodCA9IHZtYXggKyBcInB4XCI7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCIlczpbdmlldzpyZW5kZXI6YmVmb3JlXVtvbmNlXTolcyBbJXNdIGhlaWdodHM6WyVpLCAlaV0gKG1heCAlaSlcIixcblx0XHRcdFx0XHRcdHRoaXMuY2lkLCB2aWV3LmNpZCwgVmlldy5mbGFnc1RvU3RyaW5nKGZsYWdzKSxcblx0XHRcdFx0XHRcdHRoaXMuYnVuZGxlTGlzdC5fbWV0cmljcy5oZWlnaHQsXG5cdFx0XHRcdFx0XHR0aGlzLmtleXdvcmRMaXN0Ll9tZXRyaWNzLmhlaWdodCxcblx0XHRcdFx0XHRcdHZtYXgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7Ki9cblx0XHQvLyB0aGlzLmxpc3RlblRvKHRoaXMuYnVuZGxlTGlzdCwgXCJ2aWV3OnJlbmRlcjphZnRlclwiLCBmdW5jdGlvbih2aWV3LCBmbGFncykge1xuXHRcdC8vIFx0Y29uc29sZS5pbmZvKFwiJXM6W3ZpZXc6cmVuZGVyOmFmdGVyICVzXVwiLCB0aGlzLmNpZCwgdmlldy5jaWQsIFZpZXcuZmxhZ3NUb1N0cmluZyhmbGFncyAmIFZpZXcuU0laRV9JTlZBTElEKSk7XG5cdFx0Ly8gXHRcdGlmIChmbGFncyAmIFZpZXcuU0laRV9JTlZBTElEKSB7XG5cdFx0Ly8gXHRcdFx0Ly8gY29uc29sZS5pbmZvKFwiJXM6WyVzIHZpZXc6cmVuZGVyOmFmdGVyXSBidW5kbGVMaXN0IGhlaWdodFwiLCB0aGlzLmNpZCwgdmlldy5jaWQsIHRoaXMuYnVuZGxlTGlzdC5lbC5zdHlsZS5oZWlnaHQpO1xuXHRcdC8vIFx0XHRcdC8vIHRoaXMuZ3JhcGguZWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5idW5kbGVMaXN0LmVsLnN0eWxlLmhlaWdodDtcblx0XHQvLyBcdFx0XHR0aGlzLmdyYXBoLmVsLnN0eWxlLm9wYWNpdHkgPSB0aGlzLmJ1bmRsZUxpc3QuY29sbGFwc2VkPyAwIDogMTtcblx0XHQvLyBcdFx0XHR0aGlzLmdyYXBoLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQpLnJlbmRlck5vdygpO1xuXHRcdC8vIFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cdFx0Ly8gdGhpcy5saXN0ZW5Ubyh0aGlzLmJ1bmRsZUxpc3QsIFwidmlldzpyZW5kZXI6YWZ0ZXJcIiwgdGhpcy5fb25MaXN0UmVzaXplKTtcblx0XHQvLyB0aGlzLmxpc3RlblRvKHRoaXMua2V5d29yZExpc3QsIFwidmlldzpyZW5kZXI6YWZ0ZXJcIiwgdGhpcy5fb25MaXN0UmVzaXplKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBSZW5kZXJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0cmVuZGVyRnJhbWU6IGZ1bmN0aW9uKHRzdGFtcCwgZmxhZ3MpIHtcblx0XHRpZiAoZmxhZ3MgJiBWaWV3Lk1PREVMX0lOVkFMSUQpIHtcblx0XHRcdGlmICh0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiY29udGFpbmVyLWNvbGxhcHNlZFwiLCB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSk7XG5cdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImNvbnRhaW5lci1leHBhbmRlZFwiLCAhdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImNvbGxhcHNlZFwiKVxuXHRcdFx0XHR8fCB0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJ3aXRoQnVuZGxlXCIpKSB7XG5cdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImNvbnRhaW5lci1jaGFuZ2luZ1wiKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJyb3V0ZU5hbWVcIikpIHtcblx0XHRcdFx0dGhpcy5idW5kbGVMaXN0LnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKTtcblx0XHRcdFx0dGhpcy5rZXl3b3JkTGlzdC5yZXF1ZXN0UmVuZGVyKFZpZXcuU0laRV9JTlZBTElEIHwgVmlldy5MQVlPVVRfSU5WQUxJRCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNmb3Jtc1xuXHRcdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcdGlmICh0aGlzLnNraXBUcmFuc2l0aW9ucyB8fFxuXHRcdFx0KGZsYWdzICYgVmlldy5BTExfSU5WQUxJRCkpIHtcblx0XHRcdC8vIChmbGFncyAmIChWaWV3Lk1PREVMX0lOVkFMSUQgfCBWaWV3LlNJWkVfSU5WQUxJRCB8IFZpZXcuTEFZT1VUX0lOVkFMSUQpKSkge1xuXHRcdFx0Ly8gaWYgKHRyYW5zZm9ybXNDaGFuZ2VkKSB7XG5cdFx0XHRpZiAodGhpcy5za2lwVHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLnN0b3BBbGxUcmFuc2l0aW9ucygpO1xuXHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLmNsZWFyQWxsT2Zmc2V0cygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZW5kZXJUcmFuc2l0aW9ucyhmbGFncyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OnJlbmRlckZyYW1lICVvXCIsIHRoaXMuY2lkLFxuXHRcdFx0Ly8gXHR0aGlzLnRyYW5zZm9ybXMuaXRlbXMubWFwKGZ1bmN0aW9uKG8pIHtcblx0XHRcdC8vIFx0XHRyZXR1cm4gdHJhY2VFbGVtZW50KG8uZWwpICsgXCI6XCIgK1xuXHRcdFx0Ly8gXHRcdFx0KG8uaGFzVHJhbnNpdGlvbiA/IG8udHJhbnNpdGlvbi5uYW1lIDogXCItXCIpO1xuXHRcdFx0Ly8gXHR9KSk7XG5cdFx0fVxuXHRcdC8vIGlmICh0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJjb2xsYXBzZWRcIikgJiYgdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHQvLyBcdHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcblx0XHQvLyBcdC8vIHRoaXMuZWwuc3R5bGUubWluSGVpZ2h0ID0gaHZhbCArIFwicHhcIjtcblx0XHQvLyBcdHRoaXMuZ3JhcGguZWwuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcblx0XHQvLyB9XG5cblx0XHQvLyBwcm9taXNlIGhhbmRsZXJzXG5cdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cblx0XHR2YXIgbWVhc3VyZVJlbmRlcmVkTGlzdHMgPSBmdW5jdGlvbihyZXN1bHQpIHtcblx0XHRcdC8vIHZhciBodmFsID0gcmVzdWx0LnJlZHVjZShmdW5jdGlvbihhLCBvKSB7XG5cdFx0XHQvLyBcdHJldHVybiBNYXRoLm1heChhLCBvLm1ldHJpY3MuaGVpZ2h0KTtcblx0XHRcdC8vIH0sIDApO1xuXHRcdFx0dmFyIGh2YWwgPSBNYXRoLm1heChcblx0XHRcdFx0dGhpcy5idW5kbGVMaXN0Lm1ldHJpY3MuaGVpZ2h0LFxuXHRcdFx0XHR0aGlzLmtleXdvcmRMaXN0Lm1ldHJpY3MuaGVpZ2h0KTtcblxuXHRcdFx0aWYgKHRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKSB7XG5cdFx0XHRcdHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcblx0XHRcdFx0Ly8gdGhpcy5lbC5zdHlsZS5taW5IZWlnaHQgPSBodmFsICsgXCJweFwiO1xuXHRcdFx0XHR0aGlzLmdyYXBoLmVsLnN0eWxlLmhlaWdodCA9IFwiXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVsLnN0eWxlLmhlaWdodCA9IGh2YWwgKyBcInB4XCI7XG5cdFx0XHRcdC8vIHRoaXMuZWwuc3R5bGUubWluSGVpZ2h0ID0gXCJcIjtcblx0XHRcdFx0dGhpcy5ncmFwaC5lbC5zdHlsZS5oZWlnaHQgPSBodmFsICsgXCJweFwiO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSA/IFwiXCIgOiBcIjEwMCVcIjtcblx0XHRcdC8vIHRoaXMudnBhbkdyb3VwLnN0eWxlLmhlaWdodCA9IGh2YWw7XG5cdFx0XHR0aGlzLmdyYXBoLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKTtcblx0XHRcdGNvbnNvbGUubG9nKFwiJXM6W3doZW5MaXN0c1JlbmRlcmVkRG9uZV0gaGVpZ2h0IHNldCB0byAlc1wiLCB0aGlzLmNpZCwgdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikgPyBodmFsICsgXCJweFwiIDogXCJbbm90IHNldF1cIiwgcmVzdWx0KTtcblx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6Y29sbGFwc2VkOm1lYXN1cmVkXCIsIHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LmJpbmQodGhpcyk7XG5cblx0XHR2YXIgdG9nZ2xlR3JhcGggPSBmdW5jdGlvbihyZXN1bHQpIHtcblx0XHRcdHRoaXMuZ3JhcGguZW5hYmxlZCA9ICF0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKTtcblx0XHRcdHRoaXMuZ3JhcGgudmFsdWVUbyhcImEyYlwiLCAwLCAwKTtcblx0XHRcdGlmICghdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHRcdFx0dGhpcy5ncmFwaC52YWx1ZVRvKFwiYTJiXCIsIDEsIEdsb2JhbHMuVFJBTlNJVElPTl9EVVJBVElPTik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0uYmluZCh0aGlzKTtcblxuXHRcdHZhciB3aGVuQ29sbGFwc2VkQ2hhbmdlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCIlczpbd2hlbkNvbGxhcHNlZENoYW5nZURvbmVdW2ZsYWdzOiAlc11cIiwgdGhpcy5jaWQsIFZpZXcuZmxhZ3NUb1N0cmluZyhmbGFncyksIHJlc3VsdCk7XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJjb250YWluZXItY2hhbmdpbmdcIik7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OmNvbGxhcHNlZDplbmRcIiwgdGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0uYmluZCh0aGlzKTtcblxuXHRcdC8vIHByb21pc2VzXG5cdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdFx0dmFyIHA7XG5cdFx0Ly8gcCA9IFByb21pc2UuYWxsKFtcblx0XHQvLyBcdFx0dGhpcy5idW5kbGVMaXN0LndoZW5SZW5kZXJlZCgpLFxuXHRcdC8vIFx0XHR0aGlzLmtleXdvcmRMaXN0LndoZW5SZW5kZXJlZCgpLFxuXHRcdC8vIFx0XHR0aGlzLmJ1bmRsZUxpc3Qud2hlbkNvbGxhcHNlQ2hhbmdlRW5kcygpLFxuXHRcdC8vIFx0XHR0aGlzLmtleXdvcmRMaXN0LndoZW5Db2xsYXBzZUNoYW5nZUVuZHMoKSxcblx0XHQvLyBcdFx0dGhpcy50cmFuc2Zvcm1zLndoZW5BbGxUcmFuc2l0aW9uc0VuZCgpLFxuXHRcdC8vIFx0XSk7XG5cblx0XHRwID0gUHJvbWlzZS5hbGwoW1xuXHRcdFx0XHR0aGlzLmJ1bmRsZUxpc3Qud2hlbkNvbGxhcHNlQ2hhbmdlRW5kcygpLFxuXHRcdFx0XHR0aGlzLmtleXdvcmRMaXN0LndoZW5Db2xsYXBzZUNoYW5nZUVuZHMoKSxcblx0XHRcdF0pXG5cdFx0XHQudGhlbihtZWFzdXJlUmVuZGVyZWRMaXN0cyk7XG5cblx0XHRpZiAoKGZsYWdzICYgVmlldy5NT0RFTF9JTlZBTElEKSAmJiB0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHRcdHAgPSBwLnRoZW4odG9nZ2xlR3JhcGgpO1xuXHRcdH1cblx0XHRwXG5cdFx0XHQudGhlbih0aGlzLnRyYW5zZm9ybXMud2hlbkFsbFRyYW5zaXRpb25zRW5kKCkpXG5cdFx0XHQudGhlbih3aGVuQ29sbGFwc2VkQ2hhbmdlRG9uZSlcblx0XHRcdC5jYXRjaChmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiJXM6OnJlbmRlckZyYW1lIHByb21pc2UgcmVqZWN0ZWRcIiwgdGhpcy5jaWQpO1xuXHRcdFx0fS5iaW5kKHRoaXMpKTtcblxuXHRcdC8qXG5cdFx0dmFyIHdoZW5MaXN0c1JlbmRlcmVkID0gUHJvbWlzZS5hbGwoW1xuXHRcdFx0dGhpcy5idW5kbGVMaXN0LndoZW5SZW5kZXJlZCgpLFxuXHRcdFx0dGhpcy5rZXl3b3JkTGlzdC53aGVuUmVuZGVyZWQoKVxuXHRcdF0pO1xuXG5cdFx0dmFyIHdoZW5UcmFuc2Zvcm1zRW5kID0gdGhpcy50cmFuc2Zvcm1zLnByb21pc2UoKTtcblxuXHRcdHdoZW5MaXN0c1JlbmRlcmVkLnRoZW4oXG5cdFx0XHR3aGVuTGlzdHNSZW5kZXJlZERvbmUsXG5cdFx0XHRmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiJXM6W3doZW5MaXN0c1JlbmRlcmVkXSBmYWlsZWQ6ICVvXCIsIHRoaXMuY2lkLCByZWFzb24pO1xuXHRcdFx0XHRyZXR1cm4gcmVhc29uO1xuXHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0KTtcblxuXHRcdFByb21pc2UuYWxsKFtcblx0XHRcdHdoZW5MaXN0c1JlbmRlcmVkLFxuXHRcdFx0d2hlblRyYW5zZm9ybXNFbmRcblx0XHRdKVxuXHRcdFx0LnRoZW4oXG5cdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6W3doZW5MaXN0c1JlbmRlcmVkK3doZW5UcmFuc2Zvcm1zRW5kXSBbJXNdXCIsIHRoaXMuY2lkLCBWaWV3LmZsYWdzVG9TdHJpbmcoZmxhZ3MpLCByZXN1bHQpO1xuXHRcdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbnRhaW5lci1jaGFuZ2luZ1wiKTtcblx0XHRcdFx0XHR0aGlzLmdyYXBoLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpLFxuXHRcdFx0XHRmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCIlczpbd2hlbkxpc3RzUmVuZGVyZWQrd2hlblRyYW5zZm9ybXNFbmRdIFslc11cIiwgdGhpcy5jaWQsIFZpZXcuZmxhZ3NUb1N0cmluZyhmbGFncyksIHJlYXNvbik7XG5cdFx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiY29udGFpbmVyLWNoYW5naW5nXCIpO1xuXHRcdFx0XHRcdHRoaXMuZ3JhcGgucmVxdWVzdFJlbmRlcihWaWV3LlNJWkVfSU5WQUxJRCB8IFZpZXcuTEFZT1VUX0lOVkFMSUQpO1xuXHRcdFx0XHR9LmJpbmQodGhpcylcblx0XHRcdCk7Ki9cblxuXG5cdFx0Ly8gdHJhY2UgcmVzdWx0IGhhbmRsZXJzXG5cdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdFx0LyppZiAodGhpcy5tb2RlbC5oYXNDaGFuZ2VkKFwiY29sbGFwc2VkXCIpKSB7XG5cdFx0XHR2YXIgbXNnQmFzZSA9IHRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpID8gXCJjb2xsYXBzXCIgOiBcImV4cGFuZFwiO1xuXHRcdFx0UHJvbWlzZS5hbGwoW1xuXHRcdFx0XHRQcm9taXNlLmFsbChbXG5cdFx0XHRcdFx0XHR0aGlzLmJ1bmRsZUxpc3Qud2hlblJlbmRlcmVkKCksXG5cdFx0XHRcdFx0XHR0aGlzLmtleXdvcmRMaXN0LndoZW5SZW5kZXJlZCgpXG5cdFx0XHRcdFx0XSlcblx0XHRcdFx0XHQudGhlbihcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIm5hdi10eDolc2luZ1wiLCBtc2dCYXNlLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5wcm9taXNlKClcblx0XHRcdF0pXG5cdFx0XHRcdC5jYXRjaChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihcIm5hdi10eDolc2VkIFtyZWplY3RlZF1cIiwgbXNnQmFzZSwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQuZmluYWxseShcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwibmF2LXR4OiVzZWRcIiwgbXNnQmFzZSwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0fSovXG5cblx0XHQvLyBncmFwaFxuXHRcdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcdC8vIGlmICgoZmxhZ3MgJiAoVmlldy5TSVpFX0lOVkFMSUQgfCB+Vmlldy5NT0RFTF9JTlZBTElEKSlcblx0XHQvLyBcdC8qIGNvbGxhcHNlZCBoYXMgbm90IGNoYW5nZWQsIG5vIGJ1bmRsZSBzZWxlY3RlZCAqL1xuXHRcdC8vIFx0JiYgIXRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImNvbGxhcHNlZFwiKVxuXHRcdC8vIFx0JiYgIXRoaXMubW9kZWwuZ2V0KFwid2l0aEJ1bmRsZVwiKSkge1xuXHRcdC8vIFx0dGhpcy5ncmFwaC5yZXF1ZXN0UmVuZGVyKFZpZXcuU0laRV9JTlZBTElEIHwgVmlldy5MQVlPVVRfSU5WQUxJRCk7XG5cdFx0Ly8gXHRpZiAoIXRoaXMuc2tpcFRyYW5zaXRpb25zKSB7XG5cdFx0Ly8gXHRcdHRoaXMuZ3JhcGgucmVuZGVyTm93KCk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXHRcdC8vIGVsc2Vcblx0XHQvLyBpZiAoKGZsYWdzICYgVmlldy5TSVpFX0lOVkFMSUQpICYmICF0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkge1xuXHRcdC8vIFx0LyogTmF2aWdhdGlvblZpZXcgaGFzIHJlc2l6ZWQgd2hpbGUgdW5jb2xsYXBzZWQsXG5cdFx0Ly8gXHRidXQgbW9kZWwgaXMgdW5jaGFuZ2VkICovXG5cdFx0Ly8gXHR0aGlzLmdyYXBoLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKTtcblx0XHQvLyB9XG5cblxuXHRcdC8vIGNoaWxkcmVuIGxvb3Bcblx0XHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XHR0aGlzLml0ZW1WaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdC8vIHZpZXcuc2tpcFRyYW5zaXRpb25zID0gdmlldy5za2lwVHJhbnNpdGlvbnMgfHwgdGhpcy5za2lwVHJhbnNpdGlvbnM7XG5cdFx0XHRpZiAodGhpcy5za2lwVHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0dmlldy5za2lwVHJhbnNpdGlvbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZsYWdzICYgVmlldy5TSVpFX0lOVkFMSUQpIHtcblx0XHRcdFx0dmlldy5yZXF1ZXN0UmVuZGVyKFZpZXcuU0laRV9JTlZBTElEKTtcblx0XHRcdH1cblx0XHRcdC8vIGlmICghdmlldy5za2lwVHJhbnNpdGlvbnMpIHtcblx0XHRcdHZpZXcucmVuZGVyTm93KCk7XG5cdFx0XHQvLyB9XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc2tpcFRyYW5zaXRpb25zID0gZmFsc2U7XG5cdFx0fSk7XG5cdH0sXG5cblx0Lypfd2hlbkxpc3RzUmVuZGVyZWQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHRcdHZhciBodmFsO1xuXHRcdGlmICh0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkge1xuXHRcdFx0dGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuXHRcdFx0Ly8gdGhpcy5ncmFwaC5lbC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaHZhbCA9IHJlc3VsdC5yZWR1Y2UoZnVuY3Rpb24oYSwgbykge1xuXHRcdFx0Ly8gXHRyZXR1cm4gTWF0aC5tYXgoYSwgby5tZXRyaWNzLmhlaWdodCk7XG5cdFx0XHQvLyB9LCAwKTtcblx0XHRcdGh2YWwgPSBNYXRoLm1heChcblx0XHRcdFx0dGhpcy5idW5kbGVMaXN0Lm1ldHJpY3MuaGVpZ2h0LFxuXHRcdFx0XHR0aGlzLmtleXdvcmRMaXN0Lm1ldHJpY3MuaGVpZ2h0KTtcblx0XHRcdHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gaHZhbCArIFwicHhcIjtcblx0XHRcdC8vIHRoaXMuZ3JhcGguZWwuc3R5bGUuaGVpZ2h0ID0gaHZhbCArIFwicHhcIjtcblx0XHR9XG5cdFx0dGhpcy5ncmFwaC5yZXF1ZXN0UmVuZGVyKFZpZXcuU0laRV9JTlZBTElEIHwgVmlldy5MQVlPVVRfSU5WQUxJRCkucmVuZGVyTm93KCk7XG5cdFx0Y29uc29sZS5sb2coXCIlczpbX3doZW5MaXN0c1JlbmRlcmVkXSBoZWlnaHQgc2V0IHRvICVvcHhcIiwgdGhpcy5jaWQsIGh2YWwgPyBodmFsIDogXCJbZW1wdHldXCIsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9LFxuXG5cdF93aGVuVHJhbnNpdGlvbnNFbmQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHRcdGNvbnNvbGUuaW5mbyhcIiVzOjpfd2hlblRyYW5zaXRpb25zRW5kXCIsIHRoaXMuY2lkKTtcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJjb250YWluZXItY2hhbmdpbmdcIik7XG5cdFx0Ly8gaWYgKCFHbG9iYWxzLkJSRUFLUE9JTlRTW1wibWVkaXVtLXdpZGVcIl0ubWF0Y2hlcylcblx0XHQvLyBcdHJldHVybjtcblx0XHQvLyBpZiAoIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKSB7XG5cdFx0Ly8gXHR0aGlzLmdyYXBoLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKTsgLy8ucmVuZGVyTm93KCk7XG5cdFx0Ly8gfVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3doZW5UcmFuc2l0aW9uc0Fib3J0OiBmdW5jdGlvbihyZWFzb24pIHtcblx0XHRjb25zb2xlLndhcm4oXCIlczo6X3doZW5UcmFuc2l0aW9uc0Fib3J0ICVvXCIsIHRoaXMuY2lkLCByZWFzb24pO1xuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbnRhaW5lci1jaGFuZ2luZ1wiKTtcblx0XHQvLyBpZiAoIUdsb2JhbHMuQlJFQUtQT0lOVFNbXCJtZWRpdW0td2lkZVwiXS5tYXRjaGVzKVxuXHRcdC8vIFx0cmV0dXJuO1xuXHRcdC8vIGlmICghdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHQvLyBcdHRoaXMuZ3JhcGgucmVxdWVzdFJlbmRlcihWaWV3LlNJWkVfSU5WQUxJRCB8IFZpZXcuTEFZT1VUX0lOVkFMSUQpOyAvLy5yZW5kZXJOb3coKTtcblx0XHQvLyB9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwqL1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogcmVuZGVyVHJhbnNpdGlvbnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHJlbmRlclRyYW5zaXRpb25zOiBmdW5jdGlvbihmbGFncykge1xuXG5cdFx0dmFyIG1vZGVsQ2hhbmdlZCA9IChmbGFncyAmIFZpZXcuTU9ERUxfSU5WQUxJRCk7XG5cblx0XHR2YXIgZnJvbVJvdXRlID0gdGhpcy5tb2RlbC5nZXQoXCJmcm9tUm91dGVOYW1lXCIpO1xuXHRcdHZhciB0b1JvdXRlID0gdGhpcy5tb2RlbC5nZXQoXCJyb3V0ZU5hbWVcIik7XG5cdFx0dmFyIHJvdXRlQ2hhbmdlZCA9IG1vZGVsQ2hhbmdlZCAmJiB0aGlzLm1vZGVsLmhhc0NoYW5nZWQoXCJyb3V0ZU5hbWVcIik7XG5cblx0XHQvKiBidW5kbGUgKi9cblx0XHR2YXIgd2l0aEJ1bmRsZSA9IHRoaXMubW9kZWwuaGFzKFwiYnVuZGxlXCIpO1xuXHRcdHZhciB3aXRoQnVuZGxlQ2hhbmdlZCA9IG1vZGVsQ2hhbmdlZCAmJiB0aGlzLm1vZGVsLmhhc0FueUNoYW5nZWQoXCJidW5kbGVcIik7XG5cdFx0dmFyIGJ1bmRsZUNoYW5nZWQgPSBtb2RlbENoYW5nZWQgJiYgdGhpcy5tb2RlbC5oYXNDaGFuZ2VkKFwiYnVuZGxlXCIpO1xuXHRcdC8qIG1lZGlhICovXG5cdFx0dmFyIHdpdGhNZWRpYSA9IHRoaXMubW9kZWwuaGFzKFwibWVkaWFcIik7XG5cdFx0dmFyIHdpdGhNZWRpYUNoYW5nZWQgPSBtb2RlbENoYW5nZWQgJiYgdGhpcy5tb2RlbC5oYXNBbnlDaGFuZ2VkKFwibWVkaWFcIik7XG5cdFx0Ly92YXIgbWVkaWFDaGFuZ2VkID0gbW9kZWxDaGFuZ2VkICYmIHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcIm1lZGlhXCIpO1xuXHRcdC8qIGFydGljbGUgKi9cblx0XHQvLyB2YXIgd2l0aEFydGljbGUgPSB0aGlzLm1vZGVsLmhhcyhcImFydGljbGVcIik7XG5cdFx0dmFyIHdpdGhBcnRpY2xlQ2hhbmdlZCA9IG1vZGVsQ2hhbmdlZCAmJiB0aGlzLm1vZGVsLmhhc0FueUNoYW5nZWQoXCJhcnRpY2xlXCIpO1xuXHRcdC8vdmFyIGFydGljbGVDaGFuZ2VkID0gbW9kZWxDaGFuZ2VkICYmIHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImFydGljbGVcIik7XG5cdFx0LyogY29sbGFwc2VkICovXG5cdFx0dmFyIGNvbGxhcHNlZCA9IHRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpO1xuXHRcdHZhciBjb2xsYXBzZWRDaGFuZ2VkID0gbW9kZWxDaGFuZ2VkICYmIHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImNvbGxhcHNlZFwiKTtcblxuXHRcdHZhciB0Zjtcblx0XHQvKiB0aGlzLnZwYW5Hcm91cCAqL1xuXHRcdHRmID0gdGhpcy50cmFuc2Zvcm1zLmdldCh0aGlzLnZwYW5Hcm91cCk7XG5cdFx0aWYgKHRmICYmIHRmLmhhc09mZnNldCkge1xuXHRcdFx0dGYucnVuVHJhbnNpdGlvbihjb2xsYXBzZWRDaGFuZ2VkID8gdHguQkVUV0VFTiA6IHR4Lk5PVyk7XG5cdFx0XHR0Zi5jbGVhck9mZnNldCgpO1xuXHRcdH1cblx0XHQvKiB0aGlzLmJ1bmRsZUxpc3QuZWwgKi9cblx0XHQvLyB0ZiA9IHRoaXMudHJhbnNmb3Jtcy5nZXQodGhpcy5idW5kbGVMaXN0LmVsKTtcblx0XHQvLyBpZiAodGYuaGFzT2Zmc2V0KSB7XG5cdFx0Ly8gXHR0Zi5ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZENoYW5nZWQgPyB0eC5CRVRXRUVOIDogdHguTk9XKTtcblx0XHQvLyBcdHRmLmNsZWFyT2Zmc2V0KCk7XG5cdFx0Ly8gfVxuXHRcdC8qIHRoaXMua2V5d29yZExpc3QuZWwgKi9cblx0XHQvLyB0ZiA9IHRoaXMudHJhbnNmb3Jtcy5nZXQodGhpcy5rZXl3b3JkTGlzdC5lbCk7XG5cdFx0Ly8gaWYgKHRmLmhhc09mZnNldCkge1xuXHRcdC8vIFx0dGYucnVuVHJhbnNpdGlvbihjb2xsYXBzZWRDaGFuZ2VkID8gdHguQkVUV0VFTiA6IHR4Lk5PVyk7XG5cdFx0Ly8gXHR0Zi5jbGVhck9mZnNldCgpO1xuXHRcdC8vIH1cblx0XHQvKiB0aGlzLmdyYXBoLmVsICovXG5cdFx0Ly8gdGYgPSB0aGlzLnRyYW5zZm9ybXMuZ2V0KHRoaXMuZ3JhcGguZWwpO1xuXHRcdC8vIGlmICh0ZiAmJiB0Zi5oYXNPZmZzZXQpIHtcblx0XHQvLyBcdHRmLnJ1blRyYW5zaXRpb24oY29sbGFwc2VkQ2hhbmdlZCA/IHR4LkJFVFdFRU4gOiB0eC5OT1cpO1xuXHRcdC8vIFx0dGYuY2xlYXJPZmZzZXQoKTtcblx0XHQvLyB9XG5cblx0XHQvKlxuXHRcdCAqIE5PVEU6XG5cdFx0ICogVmVydGljYWw6XG5cdFx0ICpcdFx0c2l0ZS1uYW1lLXdyYXBwZXIsXG5cdFx0ICpcdFx0YXJ0aWNsZS1saXN0LXdyYXBwZXJcblx0XHQgKiBIb3Jpem9udGFsOlxuXHRcdCAqXHRcdHNpdGUtbmFtZSxcblx0XHQgKlx0XHRhcnRpY2xlLWJ1dHRvbnMsXG5cdFx0ICpcdFx0a2V5d29yZExpc3Qud3JhcHBlcixcblx0XHQgKlx0XHRidW5kbGVMaXN0LndyYXBwZXIsXG5cdFx0ICpcdFx0aEdyb3VwaW5nc1xuXHRcdCAqL1xuXHRcdGlmIChHbG9iYWxzLkJSRUFLUE9JTlRTW1wibWVkaXVtLXdpZGVcIl0ubWF0Y2hlcykge1xuXHRcdFx0LyogSE9SSVpPTlRBTDoga2V5d29yZExpc3Qud3JhcHBlciAqL1xuXHRcdFx0dGYgPSB0aGlzLnRyYW5zZm9ybXMuZ2V0KHRoaXMua2V5d29yZExpc3Qud3JhcHBlcik7XG5cdFx0XHRpZiAoY29sbGFwc2VkQ2hhbmdlZCAmJiAhd2l0aEFydGljbGVDaGFuZ2VkKSB7XG5cdFx0XHRcdC8vIGlmIChjb2xsYXBzZWRDaGFuZ2VkKSB7XG5cdFx0XHRcdGlmICh3aXRoQnVuZGxlQ2hhbmdlZCkge1xuXHRcdFx0XHRcdGlmICh3aXRoTWVkaWFDaGFuZ2VkKVxuXHRcdFx0XHRcdFx0dGYucnVuVHJhbnNpdGlvbih3aXRoQnVuZGxlID8gdHguTEFTVCA6IHR4LkZJUlNUKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAod2l0aE1lZGlhKVxuXHRcdFx0XHRcdFx0dGYucnVuVHJhbnNpdGlvbihjb2xsYXBzZWQgPyB0eC5MQVNUIDogdHguRklSU1QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIXdpdGhCdW5kbGVDaGFuZ2VkICYmIHdpdGhNZWRpYUNoYW5nZWQpXG5cdFx0XHRcdFx0dGYucnVuVHJhbnNpdGlvbihidW5kbGVDaGFuZ2VkID8gdHguQkVUV0VFTiA6IHR4Tm93KTsgLy90eC5OT1cpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRmLmhhc09mZnNldClcblx0XHRcdFx0dGYuY2xlYXJPZmZzZXQoKTtcblxuXHRcdFx0LyogSE9SSVpPTlRBTDogdGhlIHJlc3QgKi9cblx0XHRcdGlmIChjb2xsYXBzZWRDaGFuZ2VkIF4gd2l0aEFydGljbGVDaGFuZ2VkKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZCA/IHR4LkxBU1QgOiB0eC5GSVJTVCxcblx0XHRcdFx0XHR0aGlzLnNpdGVuYW1lLmVsLCB0aGlzLmFib3V0LmVsLCB0aGlzLmJ1bmRsZUxpc3Qud3JhcHBlcik7XG5cdFx0XHRcdC8vIGlmIChmcm9tUm91dGUgIT0gJ2FydGljbGUtaXRlbScgJiYgdG9Sb3V0ZSAhPSAnbWVkaWEtaXRlbScpIHtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLnJ1blRyYW5zaXRpb24oY29sbGFwc2VkID8gdHguTEFTVCA6IHR4LkZJUlNULCB0aGlzLmhHcm91cGluZ3MpO1xuXHRcdFx0XHQvLyB9XG5cdFx0XHR9XG5cdFx0XHQvKiBWRVJUSUNBTCAqL1xuXHRcdFx0aWYgKHJvdXRlQ2hhbmdlZCAmJiAoZnJvbVJvdXRlID09ICdyb290JyB8fCB0b1JvdXRlID09ICdyb290JykpIHtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLnJ1blRyYW5zaXRpb24odHguQkVUV0VFTixcblx0XHRcdFx0XHR0aGlzLnNpdGVuYW1lLndyYXBwZXIsIHRoaXMuYWJvdXQud3JhcHBlcik7XG5cdFx0XHR9XG5cdFx0XHQvKiB0aGlzLmhHcm91cGluZ3MgKi9cblx0XHRcdC8vIGlmIChjb2xsYXBzZWRDaGFuZ2VkIF4gd2l0aEFydGljbGVDaGFuZ2VkKSB7XG5cdFx0XHQvLyBcdC8vIGlmIChjb2xsYXBzZWRDaGFuZ2VkICYmICF3aXRoQXJ0aWNsZUNoYW5nZWQpIHtcblx0XHRcdC8vIFx0dGhpcy50cmFuc2Zvcm1zLnJ1blRyYW5zaXRpb24oY29sbGFwc2VkID8gdHguTEFTVCA6IHR4LkZJUlNULCB0aGlzLmhHcm91cGluZ3MpO1xuXHRcdFx0Ly8gfVxuXHRcdFx0Ly8gaWYgKGNvbGxhcHNlZENoYW5nZWQpIHtcblx0XHRcdC8vIFx0aWYgKCF3aXRoQXJ0aWNsZUNoYW5nZWQpIHtcblx0XHRcdC8vIFx0XHQvLyBpZiAoZnJvbVJvdXRlID09ICdyb290JyB8fCB0b1JvdXRlID09ICdyb290Jykge1xuXHRcdFx0Ly8gXHRcdHRoaXMudHJhbnNmb3Jtcy5ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZCA/IHR4LkxBU1QgOiB0eC5GSVJTVCwgdGhpcy5idW5kbGVMaXN0LndyYXBwZXIpO1xuXHRcdFx0Ly8gXHR9XG5cdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0Ly8gXHRpZiAod2l0aEFydGljbGVDaGFuZ2VkICYmIHdpdGhCdW5kbGVDaGFuZ2VkKSB7XG5cdFx0XHQvLyBcdFx0dGhpcy50cmFuc2Zvcm1zLnJ1blRyYW5zaXRpb24od2l0aEFydGljbGUgPyB0eC5CRVRXRUVOIDogdHguTEFTVCwgdGhpcy5idW5kbGVMaXN0LndyYXBwZXIpO1xuXHRcdFx0Ly8gXHR9XG5cdFx0XHQvLyB9XG5cdFx0fSBlbHNlIGlmIChHbG9iYWxzLkJSRUFLUE9JTlRTW1wic21hbGwtc3RyZXRjaFwiXS5tYXRjaGVzKSB7XG5cdFx0XHQvLyBpZiAoY29sbGFwc2VkQ2hhbmdlZCApIHtcblx0XHRcdGlmIChjb2xsYXBzZWRDaGFuZ2VkIF4gd2l0aEFydGljbGVDaGFuZ2VkKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZCA/IHR4LkZJUlNUIDogdHguTEFTVCxcblx0XHRcdFx0XHR0aGlzLnNpdGVuYW1lLmVsLCB0aGlzLmFib3V0LmVsKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHdpdGhCdW5kbGVDaGFuZ2VkKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5ydW5UcmFuc2l0aW9uKHR4LkJFVFdFRU4sXG5cdFx0XHRcdFx0dGhpcy5zaXRlbmFtZS5lbCwgdGhpcy5hYm91dC5lbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIHRoaXMudHJhbnNmb3Jtcy5jbGVhck9mZnNldChcblx0XHQvLyBcdC8vIHRoaXMuYnVuZGxlTGlzdC5lbCxcblx0XHQvLyBcdC8vIHRoaXMua2V5d29yZExpc3QuZWwsXG5cdFx0Ly8gXHR0aGlzLmJ1bmRsZUxpc3Qud3JhcHBlcik7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0Lyogb3duIG1vZGVsIGNoYW5nZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uTW9kZWxDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0dGhpcy5zZXRJbW1lZGlhdGUodGhpcy5jb21taXRNb2RlbCk7XG5cdFx0Ly8gfSxcblx0XHQvL1xuXHRcdC8vIGNvbW1pdE1vZGVsOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0aGlzLnJlcXVlc3RSZW5kZXIoVmlldy5NT0RFTF9JTlZBTElEIHwgVmlldy5MQVlPVVRfSU5WQUxJRCk7XG5cdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKFZpZXcuTU9ERUxfSU5WQUxJRCk7XG5cdFx0Ly8ga2V5d29yZHMuZGVzZWxlY3QoKTtcblx0XHRpZiAodGhpcy5tb2RlbC5oYXNDaGFuZ2VkKFwiY29sbGFwc2VkXCIpKSB7XG5cdFx0XHRpZiAodGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHRcdFx0Ly8gY2xlYXIga2V5d29yZCBzZWxlY3Rpb25cblx0XHRcdFx0a2V5d29yZHMuZGVzZWxlY3QoKTtcblx0XHRcdH0gLy8gZWxzZSB7fVxuXHRcdFx0dGhpcy5rZXl3b3JkTGlzdC5jb2xsYXBzZWQgPSB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKTtcblx0XHRcdHRoaXMuYnVuZGxlTGlzdC5jb2xsYXBzZWQgPSB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcImJ1bmRsZVwiKSkge1xuXHRcdFx0dGhpcy5idW5kbGVMaXN0LnNlbGVjdGVkSXRlbSA9IHRoaXMubW9kZWwuZ2V0KFwiYnVuZGxlXCIpO1xuXHRcdFx0dGhpcy5rZXl3b3JkTGlzdC5yZWZyZXNoRmlsdGVyKCk7XG5cblx0XHRcdC8vIGlmICghdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikgJiYgdGhpcy5ncmFwaCkge1xuXHRcdFx0Ly8gXHR0aGlzLmxpc3RlblRvT25jZSh0aGlzLmtleXdvcmRMaXN0LCBcInZpZXc6cmVuZGVyOmFmdGVyXCIsIGZ1bmN0aW9uKHZpZXcsIGZsYWdzKSB7XG5cdFx0XHQvLyBcdFx0Y29uc29sZS5sb2coXCIlczo6X29uQnVuZGxlU2VsZWN0IC0+ICVzOlt2aWV3OnJlbmRlcjphZnRlcl0gZmxhZ3M6JXNcIiwgdGhpcy5jaWQsIHZpZXcuY2lkLCBWaWV3LmZsYWdzVG9TdHJpbmcoZmxhZ3MpKTtcblx0XHRcdC8vIFx0XHR0aGlzLmdyYXBoLnZhbHVlVG8oIFwiYTJiXCIsIDAsICAwKTtcblx0XHRcdC8vIFx0XHQvLyB0aGlzLmdyYXBoLnJlbmRlck5vdygpO1xuXHRcdFx0Ly8gXHRcdHRoaXMuZ3JhcGgudmFsdWVUbyggXCJhMmJcIiwgMSwgIEdsb2JhbHMuVFJBTlNJVElPTl9EVVJBVElPTik7XG5cdFx0XHQvLyBcdH0pO1xuXHRcdFx0Ly8gfVxuXHRcdFx0Ly8ga2V5d29yZHMuZGVzZWxlY3QoKTtcblx0XHRcdC8vIHRoaXMuZ3JhcGggJiYgdGhpcy5ncmFwaC5yZXF1ZXN0UmVuZGVyKFZpZXcuU0laRV9JTlZBTElEKTtcblx0XHR9XG5cdFx0Ly8gdmFyIGNsaWNrRXYgPSBcImNsaWNrXCI7Ly9WaWV3LkNMSUNLX0VWRU5UXG5cdFx0aWYgKHRoaXMubW9kZWwuaGFzQ2hhbmdlZChcIndpdGhCdW5kbGVcIikpIHtcblx0XHRcdC8vIHRoaXMua2V5d29yZExpc3QucmVmcmVzaEZpbHRlcigpXG5cdFx0XHRpZiAodGhpcy5tb2RlbC5nZXQoXCJ3aXRoQnVuZGxlXCIpKSB7XG5cblx0XHRcdFx0dGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFZpZXcuQ0xJQ0tfRVZFTlQsIHRoaXMuX29uTmF2aWdhdGlvbkNsaWNrKTtcblx0XHRcdFx0dGhpcy52cGFuLm9uKFwidnBhbnN0YXJ0XCIsIHRoaXMuX29uVlBhblN0YXJ0KTtcblx0XHRcdFx0dGhpcy5ocGFuLm9uKFwiaHBhbnN0YXJ0XCIsIHRoaXMuX29uSFBhblN0YXJ0KTtcblx0XHRcdFx0Ly8gdGhpcy5ocGFuLm9uKFwidGFwXCIsIHRoaXMuX29uVGFwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihWaWV3LkNMSUNLX0VWRU5ULCB0aGlzLl9vbk5hdmlnYXRpb25DbGljayk7XG5cdFx0XHRcdHRoaXMudnBhbi5vZmYoXCJ2cGFuc3RhcnRcIiwgdGhpcy5fb25WUGFuU3RhcnQpO1xuXHRcdFx0XHR0aGlzLmhwYW4ub2ZmKFwiaHBhbnN0YXJ0XCIsIHRoaXMuX29uSFBhblN0YXJ0KTtcblx0XHRcdFx0a2V5d29yZHMuZGVzZWxlY3QoKTtcblx0XHRcdFx0Ly8gdGhpcy5ocGFuLm9mZihcInRhcFwiLCB0aGlzLl9vblRhcCk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0aGlzLmdyYXBoLnZhbHVlVG8oKVxuXHRcdH1cblx0fSxcblxuXHQvLyBfb253aXRoQnVuZGxlQ2hhbmdlOiBmdW5jdGlvbih3aXRoQnVuZGxlKSB7XG5cdC8vIFx0aWYgKHdpdGhCdW5kbGUpIHtcblx0Ly8gXHRcdHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJjb2xsYXBzZWQ6Y2hhbmdlXCIsIGZ1bmN0aW9uKGNvbGxhcHNlZCl7XG5cdC8vXG5cdC8vIFx0XHR9KTtcblx0Ly8gXHR9IGVsc2Uge1xuXHQvLyBcdFx0dGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMubW9kZWwsIFwiY29sbGFwc2VkOmNoYW5nZVwiLCBmdW5jdGlvbihjb2xsYXBzZWQpe1xuXHQvL1xuXHQvLyBcdFx0fSk7XG5cdC8vIFx0fVxuXHQvLyB9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIGtleXdvcmQgY29sbGVjdGlvbiBjaGFuZ2VkXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9vbktleXdvcmRTZWxlY3Q6IGZ1bmN0aW9uKGtleXdvcmQpIHtcblx0XHQvLyB1c2UgY29sbGVjdGlvbiBsaXN0ZW5lciB0byBhdm9pZCByZWR1bmRhbnQgcmVmcmVzaEZpbHRlciBjYWxsc1xuXHRcdGlmICghdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikgJiYgdGhpcy5ncmFwaCkge1xuXHRcdFx0dGhpcy5saXN0ZW5Ub09uY2UodGhpcy5idW5kbGVMaXN0LCBcInZpZXc6cmVuZGVyOmFmdGVyXCIsIGZ1bmN0aW9uKHZpZXcsIGZsYWdzKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6Ol9vbktleXdvcmRTZWxlY3QgLT4gJXM6W3ZpZXc6cmVuZGVyOmFmdGVyXSBmbGFnczolc1wiLCB0aGlzLmNpZCwgdmlldy5jaWQsIFZpZXcuZmxhZ3NUb1N0cmluZyhmbGFncykpO1xuXHRcdFx0XHR0aGlzLmdyYXBoLnZhbHVlVG8oXCJiMmFcIiwgMCwgMCk7XG5cdFx0XHRcdHRoaXMuZ3JhcGgudmFsdWVUbyhcImIyYVwiLCAxLCBHbG9iYWxzLlRSQU5TSVRJT05fRFVSQVRJT04pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHRoaXMuYnVuZGxlTGlzdC5yZWZyZXNoRmlsdGVyKCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogVUkgRXZlbnRzOiBidW5kbGVMaXN0IGtleXdvcmRMaXN0IGJ1dHRvbnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uTmF2aWdhdGlvbkNsaWNrOiBmdW5jdGlvbihldikge1xuXHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9vbk5hdmlnYXRpb25DbGljayBbJXNdIGRlZmF1bHRQcmV2ZW50ZWQ6JXNcIiwgdGhpcy5jaWQsIGV2LnR5cGUsIGV2LmRlZmF1bHRQcmV2ZW50ZWQpO1xuXHRcdGlmIChldi5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cdFx0Ly8gaWYgKGV2LnRhcmdldCAhPT0gdGhpcy5ncmFwaC5lbCAmJiBldi50YXJnZXQgIT09IHRoaXMuZWwpIHJldHVybjtcblxuXHRcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0aWYgKHRoaXMubW9kZWwuaGFzKFwiYnVuZGxlXCIpKSB7XG5cdFx0XHQvLyB0aGlzLnRyYW5zZm9ybXMub2Zmc2V0KDAsIDEsIHRoaXMuZ3JhcGguZWwpO1xuXHRcdFx0Ly8gdGhpcy50cmFuc2Zvcm1zLnZhbGlkYXRlKCk7XG5cdFx0XHQvLyB0aGlzLl9zZXRDb2xsYXBzZWQoIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKTtcblx0XHRcdC8vIHRoaXMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RlbC5zZXQoXCJjb2xsYXBzZWRcIiwgIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKTtcblx0XHRcdC8vIH0pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Q29sbGFwc2VkOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIikpIHtcblx0XHRcdC8vIHRoaXMudHJhbnNmb3Jtcy5vZmZzZXQoMCwgMSwgdGhpcy5ncmFwaC5lbCk7XG5cdFx0XHQvLyB0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblx0XHRcdHRoaXMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjpfc2V0Q29sbGFwc2VkIC0+ICVzIChzZXRJbW1lZGlhdGUpXCIsIHRoaXMuY2lkLCB2YWx1ZSk7XG5cdFx0XHRcdHRoaXMubW9kZWwuc2V0KFwiY29sbGFwc2VkXCIsIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIEhvcml6b250YWwgdG91Y2gvbW92ZSAoSGFtbWVySlMpXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfb25IUGFuU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50cmFuc2Zvcm1zLmdldCh0aGlzLmtleXdvcmRMaXN0LndyYXBwZXIpXG5cdFx0XHQuc3RvcFRyYW5zaXRpb24oKVxuXHRcdFx0LmNsZWFyT2Zmc2V0KClcblx0XHRcdC52YWxpZGF0ZSgpO1xuXHRcdC8vIGlmICh0aGlzLm1vZGVsLmdldChcImxheW91dE5hbWVcIikgIT0gXCJsZWZ0LWxheW91dFwiXG5cdFx0Ly8gXHQmJiB0aGlzLm1vZGVsLmdldChcImxheW91dE5hbWVcIikgIT0gXCJkZWZhdWx0LWxheW91dFwiKSB7XG5cdFx0Ly8gXHRyZXR1cm47XG5cdFx0Ly8gfVxuXHRcdGlmIChHbG9iYWxzLkJSRUFLUE9JTlRTW1wibWVkaXVtLXdpZGVcIl0ubWF0Y2hlc1xuXHRcdFx0JiYgdGhpcy5tb2RlbC5nZXQoXCJidW5kbGVcIikuZ2V0KFwibWVkaWFcIikuc2VsZWN0ZWRJbmRleCA8PSAwXG5cdFx0XHQmJiB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkge1xuXHRcdFx0dGhpcy50cmFuc2Zvcm1zLmdldCh0aGlzLmtleXdvcmRMaXN0LndyYXBwZXIpLmNsZWFyQ2FwdHVyZSgpO1xuXHRcdFx0dGhpcy5fb25IUGFuTW92ZShldik7XG5cblx0XHRcdHRoaXMuaHBhbi5vbihcImhwYW5tb3ZlXCIsIHRoaXMuX29uSFBhbk1vdmUpO1xuXHRcdFx0dGhpcy5ocGFuLm9uKFwiaHBhbmVuZCBocGFuY2FuY2VsXCIsIHRoaXMuX29uSFBhbkZpbmFsKTtcblx0XHR9XG5cdH0sXG5cblx0X29uSFBhbk1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0Ly8gdmFyIEhQQU5fRFJBRyA9IDE7XG5cdFx0Ly8gdmFyIEhQQU5fRFJBRyA9IDAuNzU7XG5cdFx0dmFyIEhQQU5fRFJBRyA9IDcyMCAvIDkyMDtcblx0XHR2YXIgZGVsdGEgPSBldi5kZWx0YVg7IC8vZXYudGhyZXNob2xkRGVsdGFYO1xuXHRcdC8vIHZhciBtZWRpYUl0ZW1zID0gdGhpcy5tb2RlbC5nZXQoXCJidW5kbGVcIikuZ2V0KFwibWVkaWFcIik7XG5cblx0XHRpZiAodGhpcy5tb2RlbC5oYXMoXCJtZWRpYVwiKSkge1xuXHRcdFx0ZGVsdGEgKj0gKGV2Lm9mZnNldERpcmVjdGlvbiAmIEhhbW1lci5ESVJFQ1RJT05fTEVGVCkgP1xuXHRcdFx0XHQwLjAgOiBIUEFOX0RSQUc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbHRhICo9IChldi5vZmZzZXREaXJlY3Rpb24gJiBIYW1tZXIuRElSRUNUSU9OX0xFRlQpID9cblx0XHRcdFx0SFBBTl9EUkFHIDogR2xvYmFscy5IUEFOX09VVF9EUkFHO1xuXHRcdH1cblx0XHR0aGlzLnRyYW5zZm9ybXMub2Zmc2V0KGRlbHRhLCBudWxsLCB0aGlzLmtleXdvcmRMaXN0LndyYXBwZXIpO1xuXHRcdHRoaXMudHJhbnNmb3Jtcy52YWxpZGF0ZSgpO1xuXHR9LFxuXG5cdF9vbkhQYW5GaW5hbDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLmhwYW4ub2ZmKFwiaHBhbm1vdmVcIiwgdGhpcy5fb25IUGFuTW92ZSk7XG5cdFx0dGhpcy5ocGFuLm9mZihcImhwYW5lbmQgaHBhbmNhbmNlbFwiLCB0aGlzLl9vbkhQYW5GaW5hbCk7XG5cblx0XHQvKiBOT1RFOiBpZiB0aGVyZSBpcyBubyBtb2RlbCBjaGFuZ2UsIHNldCB0eCBoZXJlLiBPdGhlcndpc2UganVzdCB3YWl0IGZvciByZW5kZXIgKi9cblx0XHR2YXIga1RmID0gdGhpcy50cmFuc2Zvcm1zLmdldCh0aGlzLmtleXdvcmRMaXN0LndyYXBwZXIpO1xuXHRcdGlmICghKHRoaXMuX3JlbmRlckZsYWdzICYgVmlldy5NT0RFTF9JTlZBTElEKSAmJiBrVGYuaGFzT2Zmc2V0KSB7XG5cdFx0XHRpZiAoa1RmLm9mZnNldFggIT0gMCkge1xuXHRcdFx0XHRrVGYucnVuVHJhbnNpdGlvbih0eC5OT1cpO1xuXHRcdFx0fVxuXHRcdFx0a1RmLmNsZWFyT2Zmc2V0KCkudmFsaWRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBWZXJ0aWNhbCB0b3VjaC9tb3ZlIChfb25WUGFuKilcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9jb2xsYXBzZWRPZmZzZXRZOiBHbG9iYWxzLkNPTExBUFNFX09GRlNFVCxcblxuXHRfb25WUGFuU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy52cGFuLm9uKFwidnBhbm1vdmVcIiwgdGhpcy5fb25WUGFuTW92ZSk7XG5cdFx0dGhpcy52cGFuLm9uKFwidnBhbmVuZCB2cGFuY2FuY2VsXCIsIHRoaXMuX29uVlBhbkZpbmFsKTtcblxuXG5cdFx0dGhpcy50cmFuc2Zvcm1zLnN0b3BUcmFuc2l0aW9uKHRoaXMudnBhbkdyb3VwKTtcblx0XHR0aGlzLnRyYW5zZm9ybXMuY2xlYXJDYXB0dXJlKHRoaXMudnBhbkdyb3VwKTtcblx0XHQvLyB0aGlzLnRyYW5zZm9ybXMuc3RvcFRyYW5zaXRpb24odGhpcy5idW5kbGVMaXN0LmVsLCB0aGlzLmtleXdvcmRMaXN0LmVsKTsgLy8sIHRoaXMuZ3JhcGguZWwpO1xuXHRcdC8vIC8vIHRoaXMudHJhbnNmb3Jtcy5jbGVhck9mZnNldCh0aGlzLmJ1bmRsZUxpc3QuZWwsIHRoaXMua2V5d29yZExpc3QuZWwpO1xuXHRcdC8vIC8vIHRoaXMudHJhbnNmb3Jtcy52YWxpZGF0ZSgpO1xuXHRcdC8vIHRoaXMudHJhbnNmb3Jtcy5jbGVhckNhcHR1cmUodGhpcy5idW5kbGVMaXN0LmVsLCB0aGlzLmtleXdvcmRMaXN0LmVsKTsgLy8sIHRoaXMuZ3JhcGguZWwpO1xuXHRcdC8vXG5cdFx0Ly8gaWYgKCF0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkge1xuXHRcdC8vIFx0dGhpcy50cmFuc2Zvcm1zLnN0b3BUcmFuc2l0aW9uKHRoaXMuZ3JhcGguZWwpO1xuXHRcdC8vIFx0dGhpcy50cmFuc2Zvcm1zLmNsZWFyQ2FwdHVyZSh0aGlzLmdyYXBoLmVsKTtcblx0XHQvLyB9XG5cdFx0Ly8gLy8gdGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiY29udGFpbmVyLWNoYW5naW5nXCIpO1xuXG5cdFx0Ly8gdGhpcy5fb25WUGFuTW92ZShldik7XG5cdH0sXG5cblx0X29uVlBhbk1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5fY29tcHV0ZVZQYW5EZWx0YShldi5kZWx0YVkpOyAvL2V2LnRocmVzaG9sZERlbHRhWSk7XG5cblx0XHR0aGlzLnRyYW5zZm9ybXMub2Zmc2V0KDAsIGRlbHRhLCB0aGlzLnZwYW5Hcm91cCk7XG5cdFx0Ly8gdGhpcy50cmFuc2Zvcm1zLm9mZnNldCgwLCBkZWx0YSxcblx0XHQvLyBcdHRoaXMuYnVuZGxlTGlzdC5lbCwgdGhpcy5rZXl3b3JkTGlzdC5lbCk7XG5cdFx0Ly8gaWYgKCF0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkge1xuXHRcdC8vIFx0dGhpcy50cmFuc2Zvcm1zLm9mZnNldCgwLCBkZWx0YSwgdGhpcy5ncmFwaC5lbCk7XG5cdFx0Ly8gfVxuXHRcdHRoaXMudHJhbnNmb3Jtcy52YWxpZGF0ZSgpO1xuXHR9LFxuXG5cdF9vblZQYW5GaW5hbDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnZwYW4ub2ZmKFwidnBhbm1vdmVcIiwgdGhpcy5fb25WUGFuTW92ZSk7XG5cdFx0dGhpcy52cGFuLm9mZihcInZwYW5lbmQgdnBhbmNhbmNlbFwiLCB0aGlzLl9vblZQYW5GaW5hbCk7XG5cblx0XHQvLyB0aGlzLl9vblZQYW5Nb3ZlKGV2KTtcblx0XHQvLyB0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblxuXHRcdHRoaXMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gdGhpcy50cmFuc2Zvcm1zLmNsZWFyT2Zmc2V0KHRoaXMuYnVuZGxlTGlzdC5lbCwgdGhpcy5rZXl3b3JkTGlzdC5lbCwgdGhpcy5ncmFwaC5lbCk7XG5cdFx0XHRpZiAodGhpcy53aWxsQ29sbGFwc2VkQ2hhbmdlKGV2KSkge1xuXHRcdFx0XHQvLyB0aGlzLl9zZXRDb2xsYXBzZWQoIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKTtcblx0XHRcdFx0dGhpcy5tb2RlbC5zZXQoXCJjb2xsYXBzZWRcIiwgIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVxdWVzdFJlbmRlcihWaWV3LkxBWU9VVF9JTlZBTElEKTsgLy8ucmVuZGVyTm93KCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0d2lsbENvbGxhcHNlZENoYW5nZTogZnVuY3Rpb24oZXYpIHtcblx0XHRyZXR1cm4gZXYudHlwZSA9PSBcInZwYW5lbmRcIiA/IHRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpID9cblx0XHRcdGV2LmRlbHRhWSA+IEdsb2JhbHMuQ09MTEFQU0VfVEhSRVNIT0xEIDpcblx0XHRcdGV2LmRlbHRhWSA8IC1HbG9iYWxzLkNPTExBUFNFX1RIUkVTSE9MRCA6XG5cdFx0XHRmYWxzZTtcblx0fSxcblxuXHRfY29tcHV0ZVZQYW5EZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR2YXIgY29sbGFwc2VkID0gdGhpcy5tb2RlbC5nZXQoXCJjb2xsYXBzZWRcIik7XG5cdFx0dmFyIG1heERlbHRhID0gdGhpcy5fY29sbGFwc2VkT2Zmc2V0WTsgLy8gKyBNYXRoLmFicyhldi50aHJlc2hvbGRPZmZzZXRZKTtcblx0XHQvLyBjaGVjayBpZiBkaXJlY3Rpb24gaXMgYWxpZ25lZCB3aXRoIGNvbGxhcHNlZC9leHBhbmRcblx0XHR2YXIgaXNWYWxpZERpciA9IGNvbGxhcHNlZCA/IChkZWx0YSA+IDApIDogKGRlbHRhIDwgMCk7XG5cdFx0dmFyIG1vdmVGYWN0b3IgPSBjb2xsYXBzZWQgPyAxIC0gR2xvYmFscy5WUEFOX0RSQUcgOiBHbG9iYWxzLlZQQU5fRFJBRztcblxuXHRcdGRlbHRhID0gTWF0aC5hYnMoZGVsdGEpOyAvLyByZW1vdmUgc2lnblxuXHRcdGRlbHRhICo9IG1vdmVGYWN0b3I7XG5cdFx0bWF4RGVsdGEgKj0gbW92ZUZhY3RvcjtcblxuXHRcdGlmIChpc1ZhbGlkRGlyKSB7XG5cdFx0XHRpZiAoZGVsdGEgPiBtYXhEZWx0YSkgeyAvLyBvdmVyc2hvb3Rpbmdcblx0XHRcdFx0ZGVsdGEgPSAoKGRlbHRhIC0gbWF4RGVsdGEpICogR2xvYmFscy5WUEFOX09VVF9EUkFHKSArIG1heERlbHRhO1xuXHRcdFx0fSBlbHNlIHsgLy8gbm8gb3ZlcnNob290aW5nXG5cdFx0XHRcdC8vIGRlbHRhID0gZGVsdGE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbHRhID0gKC1kZWx0YSkgKiBHbG9iYWxzLlZQQU5fT1VUX0RSQUc7IC8vIGRlbHRhIGlzIG9wcG9zaXRlXG5cdFx0fVxuXHRcdGRlbHRhICo9IGNvbGxhcHNlZCA/IDAuNSA6IC0xOyAvLyByZWFwcGx5IHNpZ25cblx0XHRyZXR1cm4gZGVsdGE7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBDcmVhdGUgY2hpbGRyZW4gY29tcG9uZW50c1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyAjc2l0ZS1uYW1lXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRjcmVhdGVTaXRlbmFtZUJ1dHRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSBuZXcgVmlldyh7XG5cdFx0XHRlbDogXCIjc2l0ZS1uYW1lXCIsXG5cdFx0XHRldmVudHM6IHtcblx0XHRcdFx0XCJjbGljayBhXCI6IGZ1bmN0aW9uKGRvbWV2KSB7XG5cdFx0XHRcdFx0ZG9tZXYuZGVmYXVsdFByZXZlbnRlZCB8fCBkb21ldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6Y2xpY2tcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHR2aWV3LndyYXBwZXIgPSB2aWV3LmVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0dGhpcy5saXN0ZW5Ubyh2aWV3LCBcInZpZXc6Y2xpY2tcIiwgdGhpcy5fb25TaXRlbmFtZUNsaWNrKTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHRfb25TaXRlbmFtZUNsaWNrOiBmdW5jdGlvbigpIHtcblx0XHRzd2l0Y2ggKHRoaXMubW9kZWwuZ2V0KFwicm91dGVOYW1lXCIpKSB7XG5cdFx0XHRjYXNlIFwibWVkaWEtaXRlbVwiOlxuXHRcdFx0Y2FzZSBcImJ1bmRsZS1pdGVtXCI6XG5cdFx0XHRcdC8vIGlmICh0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkge1xuXHRcdFx0XHQvLyBcdHRoaXMuX3NldENvbGxhcHNlZChmYWxzZSk7XG5cdFx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRyb2xsZXIuZGVzZWxlY3RCdW5kbGUoKTtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJhcnRpY2xlLWl0ZW1cIjpcblx0XHRcdFx0Y29udHJvbGxlci5kZXNlbGVjdEFydGljbGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gLmFydGljbGUtYnV0dG9uXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRjcmVhdGVBcnRpY2xlQnV0dG9uOiBmdW5jdGlvbihhcnRpY2xlSXRlbSkge1xuXHRcdHZhciB2aWV3ID0gbmV3IEFydGljbGVCdXR0b24oe1xuXHRcdFx0ZWw6IFwiLmFydGljbGUtYnV0dG9uW2RhdGEtaGFuZGxlPSdhYm91dCddXCIsXG5cdFx0XHRtb2RlbDogYXJ0aWNsZUl0ZW1cblx0XHR9KS5yZW5kZXIoKTtcblx0XHR2aWV3LndyYXBwZXIgPSB2aWV3LmVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0dGhpcy5saXN0ZW5Ubyh2aWV3LCBcInZpZXc6Y2xpY2tcIiwgdGhpcy5fb25BcnRpY2xlQ2xpY2spO1xuXHRcdHJldHVybiB2aWV3O1xuXHR9LFxuXG5cdF9vbkFydGljbGVDbGljazogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHN3aXRjaCAodGhpcy5tb2RlbC5nZXQoXCJyb3V0ZU5hbWVcIikpIHtcblx0XHRcdGNhc2UgXCJhcnRpY2xlLWl0ZW1cIjpcblx0XHRcdFx0Y29udHJvbGxlci5kZXNlbGVjdEFydGljbGUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicm9vdFwiOlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29udHJvbGxlci5zZWxlY3RBcnRpY2xlKGl0ZW0pO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0Y3JlYXRlQWJvdXRCdXR0b246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUFydGljbGVCdXR0b24oYXJ0aWNsZXMuZmluZFdoZXJlKHsgaGFuZGxlOiBcImFib3V0XCIgfSkpO1xuXHR9LFxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gI2J1bmRsZS1saXN0XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQvKipcblx0ICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH1cblx0ICogQHJldHVybiB7bW9kdWxlOmFwcC9iYXNlL3ZpZXcvY29tcG9uZW50L0ZpbHRlcmFibGVMaXN0Vmlld31cblx0ICovXG5cdGNyZWF0ZUJ1bmRsZUxpc3Q6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0dmFyIHZpZXcgPSBuZXcgRmlsdGVyYWJsZUxpc3RWaWV3KHtcblx0XHRcdGVsOiBcIiNidW5kbGUtbGlzdFwiLFxuXHRcdFx0Y29sbGVjdGlvbjogYnVuZGxlcyxcblx0XHRcdGNvbGxhcHNlZDogZmFsc2UsXG5cdFx0XHRmaWx0ZXJGbjogZnVuY3Rpb24oYnVuZGxlLCBpbmRleCwgYXJyKSB7XG5cdFx0XHRcdHJldHVybiBrZXl3b3Jkcy5zZWxlY3RlZCA/XG5cdFx0XHRcdFx0YnVuZGxlLmdldChcImtJZHNcIikuaW5kZXhPZihrZXl3b3Jkcy5zZWxlY3RlZC5pZCkgIT09IC0xIDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHRcdHZpZXcud3JhcHBlciA9IHZpZXcuZWwucGFyZW50RWxlbWVudDtcblx0XHR0aGlzLmxpc3RlblRvKHZpZXcsIFwidmlldzpzZWxlY3Q6b25lIHZpZXc6c2VsZWN0Om5vbmVcIiwgZnVuY3Rpb24oYnVuZGxlKSB7XG5cdFx0XHR0aGlzLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29udHJvbGxlci5zZWxlY3RCdW5kbGUoYnVuZGxlKTtcblx0XHRcdH0pO1xuXHRcdH0pXG5cdFx0dGhpcy5saXN0ZW5Ubyh2aWV3LCBcInZpZXc6c2VsZWN0OnNhbWVcIiwgdGhpcy5fb25CdW5kbGVMaXN0U2FtZSk7XG5cdFx0cmV0dXJuIHZpZXc7XG5cdH0sXG5cblx0X29uQnVuZGxlTGlzdFNhbWU6IGZ1bmN0aW9uKGJ1bmRsZSkge1xuXHRcdC8vIHRoaXMudHJhbnNmb3Jtcy5vZmZzZXQoMCwgMSwgdGhpcy5ncmFwaC5lbCk7XG5cdFx0Ly8gdGhpcy50cmFuc2Zvcm1zLnZhbGlkYXRlKCk7XG5cdFx0Ly8gdGhpcy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJjb2xsYXBzZWRcIiwgIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKTtcblx0XHQvLyB9KTtcblx0fSxcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vICNrZXl3b3JkLWxpc3Rcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fVxuXHQgKiBAcmV0dXJuIHttb2R1bGU6YXBwL2Jhc2Uvdmlldy9jb21wb25lbnQvR3JvdXBpbmdMaXN0Vmlld31cblx0ICovXG5cdGNyZWF0ZUtleXdvcmRMaXN0OiBmdW5jdGlvbihlbCkge1xuXHRcdHZhciB2aWV3ID0gbmV3IEdyb3VwaW5nTGlzdFZpZXcoe1xuXHRcdFx0ZWw6IFwiI2tleXdvcmQtbGlzdFwiLFxuXHRcdFx0Y29sbGVjdGlvbjoga2V5d29yZHMsXG5cdFx0XHRjb2xsYXBzZWQ6IGZhbHNlLFxuXHRcdFx0ZmlsdGVyRm46IGZ1bmN0aW9uKGl0ZW0sIGlkeCwgYXJyKSB7XG5cdFx0XHRcdHJldHVybiBidW5kbGVzLnNlbGVjdGVkID9cblx0XHRcdFx0XHQoYnVuZGxlcy5zZWxlY3RlZC5nZXQoXCJrSWRzXCIpLmluZGV4T2YoaXRlbS5pZCkgIT09IC0xKSA6IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGdyb3VwaW5nRm46IGZ1bmN0aW9uKGl0ZW0sIGlkeCwgYXJyKSB7XG5cdFx0XHRcdHJldHVybiB0eXBlcy5nZXQoaXRlbS5nZXQoXCJ0SWRcIikpO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0XHR2aWV3LndyYXBwZXIgPSB2aWV3LmVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0dmlldy5saXN0ZW5UbyhrZXl3b3JkcywgXCJzZWxlY3Q6b25lIHNlbGVjdDpub25lXCIsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZpZXcuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHR9KTtcblx0XHR0aGlzLmxpc3RlblRvKHZpZXcsIFwidmlldzpzZWxlY3Q6b25lIHZpZXc6c2VsZWN0Om5vbmVcIiwgdGhpcy5fb25LZXl3b3JkTGlzdENoYW5nZSk7XG5cdFx0cmV0dXJuIHZpZXc7XG5cdH0sXG5cblx0X29uS2V5d29yZExpc3RDaGFuZ2U6IGZ1bmN0aW9uKGtleXdvcmQpIHtcblx0XHRpZiAoIXRoaXMubW9kZWwuZ2V0KFwiY29sbGFwc2VkXCIpKSB7XG5cdFx0XHRrZXl3b3Jkcy5zZWxlY3Qoa2V5d29yZCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gI25hdi1ncmFwaFxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0LyoqXG5cdCAqIEBwYXJhbSBsaXN0QSB7bW9kdWxlOmFwcC9iYXNlL3ZpZXcvY29tcG9uZW50L0ZpbHRlcmFibGVMaXN0Vmlld31cblx0ICogQHBhcmFtIGxpc3RCIHttb2R1bGU6YXBwL2Jhc2Uvdmlldy9jb21wb25lbnQvRmlsdGVyYWJsZUxpc3RWaWV3fVxuXHQgKiBAcGFyYW0gcGFyZW50RWwge0hUTUxFbGVtZW50fVxuXHQgKiBAcmV0dXJuIHttb2R1bGU6YXBwL2Jhc2Uvdmlldy9jb21wb25lbnQvR3JhcGhWaWV3fVxuXHQgKi9cblx0Y3JlYXRlR3JhcGhWaWV3OiBmdW5jdGlvbihsaXN0QSwgbGlzdEIsIHBhcmVudEVsKSB7XG5cdFx0dmFyIHZpZXcgPSBuZXcgR3JhcGhWaWV3KHtcblx0XHRcdGlkOiBcIm5hdi1ncmFwaFwiLFxuXHRcdFx0bGlzdEE6IGxpc3RBLFxuXHRcdFx0bGlzdEI6IGxpc3RCLFxuXHRcdFx0bW9kZWw6IHRoaXMubW9kZWwsXG5cdFx0XHR1c2VPcGFxdWU6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cGFyZW50RWwgfHwgKHBhcmVudEVsID0gdGhpcy5lbCk7XG5cdFx0cGFyZW50RWwuaW5zZXJ0QmVmb3JlKHZpZXcuZWwsIHBhcmVudEVsLmZpcnN0RWxlbWVudENoaWxkKTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIEhvcml6b250YWwgdG91Y2gvbW92ZSAoTXV0YXRpb25PYnNlcnZlcilcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qXG5cdF9iZWdpblRyYW5zZm9ybU9ic2VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghKEdsb2JhbHMuQlJFQUtQT0lOVFNbXCJtZWRpdW0td2lkZVwiXS5tYXRjaGVzICYmIHRoaXMubW9kZWwuZ2V0KFwiYnVuZGxlXCIpLmdldChcIm1lZGlhXCIpLnNlbGVjdGVkSW5kZXggPD0gMCAmJiB0aGlzLm1vZGVsLmdldChcImNvbGxhcHNlZFwiKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY2Fyb3VzZWwgPiAuZW1wdHktaXRlbVwiKTtcblx0XHRpZiAodGFyZ2V0ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5fdHJhbnNmb3JtT2JzZXJ2ZXIpIHtcblx0XHRcdHRoaXMuX3RyYW5zZm9ybU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25UcmFuc2Zvcm1NdXRhdGlvbik7XG5cdFx0fVxuXHRcdHRoaXMuX3RyYW5zZm9ybU9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogW1wic3R5bGVcIl0gfSk7XG5cdFx0dGhpcy5ocGFuLm9uKFwiaHBhbmVuZCBocGFuY2FuY2VsXCIsIHRoaXMuX2VuZFRyYW5zZm9ybU9ic2VydmUpO1xuXHRcdHRoaXMudHJhbnNmb3Jtcy5nZXQodGhpcy5rZXl3b3JkTGlzdC53cmFwcGVyKVxuXHRcdFx0LnN0b3BUcmFuc2l0aW9uKClcblx0XHRcdC5jbGVhck9mZnNldCgpXG5cdFx0XHQuY2xlYXJDYXB0dXJlKClcblx0XHRcdC52YWxpZGF0ZSgpO1xuXHR9LFxuXG5cdF9lbmRUcmFuc2Zvcm1PYnNlcnZlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1PYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5ocGFuLm9mZihcImhwYW5lbmQgaHBhbmNhbmNlbFwiLCB0aGlzLl9lbmRUcmFuc2Zvcm1PYnNlcnZlKTtcblx0XHR0aGlzLnRyYW5zZm9ybXMuZ2V0KHRoaXMua2V5d29yZExpc3Qud3JhcHBlcilcblx0XHRcdC5jbGVhck9mZnNldCgpXG5cdFx0XHQucnVuVHJhbnNpdGlvbih0eC5OT1cpXG5cdFx0XHQudmFsaWRhdGUoKTtcblx0fSxcblxuXHRfb25UcmFuc2Zvcm1NdXRhdGlvbjogZnVuY3Rpb24obXV0YXRpb25zKSB7XG5cdFx0dmFyIHRWaWV3LCB0TWV0cmljcywgdENzcywgZFR4T2JqLCBwb3M7XG5cblx0XHQvLyB0aGlzLmtleXdvcmRMaXN0LndyYXBwZXIuc3R5bGVbcHJlZml4ZWRQcm9wZXJ0eShcInRyYW5zZm9ybVwiKV07XG5cdFx0Ly8gdHJhbnNmb3JtID0gbXV0YXRpb25zWzBdLnRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVkUHJvcGVydHkoXCJ0cmFuc2Zvcm1cIikpO1xuXG5cdFx0dFZpZXcgPSBWaWV3LmZpbmRCeUVsZW1lbnQobXV0YXRpb25zWzBdLnRhcmdldCk7XG5cdFx0aWYgKHRWaWV3KSB7XG5cdFx0XHR0TWV0cmljcyA9IHRWaWV3Lm1ldHJpY3M7XG5cdFx0XHRkVHhPYmogPSB0aGlzLnRyYW5zZm9ybXMuZ2V0KHRoaXMua2V5d29yZExpc3Qud3JhcHBlcik7XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOjpfb25UcmFuc2Zvcm1NdXRhdGlvbiBbd2l0aE1lZGlhOiAlc10gdGFyZ2V0OiAoJWZcXCslZikgJWYgd3JhcHBlcjogKCVmKSAlZlwiLCB0aGlzLmNpZCxcblx0XHRcdFx0dGhpcy5tb2RlbC5oYXMoXCJtZWRpYVwiKSxcblx0XHRcdFx0dE1ldHJpY3MudHJhbnNsYXRlWCwgdE1ldHJpY3Mud2lkdGgsIHRNZXRyaWNzLnRyYW5zbGF0ZVggKyB0TWV0cmljcy53aWR0aCxcblx0XHRcdFx0ZFR4T2JqLmNhcHR1cmVkWCwgdE1ldHJpY3MudHJhbnNsYXRlWCAtIGRUeE9iai5jYXB0dXJlZFgsXG5cdFx0XHRcdHRNZXRyaWNzXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLnRyYW5zZm9ybXMub2Zmc2V0KHRNZXRyaWNzLnRyYW5zbGF0ZVggLSBkVHhPYmouY2FwdHVyZWRYLCB2b2lkIDAsIHRoaXMua2V5d29yZExpc3Qud3JhcHBlcik7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybXMudmFsaWRhdGUoKTtcblx0XHR9XG5cdH0sXG5cdCovXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFByaW9yaXR5UXVldWUgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0dGhpcy5fb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblx0dGhpcy5faXRlbXMgPSBbXTtcblx0dGhpcy5fcHJpb3JpdGllcyA9IFtdO1xuXHR0aGlzLl9udW1JdGVtcyA9IDA7XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoe1xuXHRlbnF1ZXVlOiBmdW5jdGlvbihpdGVtLCBwcmlvcml0eSkge1xuXHRcdHZhciBpID0gdGhpcy5faXRlbXMubGVuZ3RoO1xuXHRcdHRoaXMuX2l0ZW1zW2ldID0gaXRlbTtcblx0XHR0aGlzLl9wcmlvcml0aWVzW2ldID0ge1xuXHRcdFx0cHJpb3JpdHk6IChwcmlvcml0eSB8IDApLFxuXHRcdFx0aW5kZXg6IGlcblx0XHR9O1xuXHRcdHRoaXMuX251bUl0ZW1zKys7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJGcmFtZVF1ZXVlOjpSZXF1ZXN0UXVldWU6OmVucXVldWUoKSBbbnVtSXRlbXM6JWldIElEOiVpXCIsIHRoaXMuX251bUl0ZW1zLCB0aGlzLl9vZmZzZXQgKyBpKTtcblx0XHRyZXR1cm4gdGhpcy5fb2Zmc2V0ICsgaTtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRpbmRleCAtPSB0aGlzLm9mZnNldDtcblx0XHRyZXR1cm4gMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMuX2l0ZW1zLmxlbmd0aDtcblx0fSxcblxuXHRza2lwOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBpLCBpdGVtO1xuXHRcdGkgPSBpbmRleCAtIHRoaXMuX29mZnNldDtcblx0XHRpZiAoMCA+IGkgfHwgaSA+PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcblx0XHRcdC8vIFx0Y29uc29sZS53YXJuKFwiRnJhbWVRdWV1ZTo6UmVxdWVzdFF1ZXVlOjpza2lwKGlkOiVpKSBvdXQgb2YgcmFuZ2UgKCVpLSVpKVwiLCBpbmRleCwgdGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyAodGhpcy5fbnVtSXRlbXMgLSAxKSk7XG5cdFx0XHRyZXR1cm4gdm9pZCAwO1xuXHRcdH1cblx0XHRpdGVtID0gdGhpcy5faXRlbXNbaV07XG5cdFx0aWYgKGl0ZW0gIT09IG51bGwpIHtcblx0XHRcdC8vIGlmIChpdGVtID0gdGhpcy5faXRlbXNbaV0pIHtcblx0XHRcdHRoaXMuX2l0ZW1zW2ldID0gbnVsbDtcblx0XHRcdHRoaXMuX251bUl0ZW1zLS07XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXG5cdGluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuX3ByaW9yaXRpZXMuY29uY2F0KCk7XG5cdFx0aXRlbXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRpZiAoYS5wcmlvcml0eSA+IGIucHJpb3JpdHkpXG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0aWYgKGEucHJpb3JpdHkgPCBiLnByaW9yaXR5KVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9KTtcblx0XHRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKG8sIGksIGEpIHtcblx0XHRcdGFbaV0gPSBvLmluZGV4O1xuXHRcdH0sIHRoaXMpO1xuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRpdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fcHJpb3JpdGllcy5jb25jYXQoKTtcblx0XHRpdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdGlmIChhLnByaW9yaXR5ID4gYi5wcmlvcml0eSlcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRpZiAoYS5wcmlvcml0eSA8IGIucHJpb3JpdHkpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH0pO1xuXHRcdGl0ZW1zLmZvckVhY2goZnVuY3Rpb24obywgaSwgYSkge1xuXHRcdFx0YVtpXSA9IHRoaXMuX2l0ZW1zW28uaW5kZXhdO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfZW1wdHk6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHRoaXMuX29mZnNldCA9IG9mZnNldDtcblx0XHR0aGlzLl9pdGVtcy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3ByaW9yaXRpZXMubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9udW1JdGVtcyA9IDA7XG5cdH1cbn0sIHtcblxuXHRvZmZzZXQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29mZnNldDtcblx0XHR9XG5cdH0sXG5cblx0bGVuZ3RoOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG5cdFx0fVxuXHR9LFxuXG5cdG51bUl0ZW1zOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9udW1JdGVtcztcblx0XHR9XG5cdH0sXG59KTtcblxudmFyIENhbGxiYWNrUXVldWUgPSBmdW5jdGlvbihyZXF1ZXN0Rm4sIGNhbmNlbEZuKSB7XG5cdHRoaXMuX25leHRRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKDApO1xuXHR0aGlzLl9jdXJyUXVldWUgPSBudWxsO1xuXG5cdC8vIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcblx0dGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXHR0aGlzLl9ydW5JZCA9IC0xO1xuXG5cdHRoaXMuX3JlcXVlc3RGbiA9IHJlcXVlc3RGbjtcblx0dGhpcy5fY2FuY2VsRm4gPSBjYW5jZWxGbjtcblx0dGhpcy5fcnVuUXVldWUgPSB0aGlzLl9ydW5RdWV1ZS5iaW5kKHRoaXMpXG59O1xuXG5DYWxsYmFja1F1ZXVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoe1xuXHQvKipcblx0ICogQHBhcmFtIHRzdGFtcCB7aW50fVxuXHQgKi9cblx0X3J1blF1ZXVlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fcnVubmluZykgdGhyb3cgbmV3IEVycm9yKFwid3RmISEhXCIpO1xuXG5cdFx0dGhpcy5fY3VyclF1ZXVlID0gdGhpcy5fbmV4dFF1ZXVlO1xuXHRcdHRoaXMuX25leHRRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKHRoaXMuX2N1cnJRdWV1ZS5vZmZzZXQgKyB0aGlzLl9jdXJyUXVldWUubGVuZ3RoKTtcblxuXHRcdHRoaXMuX3J1bklkID0gLTE7XG5cdFx0dGhpcy5fcnVubmluZyA9IHRydWU7XG5cblx0XHR2YXIgaSwgaXRlbTtcblx0XHR2YXIgaW5kZXhlcyA9IHRoaXMuX2N1cnJRdWV1ZS5pbmRleGVzKCk7XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fY3VyclF1ZXVlLl9pdGVtcztcblx0XHRmb3IgKGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aXRlbSA9IGl0ZW1zW2luZGV4ZXNbaV1dO1xuXHRcdFx0aWYgKGl0ZW0gIT09IG51bGwpIHtcblx0XHRcdFx0aXRlbS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHZhciBzZWxmID0gdGhpcztcblx0XHQvLyB0aGlzLl9jdXJyUXVldWUuaW5kZXhlcygpLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpIHtcblx0XHQvLyBcdHZhciBmbiA9IHNlbGYuX2N1cnJRdWV1ZS5faXRlbXNbaW5kZXhdO1xuXHRcdC8vIFx0aWYgKGZuICE9PSBudWxsKSB7XG5cdFx0Ly8gXHRcdGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX2N1cnJRdWV1ZSA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fbmV4dFF1ZXVlLm51bUl0ZW1zID4gMCkge1xuXHRcdFx0dGhpcy5fcnVuSWQgPSB0aGlzLl9yZXF1ZXN0Rm4uY2FsbChudWxsLCB0aGlzLl9ydW5RdWV1ZSk7XG5cdFx0XHQvLyB0aGlzLl9ydW5JZCA9IHRoaXMuX3JlcXVlc3RGbih0aGlzLl9ydW5RdWV1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gZm4ge0Z1bmN0aW9ufVxuXHQgKiBAcGFyYW0gcHJpb3JpdHkge2ludH1cblx0ICogQHJldHVybiB7aW50fVxuXHQgKi9cblx0cmVxdWVzdDogZnVuY3Rpb24oZm4sIHByaW9yaXR5KSB7XG5cdFx0Ly8gaWYgKCF0aGlzLl9ydW5uaW5nICYmICF0aGlzLl9wZW5kaW5nKSB7XG5cdFx0Ly8gXHR0aGlzLl9wZW5kaW5nID0gdHJ1ZTtcblx0XHQvLyBcdGNvbnNvbGUud2FybihcIkZyYW1lUXVldWU6OnJlcXVlc3Qgc2V0SW1tZWRpYXRlOiBwZW5kaW5nXCIpO1xuXHRcdC8vIFx0c2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHR0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG5cdFx0Ly8gXHRcdGlmICh0aGlzLl9uZXh0UXVldWUubnVtSXRlbXMgPiAwKSB7XG5cdFx0Ly8gXHRcdFx0dGhpcy5fcnVuSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9ydW5RdWV1ZSk7XG5cdFx0Ly8gXHRcdFx0Y29uc29sZS53YXJuKFwiRnJhbWVRdWV1ZTo6cmVxdWVzdCBzZXRJbW1lZGlhdGU6IHJhZjolaSBmb3IgJWkgaXRlbXNcIiwgdGhpcy5fcnVuSWQsIHRoaXMuX25leHRRdWV1ZS5udW1JdGVtcyk7XG5cdFx0Ly8gXHRcdH0gZWxzZSB7XG5cdFx0Ly8gXHRcdFx0Y29uc29sZS53YXJuKFwiRnJhbWVRdWV1ZTo6cmVxdWVzdCBzZXRJbW1lZGlhdGU6IG5vIGl0ZW1zXCIpO1xuXHRcdC8vIFx0XHR9XG5cdFx0Ly8gXHR9KTtcblx0XHQvLyB9XG5cdFx0aWYgKCF0aGlzLl9ydW5uaW5nICYmIHRoaXMuX3J1bklkID09PSAtMSkge1xuXHRcdFx0dGhpcy5fcnVuSWQgPSB0aGlzLl9yZXF1ZXN0Rm4uY2FsbChudWxsLCB0aGlzLl9ydW5RdWV1ZSk7XG5cdFx0XHQvLyB0aGlzLl9ydW5JZCA9IHRoaXMuX3JlcXVlc3RGbih0aGlzLl9ydW5RdWV1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9uZXh0UXVldWUuZW5xdWV1ZShmbiwgcHJpb3JpdHkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gaWQge2ludH1cblx0ICogQHJldHVybiB7RnVuY3Rpb24/fVxuXHQgKi9cblx0Y2FuY2VsOiBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBmbjtcblx0XHRpZiAodGhpcy5fcnVubmluZykge1xuXHRcdFx0Zm4gPSB0aGlzLl9jdXJyUXVldWUuc2tpcChpZCkgfHwgdGhpcy5fbmV4dFF1ZXVlLnNraXAoaWQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmbiA9IHRoaXMuX25leHRRdWV1ZS5za2lwKGlkKTtcblx0XHRcdGlmICgodGhpcy5fcnVuSWQgIT09IC0xKSAmJiAodGhpcy5fbmV4dFF1ZXVlLm51bUl0ZW1zID09PSAwKSkge1xuXHRcdFx0XHR0aGlzLl9jYW5jZWxGbi5jYWxsKG51bGwsIHRoaXMuX3J1bklkKTtcblx0XHRcdFx0Ly8gdGhpcy5fY2FuY2VsRm4odGhpcy5fcnVuSWQpO1xuXHRcdFx0XHR0aGlzLl9ydW5JZCA9IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZm47XG5cdH0sXG59LCB7XG5cdHJ1bm5pbmc6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3J1bm5pbmc7XG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgUGF0aDJEICovXG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvY29tcG9uZW50L3Byb2dyZXNzL0NhbnZhc1ZpZXdcbiAqL1xuXG4vLyAvKiogQHR5cGUge21vZHVsZTpjb2xvcn0gKi9cbi8vIHZhciBDb2xvciA9IHJlcXVpcmUoXCJjb2xvclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld30gKi9cbmNvbnN0IFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3XCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvR2xvYmFsc30gKi9cbmNvbnN0IEdsb2JhbHMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvSW50ZXJwb2xhdG9yfSAqL1xuY29uc3QgSW50ZXJwb2xhdG9yID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvSW50ZXJwb2xhdG9yXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvY3NzL2dldEJveEVkZ2VTdHlsZXN9ICovXG5jb25zdCBnZXRCb3hFZGdlU3R5bGVzID0gcmVxdWlyZShcInV0aWxzL2Nzcy9nZXRCb3hFZGdlU3R5bGVzXCIpO1xuXG52YXIgTUlOX0NBTlZBU19SQVRJTyA9IDE7IC8vIC9GaXJlZm94Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KT8gMiA6IDE7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9wcm9ncmVzcy9DYW52YXNWaWV3fVxuICovXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2lkUHJlZml4OiBcImNhbnZhc1ZpZXdcIixcblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdHRhZ05hbWU6IFwiY2FudmFzXCIsXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjbGFzc05hbWU6IFwiY2FudmFzLXZpZXdcIixcblxuXHRwcm9wZXJ0aWVzOiB7XG5cdFx0cGF1c2VkOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24ocGF1c2VkKSB7XG5cdFx0XHRcdHBhdXNlZCA9ICEhKHBhdXNlZCk7XG5cdFx0XHRcdGlmICh0aGlzLl9pbnRlcnBvbGF0b3IucGF1c2VkICE9PSBwYXVzZWQpIHtcblx0XHRcdFx0XHR0aGlzLl9pbnRlcnBvbGF0b3IucGF1c2VkID0gcGF1c2VkO1xuXHRcdFx0XHRcdGlmICghcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNvbnRleHQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jdHg7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbnRlcnBvbGF0b3I6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbnRlcnBvbGF0b3I7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjYW52YXNSYXRpbzoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1JhdGlvO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH0sXG5cblx0LyoqIEB0eXBlIHtPYmplY3R9ICovXG5cdGRlZmF1bHRzOiB7XG5cdFx0dmFsdWVzOiB7XG5cdFx0XHR2YWx1ZTogMFxuXHRcdH0sXG5cdFx0bWF4VmFsdWVzOiB7XG5cdFx0XHR2YWx1ZTogMVxuXHRcdH0sXG5cdFx0cGF1c2VkOiBmYWxzZSxcblx0XHR1c2VPcGFxdWU6IGZhbHNlLFxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIGNoaWxkcmVuL2xheW91dFxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHQvLyBUT0RPOiBjbGVhbnVwIHRoaXMgb3B0aW9ucyBtZXNzXG5cdFx0b3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0cyk7XG5cdFx0b3B0aW9ucy52YWx1ZXMgPSBfLmRlZmF1bHRzKG9wdGlvbnMudmFsdWVzIHx8IHt9LCB0aGlzLmRlZmF1bHRzLnZhbHVlcyk7XG5cdFx0b3B0aW9ucy5tYXhWYWx1ZXMgPSBfLmRlZmF1bHRzKG9wdGlvbnMubWF4VmFsdWVzIHx8IHt9LCB0aGlzLmRlZmF1bHRzLm1heFZhbHVlcyk7XG5cblx0XHR0aGlzLl9pbnRlcnBvbGF0b3IgPSBuZXcgSW50ZXJwb2xhdG9yKG9wdGlvbnMudmFsdWVzLCBvcHRpb25zLm1heFZhbHVlcyk7XG5cdFx0dGhpcy5faW50ZXJwb2xhdG9yLnBhdXNlZCA9IG9wdGlvbnMucGF1c2VkO1xuXG5cdFx0dGhpcy5fdXNlT3BhcXVlID0gb3B0aW9ucy51c2VPcGFxdWU7XG5cdFx0dGhpcy5fb3B0aW9ucyA9IF8ucGljayhvcHRpb25zLCBcImNvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIpO1xuXG5cdFx0Ly8gb3BhcXVlIGJhY2tncm91bmRcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHZhciBjdHhPcHRzID0ge307XG5cdFx0Ly8gaWYgKHRoaXMuX3VzZU9wYXF1ZSkge1xuXHRcdC8vIFx0dGhpcy5fb3BhcXVlUHJvcCA9IE1vZGVybml6ci5wcmVmaXhlZChcIm9wYXF1ZVwiLCB0aGlzLmVsLCBmYWxzZSk7XG5cdFx0Ly8gXHRpZiAodGhpcy5fb3BhcXVlUHJvcCkge1xuXHRcdC8vIFx0XHR0aGlzLmVsW3RoaXMuX29wYXF1ZVByb3BdID0gdHJ1ZTtcblx0XHQvLyBcdH0gZWxzZSB7XG5cdFx0Ly8gXHRcdGN0eE9wdHMuYWxwaGEgPSB0cnVlO1xuXHRcdC8vIFx0fVxuXHRcdC8vIFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKFwiY29sb3ItYmdcIik7XG5cdFx0Ly8gfVxuXG5cdFx0Ly8gY2FudmFzJyBjb250ZXh0IGluaXRcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHRoaXMuX2N0eCA9IHRoaXMuZWwuZ2V0Q29udGV4dChcIjJkXCIsIGN0eE9wdHMpO1xuXG5cdFx0Ly8gYWRqdXN0IGNhbnZhcyBzaXplIHRvIHBpeGVsIHJhdGlvXG5cdFx0Ly8gdXBzY2FsZSB0aGUgY2FudmFzIGlmIHRoZSB0d28gcmF0aW9zIGRvbid0IG1hdGNoXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR2YXIgcmF0aW8gPSBNSU5fQ0FOVkFTX1JBVElPO1xuXHRcdHZhciBjdHhSYXRpbyA9IHRoaXMuX2N0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cdFx0aWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSBjdHhSYXRpbykge1xuXHRcdFx0Ly8gcmF0aW8gPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAvIGN0eFJhdGlvLCBNSU5fQ0FOVkFTX1JBVElPKTtcblx0XHRcdHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gLyBjdHhSYXRpbztcblx0XHRcdHJhdGlvID0gTWF0aC5tYXgocmF0aW8sIE1JTl9DQU5WQVNfUkFUSU8pO1xuXHRcdH1cblx0XHR0aGlzLl9jYW52YXNSYXRpbyA9IHJhdGlvO1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OmluaXQgY2FudmFzUmF0aW86ICVmXCIsIHRoaXMuY2lkLCB0aGlzLl9jYW52YXNSYXRpbyk7XG5cblx0XHR0aGlzLmxpc3RlblRvKHRoaXMsIFwidmlldzphdHRhY2hlZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcblx0XHRcdC8vIHRoaXMucmVuZGVyTm93KCk7XG5cdFx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKS5yZW5kZXJOb3coKTtcblx0XHR9KTtcblx0fSxcblxuXHQvLyBfY29tcHV0ZUNhbnZhc1JhdGlvOiBmdW5jdGlvbigpIHtcblx0Ly8gXHR2YXIgcmF0aW8gPSBNSU5fQ0FOVkFTX1JBVElPO1xuXHQvLyBcdHZhciBjdHhSYXRpbyA9IHRoaXMuX2N0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cdC8vIFx0aWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSBjdHhSYXRpbykge1xuXHQvLyBcdFx0Ly8gcmF0aW8gPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAvIGN0eFJhdGlvLCBNSU5fQ0FOVkFTX1JBVElPKTtcblx0Ly8gXHRcdHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gLyBjdHhSYXRpbztcblx0Ly8gXHRcdHJhdGlvID0gTWF0aC5tYXgocmF0aW8sIE1JTl9DQU5WQVNfUkFUSU8pO1xuXHQvLyBcdH1cblx0Ly8gXHR0aGlzLl9jYW52YXNSYXRpbyA9IHJhdGlvO1xuXHQvLyB9LFxuXG5cdF91cGRhdGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIGFkanVzdCBjYW52YXMgc2l6ZSB0byBwaXhlbCByYXRpb1xuXHRcdC8vIHVwc2NhbGUgdGhlIGNhbnZhcyBpZiB0aGUgdHdvIHJhdGlvcyBkb24ndCBtYXRjaFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHR2YXIgcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG5cblx0XHQvLyB0aGlzLl9jYW52YXNXaWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XG5cdFx0Ly8gdGhpcy5fY2FudmFzSGVpZ2h0ID0gdGhpcy5lbC5vZmZzZXRIZWlnaHQ7XG5cdFx0dGhpcy5fY2FudmFzV2lkdGggPSB0aGlzLmVsLnNjcm9sbFdpZHRoO1xuXHRcdHRoaXMuX2NhbnZhc0hlaWdodCA9IHRoaXMuZWwuc2Nyb2xsSGVpZ2h0O1xuXG5cdFx0aWYgKHMuYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIikge1xuXHRcdFx0dmFyIG0gPSBnZXRCb3hFZGdlU3R5bGVzKHMpO1xuXHRcdFx0dGhpcy5fY2FudmFzV2lkdGggLT0gbS5wYWRkaW5nTGVmdCArIG0ucGFkZGluZ1JpZ2h0ICsgbS5ib3JkZXJMZWZ0V2lkdGggKyBtLmJvcmRlclJpZ2h0V2lkdGg7XG5cdFx0XHR0aGlzLl9jYW52YXNIZWlnaHQgLT0gbS5wYWRkaW5nVG9wICsgbS5wYWRkaW5nQm90dG9tICsgbS5ib3JkZXJUb3BXaWR0aCArIG0uYm9yZGVyQm90dG9tV2lkdGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2FudmFzV2lkdGggKj0gdGhpcy5fY2FudmFzUmF0aW87XG5cdFx0dGhpcy5fY2FudmFzSGVpZ2h0ICo9IHRoaXMuX2NhbnZhc1JhdGlvO1xuXG5cdFx0dGhpcy5tZWFzdXJlQ2FudmFzKHRoaXMuX2NhbnZhc1dpZHRoLCB0aGlzLl9jYW52YXNIZWlnaHQsIHMpO1xuXHRcdHRoaXMuZWwud2lkdGggPSB0aGlzLl9jYW52YXNXaWR0aDtcblx0XHR0aGlzLmVsLmhlaWdodCA9IHRoaXMuX2NhbnZhc0hlaWdodDtcblx0XHQvLyB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IGggKyBcInB4XCI7XG5cdFx0Ly8gdGhpcy5lbC5zdHlsZS53aWR0aCA9IHcgKyBcInB4XCI7XG5cblx0XHQvLyBjb2xvcnNcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHRoaXMuX2NvbG9yID0gdGhpcy5fb3B0aW9ucy5jb2xvciB8fFxuXHRcdFx0cy5jb2xvciB8fCBHbG9iYWxzLkRFRkFVTFRfQ09MT1JTW1wiY29sb3JcIl07XG5cdFx0dGhpcy5fYmFja2dyb3VuZENvbG9yID0gdGhpcy5fb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHxcblx0XHRcdHMuYmFja2dyb3VuZENvbG9yIHx8IEdsb2JhbHMuREVGQVVMVF9DT0xPUlNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdO1xuXG5cdFx0Ly8gbW96T3BhcXVlXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRpZiAodGhpcy5fdXNlT3BhcXVlICYmIHRoaXMuX29wYXF1ZVByb3ApIHtcblx0XHRcdC8vIHRoaXMuZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0dGhpcy5lbFt0aGlzLl9vcGFxdWVQcm9wXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gZm9udFNpemVcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHRoaXMuX2ZvbnRTaXplID0gcGFyc2VGbG9hdChzLmZvbnRTaXplKSAqIHRoaXMuX2NhbnZhc1JhdGlvO1xuXHRcdHRoaXMuX2ZvbnRGYW1pbHkgPSBzLmZvbnRGYW1pbHk7XG5cblx0XHQvLyBwcmVwYXJlIGNhbnZhcyBjb250ZXh0XG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXG5cdFx0dGhpcy5fY3R4LmZvbnQgPSBbcy5mb250V2VpZ2h0LCBzLmZvbnRTdHlsZSwgdGhpcy5fZm9udFNpemUgKyBcInB4LzFcIiwgcy5mb250RmFtaWx5XS5qb2luKFwiIFwiKTtcblx0XHR0aGlzLl9jdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG5cdFx0dGhpcy5fY3R4LmxpbmVDYXAgPSBcImJ1dHRcIjtcblx0XHR0aGlzLl9jdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG5cdFx0dGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fY29sb3I7XG5cdFx0dGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NvbG9yO1xuXG5cdFx0dGhpcy51cGRhdGVDYW52YXModGhpcy5fY3R4LCBzKTtcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXG5cdFx0Ly8gY29uc29sZS5ncm91cCh0aGlzLmNpZCtcIjo6X3VwZGF0ZUNhbnZhc1wiKTtcblx0XHQvLyBjb25zb2xlLmxvZyhcInJhdGlvOiAgICAlZiAobWluOiAlZiwgZGV2aWNlOiAlZiwgY29udGV4dDogJXMpXCIsIHRoaXMuX2NhbnZhc1JhdGlvLCBNSU5fQ0FOVkFTX1JBVElPLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgdGhpcy5fY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgXCIod2Via2l0LW9ubHkpXCIpO1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiY29sb3JzOiAgIGZnOiAlcyBiZzogJXNcIiwgdGhpcy5fY29sb3IsIHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJzdHlsZTogICAgJXMsICVzLCBwYWRkaW5nOiAlcyAoJXMpXCIsIHMud2lkdGgsIHMuaGVpZ2h0LCBzLnBhZGRpbmcsIHMuYm94U2l6aW5nKTtcblx0XHQvLyBjb25zb2xlLmxvZyhcImJveDogICAgICAlZiB4ICVmIHB4XCIsIG0ud2lkdGgsIG0uaGVpZ2h0KTtcblx0XHQvLyBjb25zb2xlLmxvZyhcIm1lYXN1cmVkOiAlZiB4ICVmIHB4XCIsIHcsIGgpO1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiY2FudmFzOiAgICVmIHggJWYgcHhcIiwgdGhpcy5fY2FudmFzV2lkdGgsIHRoaXMuX2NhbnZhc0hlaWdodCk7XG5cdFx0Ly8gY29uc29sZS5ncm91cEVuZCgpO1xuXHR9LFxuXG5cdG1lYXN1cmVDYW52YXM6IGZ1bmN0aW9uKHcsIGgsIHMpIHtcblx0XHQvKiBhYnN0cmFjdCAqL1xuXHR9LFxuXG5cdHVwZGF0ZUNhbnZhczogZnVuY3Rpb24oY3R4LCBzKSB7XG5cdFx0LyogYWJzdHJhY3QgKi9cblx0fSxcblxuXHRfZ2V0Rm9udE1ldHJpY3M6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBrZXksIGlkeCwgbU9iaiwgbUlkeCA9IHN0ci5sZW5ndGg7XG5cdFx0Zm9yIChrZXkgaW4gR2xvYmFscy5GT05UX01FVFJJQ1MpIHtcblx0XHRcdGlkeCA9IHN0ci5pbmRleE9mKGtleSk7XG5cdFx0XHRpZiAoaWR4ICE9PSAtMSAmJiBpZHggPCBtSWR4KSB7XG5cdFx0XHRcdG1JZHggPSBpZHg7XG5cdFx0XHRcdG1PYmogPSBHbG9iYWxzLkZPTlRfTUVUUklDU1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbU9iaiB8fCB7XG5cdFx0XHRcInVuaXRzUGVyRW1cIjogMTAyNCxcblx0XHRcdFwiYXNjZW50XCI6IDkzOSxcblx0XHRcdFwiZGVzY2VudFwiOiAtMjU2XG5cdFx0fTtcblx0fSxcblxuXHRfY2xlYXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcblx0XHRcdHRoaXMuX2NsZWFyQ2FudmFzUmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdHRoaXMuX2NsZWFyQ2FudmFzUmVjdCgwLCAwLCB0aGlzLmVsLndpZHRoLCB0aGlzLmVsLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2xlYXJDYW52YXNSZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcblx0XHRpZiAodGhpcy5fdXNlT3BhcXVlKSB7XG5cdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2JhY2tncm91bmRDb2xvcjtcblx0XHRcdHRoaXMuX2N0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcblx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRTdHlsZTogZnVuY3Rpb24ocykge1xuXHRcdENhbnZhc1ZpZXcuc2V0U3R5bGUodGhpcy5fY3R4LCBzKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiByZW5kZXJcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmF0dGFjaGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJOb3coKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW5kZXJGcmFtZTogZnVuY3Rpb24odHN0YW1wLCBmbGFncykge1xuXHRcdGlmICghdGhpcy5hdHRhY2hlZCkge1xuXHRcdFx0cmV0dXJuIGZsYWdzO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiBWaWV3LlNJWkVfSU5WQUxJRCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ2FudmFzKCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9pbnRlcnBvbGF0b3IudmFsdWVzQ2hhbmdlZCkge1xuXHRcdFx0ZmxhZ3MgfD0gVmlldy5MQVlPVVRfSU5WQUxJRDtcblx0XHRcdHRoaXMuX2ludGVycG9sYXRvci5pbnRlcnBvbGF0ZSh0c3RhbXApO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAoVmlldy5MQVlPVVRfSU5WQUxJRCB8IFZpZXcuU0laRV9JTlZBTElEKSkge1xuXHRcdFx0dGhpcy5yZWRyYXcodGhpcy5fY3R4LCB0aGlzLl9pbnRlcnBvbGF0b3IsIGZsYWdzKTtcblx0XHRcdGlmICh0aGlzLl9pbnRlcnBvbGF0b3IudmFsdWVzQ2hhbmdlZCkge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2V0RW5hYmxlZDogZnVuY3Rpb24oZW5hYmxlZCkge1xuXHQvLyBcdFZpZXcucHJvdG90eXBlLnNldEVuYWJsZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0Ly8gXHRpZiAodGhpcy5hdHRhY2hlZCkge1xuXHQvLyBcdFx0Y29uc29sZS5pbmZvKFwiWyVzXSAlczo6c2V0RW5hYmxlZFwiLCB0aGlzLnBhcmVudFZpZXcuY2lkLCB0aGlzLmNpZCwgdGhpcy5lbmFibGVkKTtcblx0Ly8gXHRcdC8vIGlmICh0aGlzLl9lbmFibGVkICYmIHRoaXMuX2ludGVycG9sYXRvci52YWx1ZXNDaGFuZ2VkKSB7XG5cdC8vIFx0XHQvLyB0aGlzLnJlcXVlc3RSZW5kZXIoKTtcblx0Ly8gXHRcdC8vIHRoaXMucmVxdWVzdFJlbmRlcihDYW52YXNWaWV3LkxBWU9VVF9JTlZBTElEKTtcblx0Ly8gXHRcdC8vIH1cblx0Ly8gXHR9XG5cdC8vIH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogcHVibGljXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGdldFRhcmdldFZhbHVlOiBmdW5jdGlvbihrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJwb2xhdG9yLmdldFRhcmdldFZhbHVlKGtleSk7XG5cdH0sXG5cblx0Z2V0UmVuZGVyZWRWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludGVycG9sYXRvci5nZXRSZW5kZXJlZFZhbHVlKGtleSk7XG5cdH0sXG5cblx0dmFsdWVUbzogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgZHVyYXRpb24pIHtcblx0XHR0aGlzLl9pbnRlcnBvbGF0b3IudmFsdWVUbyhrZXksIHZhbHVlLCBkdXJhdGlvbik7XG5cdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKFZpZXcuTU9ERUxfSU5WQUxJRCB8IFZpZXcuTEFZT1VUX0lOVkFMSUQpO1xuXHR9LFxuXG5cdC8vIHVwZGF0ZVZhbHVlOiBmdW5jdGlvbihrZXkpIHtcblx0Ly8gXHRyZXR1cm4gdGhpcy5faW50ZXJwb2xhdG9yLnVwZGF0ZVZhbHVlKGtleSB8fCB0aGlzLmRlZmF1bHRLZXkpO1xuXHQvLyB9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHJlZHJhd1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRyZWRyYXc6IGZ1bmN0aW9uKGN0eCwgaW50ZXJwLCBmbGFncykge30sXG5cbn0sIHtcblx0c2V0U3R5bGU6IGZ1bmN0aW9uKGN0eCwgcykge1xuXHRcdGlmICh0eXBlb2YgcyAhPSBcIm9iamVjdFwiKSByZXR1cm47XG5cdFx0Zm9yICh2YXIgcCBpbiBzKSB7XG5cdFx0XHRzd2l0Y2ggKHR5cGVvZiBjdHhbcF0pIHtcblx0XHRcdFx0Y2FzZSBcInVuZGVmaW5lZFwiOlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzW3BdKSkgY3R4W3BdLmFwcGx5KGN0eCwgc1twXSk7XG5cdFx0XHRcdFx0ZWxzZSBjdHhbcF0uY2FsbChjdHgsIHNbcF0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGN0eFtwXSA9IHNbcF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuaWYgKERFQlVHKSB7XG5cdENhbnZhc1ZpZXcucHJvdG90eXBlLl9sb2dGbGFncyA9IFwiXCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L2Jhc2UvSW50ZXJwb2xhdG9yXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvZWFzZS9mbi9saW5lYXJ9ICovXG5jb25zdCBsaW5lYXIgPSByZXF1aXJlKFwidXRpbHMvZWFzZS9mbi9saW5lYXJcIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvSW50ZXJwb2xhdG9yfVxuICovXG52YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24odmFsdWVzLCBtYXhWYWx1ZXMsIGVhc2VWYWx1ZXMpIHtcblx0dGhpcy5fdHN0YW1wID0gMDtcblxuXHQvLyBnZXRzIHRocm93biBhd2F5IGJ5IGZpcnN0IGludGVycG9sYXRlKCkgYnV0IGF2b2lkIG51bGwgYWNjZXNzIGVycm9yc1xuXHR0aGlzLl9yZW5kZXJhYmxlS2V5cyA9IFtdO1xuXHR0aGlzLl9yZW5kZXJlZEtleXMgPSBbXTtcblxuXHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0dGhpcy5fcGF1c2VkQ2hhbmdpbmcgPSBmYWxzZTtcblx0Ly90aGlzLl9wYXVzZWRLZXlzID0gW107XG5cblx0dGhpcy5fbWF4VmFsdWVzID0gXy5pc09iamVjdChtYXhWYWx1ZXMpID8gXy5leHRlbmQoe30sIG1heFZhbHVlcykgOiB7fTtcblx0dGhpcy5fZWFzZUZuID0gXy5pc09iamVjdChlYXNlVmFsdWVzKSA/IF8uZXh0ZW5kKHt9LCBlYXNlVmFsdWVzKSA6IHt9O1xuXHR0aGlzLl92YWx1ZURhdGEgPSB7fTtcblxuXHQvLyB2YXIga2V5LCB2YWwsIG1heFZhbCwgZWFzZUZuO1xuXHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0Xy5pc051bWJlcih0aGlzLl9tYXhWYWx1ZXNba2V5XSkgfHwgKHRoaXMuX21heFZhbHVlc1trZXldID0gbnVsbCk7XG5cdFx0Xy5pc0Z1bmN0aW9uKHRoaXMuX2Vhc2VGbltrZXldKSB8fCAodGhpcy5fZWFzZUZuW2tleV0gPSBsaW5lYXIpO1xuXG5cdFx0Ly8gY3JlYXRlIHZhbHVlIG9iamVjdCBhbmQgc3RvcmUgaXRcblx0XHR0aGlzLl92YWx1ZURhdGFba2V5XSA9IHRoaXMuX2luaXRWYWx1ZSh2YWx1ZXNba2V5XSwgMCwgdGhpcy5fbWF4VmFsdWVzW2tleV0pO1xuXG5cdFx0Ly8gYWRkIHRvIG5leHQgcmVuZGVyIGxpc3Rcblx0XHR0aGlzLl9yZW5kZXJhYmxlS2V5cy5wdXNoKGtleSk7XG5cdH1cbn07XG5cbkludGVycG9sYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBwdWJsaWMgaW50ZXJmYWNlXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGlzQXRUYXJnZXQ6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJhYmxlS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuXHR9LFxuXG5cdGdldEN1cnJlbnRWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlRGF0YVtrZXldLl9yZW5kZXJlZFZhbHVlIHx8IHRoaXMuX3ZhbHVlRGF0YVtrZXldLl92YWx1ZTtcblx0fSxcblxuXHRnZXRUYXJnZXRWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlRGF0YVtrZXldLl92YWx1ZTtcblx0fSxcblxuXHRnZXRTdGFydFZhbHVlOiBmdW5jdGlvbihrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVEYXRhW2tleV0uX3N0YXJ0VmFsdWU7XG5cdH0sXG5cblx0Z2V0UmVuZGVyZWRWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlRGF0YVtrZXldLl9yZW5kZXJlZFZhbHVlO1xuXHR9LFxuXG5cdGdldE9wdGlvbjogZnVuY3Rpb24oa2V5LCBvcHQpIHtcblx0XHRpZiAob3B0ID09PSBcIm1heFwiKSByZXR1cm4gdGhpcy5fbWF4VmFsdWVzW2tleV07XG5cdFx0aWYgKG9wdCA9PT0gXCJlYXNlXCIpIHJldHVybiB0aGlzLl9lYXNlRm5ba2V5XTtcblx0fSxcblxuXHR2YWx1ZVRvOiBmdW5jdGlvbihrZXksIHZhbHVlLCBkdXJhdGlvbiwgZWFzZSkge1xuXHRcdHZhciBjaGFuZ2VkLCBkYXRhT2JqID0gdGhpcy5fdmFsdWVEYXRhW2tleV07XG5cdFx0aWYgKF8uaXNGdW5jdGlvbihlYXNlKSkge1xuXHRcdFx0dGhpcy5fZWFzZUZuW2tleV0gPSBlYXNlO1xuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjp2YWx1ZVRvIFslc11cIiwgXCJbaW50ZXJwb2xhdG9yXVwiLCBrZXksIHZhbHVlKTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhT2JqKSkge1xuXHRcdFx0Y2hhbmdlZCA9IHZhbHVlLnJlZHVjZShmdW5jdGlvbihwcmV2Q2hhbmdlZCwgaXRlbVZhbHVlLCBpKSB7XG5cdFx0XHRcdGlmIChkYXRhT2JqW2ldKSB7XG5cdFx0XHRcdFx0ZGF0YU9ialtpXSA9IHRoaXMuX2luaXROdW1iZXIoaXRlbVZhbHVlLCBkdXJhdGlvbiwgdGhpcy5fbWF4VmFsdWVzW2tleV0pO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zZXRWYWx1ZShkYXRhT2JqW2ldLCBpdGVtVmFsdWUsIGR1cmF0aW9uKSB8fCBwcmV2Q2hhbmdlZDtcblx0XHRcdH0uYmluZCh0aGlzKSwgY2hhbmdlZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoYW5nZWQgPSB0aGlzLl9zZXRWYWx1ZShkYXRhT2JqLCB2YWx1ZSwgZHVyYXRpb24pO1xuXHRcdH1cblx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyYWJsZUtleXMuaW5kZXhPZihrZXkpICE9PSAtMSB8fCB0aGlzLl9yZW5kZXJhYmxlS2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHVwZGF0ZVZhbHVlOiBmdW5jdGlvbihrZXkpIHtcblx0XHQvLyBDYWxsIF9pbnRlcnBvbGF0ZUtleSBvbmx5IGlmIG5lZWRlZC4gX2ludGVycG9sYXRlS2V5KCkgcmV0dXJucyBmYWxzZVxuXHRcdC8vIG9uY2UgaW50ZXJwb2xhdGlvbiBpcyBkb25lLCBpbiB3aGljaCBjYXNlIHJlbW92ZSBrZXkgZnJvbSBfcmVuZGVyYWJsZUtleXMuXG5cdFx0dmFyIGtJbmRleCA9IHRoaXMuX3JlbmRlcmFibGVLZXlzLmluZGV4T2Yoa2V5KTtcblx0XHRpZiAoa0luZGV4ICE9PSAtMSAmJiAhdGhpcy5faW50ZXJwb2xhdGVLZXkoa2V5KSkge1xuXHRcdFx0dGhpcy5fcmVuZGVyYWJsZUtleXMuc3BsaWNlKGtJbmRleCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHByaXZhdGU6IHZhbHVlRGF0YVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfaW5pdFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgZHVyYXRpb24sIG1heFZhbCkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXROdW1iZXIodmFsLCBkdXJhdGlvbiwgbWF4VmFsKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faW5pdE51bWJlcih2YWx1ZSwgZHVyYXRpb24sIG1heFZhbCk7XG5cdH0sXG5cblx0X2luaXROdW1iZXI6IGZ1bmN0aW9uKHZhbHVlLCBkdXJhdGlvbiwgbWF4VmFsKSB7XG5cdFx0dmFyIG8gPSB7fTtcblx0XHRvLl92YWx1ZSA9IHZhbHVlO1xuXHRcdG8uX3N0YXJ0VmFsdWUgPSB2YWx1ZTtcblx0XHRvLl92YWx1ZURlbHRhID0gMDtcblxuXHRcdG8uX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcblx0XHRvLl9zdGFydFRpbWUgPSBOYU47XG5cdFx0by5fZWxhcHNlZFRpbWUgPSBOYU47XG5cblx0XHRvLl9sYXN0UmVuZGVyZWRWYWx1ZSA9IG51bGw7XG5cdFx0by5fcmVuZGVyZWRWYWx1ZSA9IG8uX3N0YXJ0VmFsdWU7XG5cblx0XHRvLl9tYXhWYWwgPSBtYXhWYWw7XG5cdFx0Ly8gaWYgKG1heFZhbCAhPT0gdm9pZCAwKSBvLl9tYXhWYWwgPSBtYXhWYWw7XG5cdFx0Ly8gby5fbWF4VmFsID0gdGhpcy5fbWF4VmFsdWVzW2tleV07XG5cdFx0Ly8gby5fbWF4VmFsID0gdGhpcy5fbWF4VmFsOy8vIEZJWE1FXG5cdFx0cmV0dXJuIG87XG5cdH0sXG5cblx0X3NldFZhbHVlOiBmdW5jdGlvbihvLCB2YWx1ZSwgZHVyYXRpb24pIHtcblx0XHRpZiAoby5fdmFsdWUgIT09IHZhbHVlKSB7XG5cdFx0XHRvLl9zdGFydFZhbHVlID0gby5fdmFsdWU7XG5cdFx0XHRvLl92YWx1ZURlbHRhID0gdmFsdWUgLSBvLl92YWx1ZTtcblx0XHRcdG8uX3ZhbHVlID0gdmFsdWU7XG5cblx0XHRcdG8uX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcblx0XHRcdG8uX3N0YXJ0VGltZSA9IE5hTjtcblx0XHRcdG8uX2VsYXBzZWRUaW1lID0gTmFOO1xuXG5cdFx0XHQvLyBvLl9sYXN0UmVuZGVyZWRWYWx1ZSA9IG8uX3JlbmRlcmVkVmFsdWU7XG5cdFx0XHQvLyBvLl9yZW5kZXJlZFZhbHVlID0gby5fc3RhcnRWYWx1ZTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBwcml2YXRlOiBpbnRlcnBvbGF0ZVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfdHN0YW1wOiAwLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKHRzdGFtcCkge1xuXHRcdHRoaXMuX3RzdGFtcCA9IHRzdGFtcDtcblxuXHRcdGlmICh0aGlzLnZhbHVlc0NoYW5nZWQpIHtcblx0XHRcdGlmICh0aGlzLl9wYXVzZWRDaGFuZ2luZykge1xuXHRcdFx0XHR0aGlzLl9yZW5kZXJhYmxlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdHZhciBvID0gdGhpcy5fdmFsdWVEYXRhW2tleV07XG5cdFx0XHRcdFx0aWYgKCFpc05hTihvLl9lbGFwc2VkVGltZSkpIHtcblx0XHRcdFx0XHRcdG8uX3N0YXJ0VGltZSA9IHRzdGFtcCAtIG8uX2VsYXBzZWRUaW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMuX3BhdXNlZENoYW5naW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2hhbmdlZEtleXMgPSB0aGlzLl9yZW5kZXJhYmxlS2V5cztcblx0XHRcdHRoaXMuX3JlbmRlcmFibGVLZXlzID0gY2hhbmdlZEtleXMuZmlsdGVyKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW50ZXJwb2xhdGVWYWx1ZSh0c3RhbXAsIHRoaXMuX3ZhbHVlRGF0YVtrZXldLCB0aGlzLl9lYXNlRm5ba2V5XSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdHRoaXMuX3JlbmRlcmVkS2V5cyA9IGNoYW5nZWRLZXlzO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW50ZXJwb2xhdGVLZXk6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnRlcnBvbGF0ZVZhbHVlKHRoaXMuX3RzdGFtcCwgdGhpcy5fdmFsdWVEYXRhW2tleV0sIHRoaXMuX2Vhc2VGbltrZXldKTtcblx0fSxcblxuXHRfaW50ZXJwb2xhdGVWYWx1ZTogZnVuY3Rpb24odHN0YW1wLCBvLCBmbikge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHRyZXR1cm4gby5yZWR1Y2UoZnVuY3Rpb24oY2hhbmdlZCwgaXRlbSwgaW5kZXgsIGFycikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW50ZXJwb2xhdGVOdW1iZXIodHN0YW1wLCBpdGVtLCBmbikgfHwgY2hhbmdlZDtcblx0XHRcdH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faW50ZXJwb2xhdGVOdW1iZXIodHN0YW1wLCBvLCBmbik7XG5cdH0sXG5cblx0X2ludGVycG9sYXRlTnVtYmVyOiBmdW5jdGlvbih0c3RhbXAsIG8sIGZuKSB7XG5cdFx0aWYgKGlzTmFOKG8uX3N0YXJ0VGltZSkpIHtcblx0XHRcdG8uX3N0YXJ0VGltZSA9IHRzdGFtcDtcblx0XHR9XG5cdFx0by5fbGFzdFJlbmRlcmVkVmFsdWUgPSBvLl9yZW5kZXJlZFZhbHVlO1xuXG5cdFx0dmFyIGVsYXBzZWQgPSBNYXRoLm1heCgwLCB0c3RhbXAgLSBvLl9zdGFydFRpbWUpO1xuXHRcdGlmIChlbGFwc2VkIDwgby5fZHVyYXRpb24pIHtcblx0XHRcdGlmIChvLl9tYXhWYWwgJiYgby5fdmFsdWVEZWx0YSA8IDApIHtcblx0XHRcdFx0Ly8gdXBwZXItYm91bmQgdmFsdWVzXG5cdFx0XHRcdG8uX3JlbmRlcmVkVmFsdWUgPSBmbihlbGFwc2VkLCBvLl9zdGFydFZhbHVlLFxuXHRcdFx0XHRcdG8uX3ZhbHVlRGVsdGEgKyBvLl9tYXhWYWwsIG8uX2R1cmF0aW9uKSAtIG8uX21heFZhbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVuYm91bmQgdmFsdWVzXG5cdFx0XHRcdG8uX3JlbmRlcmVkVmFsdWUgPSBmbihlbGFwc2VkLCBvLl9zdGFydFZhbHVlLFxuXHRcdFx0XHRcdG8uX3ZhbHVlRGVsdGEsIG8uX2R1cmF0aW9uKTtcblx0XHRcdH1cblx0XHRcdG8uX2VsYXBzZWRUaW1lID0gZWxhcHNlZDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRvLl9yZW5kZXJlZFZhbHVlID0gby5fdmFsdWU7XG5cdFx0by5fZWxhcHNlZFRpbWUgPSBOYU47XG5cdFx0by5fc3RhcnRUaW1lID0gTmFOO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcbn0sIHtcblx0LyoqXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0cGF1c2VkOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wYXVzZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YWx1ZSA9ICEhKHZhbHVlKTsgLy8gQ29udmVydCB0byBib29sZWFuXG5cdFx0XHRpZiAodGhpcy5fcGF1c2VkICE9PSB2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fcGF1c2VkQ2hhbmdpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0LyoqXG5cdCAqIEB0eXBlIHtib29sZWFufSBIYXMgYW55IHZhbHVlIGJlZW4gY2hhbmdlZCBieSB2YWx1ZVRvKCkgc2luY2UgbGFzdCBpbnRlcnBvbGF0ZSgpXG5cdCAqL1xuXHR2YWx1ZXNDaGFuZ2VkOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fcGF1c2VkICYmIHRoaXMuX3JlbmRlcmFibGVLZXlzLmxlbmd0aCA+IDA7XG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogQHR5cGUge2FycmF5fSBLZXlzIHRoYXQgYXJlIG5vdCB5ZXQgYXQgdGFyZ2V0IHZhbHVlXG5cdCAqL1xuXHRyZW5kZXJhYmxlS2V5czoge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyYWJsZUtleXM7XG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogQHR5cGUge2FycmF5fSBLZXlzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkIGluIHRoZSBsYXN0IGludGVycG9sYXRlKClcblx0ICovXG5cdHJlbmRlcmVkS2V5czoge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyZWRLZXlzO1xuXHRcdH1cblx0fSxcblx0LyoqXG5cdCAqIEB0eXBlIHthcnJheX0gQWxsIGtleXNcblx0ICovXG5cdGtleXM6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlRGF0YSk7XG5cdFx0fVxuXHR9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJwb2xhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9wcmVmaXhlZEV2ZW50fSAqL1xuY29uc3QgcHJlZml4ZWRFdmVudCA9IHJlcXVpcmUoXCJ1dGlscy9wcmVmaXhlZEV2ZW50XCIpO1xuXG52YXIgZXZlbnRNYXAgPSB7XG5cdFwidHJhbnNpdGlvbmVuZFwiOiBwcmVmaXhlZEV2ZW50KFwidHJhbnNpdGlvbmVuZFwiKSxcblx0XCJmdWxsc2NyZWVuY2hhbmdlXCI6IHByZWZpeGVkRXZlbnQoXCJmdWxsc2NyZWVuY2hhbmdlXCIsIGRvY3VtZW50KSxcblx0XCJmdWxsc2NyZWVuZXJyb3JcIjogcHJlZml4ZWRFdmVudChcImZ1bGxzY3JlZW5lcnJvclwiLCBkb2N1bWVudCksXG5cdFwidmlzaWJpbGl0eWNoYW5nZVwiOiBwcmVmaXhlZEV2ZW50KFwidmlzaWJpbGl0eWNoYW5nZVwiLCBkb2N1bWVudCwgXCJoaWRkZW5cIilcbn07XG5cbnZhciBldmVudE51bSA9IDA7XG5mb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRNYXApIHtcblx0aWYgKGV2ZW50TmFtZSA9PT0gZXZlbnRNYXBbZXZlbnROYW1lXSkge1xuXHRcdGRlbGV0ZSBldmVudE1hcFtldmVudE5hbWVdO1xuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudE1hcCwgZXZlbnROYW1lLCB7XG5cdFx0XHR2YWx1ZTogZXZlbnRNYXBbZXZlbnROYW1lXSxcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnRNYXAsIGV2ZW50TnVtLCB7XG5cdFx0XHR2YWx1ZTogZXZlbnROYW1lLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9KTtcblx0XHRldmVudE51bSsrO1xuXHR9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnRNYXAsIFwibGVuZ3RoXCIsIHtcblx0dmFsdWU6IGV2ZW50TnVtXG59KTtcblxuaWYgKERFQlVHKSB7XG5cdGNvbnNvbGUubG9nKFwicHJlZml4ZXMgZW5hYmxlZCBmb3IgJWkgZXZlbnRzXCIsIGV2ZW50TWFwLmxlbmd0aCwgT2JqZWN0LmtleXMoZXZlbnRNYXApKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudE1hcDtcblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBldmVudE51bSA+IDA/IGV2ZW50TWFwIDogbnVsbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L2Jhc2UvVG91Y2hNYW5hZ2VyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvR2xvYmFsc30gKi9cbmNvbnN0IEdsb2JhbHMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmhhbW1lcmpzfSAqL1xuY29uc3QgSGFtbWVyID0gcmVxdWlyZShcImhhbW1lcmpzXCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6aGFtbWVyanMuVGFwfSAqL1xuLy8gY29uc3QgVGFwID0gSGFtbWVyLlRhcDtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3RvdWNoL1Ntb290aFBhblJlY29nbml6ZXJ9ICovXG5jb25zdCBQYW4gPSByZXF1aXJlKFwidXRpbHMvdG91Y2gvU21vb3RoUGFuUmVjb2duaXplclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmhhbW1lcmpzLlBhbn0gKi9cbi8vIGNvbnN0IFBhbiA9IEhhbW1lci5QYW47XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIFN0YXRpYyBwcml2YXRlXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogQHBhcmFtIGVsIEhUTUxFbGVtZW50XG4gKiBAcmV0dXJuIHtIYW1tZXIuTWFuYWdlcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZWwpIHtcblx0bGV0IG1hbmFnZXIgPSBuZXcgSGFtbWVyLk1hbmFnZXIoZWwpO1xuXHQvLyBtYW5hZ2VyLnNldCh7IGRvbWV2ZW50czogdHJ1ZSB9KTtcblxuXHQvLyBsZXQgdGFwID0gbmV3IEhhbW1lci5UYXAoe1xuXHQvLyBcdHRocmVzaG9sZDogR2xvYmFscy5QQU5fVEhSRVNIT0xEIC0gMVxuXHQvLyB9KTtcblx0Ly8gbWFuYWdlci5hZGQodGFwKTtcblx0bGV0IGhwYW4gPSBuZXcgUGFuKHtcblx0XHRldmVudDogXCJocGFuXCIsXG5cdFx0ZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwsXG5cdFx0dGhyZXNob2xkOiBHbG9iYWxzLlBBTl9USFJFU0hPTEQsXG5cdFx0Ly8gdG91Y2hBY3Rpb246IFwicGFuLXlcIixcblx0fSk7XG5cdG1hbmFnZXIuYWRkKGhwYW4pO1xuXG5cdC8vIGxldCB2cGFuID0gbmV3IFBhbih7XG5cdC8vIFx0ZXZlbnQ6IFwidnBhblwiLFxuXHQvLyBcdGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCxcblx0Ly8gXHQvLyB0aHJlc2hvbGQ6IEdsb2JhbHMuUEFOX1RIUkVTSE9MRCxcblx0Ly8gXHQvLyB0b3VjaEFjdGlvbjogXCJwYW4teFwiLFxuXHQvLyB9KTtcblx0Ly8gbWFuYWdlci5hZGQodnBhbik7XG5cdC8vIHZwYW4ucmVxdWlyZUZhaWx1cmUoaHBhbik7XG5cblx0cmV0dXJuIG1hbmFnZXI7XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGhhbW1lcmpzIGZpeHVwIGhhbmRsZXJzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5jb25zdCBQQU5FTkRfVEhSRVNfTVMgPSAzMDA7IC8vIG1pbGxpc2Vjc1xuY29uc3QgUEFORU5EX1RIUkVTX1BYID0gMjU7IC8vIHBpeGVsc1xuY29uc3QgVVBfRVZFTlQgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJvbnBvaW50ZXJ1cFwiKSA/IFwicG9pbnRlcnVwXCIgOiBcIm1vdXNldXBcIjtcblxubGV0IHRvdWNoSGFuZGxlcnMgPSB7fTtcbmxldCBjYXB0dXJlSGFuZGxlcnMgPSB7fTtcbmxldCBidWJibGluZ0hhbmRsZXJzID0ge307XG5cbi8qaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qdGFuZ2VsZGVyLzM2MTA1Mjk3NmYwNDQyMDBlYTE3L3Jhdy9mNTRjMmNlZjc4ZDU5ZGEzZjM4Mjg2ZmFkNjgzNDcxZTFjOTc2MDcyL1ByZXZlbnRHaG9zdENsaWNrLmpzKi9cbnZhciBsYXN0VGltZVN0YW1wID0gTmFOO1xudmFyIHBhblNlc3Npb25PcGVuZWQgPSBmYWxzZTtcblxubGV0IHNhdmVUaW1lU3RhbXAgPSBmdW5jdGlvbihoZXYpIHtcblx0cGFuU2Vzc2lvbk9wZW5lZCA9ICFoZXYuaXNGaW5hbDtcblx0aWYgKGhldi5pc0ZpbmFsKSB7XG5cdFx0bGFzdFRpbWVTdGFtcCA9IGhldi5zcmNFdmVudC50aW1lU3RhbXA7XG5cdH1cblx0aWYgKERFQlVHKSB7XG5cdFx0bG9nUGFuRXZlbnQoaGV2KTtcblx0fVxufTtcblxuLy8gbGV0IHByZXZlbnRTcmNFdmVudCA9IGZ1bmN0aW9uKGhldikge1xuLy8gXHQvL2NvbnNvbGUubG9nKGhldi50eXBlLCBcInByZXZlbnREZWZhdWx0XCIpO1xuLy8gXHRoZXYuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbi8vIH07XG5cbi8vIGxldCBwcmV2ZW50V2hpbGVQYW5uaW5nID0gZnVuY3Rpb24oZG9tZXYpIHtcbi8vIFx0cGFuU2Vzc2lvbk9wZW5lZCAmJiBkb21ldi5wcmV2ZW50RGVmYXVsdCgpO1xuLy8gfTtcblxuLy8gbGV0IHByZXZlbnRXaGlsZU5vdFBhbm5pbmcgPSBmdW5jdGlvbihkb21ldikge1xuLy8gXHQhcGFuU2Vzc2lvbk9wZW5lZCAmJiBkb21ldi5wcmV2ZW50RGVmYXVsdCgpO1xuLy8gfTtcblxubGV0IHN0b3BFdmVudEFmdGVyUGFuID0gZnVuY3Rpb24oZG9tZXYpIHtcblx0aWYgKChkb21ldi50aW1lU3RhbXAgLSBsYXN0VGltZVN0YW1wKSA8IFBBTkVORF9USFJFU19NUykge1xuXHRcdC8vIGRvbWV2LmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRkb21ldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGRvbWV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG5cdGlmIChERUJVRykge1xuXHRcdGxvZ0V2ZW50KGRvbWV2LCAoZG9tZXYudGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcCkudG9GaXhlZCgzKSk7XG5cdH1cblx0bGFzdFRpbWVTdGFtcCA9IE5hTjtcbn07XG5cbnRvdWNoSGFuZGxlcnNbXCJocGFuc3RhcnQgaHBhbmVuZCBocGFuY2FuY2VsXCJdID0gc2F2ZVRpbWVTdGFtcDtcbi8vIHRvdWNoSGFuZGxlcnNbXCJ2cGFuc3RhcnQgdnBhbmVuZCB2cGFuY2FuY2VsXCJdID0gc2F2ZVRpbWVTdGFtcDtcbi8vIHRvdWNoSGFuZGxlcnNbXCJocGFubW92ZSBocGFuZW5kIGhwYW5jYW5jZWxcIl0gPSBwcmV2ZW50U3JjRXZlbnQ7XG4vLyB0b3VjaEhhbmRsZXJzW1widnBhbm1vdmUgdnBhbmVuZCB2cGFuY2FuY2VsXCJdID0gcHJldmVudFNyY0V2ZW50O1xuXG5jYXB0dXJlSGFuZGxlcnNbXCJjbGlja1wiXSA9IHN0b3BFdmVudEFmdGVyUGFuO1xuLy8gYnViYmxpbmdIYW5kbGVyc1tcImNsaWNrXCJdID0gc3RvcEV2ZW50QWZ0ZXJQYW47XG5cbi8vIHRvdWNoSGFuZGxlcnNbW1xuLy8gXHRcInZwYW5zdGFydFwiLCBcInZwYW5lbmRcIiwgXCJ2cGFuY2FuY2VsXCIsIFwidnBhbm1vdmVcIixcbi8vIFx0XCJocGFuc3RhcnRcIiwgXCJocGFuZW5kXCIsIFwiaHBhbmNhbmNlbFwiLCBcImhwYW5tb3ZlXCJcbi8vIF0uam9pbihcIiBcIildID0gbG9nSGFtbWVyRXZlbnQ7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIERPTSBldmVudCBoYW5kbGVyc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbi8vIGNhcHR1cmVIYW5kbGVyc1tVUF9FVkVOVF0gPSBwcmV2ZW50V2hpbGVQYW5uaW5nO1xuLy8gY2FwdHVyZUhhbmRsZXJzW1widG91Y2htb3ZlXCJdID0gY2FwdHVyZUhhbmRsZXJzW1wibW91c2Vtb3ZlXCJdID0gbG9nRE9NRXZlbnQ7XG5cbmlmIChERUJVRykge1xuXHR2YXIgbG9nUGFuRXZlbnQgPSBmdW5jdGlvbihoZXYpIHtcblx0XHRsb2dFdmVudChoZXYuc3JjRXZlbnQsIGBbJHtoZXYudHlwZX1dYCk7XG5cdH07XG5cdHZhciBsb2dFdmVudCA9IGZ1bmN0aW9uKGRvbWV2LCBtc2cpIHtcblx0XHRsZXQgbXNncyA9IFtdO1xuXHRcdGlmIChkb21ldi5kZWZhdWx0UHJldmVudGVkKVxuXHRcdFx0bXNncy5wdXNoKFwicHJldmVudGVkXCIpO1xuXHRcdGlmIChtc2cpXG5cdFx0XHRtc2dzLnB1c2gobXNnKTtcblx0XHRtc2dzLnB1c2goYCR7cGFuU2Vzc2lvbk9wZW5lZCA/IFwicGFubmluZ1wiIDogXCJwYW4gZW5kZWRcIn0gJHsoZG9tZXYudGltZVN0YW1wIC0gbGFzdFRpbWVTdGFtcCkudG9GaXhlZCgzKX1gKTtcblx0XHRjb25zb2xlLmxvZyhcIlRvdWNoTWFuYWdlciAlcyBbJXNdXCIsXG5cdFx0XHRkb21ldi50aW1lU3RhbXAudG9GaXhlZCgzKSxcblx0XHRcdGRvbWV2LnR5cGUsXG5cdFx0XHRtc2dzLmpvaW4oXCIsIFwiKVxuXHRcdCk7XG5cdH07XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW5zdXNlZC12YXJzICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXJzKCkge1xuXHRsZXQgZXZlbnROYW1lO1xuXHRjb25zdCBlbCA9IGluc3RhbmNlLmVsZW1lbnQ7XG5cdGZvciAoZXZlbnROYW1lIGluIHRvdWNoSGFuZGxlcnMpXG5cdFx0aWYgKHRvdWNoSGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSlcblx0XHRcdGluc3RhbmNlLm9uKGV2ZW50TmFtZSwgdG91Y2hIYW5kbGVyc1tldmVudE5hbWVdKTtcblx0Zm9yIChldmVudE5hbWUgaW4gY2FwdHVyZUhhbmRsZXJzKVxuXHRcdGlmIChjYXB0dXJlSGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSlcblx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYXB0dXJlSGFuZGxlcnNbZXZlbnROYW1lXSwgdHJ1ZSk7XG5cdGZvciAoZXZlbnROYW1lIGluIGJ1YmJsaW5nSGFuZGxlcnMpXG5cdFx0aWYgKGJ1YmJsaW5nSGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSlcblx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBidWJibGluZ0hhbmRsZXJzW2V2ZW50TmFtZV0sIGZhbHNlKTtcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBwcmV2ZW50V2hpbGVOb3RQYW5uaW5nLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXJzKCkge1xuXHRsZXQgZXZlbnROYW1lO1xuXHRjb25zdCBlbCA9IGluc3RhbmNlLmVsZW1lbnQ7XG5cdGZvciAoZXZlbnROYW1lIGluIGNhcHR1cmVIYW5kbGVycylcblx0XHRpZiAoY2FwdHVyZUhhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpXG5cdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FwdHVyZUhhbmRsZXJzW2V2ZW50TmFtZV0sIHRydWUpO1xuXHRmb3IgKGV2ZW50TmFtZSBpbiBidWJibGluZ0hhbmRsZXJzKVxuXHRcdGlmIChjYXB0dXJlSGFuZGxlcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSlcblx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBidWJibGluZ0hhbmRsZXJzW2V2ZW50TmFtZV0sIHRydWUpO1xuXHQvLyBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHByZXZlbnRXaGlsZU5vdFBhbm5pbmcsIGZhbHNlKTtcbn1cblxuLyoqIEB0eXBlIHtIYW1tZXIuTWFuYWdlcn0gKi9cbmxldCBpbnN0YW5jZSA9IG51bGw7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIFN0YXRpYyBwdWJsaWNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxubGV0IFRvdWNoTWFuYWdlciA9IHtcblx0aW5pdDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKGluc3RhbmNlID09PSBudWxsKSB7XG5cdFx0XHRpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG5cdFx0XHRhZGRIYW5kbGVycygpO1xuXHRcdH0gZWxzZSBpZiAoaW5zdGFuY2UuZWxlbWVudCAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJUb3VjaE1hbmFnZXIgYWxyZWFkeSBpbml0aWFsaXplZCB3aXRoIGFub3RoZXIgZWxlbWVudFwiKTtcblx0XHR9XG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlSGFuZGxlcnMoKTtcblx0XHRcdGluc3RhbmNlLmRlc3Ryb3koKTtcblx0XHRcdGluc3RhbmNlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKFwibm8gaW5zdGFuY2UgdG8gZGVzdHJveVwiKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0SW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIlRvdWNoTWFuYWdlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIik7XG5cdFx0fVxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3VjaE1hbmFnZXI7XG5cbi8qXG4vLyBhbHQgc3ludGF4XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShlbCkge1xuXHRyZXR1cm4gbmV3IEhhbW1lcihlbCwge1xuXHRcdHJlY29nbml6ZXJzOiBbXG5cdFx0XHRbVGFwXSxcblx0XHRcdFtQYW4sIHtcblx0XHRcdFx0ZXZlbnQ6ICdocGFuJyxcblx0XHRcdFx0ZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwsXG5cdFx0XHRcdHRocmVzaG9sZDogR2xvYmFscy5USFJFU0hPTERcblx0XHRcdH1dLFxuXHRcdFx0W1Bhbiwge1xuXHRcdFx0XHRldmVudDogJ3ZwYW4nLFxuXHRcdFx0XHRkaXJlY3Rpb246IEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwsXG5cdFx0XHRcdHRocmVzaG9sZDogR2xvYmFscy5USFJFU0hPTERcblx0XHRcdH0sIFsnaHBhbiddXVxuXHRcdF1cblx0fSk7XG59XG4qL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWwgSFRNTEVsZW1lbnQsIE11dGF0aW9uT2JzZXJ2ZXIgKi9cbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9iYXNlL1ZpZXdcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTpzZXRpbW1lZGlhdGV9ICovXG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTpiYWNrYm9uZX0gKi9cbmNvbnN0IEJhY2tib25lID0gcmVxdWlyZShcImJhY2tib25lXCIpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiBNdXRhdGlvbk9ic2VydmVyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBfY2lkU2VlZCA9IDE7XG52YXIgX3ZpZXdzQnlDaWQgPSB7fTtcblxuZnVuY3Rpb24gYWRkQ2hpbGRWaWV3cyhlbCkge1xuXHR2YXIgdmlldywgZWxzID0gZWwucXVlcnlTZWxlY3RvckFsbChcIipbZGF0YS1jaWRdXCIpO1xuXHRmb3IgKHZhciBpID0gMCwgaWkgPSBlbHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdHZpZXcgPSBWaWV3LmZpbmRCeUVsZW1lbnQoZWxzLml0ZW0oaSkpO1xuXHRcdGlmICh2aWV3KSB7XG5cdFx0XHRpZiAoIXZpZXcuYXR0YWNoZWQpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJWaWV3OjpbYXR0YWNoZWQgKHBhcmVudCldICVzXCIsIHZpZXcuY2lkKTtcblx0XHRcdFx0dmlldy5fZWxlbWVudEF0dGFjaGVkKCk7XG5cdFx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHRcdC8vIFx0Y29uc29sZS53YXJuKFwiVmlldzo6W2F0dGFjaGVkIChwYXJlbnQpXSAlcyAoaWdub3JlZClcIiwgdmlldy5jaWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZFZpZXdzKGVsKSB7XG5cdHZhciB2aWV3LCBlbHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKltkYXRhLWNpZF1cIik7XG5cdGZvciAodmFyIGkgPSAwLCBpaSA9IGVscy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0dmlldyA9IFZpZXcuZmluZEJ5RWxlbWVudChlbHMuaXRlbShpKSk7XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdGlmICh2aWV3LmF0dGFjaGVkKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiVmlldzo6W2RldGFjaGVkIChwYXJlbnQpXSAlc1wiLCB2aWV3LmNpZCk7XG5cdFx0XHRcdHZpZXcuX2VsZW1lbnREZXRhY2hlZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiVmlldzo6W2RldGFjaGVkIChwYXJlbnQpXSAlcyAoaWdub3JlZClcIiwgdmlldy5jaWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG52YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihtbSkge1xuXHQvLyBjb25zb2xlLmxvZyhcIlZpZXc6Om11dGF0aW9ucyAlc1wiLCBKU09OLnN0cmluZ2lmeShtbSwgbnVsbCwgXCIgXCIpKTtcblx0dmFyIGksIGlpLCBtO1xuXHR2YXIgaiwgamosIGU7XG5cdHZhciB2aWV3O1xuXHRmb3IgKGkgPSAwLCBpaSA9IG1tLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcblx0XHRtID0gbW1baV07XG5cdFx0aWYgKG0udHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBqaiA9IG0uYWRkZWROb2Rlcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG5cdFx0XHRcdGUgPSBtLmFkZGVkTm9kZXMuaXRlbShqKTtcblx0XHRcdFx0dmlldyA9IFZpZXcuZmluZEJ5RWxlbWVudChlKTtcblx0XHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0XHRpZiAoIXZpZXcuYXR0YWNoZWQpIHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiVmlldzo6W2F0dGFjaGVkIChjaGlsZExpc3QpXSAlc1wiLCB2aWV3LmNpZCk7XG5cdFx0XHRcdFx0XHR2aWV3Ll9lbGVtZW50QXR0YWNoZWQoKTtcblx0XHRcdFx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBcdGNvbnNvbGUud2FybihcIlZpZXc6OlthdHRhY2hlZCAoY2hpbGRMaXN0KV0gJXMgKGlnbm9yZWQpXCIsIHZpZXcuY2lkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgYWRkQ2hpbGRWaWV3cyhlKTtcblx0XHRcdH1cblx0XHRcdGZvciAoaiA9IDAsIGpqID0gbS5yZW1vdmVkTm9kZXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuXHRcdFx0XHRlID0gbS5yZW1vdmVkTm9kZXMuaXRlbShqKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJWaWV3OjpbZGV0YWNoZWQgKGNoaWxkTGlzdCldICVzXCIsIGUuY2lkKTtcblx0XHRcdFx0dmlldyA9IFZpZXcuZmluZEJ5RWxlbWVudChlKTtcblx0XHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0XHRpZiAodmlldy5hdHRhY2hlZCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJWaWV3OjpbZGV0YWNoZWQgKGNoaWxkTGlzdCldICVzXCIsIHZpZXcuY2lkLCB2aWV3LmF0dGFjaGVkKTtcblx0XHRcdFx0XHRcdHZpZXcuX2VsZW1lbnREZXRhY2hlZCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJWaWV3OjpbZGV0YWNoZWQgKGNoaWxkTGlzdCldICVzIChpZ25vcmVkKVwiLCB2aWV3LmNpZCwgdmlldy5hdHRhY2hlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHJlbW92ZUNoaWxkVmlld3MoZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcblx0XHRcdHZpZXcgPSBWaWV3LmZpbmRCeUVsZW1lbnQobS50YXJnZXQpO1xuXHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0aWYgKCF2aWV3LmF0dGFjaGVkKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJWaWV3OjpbYXR0YWNoZWQgKGF0dHJpYnV0ZSldICVzXCIsIHZpZXcuY2lkKTtcblx0XHRcdFx0XHR2aWV3Ll9lbGVtZW50QXR0YWNoZWQoKTtcblx0XHRcdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFx0Y29uc29sZS53YXJuKFwiVmlldzo6W2F0dGFjaGVkIChhdHRyaWJ1dGUpXSAlcyAoaWdub3JlZClcIiwgdmlldy5jaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBlbHNlIHtcblx0XHRcdC8vIFx0Y29uc29sZS53YXJuKFwiVmlldzo6W2F0dHJpYnV0ZXNdIHRhcmdldCBoYXMgbm8gY2lkICglcz0nJXMnKVwiLCBtLmF0dHJpYnV0ZU5hbWUsIG0udGFyZ2V0LmdldEF0dHJpYnV0ZShtLmF0dHJpYnV0ZU5hbWUpLCBtKTtcblx0XHRcdC8vIH1cblx0XHR9XG5cdH1cbn0pO1xuXG5vYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHtcblx0YXR0cmlidXRlczogdHJ1ZSxcblx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRzdWJ0cmVlOiB0cnVlLFxuXHRhdHRyaWJ1dGVGaWx0ZXI6IFtcImRhdGEtY2lkXCJdXG59KTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogc3RhdGljIHByaXZhdGVcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIF9ub3cgPSB3aW5kb3cucGVyZm9ybWFuY2UgP1xuXHR3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKSA6XG5cdERhdGUubm93LmJpbmQoRGF0ZSk7XG4vLyB2YXIgX25vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZT9cbi8vIFx0ZnVuY3Rpb24oKSB7IHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7IH06XG4vLyBcdGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9yZW5kZXJRdWV1ZX0gKi9cbi8vIHZhciByZW5kZXJRdWV1ZSA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL3JlbmRlclF1ZXVlXCIpO1xuLy9cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvQ2FsbGJhY2tRdWV1ZX0gKi9cbnZhciByZW5kZXJRdWV1ZSA9IChmdW5jdGlvbihDYWxsYmFja1F1ZXVlKSB7XG5cdHJldHVybiBuZXcgQ2FsbGJhY2tRdWV1ZShcblx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuXHRcdH0sXG5cdFx0ZnVuY3Rpb24oaWQpIHtcblx0XHRcdHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuXHRcdH1cblx0KTtcbn0pKHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL0NhbGxiYWNrUXVldWVcIikpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL0NhbGxiYWNrUXVldWV9ICovXG52YXIgbW9kZWxRdWV1ZSA9IChmdW5jdGlvbihDYWxsYmFja1F1ZXVlKSB7XG5cdHJldHVybiBuZXcgQ2FsbGJhY2tRdWV1ZShcblx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgX25vdygpKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0ZnVuY3Rpb24oaWQpIHtcblx0XHRcdHJldHVybiB3aW5kb3cuY2xlYXJJbW1lZGlhdGUoaWQpO1xuXHRcdH1cblx0KTtcbn0pKHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL0NhbGxiYWNrUXVldWVcIikpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ByZWZpeGVkRXZlbnRzfSAqL1xuY29uc3QgUHJlZml4ZWRFdmVudHMgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9QcmVmaXhlZEV2ZW50c1wiKTtcblxudmFyIGFwcGx5RXZlbnRQcmVmaXhlcyA9IGZ1bmN0aW9uKGV2ZW50cykge1xuXHR2YXIgc2VsZWN0b3IsIHVucHJlZml4ZWQ7XG5cdGZvciAoc2VsZWN0b3IgaW4gZXZlbnRzKSB7XG5cdFx0dW5wcmVmaXhlZCA9IHNlbGVjdG9yLm1hdGNoKC9eXFx3Ky9pKVswXTtcblx0XHRpZiAoUHJlZml4ZWRFdmVudHMuaGFzT3duUHJvcGVydHkodW5wcmVmaXhlZCkpIHtcblx0XHRcdGV2ZW50c1tzZWxlY3Rvci5yZXBsYWNlKHVucHJlZml4ZWQsIFByZWZpeGVkRXZlbnRzW3VucHJlZml4ZWRdKV0gPSBldmVudHNbc2VsZWN0b3JdO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJhcHBseUV2ZW50UHJlZml4ZXNcIiwgdW5wcmVmaXhlZCwgcHJlZml4ZWRFdmVudHNbdW5wcmVmaXhlZF0pO1xuXHRcdFx0ZGVsZXRlIGV2ZW50c1tzZWxlY3Rvcl07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBldmVudHM7XG59O1xuXG52YXIgZ2V0Vmlld0RlcHRoID0gZnVuY3Rpb24odmlldykge1xuXHRpZiAoIXZpZXcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIXZpZXcuYXR0YWNoZWQpIHtcblx0XHRyZXR1cm4gTmFOO1xuXHR9XG5cdGlmICh2aWV3LnBhcmVudFZpZXcgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXHRyZXR1cm4gdmlldy5wYXJlbnRWaWV3LnZpZXdEZXB0aCArIDE7XG59O1xuXG5mdW5jdGlvbiBsb2dBdHRhY2hJbmZvKHZpZXcsIG5hbWUsIGxldmVsKSB7XG5cdGlmIChbXCJsb2dcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdLmluZGV4T2YobGV2ZWwpICE9IC0xKSB7XG5cdFx0bGV2ZWwgPSBcImxvZ1wiO1xuXHR9XG5cdGNvbnNvbGVbbGV2ZWxdLmNhbGwoY29uc29sZSwgXCIlczo6JXMgW3BhcmVudDolcyAlcyAlcyBkZXB0aDolc11cIiwgdmlldy5jaWQsIG5hbWUsIHZpZXcucGFyZW50VmlldyAmJiB2aWV3LnBhcmVudFZpZXcuY2lkLCB2aWV3LmF0dGFjaGVkID8gXCJhdHRhY2hlZFwiIDogXCJkZXRhY2hlZFwiLCB2aWV3Ll92aWV3UGhhc2UsIHZpZXcudmlld0RlcHRoKTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogc3RhdGljIHB1YmxpY1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbnZhciBWaWV3ID0ge1xuXG5cdC8qKiBAY29uc3QgKi9cblx0Tk9ORV9JTlZBTElEOiAwLFxuXHQvKiogQGNvbnN0ICovXG5cdEFMTF9JTlZBTElEOiB+MCA+Pj4gMSxcblxuXHQvKiogQGNvbnN0ICovXG5cdENISUxEUkVOX0lOVkFMSUQ6IDEsXG5cdC8qKiBAY29uc3QgKi9cblx0TU9ERUxfSU5WQUxJRDogMixcblx0LyoqIEBjb25zdCAqL1xuXHRTVFlMRVNfSU5WQUxJRDogNCxcblx0LyoqIEBjb25zdCAqL1xuXHRTSVpFX0lOVkFMSUQ6IDgsXG5cdC8qKiBAY29uc3QgKi9cblx0TEFZT1VUX0lOVkFMSUQ6IDE2LFxuXG5cdC8qKiBAY29uc3QgKi9cblx0Q0xJQ0tfRVZFTlQ6IFwiY2xpY2tcIiwgLy93aW5kb3cuaGFzT3duUHJvcGVydHkoXCJvbnBvaW50ZXJ1cFwiKSA/IFwicG9pbnRlcnVwXCIgOiBcIm1vdXNldXBcIixcblxuXHQvKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXdFcnJvcn0gKi9cblx0Vmlld0Vycm9yOiByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3RXJyb3JcIiksXG5cblx0LyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZWRQcm9wZXJ0eX0gKi9cblx0cHJlZml4ZWRQcm9wZXJ0eTogcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkUHJvcGVydHlcIiksXG5cblx0LyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZWRTdHlsZU5hbWV9ICovXG5cdHByZWZpeGVkU3R5bGVOYW1lOiByZXF1aXJlKFwidXRpbHMvcHJlZml4ZWRTdHlsZU5hbWVcIiksXG5cblx0LyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZWRFdmVudH0gKi9cblx0cHJlZml4ZWRFdmVudDogcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkRXZlbnRcIiksXG5cblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcHJvbWlzZS93aGVuVmlld0lzQXR0YWNoZWR9ICovXG5cdHdoZW5WaWV3SXNBdHRhY2hlZDogcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlblZpZXdJc0F0dGFjaGVkXCIpLFxuXG5cdC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3Byb21pc2Uvd2hlblZpZXdJc1JlbmRlcmVkfSAqL1xuXHR3aGVuVmlld0lzUmVuZGVyZWQ6IHJlcXVpcmUoXCJhcHAvdmlldy9wcm9taXNlL3doZW5WaWV3SXNSZW5kZXJlZFwiKSxcblxuXHQvKipcblx0LyogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH1cblx0LyogQHJldHVybiB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld31cblx0LyovXG5cdGZpbmRCeUVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0aWYgKF92aWV3c0J5Q2lkW2VsLmNpZF0pIHtcblx0XHRcdHJldHVybiBfdmlld3NCeUNpZFtlbC5jaWRdO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0LyogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH1cblx0LyogQHJldHVybiB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld31cblx0LyovXG5cdGZpbmRCeURlc2NlbmRhbnQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKF92aWV3c0J5Q2lkW2VsLmNpZF0pIHtcblx0XHRcdFx0cmV0dXJuIF92aWV3c0J5Q2lkW2VsLmNpZF07XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoKGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKSk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRleHRlbmQ6IGZ1bmN0aW9uKHByb3RvLCBvYmopIHtcblx0XHRpZiAoUHJlZml4ZWRFdmVudHMubGVuZ3RoICYmIHByb3RvLmV2ZW50cykge1xuXHRcdFx0aWYgKF8uaXNGdW5jdGlvbihwcm90by5ldmVudHMpKSB7XG5cdFx0XHRcdHByb3RvLmV2ZW50cyA9IF8ud3JhcChwcm90by5ldmVudHMsIGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFwcGx5RXZlbnRQcmVmaXhlcyhmbi5hcHBseSh0aGlzKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZiAoXy5pc09iamVjdChwcm90by5ldmVudHMpKSB7XG5cdFx0XHRcdHByb3RvLmV2ZW50cyA9IGFwcGx5RXZlbnRQcmVmaXhlcyhwcm90by5ldmVudHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocHJvdG8ucHJvcGVydGllcyAmJiB0aGlzLnByb3RvdHlwZS5wcm9wZXJ0aWVzKSB7XG5cdFx0XHRfLmRlZmF1bHRzKHByb3RvLnByb3BlcnRpZXMsIHRoaXMucHJvdG90eXBlLnByb3BlcnRpZXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gQmFja2JvbmUuVmlldy5leHRlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRfZmxhZ3NUb1N0cmluZ3M6IFtcIi1cIl0sXG5cblx0ZmxhZ3NUb1N0cmluZzogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHR2YXIgcyA9IFZpZXcuX2ZsYWdzVG9TdHJpbmdzW2ZsYWdzIHwgMF07XG5cdFx0aWYgKCFzKSB7XG5cdFx0XHRzID0gW107XG5cdFx0XHRpZiAoZmxhZ3MgJiBWaWV3LkNISUxEUkVOX0lOVkFMSUQpIHMucHVzaChcImNoaWxkcmVuXCIpO1xuXHRcdFx0aWYgKGZsYWdzICYgVmlldy5NT0RFTF9JTlZBTElEKSBzLnB1c2goXCJtb2RlbFwiKTtcblx0XHRcdGlmIChmbGFncyAmIFZpZXcuU1RZTEVTX0lOVkFMSUQpIHMucHVzaChcInN0eWxlc1wiKTtcblx0XHRcdGlmIChmbGFncyAmIFZpZXcuU0laRV9JTlZBTElEKSBzLnB1c2goXCJzaXplXCIpO1xuXHRcdFx0aWYgKGZsYWdzICYgVmlldy5MQVlPVVRfSU5WQUxJRCkgcy5wdXNoKFwibGF5b3V0XCIpO1xuXHRcdFx0Vmlldy5fZmxhZ3NUb1N0cmluZ3NbZmxhZ3NdID0gcyA9IHMuam9pbihcIiBcIik7XG5cdFx0fVxuXHRcdHJldHVybiBzO1xuXHRcdC8vIHJldHVybiAoZmxhZ3MgfCAwKS50b1N0cmluZygyKTtcblx0fSxcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3LCBcImluc3RhbmNlc1wiLCB7XG5cdHZhbHVlOiBfdmlld3NCeUNpZCxcblx0ZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIHByb3RvdHlwZVxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbnZhciBWaWV3UHJvdG8gPSB7XG5cblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdGNpZFByZWZpeDogXCJ2aWV3XCIsXG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cblx0X2F0dGFjaGVkOiBmYWxzZSxcblx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfSAqL1xuXHRfcGFyZW50VmlldzogbnVsbCxcblx0LyoqIEB0eXBlIHtpbnR8bnVsbH0gKi9cblx0X3ZpZXdEZXB0aDogbnVsbCxcblx0LyoqIEB0eXBlIHtzdHJpbmd9IGluaXRpYWxpemluZyA+IGluaXRpYWxpemVkID4gZGlzcG9zaW5nID4gZGlzcG9zZWQgKi9cblx0X3ZpZXdQaGFzZTogXCJpbml0aWFsaXppbmdcIixcblx0LyoqIEB0eXBlIHtpbnR9ICovXG5cdF9yZW5kZXJRdWV1ZUlkOiAtMSxcblx0LyoqIEB0eXBlIHtpbnR9ICovXG5cdF9yZW5kZXJGbGFnczogMCxcblx0LyoqIEB0eXBlIHtCb29sZWFufSAqL1xuXHRfZW5hYmxlZDogbnVsbCxcblxuXHQvKiogQHR5cGUge29iamVjdH0gKi9cblx0cHJvcGVydGllczoge1xuXHRcdGNpZDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NpZCB8fCAodGhpcy5fY2lkID0gdGhpcy5jaWRQcmVmaXggKyBfY2lkU2VlZCsrKTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdC8vIGlnbm9yZWRcblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0dGFjaGVkOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fYXR0YWNoZWQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRwYXJlbnRWaWV3OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyZW50Vmlldztcblx0XHRcdH1cblx0XHR9LFxuXHRcdHZpZXdEZXB0aDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2dldFZpZXdEZXB0aCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZW5kZXJRdWV1ZUlkICE9PSAtMTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVuYWJsZWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24oZW5hYmxlZCkge1xuXHRcdFx0XHR0aGlzLnNldEVuYWJsZWQoZW5hYmxlZCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW5kZXJGbGFnczoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlbmRlckZsYWdzO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQkOiBCYWNrYm9uZS4kLFxuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMudHJhbnNmb3JtID0ge307XG5cdFx0dGhpcy5jaGlsZFZpZXdzID0ge307XG5cdFx0dGhpcy5fYXBwbHlSZW5kZXIgPSB0aGlzLl9hcHBseVJlbmRlci5iaW5kKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMucHJvcGVydGllcykge1xuXHRcdFx0Ly8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgZ2V0UHJvdG90eXBlQ2hhaW5WYWx1ZSh0aGlzLCBcInByb3BlcnRpZXNcIiwgQmFja2JvbmUuVmlldykpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgdGhpcy5wcm9wZXJ0aWVzKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGFzc05hbWUgJiYgdGhpcy5jbGFzc05hbWUpIHtcblx0XHRcdG9wdGlvbnMuY2xhc3NOYW1lICs9IFwiIFwiICsgXy5yZXN1bHQodGhpcywgXCJjbGFzc05hbWVcIik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50Vmlldykge1xuXHRcdFx0dGhpcy5fc2V0UGFyZW50VmlldyhvcHRpb25zLnBhcmVudFZpZXcsIHRydWUpO1xuXHRcdH1cblx0XHRCYWNrYm9uZS5WaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjppbml0aWFsaXplIHZpZXdQaGFzZTpbJXMgPT4gaW5pdGlhbGl6ZWRdXCIsIHRoaXMuY2lkLCB0aGlzLl92aWV3UGhhc2UpO1xuXHRcdHRoaXMuX3ZpZXdQaGFzZSA9IFwiaW5pdGlhbGl6ZWRcIjtcblxuXHRcdGlmICh0aGlzLnBhcmVudFZpZXcgIT09IG51bGwpIHtcblx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6cGFyZW50Q2hhbmdlXCIsIHRoaXMucGFyZW50VmlldywgbnVsbCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmF0dGFjaGVkKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OmF0dGFjaGVkXCIsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIHJlbW92ZVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl92aWV3UGhhc2UgPT0gXCJkaXNwb3NpbmdcIikge1xuXHRcdFx0bG9nQXR0YWNoSW5mbyh0aGlzLCBcInJlbW92ZVwiLCBcIndhcm5cIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGxvZ0F0dGFjaEluZm8odGhpcywgXCJyZW1vdmVcIiwgXCJsb2dcIik7XG5cdFx0fVxuXG5cdFx0Ly8gYmVmb3JlIHJlbW92YWxcblx0XHR0aGlzLl92aWV3UGhhc2UgPSBcImRpc3Bvc2luZ1wiO1xuXHRcdHRoaXMuX2NhbmNlbFJlbmRlcigpO1xuXG5cdFx0Ly8gY2FsbCBCYWNrYm9uZSBpbXBsXG5cdFx0Ly8gQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHQvLyBOT1RFOiBmcm9tIEJhY2tib25lIGltcGxcblx0XHR0aGlzLiRlbC5yZW1vdmUoKTsgLy8gZnJvbSBCYWNrYm9uZSBpbXBsXG5cblx0XHR0aGlzLl9hdHRhY2hlZCA9IGZhbHNlO1xuXHRcdHRoaXMudHJpZ2dlcihcInZpZXc6cmVtb3ZlZFwiLCB0aGlzKTtcblxuXHRcdC8vIHJlbW92ZSBwYXJlbnQvY2hpbGQgcmVmZXJlbmNlc1xuXHRcdHRoaXMuX3NldFBhcmVudFZpZXcobnVsbCk7XG5cblx0XHQvLyBOT1RFOiBmcm9tIEJhY2tib25lIGltcGwuIE5vIG1vcmUgZXZlbnRzIGFmdGVyIHRoaXNcblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcblxuXHRcdC8vIGNoZWNrIGZvciBpbnZhbGlkYXRpb25zIHRoYXQgbWF5IGhhdmUgYmVlbiB0cmlnZ2VyZWQgYnkgXCJ2aWV3OnJlbW92ZWRcIlxuXHRcdGlmICh0aGlzLmludmFsaWRhdGVkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCIlczo6cmVtb3ZlIGludmFsaWRhdGVkIGFmdGVyIHJlbW92ZSgpXCIsIHRoaXMuY2lkKTtcblx0XHRcdHRoaXMuX2NhbmNlbFJlbmRlcigpO1xuXHRcdH1cblx0XHQvLyAvLyBjaGVjayBmb3IgY2hpbGRyZW4gc3RpbGwgaGVyZVxuXHRcdC8vIHZhciBjY2lkcyA9IE9iamVjdC5rZXlzKHRoaXMuY2hpbGRWaWV3cyk7XG5cdFx0Ly8gaWYgKGNjaWRzLmxlbmd0aCkge1xuXHRcdC8vIFx0Y29uc29sZS53YXJuKFwiJXM6OnJlbW92ZSAlaSBjaGlsZHJlbiBub3QgcmVtb3ZlZCBbJXNdXCIsIHRoaXMuY2lkLCBjY2lkcy5sZW5ndGgsIGNjaWRzLmpvaW4oXCIsIFwiKSwgdGhpcy5jaGlsZFZpZXdzKTtcblx0XHQvLyB9XG5cdFx0Ly8gLy8gcmVtb3ZlIGNoaWxkVmlld3Ncblx0XHQvLyBmb3IgKHZhciBjaWQgaW4gdGhpcy5jaGlsZFZpZXdzKSB7XG5cdFx0Ly8gXHR0aGlzLmNoaWxkVmlld3NbY2lkXS5yZW1vdmUoKTtcblx0XHQvLyB9XG5cdFx0Ly8gY2xlYXIgcmVmZXJlbmNlIGluIHZpZXcgbWFwXG5cdFx0ZGVsZXRlIF92aWV3c0J5Q2lkW3RoaXMuY2lkXTtcblx0XHQvLyBkZWxldGUgdGhpcy5lbC5jaWQ7XG5cdFx0Ly8gdXBkYXRlIHBoYXNlXG5cdFx0dGhpcy5fdmlld1BoYXNlID0gXCJkaXNwb3NlZFwiO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogX2VsZW1lbnRBdHRhY2hlZCBfZWxlbWVudERldGFjaGVkXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfZWxlbWVudEF0dGFjaGVkOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0aGlzLl9hZGRUb1BhcmVudFZpZXcoKTtcblx0XHR0aGlzLl9hdHRhY2hlZCA9IHRydWU7XG5cdFx0dGhpcy5fdmlld0RlcHRoID0gbnVsbDtcblx0XHR0aGlzLnNldEVuYWJsZWQodHJ1ZSk7XG5cdFx0dGhpcy5fc2V0UGFyZW50VmlldyhWaWV3LmZpbmRCeURlc2NlbmRhbnQodGhpcy5lbC5wYXJlbnRFbGVtZW50KSk7XG5cblx0XHQvLyBpZiAodGhpcy5wYXJlbnRWaWV3KSB7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhcIlthdHRhY2hdIFslaV0gJXMgPiAlczo6X2VsZW1lbnRBdHRhY2hlZFwiLCB0aGlzLnZpZXdEZXB0aCwgdGhpcy5wYXJlbnRWaWV3LmNpZCwgdGhpcy5jaWQpO1xuXHRcdC8vIH0gZWxzZSB7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhcIlthdHRhY2hdIFslaV0gJXM6Ol9lbGVtZW50QXR0YWNoZWRcIiwgdGhpcy52aWV3RGVwdGgsIHRoaXMuY2lkKTtcblx0XHQvLyB9XG5cblx0XHQvLyBpZiAodGhpcy5fdmlld1BoYXNlID09IFwiaW5pdGlhbGl6aW5nXCIpIHtcblx0XHQvLyBcdC8vIHRoaXMudHJpZ2dlcihcInZpZXc6YXR0YWNoZWRcIiwgdGhpcyk7XG5cdFx0Ly8gfSBlbHNlXG5cdFx0aWYgKHRoaXMuX3ZpZXdQaGFzZSA9PSBcImluaXRpYWxpemVkXCIpIHtcblx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6YXR0YWNoZWRcIiwgdGhpcyk7XG5cdFx0fSBlbHNlXG5cdFx0aWYgKHRoaXMuX3ZpZXdQaGFzZSA9PSBcInJlcGxhY2luZ1wiKSB7XG5cdFx0XHR0aGlzLl92aWV3UGhhc2UgPSBcImluaXRpYWxpemVkXCI7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OnJlcGxhY2VkXCIsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfZWxlbWVudERldGFjaGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuYXR0YWNoZWQgfHwgKHRoaXMuX3ZpZXdQaGFzZSA9PSBcImRpc3Bvc2luZ1wiKSB8fCAodGhpcy5fdmlld1BoYXNlID09IFwiZGlzcG9zZWRcIikpIHtcblx0XHRcdGxvZ0F0dGFjaEluZm8odGhpcywgXCJfZWxlbWVudERldGFjaGVkXCIsIFwiZXJyb3JcIik7XG5cdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0Ly8gXHRsb2dBdHRhY2hJbmZvKHRoaXMsIFwiX2VsZW1lbnREZXRhY2hlZFwiLCBcImxvZ1wiKTtcblx0XHR9XG5cdFx0dGhpcy5fYXR0YWNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLl92aWV3RGVwdGggPSBudWxsO1xuXHRcdHRoaXMuc2V0RW5hYmxlZChmYWxzZSk7XG5cblx0XHRpZiAodGhpcy5fdmlld1BoYXNlICE9IFwiZGlzcG9zaW5nXCIgfHwgdGhpcy5fdmlld1BoYXNlID09IFwiZGlzcG9zZWRcIikge1xuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBwYXJlbnRWaWV3XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfc2V0UGFyZW50VmlldzogZnVuY3Rpb24obmV3UGFyZW50LCBzaWxlbnQpIHtcblx0XHRpZiAobmV3UGFyZW50ID09PSB2b2lkIDApIHtcblx0XHRcdGNvbnNvbGUud2FybihcIiRzOjpfc2V0UGFyZW50VmlldyBpbnZhbGlkIHZhbHVlICclcydcIiwgdGhpcy5jaWQsIG5ld1BhcmVudCk7XG5cdFx0XHRuZXdQYXJlbnQgPSBudWxsO1xuXHRcdH1cblx0XHR2YXIgb2xkUGFyZW50ID0gdGhpcy5fcGFyZW50Vmlldztcblx0XHR0aGlzLl9wYXJlbnRWaWV3ID0gbmV3UGFyZW50O1xuXG5cdFx0Ly8gZm9yY2UgdXBkYXRlIG9mIF92aWV3RGVwdGhcblx0XHR0aGlzLl92aWV3RGVwdGggPSBudWxsOyAvL2dldFZpZXdEZXB0aCh0aGlzKTtcblxuXHRcdC8vIHNraXAgdGhlIHJlc3QgaWYgYXJnIGlzIHRoZSBzYW1lXG5cdFx0aWYgKG5ld1BhcmVudCA9PT0gb2xkUGFyZW50KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdGlmICh0aGlzLmNpZCBpbiBvbGRQYXJlbnQuY2hpbGRWaWV3cykge1xuXHRcdFx0XHRkZWxldGUgb2xkUGFyZW50LmNoaWxkVmlld3NbdGhpcy5jaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmV3UGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRuZXdQYXJlbnQuY2hpbGRWaWV3c1t0aGlzLmNpZF0gPSB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIXNpbGVudClcblx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6cGFyZW50Q2hhbmdlXCIsIHRoaXMsIG5ld1BhcmVudCwgb2xkUGFyZW50KTtcblx0fSxcblxuXHR3aGVuQXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBWaWV3LndoZW5WaWV3SXNBdHRhY2hlZCh0aGlzKTtcblx0fSxcblxuXHRfZ2V0Vmlld0RlcHRoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fdmlld0RlcHRoID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl92aWV3RGVwdGggPSBnZXRWaWV3RGVwdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl92aWV3RGVwdGg7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBCYWNrYm9uZS5WaWV3IG92ZXJyaWRlc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBkZWxlZ2F0ZSkge1xuXHRcdC8vIHNldEVsZW1lbnQgYWx3YXlzIGluaXRpYWxpemVzIHRoaXMuZWwsIHNvIGNoZWNrIGl0IHRvIGJlIG5vbi1udWxsIGJlZm9yZSBjYWxsaW5nIHN1cGVyXG5cdFx0aWYgKHRoaXMuZWwpIHtcblx0XHRcdGlmICh0aGlzLmVsICE9PSBlbGVtZW50ICYmIHRoaXMuZWwucGFyZW50RWxlbWVudCkge1xuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGJlaW5nIHJlcGxhY2VkXG5cdFx0XHRcdGlmICh0aGlzLmF0dGFjaGVkKSB7XG5cdFx0XHRcdFx0Ly8gU2luY2Ugb2xkIGVsZW1lbnQgaXMgYXR0YWNoZWQgdG8gZG9jdW1lbnQgdHJlZSwgX2VsZW1lbnRBdHRhY2hlZCB3aWxsIGJlXG5cdFx0XHRcdFx0Ly8gdHJpZ2dlcmVkIGJ5IHJlcGxhY2VDaGlsZDogc2V0IF92aWV3UGhhc2UgPSBcInJlcGxhY2luZ1wiIHRvIGZsYWcgdGhpc1xuXHRcdFx0XHRcdC8vIGNoYW5nZSBhbmQgdHJpZ2dlciAndmlldzpyZXBsYWNlZCcgaW5zdGVhZCBvZiAndmlldzphZGRlZCcuXG5cdFx0XHRcdFx0dGhpcy5fdmlld1BoYXNlID0gXCJyZXBsYWNpbmdcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmVsLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGVsZW1lbnQsIHRoaXMuZWwpO1xuXHRcdFx0fVxuXHRcdFx0QmFja2JvbmUuVmlldy5wcm90b3R5cGUuc2V0RWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gTWVyZ2UgY2xhc3NlcyBzcGVjaWZpZWQgYnkgdGhpcyB2aWV3IHdpdGggdGhlIG9uZXMgYWxyZWFkeSBpbiB0aGUgZWxlbWVudCxcblx0XHRcdC8vIGFzIGJhY2tib25lIHdpbGwgbm90OlxuXHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdF8ucmVzdWx0KHRoaXMsIFwiY2xhc3NOYW1lXCIpLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoaXRlbSk7XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5zZXRFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZWwgPT09IHZvaWQgMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFja2JvbmUgdmlldyBoYXMgbm8gZWxlbWVudFwiKTtcblx0XHR9XG5cdFx0X3ZpZXdzQnlDaWRbdGhpcy5jaWRdID0gdGhpcztcblx0XHR0aGlzLmVsLmNpZCA9IHRoaXMuY2lkO1xuXHRcdHRoaXMuZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1jaWRcIiwgdGhpcy5jaWQpO1xuXHRcdGlmICh0aGlzLm1vZGVsKSB7XG5cdFx0XHR0aGlzLmVsLnNldEF0dHJpYnV0ZShcImRhdGEtbWNpZFwiLCB0aGlzLm1vZGVsLmNpZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIGV2ZW50IGhlbHBlcnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0YWRkTGlzdGVuZXJzOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cywgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuXHRcdGlmICghXy5pc09iamVjdCh1c2VDYXB0dXJlKSkgdXNlQ2FwdHVyZSA9ICEhdXNlQ2FwdHVyZTtcblx0XHRpZiAodHlwZW9mIGV2ZW50cyA9PT0gXCJzdHJpbmdcIikgeyBldmVudHMgPSBldmVudHMuc3BsaXQoXCIgXCIpOyB9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50c1tpXSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24odGFyZ2V0LCBldmVudHMsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcblx0XHRpZiAoIV8uaXNPYmplY3QodXNlQ2FwdHVyZSkpIHVzZUNhcHR1cmUgPSAhIXVzZUNhcHR1cmU7XG5cdFx0aWYgKHR5cGVvZiBldmVudHMgPT09IFwic3RyaW5nXCIpIHsgZXZlbnRzID0gZXZlbnRzLnNwbGl0KFwiIFwiKTsgfVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudHNbaV0sIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRsaXN0ZW5Ub0VsZW1lbnQ6IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRzLCBoYW5kbGVyKSB7XG5cdFx0dGFyZ2V0ID0gQmFja2JvbmUuJCh0YXJnZXQpO1xuXHRcdGlmICh0eXBlb2YgZXZlbnRzID09PSBcInN0cmluZ1wiKSB7IGV2ZW50cyA9IGV2ZW50cy5zcGxpdChcIiBcIik7IH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5saXN0ZW5Ubyh0YXJnZXQsIGV2ZW50c1tpXSwgaGFuZGxlcik7XG5cdFx0fVxuXHR9LFxuXHRzdG9wTGlzdGVuaW5nVG9FbGVtZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cywgaGFuZGxlcikge1xuXHRcdHRhcmdldCA9IEJhY2tib25lLiQodGFyZ2V0KTtcblx0XHRpZiAodHlwZW9mIGV2ZW50cyA9PT0gXCJzdHJpbmdcIikgeyBldmVudHMgPSBldmVudHMuc3BsaXQoXCIgXCIpOyB9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuc3RvcExpc3RlbmluZyh0YXJnZXQsIGV2ZW50c1tpXSwgaGFuZGxlcik7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGxpc3RlblRvRWxlbWVudE9uY2U6IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcblx0Ly8gXHR0aGlzLmxpc3RlblRvT25jZSh0aGlzLiQodGFyZ2V0KSwgZXZlbnQsIGhhbmRsZXIpO1xuXHQvLyB9LFxuXHQvLyBzdG9wTGlzdGVuVG9FbGVtZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG5cdC8vIFx0dGhpcy5zdG9wTGlzdGVuaW5nKEJhY2tib25lLiQodGFyZ2V0KSwgZXZlbnQsIGhhbmRsZXIpO1xuXHQvLyB9LFxuXG5cdGxpc3RlblRvRWxlbWVudE9uY2U6IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcblx0XHRpZiAoIV8uaXNPYmplY3QodXNlQ2FwdHVyZSkpIHVzZUNhcHR1cmUgPSAhIXVzZUNhcHR1cmU7XG5cdFx0dmFyIGNsZWFudXAsIHdyYXBwZXIsIGN0eDtcblx0XHRjdHggPSB0aGlzO1xuXHRcdGNsZWFudXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdGN0eC5vZmYoXCJ2aWV3OnJlbW92ZVwiLCBjbGVhbnVwKTtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB3cmFwcGVyLCB1c2VDYXB0dXJlKTtcblx0XHR9O1xuXHRcdHdyYXBwZXIgPSBmdW5jdGlvbihldikge1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0aGFuZGxlci5jYWxsKGN0eCwgZXYpO1xuXHRcdH07XG5cdFx0Y3R4Lm9uKFwidmlldzpyZW1vdmVcIiwgY2xlYW51cCk7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHdyYXBwZXIsIHVzZUNhcHR1cmUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcmlvcml0eSwgY3R4KSB7XG5cdFx0cmV0dXJuIHJlbmRlclF1ZXVlLnJlcXVlc3QoY2FsbGJhY2suYmluZChjdHggfHwgdGhpcyksIHByaW9yaXR5KTtcblx0fSxcblxuXHRjYW5jZWxBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oaWQpIHtcblx0XHRyZXR1cm4gcmVuZGVyUXVldWUuY2FuY2VsKGlkKTtcblx0fSxcblxuXHRzZXRJbW1lZGlhdGU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcmlvcml0eSwgY3R4KSB7XG5cdFx0cmV0dXJuIG1vZGVsUXVldWUucmVxdWVzdChjYWxsYmFjay5iaW5kKGN0eCB8fCB0aGlzKSwgcHJpb3JpdHkpO1xuXHR9LFxuXG5cdGNsZWFySW1tZWRpYXRlOiBmdW5jdGlvbihpZCkge1xuXHRcdHJldHVybiBtb2RlbFF1ZXVlLmNhbmNlbChpZCk7XG5cdFx0Ly8gcmV0dXJuIHdpbmRvdy5jbGVhckltbWVkaWF0ZShpZCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBkZWZlcnJlZCByZW5kZXI6IHByaXZhdGUgbWV0aG9kc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X3RyYWNlUmVuZGVyU3RhdHVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0KHRoaXMuX3JlbmRlclF1ZXVlSWQgIT0gLTEgPyBcImFzeW5jIGlkOlwiICsgdGhpcy5fcmVuZGVyUXVldWVJZCA6IFwic3luY1wiKSxcblx0XHRcdFZpZXcuZmxhZ3NUb1N0cmluZyh0aGlzLl9yZW5kZXJGbGFncyksXG5cdFx0XHQodGhpcy5hdHRhY2hlZCA/IFwiYXR0YWNoZWRcIiA6IFwiZGV0YWNoZWRcIiksXG5cdFx0XHQodGhpcy5za2lwVHJhbnNpdGlvbnMgPyBcInNraXBcIiA6IFwicnVuXCIpICsgXCItdHhcIlxuXHRcdF0uam9pbihcIiwgXCIpO1xuXHR9LFxuXG5cdC8qKiBAcHJpdmF0ZSAqL1xuXHRfYXBwbHlSZW5kZXI6IGZ1bmN0aW9uKHRzdGFtcCkge1xuXHRcdGlmIChERUJVRykge1xuXHRcdFx0aWYgKHRoaXMuX2xvZ0ZsYWdzW1widmlldy5yZW5kZXJcIl0pIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCIlczo6X2FwcGx5UmVuZGVyIFslc11cIixcblx0XHRcdFx0XHR0aGlzLmNpZCwgdGhpcy5fdHJhY2VSZW5kZXJTdGF0dXMoKSxcblx0XHRcdFx0XHR0aGlzLl9sb2dGbGFnc1tcInZpZXcudHJhY2VcIl0gP1xuXHRcdFx0XHRcdHRoaXMuX2xvZ1JlbmRlckNhbGxlcnMuam9pbihcIlxcblwiKSA6IFwiXCIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbG9nUmVuZGVyQ2FsbGVycy5sZW5ndGggPSAwO1xuXHRcdH1cblxuXHRcdHZhciBmbGFncyA9IHRoaXMuX3JlbmRlckZsYWdzO1xuXHRcdHRoaXMudHJpZ2dlcihcInZpZXc6cmVuZGVyOmJlZm9yZVwiLCB0aGlzLCBmbGFncyk7XG5cdFx0dGhpcy5fcmVuZGVyRmxhZ3MgPSAwO1xuXHRcdHRoaXMuX3JlbmRlclF1ZXVlSWQgPSAtMTtcblx0XHR0aGlzLl9yZW5kZXJGbGFncyB8PSB0aGlzLnJlbmRlckZyYW1lKHRzdGFtcCwgZmxhZ3MpO1xuXHRcdHRoaXMudHJpZ2dlcihcInZpZXc6cmVuZGVyOmFmdGVyXCIsIHRoaXMsIGZsYWdzKTtcblxuXHRcdGlmICh0aGlzLl9yZW5kZXJGbGFncyAhPSAwKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCIlczo6X2FwcGx5UmVuZGVyIFtyZXR1cm5lZF0gcGhhc2U6ICVzIGZsYWdzOiAlcyAoJXMpXCIsIHRoaXMuY2lkLCB0aGlzLl92aWV3UGhhc2UsIFZpZXcuZmxhZ3NUb1N0cmluZyh0aGlzLl9yZW5kZXJGbGFncyksIHRoaXMuX3JlbmRlckZsYWdzKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbmNlbFJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlclF1ZXVlSWQgIT0gLTEpIHtcblx0XHRcdHZhciBjYW5jZWxJZCwgY2FuY2VsRm47XG5cblx0XHRcdGNhbmNlbElkID0gdGhpcy5fcmVuZGVyUXVldWVJZDtcblx0XHRcdHRoaXMuX3JlbmRlclF1ZXVlSWQgPSAtMTtcblx0XHRcdGNhbmNlbEZuID0gcmVuZGVyUXVldWUuY2FuY2VsKGNhbmNlbElkKTtcblxuXHRcdFx0aWYgKGNhbmNlbEZuID09PSB2b2lkIDApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiJXM6Ol9jYW5jZWxSZW5kZXIgW2lkOiVpXSBub3QgZm91bmRcIiwgdGhpcy5jaWQsIGNhbmNlbElkKTtcblx0XHRcdH0gZWxzZSBpZiAoY2FuY2VsRm4gPT09IG51bGwpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiJXM6Ol9jYW5jZWxSZW5kZXIgW2lkOiVpXSBhbHJlYWR5IGNhbmNlbGxlZFwiLCB0aGlzLmNpZCwgY2FuY2VsSWQpO1xuXHRcdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0XHQvLyBcdGlmICh0aGlzLl9sb2dGbGFnc1tcInZpZXcucmVuZGVyXCJdICYmICFyZW5kZXJRdWV1ZS5ydW5uaW5nKVxuXHRcdFx0XHQvLyBcdFx0Y29uc29sZS5sb2coXCIlczo6X2NhbmNlbFJlbmRlciBJRDolaSBjYW5jZWxsZWRcIiwgdGhpcy5jaWQsIGNhbmNlbElkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChyZW5kZXJRdWV1ZS5ydW5uaW5nKSB7XG5cdFx0XHR0aGlzLl9jYW5jZWxSZW5kZXIoKTtcblx0XHRcdC8vIGlmIChERUJVRykge1xuXHRcdFx0Ly8gXHRpZiAodGhpcy5fbG9nRmxhZ3NbXCJ2aWV3LnJlbmRlclwiXSkge1xuXHRcdFx0Ly8gXHRcdGNvbnNvbGUuaW5mbyhcIiVzOjpfcmVxdWVzdFJlbmRlciByZXNjaGVkdWxlZCBbJXMgKCVzKV1cIiwgdGhpcy5jaWQsIFZpZXcuZmxhZ3NUb1N0cmluZyh0aGlzLl9yZW5kZXJGbGFncyksIHRoaXMuX3JlbmRlckZsYWdzKTtcblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gfVxuXHRcdH1cblx0XHRpZiAodGhpcy5fcmVuZGVyUXVldWVJZCA9PSAtMSkge1xuXHRcdFx0dGhpcy5fcmVuZGVyUXVldWVJZCA9IHJlbmRlclF1ZXVlLnJlcXVlc3QodGhpcy5fYXBwbHlSZW5kZXIsIGlzTmFOKHRoaXMudmlld0RlcHRoKSA/IE51bWJlci5NQVhfVkFMVUUgOiB0aGlzLnZpZXdEZXB0aCk7XG5cdFx0fVxuXHRcdGlmIChERUJVRykge1xuXHRcdFx0aWYgKHRoaXMuX2xvZ0ZsYWdzW1widmlldy50cmFjZVwiXSkge1xuXHRcdFx0XHQvLyBpZiAodGhpcy5fbG9nRmxhZ3NbXCJ2aWV3LnRyYWNlXCJdKSB7XG5cdFx0XHRcdC8vIFx0Y29uc29sZS5ncm91cENvbGxhcHNlZCh0aGlzLmNpZCArIFwiOjpfcmVxdWVzdFJlbmRlciBbXCIgKyB0aGlzLl90cmFjZVJlbmRlclN0YXR1cygpICsgXCJdIHRyYWNlXCIpO1xuXHRcdFx0XHQvLyBcdGNvbnNvbGUudHJhY2UoKTtcblx0XHRcdFx0Ly8gXHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9yZXF1ZXN0UmVuZGVyICVzIFslc11cIiwgdGhpcy5jaWQsXG5cdFx0XHRcdFx0KHJlbmRlclF1ZXVlLnJ1bm5pbmcgPyBcInJlc2NoZWR1bGVkIFwiIDogXCJcIiksXG5cdFx0XHRcdFx0dGhpcy5fdHJhY2VSZW5kZXJTdGF0dXMoKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHQvLyB9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogcmVuZGVyOiBwdWJsaWMgLyBhYnN0cmFjdCBtZXRob2RzXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRpbnZhbGlkYXRlOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAhPT0gdm9pZCAwKSB7XG5cdFx0XHQvKmlmIChERUJVRykge1xuXHRcdFx0XHRpZiAodGhpcy5fbG9nRmxhZ3NbXCJ2aWV3LnJlbmRlclwiXSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9yZW5kZXJGbGFncyA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6OmludmFsaWRhdGUgWyVzICglcyldICsgWyVzICglcyldXCIsIHRoaXMuY2lkLCBWaWV3LmZsYWdzVG9TdHJpbmcodGhpcy5fcmVuZGVyRmxhZ3MpLCB0aGlzLl9yZW5kZXJGbGFncywgVmlldy5mbGFnc1RvU3RyaW5nKGZsYWdzKSwgZmxhZ3MpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIiVzOjppbnZhbGlkYXRlIFslcyAoJXMpXVwiLCB0aGlzLmNpZCwgVmlldy5mbGFnc1RvU3RyaW5nKGZsYWdzKSwgZmxhZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSovXG5cdFx0XHR0aGlzLl9yZW5kZXJGbGFncyB8PSBmbGFncztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVxdWVzdFJlbmRlcjogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHQvLyBpZiAoREVCVUcpIHtcblx0XHQvLyBcdGlmICh0aGlzLl9sb2dGbGFnc1tcInZpZXcudHJhY2VcIl0pIHtcblx0XHQvLyBcdFx0dmFyIGZuUGF0aCA9IFtdO1xuXHRcdC8vIFx0XHR2YXIgZm4gPSBhcmd1bWVudHMuY2FsbGVlLmNhbGxlcjtcblx0XHQvLyBcdFx0d2hpbGUgKGZuKSB7XG5cdFx0Ly8gXHRcdFx0aWYgKGZuUGF0aC5sZW5ndGggPiA1KSBicmVhaztcblx0XHQvLyBcdFx0XHRmblBhdGgucHVzaChmbi5uYW1lKTtcblx0XHQvLyBcdFx0XHRmbiA9IGZuLmNhbGxlcjtcblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0XHQvLyB0aGlzLl9sb2dSZW5kZXJDYWxsZXJzLnB1c2goZm5QYXRoLmpvaW4oXCJcXG5cXHQtPlwiKSk7XG5cdFx0Ly8gXHRcdHRoaXMuX2xvZ1JlbmRlckNhbGxlcnMucHVzaChmblBhdGguam9pbihcIiAtPiBcIikpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblx0XHQvLyBpZiAoZmxhZ3MgIT09IHZvaWQgMCkge1xuXHRcdC8vIFx0dGhpcy5fcmVuZGVyRmxhZ3MgfD0gZmxhZ3M7XG5cdFx0Ly8gfVxuXHRcdHRoaXMuaW52YWxpZGF0ZShmbGFncyk7XG5cdFx0dGhpcy5fcmVxdWVzdFJlbmRlcigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKiBAYWJzdHJhY3QgKi9cblx0cmVuZGVyRnJhbWU6IGZ1bmN0aW9uKHRzdGFtcCwgZmxhZ3MpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZFxuXHRcdHJldHVybiBWaWV3Lk5PTkVfSU5WQUxJRDtcblx0fSxcblxuXHRyZW5kZXJOb3c6IGZ1bmN0aW9uKGFsd2F5c1J1bikge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJRdWV1ZUlkICE9IC0xKSB7XG5cdFx0XHR0aGlzLl9jYW5jZWxSZW5kZXIoKTtcblx0XHRcdGFsd2F5c1J1biA9IHRydWU7XG5cdFx0fVxuXHRcdC8vIGlmIChhbHdheXNSdW4gPT09IHRydWUpIHtcblx0XHRpZiAoYWx3YXlzUnVuKSB7XG5cdFx0XHR0aGlzLl9hcHBseVJlbmRlcihfbm93KCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3aGVuUmVuZGVyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBWaWV3LndoZW5WaWV3SXNSZW5kZXJlZCh0aGlzKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIHJlbmRlciBiaXR3aXNlIGZsYWdzXG5cdC8qIC0gY2hlY2s6IHRoaXMuX3JlbmRlckZsYWdzICYgZmxhZ3Ncblx0LyogLSBhZGQ6IHRoaXMuX3JlbmRlckZsYWdzIHw9IGZsYWdzXG5cdC8qIC0gcmVtb3ZlOiB0aGlzLl9yZW5kZXJGbGFncyAmPSB+ZmxhZ3Ncblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qIGhlbHBlcnMgLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0cmVxdWVzdENoaWxkcmVuUmVuZGVyOiBmdW5jdGlvbihmbGFncywgbm93LCBmb3JjZSkge1xuXHRcdHZhciBjY2lkLCB2aWV3O1xuXHRcdGZvciAoY2NpZCBpbiB0aGlzLmNoaWxkVmlld3MpIHtcblx0XHRcdHZpZXcgPSB0aGlzLmNoaWxkVmlld3NbY2NpZF07XG5cdFx0XHR2aWV3LnNraXBUcmFuc2l0aW9ucyA9IHZpZXcuc2tpcFRyYW5zaXRpb25zIHx8IHRoaXMuc2tpcFRyYW5zaXRpb25zO1xuXHRcdFx0dmlldy5yZXF1ZXN0UmVuZGVyKGZsYWdzKTtcblx0XHRcdGlmIChub3cpIHtcblx0XHRcdFx0dmlldy5yZW5kZXJOb3coZm9yY2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlck5vdyh0cnVlKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIGNvbW1vbiBhYnN0cmFjdFxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqXG5cdC8qIEBwYXJhbSB7Qm9vbGVhbn1cblx0LyovXG5cdHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZSkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkID09IGVuYWJsZSkgcmV0dXJuO1xuXHRcdHRoaXMuX2VuYWJsZWQgPSAhIShlbmFibGUpO1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHR0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuXHRcdH1cblx0fSxcbn07XG4vLywgVmlldyk7XG5cbmlmIChERUJVRykge1xuXHRWaWV3UHJvdG8uX2xvZ0ZsYWdzID0gW1xuXHRcdFwidmlldy5yZW5kZXJcIixcblx0XHQvLyBcInZpZXcudHJhY2VcIlxuXHRdLmpvaW4oXCIgXCIpO1xuXG5cdFZpZXdQcm90by5jb25zdHJ1Y3RvciA9IChmdW5jdGlvbihmbikge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXR2YWw7XG5cdFx0XHR0aGlzLl9sb2dSZW5kZXJDYWxsZXJzID0gW107XG5cdFx0XHR0aGlzLl9sb2dGbGFncyA9IHRoaXMuX2xvZ0ZsYWdzLnNwbGl0KFwiIFwiKS5yZWR1Y2UoZnVuY3Rpb24ociwgbykge1xuXHRcdFx0XHRyW29dID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHI7XG5cdFx0XHR9LCB7fSk7XG5cdFx0XHRyZXR2YWwgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCItLS0tLS0gJXMgJW9cIiwgdGhpcy5jaWQsIHRoaXMuX2xvZ0ZsYWdzKTtcblx0XHRcdHJldHVybiByZXR2YWw7XG5cdFx0fTtcblx0fSkoVmlld1Byb3RvLmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZChWaWV3UHJvdG8sIFZpZXcpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBWaWV3RXJyb3IodmlldywgZXJyKSB7XG5cdHRoaXMudmlldyA9IHZpZXc7XG5cdHRoaXMuZXJyID0gZXJyO1xuXHR0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbn1cblZpZXdFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5WaWV3RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmlld0Vycm9yO1xuVmlld0Vycm9yLnByb3RvdHlwZS5uYW1lID0gXCJWaWV3RXJyb3JcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3RXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGFsaWFzND1cImZ1bmN0aW9uXCI7XG5cbiAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCJcbiAgICArIGFsaWFzMygoaGVscGVycy5nbG9iYWwgfHwgKGRlcHRoMCAmJiBkZXB0aDAuZ2xvYmFsKSB8fCBhbGlhczIpLmNhbGwoYWxpYXMxLFwiQVBQX1JPT1RcIix7XCJuYW1lXCI6XCJnbG9iYWxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpXG4gICAgKyBcIiNcIlxuICAgICsgYWxpYXMzKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaGFuZGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5oYW5kbGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXM0ID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImhhbmRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiPlwiXG4gICAgKyAoKHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczQgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9hPlxcblwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuLyogQG1vZHVsZSBhcHAvdmlldy9jb21wb25lbnQvQXJ0aWNsZVZpZXdcbi8qL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcbi8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5jb25zdCB2aWV3VGVtcGxhdGUgPSByZXF1aXJlKFwiLi9BcnRpY2xlQnV0dG9uLmhic1wiKTtcblxuLyoqXG4vKiBAY29uc3RydWN0b3Jcbi8qIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0FydGljbGVCdXR0b259XG4vKi9cbnZhciBBcnRpY2xlQnV0dG9uID0gVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwiYXJ0aWNsZUJ1dHRvblwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRhZ05hbWU6IFwiaDJcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjbGFzc05hbWU6IFwiYXJ0aWNsZS1idXR0b25cIixcblx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cblx0dGVtcGxhdGU6IHZpZXdUZW1wbGF0ZSxcblxuXHRldmVudHM6IHtcblx0XHRcImNsaWNrIGFcIjogZnVuY3Rpb24oZG9tZXYpIHtcblx0XHRcdGRvbWV2LmRlZmF1bHRQcmV2ZW50ZWQgfHwgZG9tZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6Y2xpY2tcIiwgdGhpcy5tb2RlbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIC8qKiBAb3ZlcnJpZGUgKi9cblx0Ly8gaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge30sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogUmVuZGVyXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHJlbmRlckZyYW1lOiBmdW5jdGlvbih0c3RhbXAsIGZsYWdzKSB7XG5cdFx0dGhpcy5lbC5pbm5lckhUTUwgPSB0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwudG9KU09OKCkpO1xuXHR9LFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEFydGljbGVCdXR0b247XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuLyogQG1vZHVsZSBhcHAvdmlldy9jb21wb25lbnQvQXJ0aWNsZVZpZXdcbi8qL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvbmV0L3RvQWJzb2x1dGVVUkx9ICovXG4vLyB2YXIgdG9BYnNvbHV0ZVVSTCA9IHJlcXVpcmUoXCJ1dGlscy9uZXQvdG9BYnNvbHV0ZVVSTFwiKTtcbi8vXG4vLyAvKiogQHR5cGUge3N0cmluZ30gKi9cbi8vIHZhciBBQlNfQVBQX1JPT1QgPSB0b0Fic29sdXRlVVJMKHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpLkFQUF9ST09UKTtcblxuLyoqXG4vKiBAY29uc3RydWN0b3Jcbi8qIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0FydGljbGVWaWV3fVxuLyovXG52YXIgQXJ0aWNsZVZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdGNpZFByZWZpeDogXCJhcnRpY2xlVmlld1wiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRhZ05hbWU6IFwiYXJ0aWNsZVwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJhcnRpY2xlLXZpZXcgbWRvd25cIixcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHt9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIFJlbmRlclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRyZW5kZXJGcmFtZTogZnVuY3Rpb24odHN0YW1wLCBmbGFncykge1xuXHRcdHRoaXMuZWwuaW5uZXJIVE1MID0gdGhpcy5tb2RlbC5nZXQoXCJ0ZXh0XCIpO1xuXHRcdC8vIEZJWE1FOiBub3cgZG9uZSBpbiB4c2x0XG5cdFx0Ly8gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiYVtocmVmXVwiKS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0Ly8gXHR2YXIgdXJsID0gdG9BYnNvbHV0ZVVSTChlbC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKTtcblx0XHQvLyBcdGlmICh1cmwuaW5kZXhPZihBQlNfQVBQX1JPT1QpICE9PSAwKSB7XG5cdFx0Ly8gXHRcdGVsLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcblx0XHQvLyBcdH1cblx0XHQvLyB9KTtcblx0fSxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBBcnRpY2xlVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L2NvbXBvbmVudC9wcm9ncmVzcy9DYW52YXNQcm9ncmVzc01ldGVyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9DYW52YXNWaWV3fSAqL1xuY29uc3QgQ2FudmFzVmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL0NhbnZhc1ZpZXdcIik7XG5cbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbi8qIE5PVEU6IGF2b2lkIG5lZ2F0aXZlIHJvdGF0aW9ucyAqL1xudmFyIEJBU0VfUk9UQVRJT04gPSAxIC0gMC4yNTsgLy8gb2YgUEkyICgtOTAgZGVncmVlcylcbnZhciBHQVBfQVJDID0gUEkyIC8gNDg7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2Vhc2UvZm4vZWFzZUluUXVhZH0gKi9cbmNvbnN0IGVhc2VJbiA9IHJlcXVpcmUoXCJ1dGlscy9lYXNlL2ZuL2Vhc2VJblF1YWRcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9lYXNlL2ZuL2Vhc2VPdXRRdWFkfSAqL1xuY29uc3QgZWFzZU91dCA9IHJlcXVpcmUoXCJ1dGlscy9lYXNlL2ZuL2Vhc2VPdXRRdWFkXCIpO1xuXG52YXIgTE9PUF9PRkZTRVQgPSAxLjgzMzMzMztcbnZhciBTVEVQX01TID0gNDAwOyAvLyB0d2VlbiB0aW1lIGJhc2VcblxudmFyIEFSQ19ERUZBVUxUUyA9IHtcblx0XCJhbW91bnRcIjoge1xuXHRcdGxpbmVXaWR0aDogMC43NSxcblx0XHRyYWRpdXNPZmZzZXQ6IDBcblx0fSxcblx0XCJhdmFpbGFibGVcIjoge1xuXHRcdGxpbmVXaWR0aDogMC43NSxcblx0XHQvLyBsaW5lRGFzaDogWzEuMywgMC43XSxcblx0XHRpbnZlcnNlOiBcIm5vdC1hdmFpbGFibGVcIlxuXHR9LFxuXHRcIm5vdC1hdmFpbGFibGVcIjoge1xuXHRcdGxpbmVXaWR0aDogMC44LFxuXHRcdGxpbmVEYXNoOiBbMC4zLCAwLjddLFxuXHRcdGxpbmVEYXNoT2Zmc2V0OiAwXG5cdH0sXG5cdFwiaW5kZXRlcm1pbmF0ZVwiOiB7XG5cdFx0bGluZVdpZHRoOiAyLjAsIC8vMC44LFxuXHRcdGxpbmVEYXNoOiBbMC4zLCAxLjddLFxuXHRcdC8vIGxpbmVEYXNoOiBbMC42LCAxLjRdLFxuXHRcdGxpbmVEYXNoT2Zmc2V0OiAwXG5cdH0sXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9jb21wb25lbnQvcHJvZ3Jlc3MvQ2FudmFzUHJvZ3Jlc3NNZXRlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNWaWV3LmV4dGVuZCh7XG5cblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdGNpZFByZWZpeDogXCJjYW52YXNQcm9ncmVzc01ldGVyXCIsXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjbGFzc05hbWU6IFwicHJvZ3Jlc3MtbWV0ZXIgY2FudmFzLXByb2dyZXNzLW1ldGVyXCIsXG5cblx0ZGVmYXVsdEtleTogXCJhbW91bnRcIixcblxuXHRkZWZhdWx0czoge1xuXHRcdHZhbHVlczoge1xuXHRcdFx0YW1vdW50OiAwLFxuXHRcdFx0YXZhaWxhYmxlOiAwLFxuXHRcdFx0X2xvb3A6IDAsXG5cdFx0XHRfc3RhbGxlZF9hcmM6IDAsXG5cdFx0XHRfc3RhbGxlZF9sb29wOiAwLFxuXHRcdH0sXG5cdFx0bWF4VmFsdWVzOiB7XG5cdFx0XHRhbW91bnQ6IDEsXG5cdFx0XHRhdmFpbGFibGU6IDEsXG5cdFx0XHRfc3RhbGxlZF9sb29wOiAxLFxuXHRcdH0sXG5cdFx0dXNlT3BhcXVlOiB0cnVlLFxuXHRcdGxhYmVsRm46IGZ1bmN0aW9uKHZhbHVlLCBtYXgpIHtcblx0XHRcdHJldHVybiAoKHZhbHVlIC8gbWF4KSAqIDEwMCkgfCAwO1xuXHRcdH0sXG5cdH0sXG5cblx0cHJvcGVydGllczoge1xuXHRcdHN0YWxsZWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTsgLy90aGlzLl9zdGFsbGVkO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0Ly8gdGhpcy5fc2V0U3RhbGxlZCh2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3NldFN0YWxsZWQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX3N0YWxsZWQgIT09IHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9zdGFsbGVkID0gdmFsdWU7XG5cdFx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoQ2FudmFzVmlldy5NT0RFTF9JTlZBTElEIHwgQ2FudmFzVmlldy5MQVlPVVRfSU5WQUxJRCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIGNoaWxkcmVuL2xheW91dFxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHQvLyBUT0RPOiBjbGVhbnVwIG9wdGlvbnMgbWVzcyBpbiBDYW52YXNWaWV3XG5cdFx0Q2FudmFzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdC8vIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMuZGVmYXVsdHMpO1xuXG5cdFx0dGhpcy5fbGFiZWxGbiA9IG9wdGlvbnMubGFiZWxGbjtcblx0XHR0aGlzLl9zdGFsbGVkID0gISEob3B0aW9ucy5zdGFsbGVkKTtcblx0XHR0aGlzLl92YWx1ZVN0eWxlcyA9IHt9O1xuXHRcdHRoaXMuX2NhbnZhc1NpemUgPSBudWxsO1xuXHRcdHRoaXMuX2NhbnZhc09yaWdpbiA9IG51bGw7XG5cdH0sXG5cblx0X25lZWRzTG9vcDogZmFsc2UsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHR2YWx1ZVRvOiBmdW5jdGlvbihrZXksIHZhbHVlLCBkdXJhdGlvbikge1xuXHRcdGlmIChrZXkgPT09IFwiYW1vdW50XCIgJiYgdmFsdWUgPCB0aGlzLmludGVycG9sYXRvci5nZXRDdXJyZW50VmFsdWUoXCJhbW91bnRcIikpIHtcblx0XHRcdHRoaXMuX25lZWRzTG9vcCA9IHRydWU7XG5cdFx0fVxuXHRcdENhbnZhc1ZpZXcucHJvdG90eXBlLnZhbHVlVG8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBwcml2YXRlXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0bWVhc3VyZUNhbnZhczogZnVuY3Rpb24odywgaCwgcykge1xuXHRcdC8vIG1ha2UgY2FudmFzIHNxdWFyZVxuXHRcdHRoaXMuX2NhbnZhc0hlaWdodCA9IHRoaXMuX2NhbnZhc1dpZHRoID0gTWF0aC5taW4odywgaCk7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHR1cGRhdGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIENhbnZhc1ZpZXcucHJvdG90eXBlLl91cGRhdGVDYW52YXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdC8vIHNpemUsIGxpbmVzLCBnYXBzLCBkYXNoZXMgKHRoaXMuX3ZhbHVlU3R5bGVzLCBHQVBfQVJDLCB0aGlzLl9hcmNSYWRpdXMpXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyB2YXIgYXJjTmFtZSwgcywgYXJjRGVmYXVsdDtcblx0XHQvLyB2YXIgbWFwTGluZURhc2ggPSBmdW5jdGlvbihuKSB7XG5cdFx0Ly8gXHRyZXR1cm4gbiAqIHRoaXMucmFkaXVzICogR0FQX0FSQztcblx0XHQvLyB9O1xuXHRcdC8vIHZhciBzdW1GbiA9IGZ1bmN0aW9uKHMsIG4pIHtcblx0XHQvLyBcdHJldHVybiBzICsgbjtcblx0XHQvLyB9O1xuXG5cdFx0Ly8gdGhpcy5fY2FudmFzU2l6ZSA9IE1hdGgubWluKHRoaXMuX2NhbnZhc1dpZHRoLCB0aGlzLl9jYW52YXNIZWlnaHQpO1xuXG5cdFx0dmFyIHM7XG5cdFx0Ly8gdGhpcy5fbWF4RGFzaEFyYyA9IDBcblx0XHRmb3IgKHZhciBzdHlsZU5hbWUgaW4gQVJDX0RFRkFVTFRTKSB7XG5cdFx0XHRzID0gXy5kZWZhdWx0cyh7fSwgQVJDX0RFRkFVTFRTW3N0eWxlTmFtZV0pO1xuXHRcdFx0cy5saW5lV2lkdGggKj0gdGhpcy5fY2FudmFzUmF0aW87XG5cdFx0XHRzLnJhZGl1cyA9ICh0aGlzLl9jYW52YXNXaWR0aCAtIHMubGluZVdpZHRoKSAvIDI7XG5cdFx0XHRpZiAocy5yYWRpdXNPZmZzZXQpIHtcblx0XHRcdFx0cy5yYWRpdXMgKz0gcy5yYWRpdXNPZmZzZXQgKiB0aGlzLl9jYW52YXNSYXRpbztcblx0XHRcdH1cblx0XHRcdGlmIChfLmlzQXJyYXkocy5saW5lRGFzaCkpIHtcblx0XHRcdFx0cy5saW5lRGFzaCA9IHMubGluZURhc2gubWFwKGZ1bmN0aW9uKHZhbCwgaSwgYXJyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbCAqIHRoaXMucmFkaXVzICogR0FQX0FSQztcblx0XHRcdFx0fSwgcyk7XG5cdFx0XHRcdHMubGluZURhc2hMZW5ndGggPSBzLmxpbmVEYXNoLnJlZHVjZShmdW5jdGlvbihyZXMsIHZhbCwgaSwgYXJyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlcyArIHZhbDtcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdHMubGluZURhc2hBcmMgPSBzLmxpbmVEYXNoWzBdICogR0FQX0FSQztcblx0XHRcdFx0Ly8gdGhpcy5fbWF4RGFzaEFyYyA9IE1hdGgubWF4KHRoaXMuX21heERhc2hBcmMsIHMubGluZURhc2hBcmMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cy5saW5lRGFzaEFyYyA9IDA7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl92YWx1ZVN0eWxlc1tzdHlsZU5hbWVdID0gcztcblx0XHR9XG5cblx0XHQvLyBiYXNlbGluZVNoaWZ0XG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyBOT1RFOiBDZW50ZXIgYmFzZWxpbmU6IHVzZSBhc2NlbnQgZGF0YSB0byBjZW50ZXIgdG8geC1oZWlnaHQsIG9yIHNvcnQtb2YuXG5cdFx0Ly8gd2l0aCBhc2NlbnQvZGVzY2VudCB2YWx1ZXMgKDAuNywgLTAuMyksIHgtaGVpZ2h0IGlzIDAuNFxuXHRcdHZhciBtT2JqID0gdGhpcy5fZ2V0Rm9udE1ldHJpY3ModGhpcy5fZm9udEZhbWlseSk7XG5cdFx0dGhpcy5fYmFzZWxpbmVTaGlmdCA9IG1PYmogPyAobU9iai5hc2NlbnQgKyBtT2JqLmRlc2NlbnQpIC8gbU9iai51bml0c1BlckVtIDogMC43OyAvLyBkZWZhdWx0IHZhbHVlXG5cdFx0dGhpcy5fYmFzZWxpbmVTaGlmdCAqPSB0aGlzLl9mb250U2l6ZSAqIDAuNTsgLy8gYXBwbHkgdG8gZm9udC1zaXplLCBoYWx2ZSBpdFxuXHRcdHRoaXMuX2Jhc2VsaW5lU2hpZnQgPSBNYXRoLnJvdW5kKHRoaXMuX2Jhc2VsaW5lU2hpZnQpO1xuXG5cdFx0Ly8gc2F2ZSBjYW52YXMgY29udGV4dFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly8gcmVzZXQgbWF0cml4IGFuZCB0cmFuc2xhdGUgMCwwIHRvIGNlbnRlclxuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCB0aGlzLl9jYW52YXNXaWR0aCAvIDIsIHRoaXMuX2NhbnZhc0hlaWdodCAvIDIpO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZWRyYXc6IGZ1bmN0aW9uKGN0eCwgaW50cnAsIGZsYWdzKSB7XG5cdFx0dGhpcy5fY2xlYXJDYW52YXMoLXRoaXMuX2NhbnZhc1dpZHRoIC8gMiwgLXRoaXMuX2NhbnZhc0hlaWdodCAvIDIsXG5cdFx0XHR0aGlzLl9jYW52YXNXaWR0aCwgdGhpcy5fY2FudmFzSGVpZ2h0XG5cdFx0KTtcblxuXHRcdHZhciBzLCAvLyByZXVzZWQgc3R5bGUgb2JqZWN0c1xuXHRcdFx0dmFsRGF0YSwgLy8gcmV1c2VkIGZvciBpbnRlcnBvbGF0ZWQgZGF0YVxuXHRcdFx0YXJjVmFsOyAvLyByZXVzZWQgYXJjIHZhbHVlc1xuXG5cdFx0Ly8gYW1vdW50IGxhYmVsXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR2YWxEYXRhID0gaW50cnAuX3ZhbHVlRGF0YVtcImFtb3VudFwiXTtcblx0XHR0aGlzLmRyYXdMYWJlbCh0aGlzLl9sYWJlbEZuKHZhbERhdGEuX3JlbmRlcmVkVmFsdWUsIHZhbERhdGEuX21heFZhbCkpO1xuXG5cdFx0Ly8gaW5kZXRlcm1pbmF0ZVxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHQvKlxuXHRcdHZhciBpbmRWYWw7XG5cdFx0aWYgKHRoaXMuc3RhbGxlZCkge1xuXHRcdFx0Ly8gX2luZCBsb29wIGluZGVmaW5pdGVseSB3aGlsZSBpbmRldGVybWluYXRlOiByZXN0YXJ0IGlmIGF0IGVuZFxuXHRcdFx0aWYgKGludHJwLmlzQXRUYXJnZXQoXCJfaW5kXCIpKSB7XG5cdFx0XHRcdC8vIGlmIChpbnRycC5yZW5kZXJlZEtleXMgJiYgKGludHJwLnJlbmRlcmVkS2V5cy5pbmRleE9mKFwiX2luZFwiKSA9PT0gLTEpKSB7XG5cdFx0XHRcdGludHJwLnZhbHVlVG8oXCJfaW5kXCIsIDAsIDApO1xuXHRcdFx0XHRpbnRycC52YWx1ZVRvKFwiX2luZFwiLCAxLCAxMDAwKTtcblx0XHRcdFx0aW50cnAudXBkYXRlVmFsdWUoXCJfaW5kXCIpO1xuXHRcdFx0fVxuXHRcdFx0aW5kVmFsID0gaW50cnAuZ2V0Q3VycmVudFZhbHVlKFwiX2luZFwiKTtcblx0XHRcdC8vaW5kVmFsID0gaW50cnAuX3ZhbHVlRGF0YVtcIl9pbmRcIl0uX3JlbmRlcmVkVmFsdWUgfHwgMDtcblxuXHRcdFx0Ly8gZHJhdyBzcGlubmluZyBhcmNcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHQvLyBzID0gdGhpcy5fdmFsdWVTdHlsZXNbXCJhbW91bnRcIl07XG5cdFx0XHQvLyBjdHguc2F2ZSgpO1xuXHRcdFx0Ly8gY3R4LnJvdGF0ZShQSTIgKiAoQkFTRV9ST1RBVElPTiArIChpbmRWYWwpKSk7IC8vICsgR0FQX0FSQyk7XG5cdFx0XHQvLyBsYXN0RW5kQXJjID0gdGhpcy5kcmF3QXJjKDEsXG5cdFx0XHQvLyBcdEdBUF9BUkMsXG5cdFx0XHQvLyBcdFBJMiAtIEdBUF9BUkMsXG5cdFx0XHQvLyBcdDAsIHMpO1xuXHRcdFx0Ly8gY3R4LnJlc3RvcmUoKTtcblx0XHRcdC8vIHJldHVybjtcblxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgYW5pbWF0aW9uXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0cyA9IHRoaXMuX3ZhbHVlU3R5bGVzW1wiaW5kZXRlcm1pbmF0ZVwiXTtcblx0XHRcdHMubGluZURhc2hPZmZzZXQgPSBzLmxpbmVEYXNoTGVuZ3RoICogKCgxIC0gaW5kVmFsKSAlIDMpICogMztcblx0XHRcdHRoaXMuX3ZhbHVlU3R5bGVzW1wiYXZhaWxhYmxlXCJdLmludmVyc2UgPSBcImluZGV0ZXJtaW5hdGVcIjtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczo6cmVkcmF3IGluZFZhbDolbyBzLmxpbmVEYXNoT2Zmc2V0OiVvIHMubGluZURhc2g6JW9cIiwgdGhpcy5jaWQsIGluZFZhbCwgcy5saW5lRGFzaE9mZnNldCwgcy5saW5lRGFzaFswXSk7XG5cblx0XHRcdC8vIGRyYXcgc3Bpbm5pbmcgd2hlZWxcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHQvLyBjdHguc2F2ZSgpO1xuXHRcdFx0Ly8gY3R4LnJvdGF0ZSgoUEkyIC8gV0hFRUxfTlVNKSAqIGluZFZhbCk7IC8vICsgR0FQX0FSQyk7XG5cdFx0XHQvLyB0aGlzLmRyYXdXaGVlbCh0aGlzLl92YWx1ZVN0eWxlc1tcImFtb3VudFwiXSwgMiAvIDUsIDMgLyA1KTtcblx0XHRcdC8vIGN0eC5yZXN0b3JlKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCFpbnRycC5pc0F0VGFyZ2V0KFwiX2luZFwiKSkge1xuXHRcdFx0XHQvLyBpZiAoaW50cnAucmVuZGVyZWRLZXlzICYmIChpbnRycC5yZW5kZXJlZEtleXMuaW5kZXhPZihcIl9pbmRcIikgIT09IC0xKSkge1xuXHRcdFx0XHRpbnRycC52YWx1ZVRvKFwiX2luZFwiLCAwLCAwKTtcblx0XHRcdFx0aW50cnAudXBkYXRlVmFsdWUoXCJfaW5kXCIpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgYW5pbWF0aW9uXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0dGhpcy5fdmFsdWVTdHlsZXNbXCJhdmFpbGFibGVcIl0uaW52ZXJzZSA9IFwibm90LWF2YWlsYWJsZVwiO1xuXHRcdH0qL1xuXG5cdFx0Ly8gc2F2ZSBjdHggYmVmb3JlIGRyYXdpbmcgYXJjc1xuXHRcdGN0eC5zYXZlKCk7XG5cblx0XHQvLyBsb29wIChhbW91bnQpXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR2YXIgbG9vcFZhbDtcblx0XHQvKlxuXHRcdE5PVEU6IElmIHZhbHVlIFwiYW1vdW50XCIgaGFzIGNoYW5nZWQgKHdpdGggdmFsdWVUbygpKSBidXQgbm8geWV0XG5cdFx0aW50ZXJwb2xhdGVkLCBhbmQgaXRzIGxhc3QgcmVuZGVyZWQgdmFsdWUgaXMgbGVzcywgdGhlbiBpdHMgYmVlbiByZXNldFxuXHRcdChhIHJlbG9hZCwgYSBsb29wLCBldGMpOiB3ZSB0cmlnZ2VyIGEgJ2xvb3AnIG9mIHRoZSB3aG9sZSBhcmMuXG5cdFx0Ki9cblx0XHQvLyBpZiAoKGludHJwLnJlbmRlcmVkS2V5cy5pbmRleE9mKFwiYW1vdW50XCIpICE9PSAtMSkgJiYgKHZhbERhdGEuX2xhc3RSZW5kZXJlZFZhbHVlID4gdmFsRGF0YS5fcmVuZGVyZWRWYWx1ZSkpIHtcblx0XHRpZiAodGhpcy5fbmVlZHNMb29wKSB7XG5cdFx0XHR0aGlzLl9uZWVkc0xvb3AgPSBmYWxzZTtcblx0XHRcdC8vIHRyaWdnZXIgbG9vcFxuXHRcdFx0aW50cnAudmFsdWVUbyhcIl9sb29wXCIsIDEsIDApO1xuXHRcdFx0aW50cnAudmFsdWVUbyhcIl9sb29wXCIsIDAsIDc1MCk7XG5cdFx0XHRpbnRycC51cGRhdGVWYWx1ZShcIl9sb29wXCIpO1xuXHRcdH1cblx0XHQvLyBsb29wVmFsID0gaW50cnAuX3ZhbHVlRGF0YVtcIl9sb29wXCJdLl9yZW5kZXJlZFZhbHVlIHx8IDA7XG5cdFx0bG9vcFZhbCA9IGludHJwLmdldEN1cnJlbnRWYWx1ZShcIl9sb29wXCIpO1xuXHRcdGN0eC5yb3RhdGUoKFBJMiAqIChCQVNFX1JPVEFUSU9OICsgKDEgLSBsb29wVmFsKSkpKTsgLy8gKyBHQVBfQVJDKTtcblxuXHRcdC8vIGFtb3VudCBhcmNcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vIHZhciBhbW91bnRHYXBBcmMgPSBHQVBfQVJDO1xuXHRcdHZhciBsYXN0RW5kQXJjID0gMDtcblxuXHRcdHMgPSB0aGlzLl92YWx1ZVN0eWxlc1tcImFtb3VudFwiXTtcblx0XHRhcmNWYWwgPSBsb29wVmFsICsgdmFsRGF0YS5fcmVuZGVyZWRWYWx1ZSAvIHZhbERhdGEuX21heFZhbDtcblxuXHRcdGlmIChhcmNWYWwgPiAwKSB7XG5cdFx0XHRsYXN0RW5kQXJjID0gdGhpcy5kcmF3QXJjKGFyY1ZhbCxcblx0XHRcdFx0R0FQX0FSQyxcblx0XHRcdFx0UEkyIC0gR0FQX0FSQyxcblx0XHRcdFx0bGFzdEVuZEFyYywgcyk7XG5cdFx0XHR0aGlzLmRyYXdFbmRDYXAobGFzdEVuZEFyYywgcyk7XG5cdFx0XHRsYXN0RW5kQXJjID0gbGFzdEVuZEFyYyArIEdBUF9BUkMgKiAyO1xuXHRcdH1cblxuXHRcdC8vIGF2YWlsYWJsZSBhcmNcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHMgPSB0aGlzLl92YWx1ZVN0eWxlc1tcImF2YWlsYWJsZVwiXTtcblx0XHR2YWxEYXRhID0gaW50cnAuX3ZhbHVlRGF0YVtcImF2YWlsYWJsZVwiXTtcblxuXHRcdHZhciBzdGVwc051bSA9IHZhbERhdGEubGVuZ3RoIHx8IDE7XG5cdFx0dmFyIHN0ZXBCYXNlQXJjID0gUEkyIC8gc3RlcHNOdW07XG5cdFx0dmFyIHN0ZXBBZGp1c3RBcmMgPSBzdGVwQmFzZUFyYyAlIEdBUF9BUkM7XG5cdFx0dmFyIHN0ZXBHYXBBcmMgPSBHQVBfQVJDICsgKHN0ZXBBZGp1c3RBcmMgLSBzLmxpbmVEYXNoQXJjKSAvIDI7XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWxEYXRhKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwc051bTsgaSsrKSB7XG5cdFx0XHRcdGFyY1ZhbCA9IHZhbERhdGFbaV0uX3JlbmRlcmVkVmFsdWUgLyAodmFsRGF0YVtpXS5fbWF4VmFsIC8gc3RlcHNOdW0pO1xuXHRcdFx0XHR0aGlzLmRyYXdBcmMoYXJjVmFsLFxuXHRcdFx0XHRcdChpICogc3RlcEJhc2VBcmMpICsgc3RlcEdhcEFyYyxcblx0XHRcdFx0XHQoKGkgKyAxKSAqIHN0ZXBCYXNlQXJjKSAtIHN0ZXBHYXBBcmMsXG5cdFx0XHRcdFx0bGFzdEVuZEFyYywgcyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyY1ZhbCA9IHZhbERhdGEuX3JlbmRlcmVkVmFsdWUgLyB2YWxEYXRhLl9tYXhWYWw7XG5cdFx0XHR0aGlzLmRyYXdBcmMoYXJjVmFsLFxuXHRcdFx0XHRzdGVwR2FwQXJjLFxuXHRcdFx0XHRQSTIgLSBzdGVwR2FwQXJjLFxuXHRcdFx0XHRsYXN0RW5kQXJjLCBzKTtcblx0XHR9XG5cdFx0Ly8gcmVzdG9yZSBjdHggYWZ0ZXIgZHJhd2luZyBhcmNzXG5cdFx0Ly8ga2VlcCByb3RhdGlvbiB0cmFuc2Zvcm1cblx0XHQvL2N0eC5yZXN0b3JlKCk7XG5cblx0XHRpZiAodGhpcy5fc3RhbGxlZCkge1xuXHRcdFx0aWYgKGludHJwLmdldFRhcmdldFZhbHVlKCdfc3RhbGxlZF9hcmMnKSA9PT0gMCkge1xuXHRcdFx0XHRpbnRycC52YWx1ZVRvKCdfc3RhbGxlZF9hcmMnLCAxLCAxICogU1RFUF9NUywgZWFzZUluKS51cGRhdGVWYWx1ZSgnX3N0YWxsZWRfYXJjJyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpbnRycC5nZXRUYXJnZXRWYWx1ZSgnX3N0YWxsZWRfYXJjJykgPT09IDEpIHtcblx0XHRcdFx0aW50cnAudmFsdWVUbygnX3N0YWxsZWRfYXJjJywgMCwgMSAqIFNURVBfTVMsIGVhc2VPdXQpLnVwZGF0ZVZhbHVlKCdfc3RhbGxlZF9hcmMnKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGEgPSBpbnRycC5nZXRSZW5kZXJlZFZhbHVlKFwiX3N0YWxsZWRfYXJjXCIpO1xuXHRcdC8vIHdoaWxlIGFyYyBpcyA+IDAsIGxvb3AgaW5kZWZpbml0ZWx5IHdoaWxlIHNwaW5uaW5nIGFuZCByZXN0YXJ0XG5cdFx0Ly8gaWYgYXQgZW5kLiBPdGhlcndpc2UgbGV0IGludGVycCBleGhhdXN0IGFyYyBkdXJhdGlvblxuXHRcdGlmIChhID4gMCkge1xuXHRcdFx0aWYgKCFpbnRycC5wYXVzZWQgJiYgaW50cnAuaXNBdFRhcmdldCgnX3N0YWxsZWRfbG9vcCcpKSB7XG5cdFx0XHRcdGludHJwXG5cdFx0XHRcdFx0LnZhbHVlVG8oJ19zdGFsbGVkX2xvb3AnLCAwLCAwKVxuXHRcdFx0XHRcdC52YWx1ZVRvKCdfc3RhbGxlZF9sb29wJywgMSwgMiAqIFNURVBfTVMpXG5cdFx0XHRcdFx0LnVwZGF0ZVZhbHVlKCdfc3RhbGxlZF9sb29wJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBsID0gaW50cnAuZ2V0UmVuZGVyZWRWYWx1ZShcIl9zdGFsbGVkX2xvb3BcIik7XG5cdFx0Ly8gYWx3YXlzIHJlbmRlciB3aGlsZSBhcmMgaXMgPiAwXG5cdFx0aWYgKGEgPiAwKSB7XG5cdFx0XHQvLyBhcmMgc3BhbiBib3VuY2Vcblx0XHRcdHZhciBiID0gKGwgPCAwLjUgPyAobCAlIDAuNSkgOiAwLjUgLSAobCAlIDAuNSkpICogMjtcblx0XHRcdC8vIGJvdW5jZSArIG1haW4gYXJjIHNwYW5cblx0XHRcdHZhciBhYSA9IChhICogYiAqIDAuMjUpICsgKGEgKiAwLjEyNSkgKyAuMDAwMTtcblx0XHRcdC8vIHJvdGF0aW9uIGxvb3Bcblx0XHRcdHZhciBsbCA9IGwgKyBMT09QX09GRlNFVDtcblxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSAxMCAqIHRoaXMuX2NhbnZhc1JhdGlvO1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW91dFwiO1xuXHRcdFx0Y3R4LnN0cm9rZUNvbG9yID0gJ3JlZCc7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHguYXJjKDAsIDAsICh0aGlzLl9jYW52YXNXaWR0aCkgLyAyLCAoKDEgLSBhYSkgKyBsbCkgKiBQSTIsIChhYSArIGxsKSAqIFBJMiwgZmFsc2UpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRkcmF3QXJjOiBmdW5jdGlvbih2YWx1ZSwgc3RhcnRBcmMsIGVuZEFyYywgcHJldkFyYywgc3R5bGUpIHtcblx0XHR2YXIgdmFsQXJjLFxuXHRcdFx0dmFsU3RhcnRBcmMsXG5cdFx0XHR2YWxFbmRBcmMsXG5cdFx0XHRpbnZTdHlsZSxcblx0XHRcdGludlN0YXJ0QXJjLFxuXHRcdFx0aW52RW5kQXJjO1xuXG5cdFx0cHJldkFyYyB8fCAocHJldkFyYyA9IDApO1xuXG5cdFx0dmFsQXJjID0gZW5kQXJjIC0gc3RhcnRBcmM7XG5cdFx0dmFsRW5kQXJjID0gc3RhcnRBcmMgKyAodmFsQXJjICogdmFsdWUpO1xuXHRcdHZhbFN0YXJ0QXJjID0gTWF0aC5tYXgoc3RhcnRBcmMsIHByZXZBcmMpO1xuXHRcdGlmICh2YWxFbmRBcmMgPiB2YWxTdGFydEFyYykge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuYXBwbHlWYWx1ZVN0eWxlKHN0eWxlKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5hcmMoMCwgMCwgc3R5bGUucmFkaXVzLCB2YWxFbmRBcmMsIHZhbFN0YXJ0QXJjLCB0cnVlKTtcblx0XHRcdHRoaXMuX2N0eC5zdHJva2UoKTtcblx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlcmUncyB2YWx1ZVN0eWxlLCBkcmF3IHJlc3Qgb2Ygc3BhbiwgbWludXMgcHJldkFyYyBvdmVybGFwIHRvb1xuXHRcdGlmIChzdHlsZS5pbnZlcnNlICE9PSB2b2lkIDApIHtcblx0XHRcdGludlN0eWxlID0gdGhpcy5fdmFsdWVTdHlsZXNbc3R5bGUuaW52ZXJzZV07XG5cblx0XHRcdGludkVuZEFyYyA9IHZhbEVuZEFyYyArICh2YWxBcmMgKiAoMSAtIHZhbHVlKSk7XG5cdFx0XHRpbnZTdGFydEFyYyA9IE1hdGgubWF4KHZhbEVuZEFyYywgcHJldkFyYyk7XG5cdFx0XHRpZiAoaW52RW5kQXJjID4gaW52U3RhcnRBcmMpIHtcblx0XHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdFx0dGhpcy5hcHBseVZhbHVlU3R5bGUoaW52U3R5bGUpO1xuXHRcdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdHRoaXMuX2N0eC5hcmMoMCwgMCwgaW52U3R5bGUucmFkaXVzLCBpbnZFbmRBcmMsIGludlN0YXJ0QXJjLCB0cnVlKTtcblx0XHRcdFx0dGhpcy5fY3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWxFbmRBcmM7XG5cdH0sXG5cblx0YXBwbHlWYWx1ZVN0eWxlOiBmdW5jdGlvbihzKSB7XG5cdFx0dGhpcy5fY3R4LmxpbmVXaWR0aCA9IHMubGluZVdpZHRoO1xuXHRcdGlmIChfLmlzQXJyYXkocy5saW5lRGFzaCkpIHtcblx0XHRcdHRoaXMuX2N0eC5zZXRMaW5lRGFzaChzLmxpbmVEYXNoKTtcblx0XHR9XG5cdFx0aWYgKF8uaXNOdW1iZXIocy5saW5lRGFzaE9mZnNldCkpIHtcblx0XHRcdHRoaXMuX2N0eC5saW5lRGFzaE9mZnNldCA9IHMubGluZURhc2hPZmZzZXQ7XG5cdFx0fVxuXHR9LFxuXG5cblx0ZHJhd05vdGNoOiBmdW5jdGlvbihhcmNQb3MsIGxlbmd0aCwgcykge1xuXHRcdHZhciBleCwgZXksIGVjMSwgZWMyO1xuXG5cdFx0ZXggPSBNYXRoLmNvcyhhcmNQb3MpO1xuXHRcdGV5ID0gTWF0aC5zaW4oYXJjUG9zKTtcblx0XHRlYzEgPSBzLnJhZGl1cztcblx0XHRlYzIgPSBzLnJhZGl1cyAtIGxlbmd0aDtcblxuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0dGhpcy5hcHBseVZhbHVlU3R5bGUocyk7XG5cdFx0dGhpcy5fY3R4LmxpbmVDYXAgPSBcInNxdWFyZVwiO1xuXHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHR0aGlzLl9jdHgubW92ZVRvKGVjMSAqIGV4LCBlYzEgKiBleSk7XG5cdFx0dGhpcy5fY3R4LmxpbmVUbyhlYzIgKiBleCwgZWMyICogZXkpO1xuXHRcdHRoaXMuX2N0eC5zdHJva2UoKTtcblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGRyYXdFbmRDYXA6IGZ1bmN0aW9uKGFyY1Bvcywgcykge1xuXHRcdHZhciByYWRpdXMgPSBzLnJhZGl1cztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdHRoaXMuX2N0eC5saW5lV2lkdGggPSBzLmxpbmVXaWR0aDtcblxuXHRcdHRoaXMuX2N0eC5yb3RhdGUoYXJjUG9zIC0gR0FQX0FSQyAqIDIpOyAvLyAxLjUpO1xuXHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHR0aGlzLl9jdHguYXJjKDAsIDAsIHJhZGl1cywgR0FQX0FSQyAqIDAuNSwgR0FQX0FSQyAqIDIsIGZhbHNlKTtcblx0XHR0aGlzLl9jdHgubGluZVRvKHJhZGl1cyAtIChHQVBfQVJDICogcmFkaXVzKSwgMCk7XG5cdFx0dGhpcy5fY3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0dGhpcy5fY3R4LmZpbGwoKTtcblx0XHR0aGlzLl9jdHguc3Ryb2tlKCk7XG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRkcmF3TGFiZWw6IGZ1bmN0aW9uKHMpIHtcblx0XHRpZiAodGhpcy5fbGFiZWxUZXh0ICE9PSBzKSB7XG5cdFx0XHR0aGlzLl9sYWJlbFRleHQgPSBzO1xuXHRcdFx0dGhpcy5fbGFiZWxXaWR0aCA9IHRoaXMuX2N0eC5tZWFzdXJlVGV4dChzKS53aWR0aDtcblx0XHR9XG5cdFx0dGhpcy5fY3R4LmZpbGxUZXh0KHMsIHRoaXMuX2xhYmVsV2lkdGggKiAtMC41LCB0aGlzLl9iYXNlbGluZVNoaWZ0LCB0aGlzLl9sYWJlbFdpZHRoKTtcblx0fSxcbn0pO1xuXG5pZiAoREVCVUcpIHtcblx0bW9kdWxlLmV4cG9ydHMucHJvdG90eXBlLl9sb2dGbGFncyA9IFwiXCI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9jb21wb25lbnQvQ2Fyb3VzZWxcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTpiYWNrYm9uZS5iYWJ5c2l0dGVyfSAqL1xuY29uc3QgQ29udGFpbmVyID0gcmVxdWlyZShcImJhY2tib25lLmJhYnlzaXR0ZXJcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmhhbW1lcmpzfSAqL1xuY29uc3QgSGFtbWVyID0gcmVxdWlyZShcImhhbW1lcmpzXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvdG91Y2gvU21vb3RoUGFuUmVjb2duaXplcn0gKi9cbmNvbnN0IFBhbiA9IHJlcXVpcmUoXCJ1dGlscy90b3VjaC9TbW9vdGhQYW5SZWNvZ25pemVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6aGFtbWVyanMuVGFwfSAqL1xudmFyIFRhcCA9IEhhbW1lci5UYXA7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0dsb2JhbHN9ICovXG5jb25zdCBHbG9iYWxzID0gcmVxdWlyZShcImFwcC9jb250cm9sL0dsb2JhbHNcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvRGVmZXJyZWRWaWV3fSAqL1xuLy8gdmFyIFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9EZWZlcnJlZFZpZXdcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3JlbmRlci9DYXJvdXNlbFJlbmRlcmVyfSAqL1xuY29uc3QgQ2Fyb3VzZWxSZW5kZXJlciA9IHJlcXVpcmUoXCJhcHAvdmlldy9yZW5kZXIvQ2Fyb3VzZWxSZW5kZXJlclwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZWRQcm9wZXJ0eX0gKi9cbmNvbnN0IHByZWZpeGVkUHJvcGVydHkgPSByZXF1aXJlKFwidXRpbHMvcHJlZml4ZWRQcm9wZXJ0eVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3ByZWZpeGVkU3R5bGVOYW1lfSAqL1xuY29uc3QgcHJlZml4ZWRTdHlsZU5hbWUgPSByZXF1aXJlKFwidXRpbHMvcHJlZml4ZWRTdHlsZU5hbWVcIik7XG5cbnZhciB0cmFuc2Zvcm1TdHlsZU5hbWUgPSBwcmVmaXhlZFN0eWxlTmFtZShcInRyYW5zZm9ybVwiKTtcbnZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IHByZWZpeGVkUHJvcGVydHkoXCJ0cmFuc2Zvcm1cIik7XG52YXIgdHJhbnNsYXRlVGVtcGxhdGUgPSBHbG9iYWxzLlRSQU5TTEFURV9URU1QTEFURTtcblxuLy8gdmFyIGNzc1RvUHggPSBmdW5jdGlvbihjc3NWYWwsIGVsKSB7XG4vLyBcdHJldHVybiBwYXJzZUludChjc3NWYWwpO1xuLy8gfTtcblxuLy8gdmFyIGRlZmF1bHRSZW5kZXJlckZ1bmN0aW9uID0gKGZ1bmN0aW9uKCkge1xuLy8gXHR2YXIgZGVmYXVsdFJlbmRlcmVyID0gQ2Fyb3VzZWxSZW5kZXJlci5leHRlbmQoeyBjbGFzc05hbWU6IFwiY2Fyb3VzZWwtaXRlbSBkZWZhdWx0LXJlbmRlcmVyXCJ9KSxcbi8vIFx0XHRlbXB0eVJlbmRlcmVyID0gQ2Fyb3VzZWxSZW5kZXJlci5leHRlbmQoeyBjbGFzc05hbWU6IFwiY2Fyb3VzZWwtaXRlbSBlbXB0eS1yZW5kZXJlclwifSk7XG4vLyBcdHJldHVybiBmdW5jdGlvbihpdGVtLCBpbmRleCwgYXJyKSB7XG4vLyBcdFx0cmV0dXJuIChpbmRleCA9PT0gLTEpPyBlbXB0eVJlbmRlcmVyOiBkZWZhdWx0UmVuZGVyZXI7XG4vLyBcdH07XG4vLyB9KSgpO1xuXG4vKiogQGNvbnN0ICovXG52YXIgTUFYX1NFTEVDVF9USFJFU0hPTEQgPSAyMDtcblxuLy8gLyoqIEBjb25zdCAqL1xuLy8gdmFyIENISUxEUkVOX0lOVkFMSUQgPSBWaWV3LkNISUxEUkVOX0lOVkFMSUQsXG4vLyBcdFNUWUxFU19JTlZBTElEID0gVmlldy5TVFlMRVNfSU5WQUxJRCxcbi8vIFx0TU9ERUxfSU5WQUxJRCA9IFZpZXcuTU9ERUxfSU5WQUxJRCxcbi8vIFx0U0laRV9JTlZBTElEID0gVmlldy5TSVpFX0lOVkFMSUQsXG4vLyBcdExBWU9VVF9JTlZBTElEID0gVmlldy5MQVlPVVRfSU5WQUxJRDtcblxudmFyIFZFUlRJQ0FMID0gSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCxcblx0SE9SSVpPTlRBTCA9IEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTDtcblxuLy8geDogW1wieFwiLCBcInlcIl0sXG4vLyB5OiBbXCJ5XCIsIFwieFwiXSxcbi8vIG9mZnNldExlZnQ6IFtcIm9mZnNldExlZnRcIiwgXCJvZmZzZXRUb3BcIl0sXG4vLyBvZmZzZXRUb3A6IFtcIm9mZnNldFRvcFwiLCBcIm9mZnNldExlZnRcIl0sXG4vLyBvZmZzZXRXaWR0aDogW1wib2Zmc2V0V2lkdGhcIiwgXCJvZmZzZXRIZWlnaHRcIl0sXG4vLyBvZmZzZXRIZWlnaHQ6IFtcIm9mZnNldEhlaWdodFwiLCBcIm9mZnNldFdpZHRoXCJdLFxuLy8gd2lkdGg6IFtcIndpZHRoXCIsXCJoZWlnaHRcIl0sXG4vLyBoZWlnaHQ6IFtcImhlaWdodFwiLFwid2lkdGhcIl0sXG4vLyBtYXJnaW5MZWZ0OiBbXCJtYXJnaW5MZWZ0XCIsXCJtYXJnaW5Ub3BcIl0sXG4vLyBtYXJnaW5SaWdodDogW1wibWFyZ2luUmlnaHRcIixcIm1hcmdpbkJvdHRvbVwiXSxcblxuLypcbnZhciBIT1JJWk9OVEFMX1BST1BTID0ge1xuXHRwb3M6IFwieFwiLFxuXHRzaXplOiBcIndpZHRoXCIsXG5cdG9mZnNldFBvczogXCJvZmZzZXRMZWZ0XCIsXG5cdG9mZnNldFNpemU6IFwib2Zmc2V0V2lkdGhcIixcblx0bWFyZ2luQmVmb3JlOiBcIm1hcmdpbkxlZnRcIixcblx0bWFyZ2luQWZ0ZXI6IFwibWFyZ2luUmlnaHRcIixcbn07XG52YXIgVkVSVElDQUxfUFJPUFMgPSB7XG5cdHBvczogXCJ5XCIsXG5cdHNpemU6IFwiaGVpZ2h0XCIsXG5cdG9mZnNldFBvczogXCJvZmZzZXRUb3BcIixcblx0b2Zmc2V0U2l6ZTogXCJvZmZzZXRIZWlnaHRcIixcblx0bWFyZ2luQmVmb3JlOiBcIm1hcmdpblRvcFwiLFxuXHRtYXJnaW5BZnRlcjogXCJtYXJnaW5Cb3R0b21cIixcbn07XG4qL1xuXG4vLyB2YXIgRElSRUNUSU9OX05PTkUgPSAxO1xuLy8gdmFyIERJUkVDVElPTl9MRUZUID0gMjtcbi8vIHZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xuLy8gdmFyIERJUkVDVElPTl9VUCA9IDg7XG4vLyB2YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIGRpclRvU3RyID0gZnVuY3Rpb24oZGlyKSB7XG5cdGlmIChkaXIgPT09IEhhbW1lci5ESVJFQ1RJT05fTk9ORSkgcmV0dXJuICdOT05FJztcblx0aWYgKGRpciA9PT0gSGFtbWVyLkRJUkVDVElPTl9MRUZUKSByZXR1cm4gJ0xFRlQnO1xuXHRpZiAoZGlyID09PSBIYW1tZXIuRElSRUNUSU9OX1JJR0hUKSByZXR1cm4gJ1JJR0hUJztcblx0aWYgKGRpciA9PT0gSGFtbWVyLkRJUkVDVElPTl9VUCkgcmV0dXJuICdVUCc7XG5cdGlmIChkaXIgPT09IEhhbW1lci5ESVJFQ1RJT05fRE9XTikgcmV0dXJuICdET1dOJztcblx0aWYgKGRpciA9PT0gSGFtbWVyLkRJUkVDVElPTl9IT1JJWk9OVEFMKSByZXR1cm4gJ0hPUic7IC8vSVpPTlRBTCc7XG5cdGlmIChkaXIgPT09IEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwpIHJldHVybiAnVkVSJzsgLy9USUNBTCc7XG5cdGlmIChkaXIgPT09IEhhbW1lci5ESVJFQ1RJT05fQUxMKSByZXR1cm4gJ0FMTCc7XG5cdHJldHVybiAnVU5SRUMnOyAvL09HTklaRUQnO1xufVxuXG52YXIgaXNWYWxpZFRvdWNoTWFuYWdlciA9IGZ1bmN0aW9uKHRvdWNoLCBkaXJlY3Rpb24pIHtcblx0Ly8gdmFyIHJldHZhbDtcblx0dHJ5IHtcblx0XHRyZXR1cm4gdG91Y2guZ2V0KFwiaHBhblwiKS5vcHRpb25zLmRpcmVjdGlvbiA9PSBkaXJlY3Rpb247XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHQvLyByZXR1cm4gcmV0dmFsO1xufTtcblxuLy8gLyoqIEB0eXBlIHtpbnR9IEluIHBpeGVscyAqL1xuLy8gdmFyIHBhblRocmVzaG9sZDogMTU7XG5cbnZhciBjcmVhdGVUb3VjaE1hbmFnZXIgPSBmdW5jdGlvbihlbCwgZGlyLCB0aHJlcykge1xuXHR2YXIgdG91Y2ggPSBuZXcgSGFtbWVyLk1hbmFnZXIoZWwpO1xuXHR2YXIgcGFuID0gbmV3IFBhbih7XG5cdFx0ZXZlbnQ6IFwiaHBhblwiLFxuXHRcdHRocmVzaG9sZDogR2xvYmFscy5USFJFU0hPTEQsXG5cdFx0ZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwsXG5cdH0pO1xuXHR2YXIgdGFwID0gbmV3IFRhcCh7XG5cdFx0dGhyZXNob2xkOiBHbG9iYWxzLlRIUkVTSE9MRCAtIDEsXG5cdFx0aW50ZXJ2YWw6IDUwLFxuXHRcdHRpbWU6IDIwMCxcblx0fSk7XG5cdHRhcC5yZWNvZ25pemVXaXRoKHBhbik7XG5cdHRvdWNoLmFkZChbcGFuLCB0YXBdKTtcblx0cmV0dXJuIHRvdWNoO1xufTtcblxuXG52YXIgQ2Fyb3VzZWwgPSB7XG5cdC8qKiBjb25zdCAqL1xuXHRBTklNQVRFRDogZmFsc2UsXG5cdC8qKiBjb25zdCAqL1xuXHRJTU1FRElBVEU6IHRydWUsXG5cblx0LyoqIGNvcHkgb2YgSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCAqL1xuXHRESVJFQ1RJT05fVkVSVElDQUw6IFZFUlRJQ0FMLFxuXHQvKiogY29weSBvZiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgKi9cblx0RElSRUNUSU9OX0hPUklaT05UQUw6IEhPUklaT05UQUwsXG5cdC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHRzZWxlY3RPblNjcm9sbEVuZDogZmFsc2UsXG5cdFx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRcdHJlcXVpcmVTZWxlY3Rpb246IGZhbHNlLFxuXHRcdC8qKiBAdHlwZSB7aW50fSAqL1xuXHRcdGRpcmVjdGlvbjogSE9SSVpPTlRBTCxcblx0XHQvKiogQHR5cGUge2ludH0gSW4gcGl4ZWxzICovXG5cdFx0c2VsZWN0VGhyZXNob2xkOiAyMCxcblx0XHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuXHRcdHJlbmRlcmVyRnVuY3Rpb246IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZWZhdWx0UmVuZGVyZXIgPSBDYXJvdXNlbFJlbmRlcmVyLmV4dGVuZCh7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lOiBcImNhcm91c2VsLWl0ZW0gZGVmYXVsdC1yZW5kZXJlclwiXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRlbXB0eVJlbmRlcmVyID0gQ2Fyb3VzZWxSZW5kZXJlci5leHRlbmQoe1xuXHRcdFx0XHRcdGNsYXNzTmFtZTogXCJjYXJvdXNlbC1pdGVtIGVtcHR5LXJlbmRlcmVyXCJcblx0XHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oaXRlbSwgaW5kZXgsIGFycikge1xuXHRcdFx0XHRyZXR1cm4gKGluZGV4ID09PSAtMSkgPyBlbXB0eVJlbmRlcmVyIDogZGVmYXVsdFJlbmRlcmVyO1xuXHRcdFx0fTtcblx0XHR9KSgpLFxuXHR9LFxufTtcbkNhcm91c2VsLnZhbGlkT3B0aW9ucyA9IF8ua2V5cyhDYXJvdXNlbC5kZWZhdWx0cyk7XG5cbi8qKlxuLyogQGNvbnN0cnVjdG9yXG4vKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9DYXJvdXNlbH1cbi8qL1xudmFyIENhcm91c2VsUHJvdG8gPSB7XG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjaWRQcmVmaXg6IFwiY2Fyb3VzZWxcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0YWdOYW1lOiBcImRpdlwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJjYXJvdXNlbCBza2lwLXRyYW5zaXRpb25zXCIsXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogcHJvcGVydGllc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRwcm9wZXJ0aWVzOiB7XG5cdFx0c2Nyb2xsaW5nOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2Nyb2xsaW5nO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0ZWRJdGVtOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRWaWV3Lm1vZGVsO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdHRoaXMuX29uU2VsZWN0T25lKHZhbHVlKVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dGhpcy5fb25TZWxlY3ROb25lKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSxcblxuXHRldmVudHM6IHtcblx0XHQvLyBcIm1vdXNlZG93blwiOiBcIl9vbk1vdXNlRG93blwiLCBcIm1vdXNldXBcIjogXCJfb25Nb3VzZVVwXCIsXG5cdFx0XCJ0cmFuc2l0aW9uZW5kIC5jYXJvdXNlbC1pdGVtLnNlbGVjdGVkXCI6IFwiX29uU2Nyb2xsVHJhbnNpdGlvbkVuZFwiLFxuXHRcdFwiY2xpY2sgLmNhcm91c2VsLWl0ZW06bm90KC5zZWxlY3RlZClcIjogXCJfb25DbGlja1wiLFxuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdF8uYmluZEFsbCh0aGlzLCBcIl9vblBvaW50ZXJFdmVudFwiLCBcIl9vbkNsaWNrXCIpO1xuXG5cdFx0dGhpcy5pdGVtVmlld3MgPSBuZXcgQ29udGFpbmVyKCk7XG5cdFx0dGhpcy5tZXRyaWNzID0ge307XG5cblx0XHRfLmV4dGVuZCh0aGlzLCBfLmRlZmF1bHRzKF8ucGljayhvcHRpb25zLCBDYXJvdXNlbC52YWxpZE9wdGlvbnMpLCBDYXJvdXNlbC5kZWZhdWx0cykpO1xuXG5cdFx0Ly8gdGhpcy5jaGlsZEdhcCA9IDA7IC8vdGhpcy5kaXJQcm9wKDIwLCAxOCk7XG5cdFx0dGhpcy5fcHJlY2VkaW5nRGlyID0gKEhhbW1lci5ESVJFQ1RJT05fTEVGVCB8IEhhbW1lci5ESVJFQ1RJT05fVVApICYgdGhpcy5kaXJlY3Rpb247XG5cdFx0dGhpcy5fZm9sbG93aW5nRGlyID0gKEhhbW1lci5ESVJFQ1RJT05fUklHSFQgfCBIYW1tZXIuRElSRUNUSU9OX0RPV04pICYgdGhpcy5kaXJlY3Rpb247XG5cblx0XHQvLyB1c2Ugc3VwcGxpZWQgdG91Y2ggbWdyIG9yIGNyZWF0ZSBwcml2YXRlXG5cdFx0aWYgKGlzVmFsaWRUb3VjaE1hbmFnZXIob3B0aW9ucy50b3VjaCwgdGhpcy5kaXJlY3Rpb24pKSB7XG5cdFx0XHR0aGlzLnRvdWNoID0gb3B0aW9ucy50b3VjaDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiJXM6OmluaXRpYWxpemUgY3JlYXRpbmcgSGFtbWVyIGluc3RhbmNlXCIsIHRoaXMuY2lkKTtcblx0XHRcdHRoaXMudG91Y2ggPSBjcmVhdGVUb3VjaE1hbmFnZXIodGhpcy5lbCwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdFx0Ly8gdGhpcy5vbihcInZpZXc6cmVtb3ZlZFwiLCB0aGlzLnRvdWNoLmRlc3Ryb3ksIHRoaXMudG91Y2gpO1xuXHRcdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcInZpZXc6cmVtb3ZlZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy50b3VjaC5kZXN0cm95KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKiBjcmVhdGUgY2hpbGRyZW4gYW5kIHByb3BzICovXG5cdFx0dGhpcy5zZXRFbmFibGVkKHRydWUpO1xuXHRcdHRoaXMuc2tpcFRyYW5zaXRpb25zID0gdHJ1ZTtcblx0XHR0aGlzLl9yZW5kZXJGbGFncyA9IFZpZXcuQ0hJTERSRU5fSU5WQUxJRDtcblx0XHQvLyB0aGlzLmludmFsaWRhdGVDaGlsZHJlbigpO1xuXG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcInZpZXc6YXR0YWNoZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNraXBUcmFuc2l0aW9ucyA9IHRydWU7XG5cdFx0XHQvLyB0aGlzLmludmFsaWRhdGVTaXplKCk7XG5cdFx0XHQvLyB0aGlzLnJlbmRlck5vdygpO1xuXHRcdFx0Ly8gdGhpcy5yZXF1ZXN0UmVuZGVyKCk7XG5cdFx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoVmlldy5TSVpFX0lOVkFMSUQgfCBWaWV3LkxBWU9VVF9JTlZBTElEKTtcblx0XHR9KTtcblxuXHRcdC8qIGNvbGxlY3Rpb24gbGlzdGVuZXJzICovXG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sIHtcblx0XHRcdFwicmVzZXRcIjogdGhpcy5fb25SZXNldCxcblx0XHRcdFwic2VsZWN0Om9uZVwiOiB0aGlzLl9vblNlbGVjdE9uZSxcblx0XHRcdFwic2VsZWN0Om5vbmVcIjogdGhpcy5fb25TZWxlY3ROb25lLFxuXHRcdFx0XCJkZXNlbGVjdDpvbmVcIjogdGhpcy5fb25EZXNlbGVjdEFueSxcblx0XHRcdFwiZGVzZWxlY3Q6bm9uZVwiOiB0aGlzLl9vbkRlc2VsZWN0QW55LFxuXHRcdH0pO1xuXHR9LFxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBIYW1tZXIgaW5pdFxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyB2YWxpZGF0ZVRvdWNoTWFuYWdlcjogZnVuY3Rpb24odG91Y2gsIGRpcmVjdGlvbikge1xuXHQvLyBcdHRyeSB7XG5cdC8vIFx0XHRyZXR1cm4gdG91Y2guZ2V0KFwicGFuXCIpLm9wdGlvbnMuZGlyZWN0aW9uID09PSBkaXJlY3Rpb24pO1xuXHQvLyBcdH0gY2F0Y2ggKGVycikge1xuXHQvLyBcdFx0cmV0dXJuIGZhbHNlO1xuXHQvLyBcdH1cblx0Ly8gfSxcblxuXHQvLyBpbml0aWFsaXplSGFtbWVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdC8vIFx0Ly8gZGlyZWN0aW9uIGZyb20gb3B0cy9kZWZhdWx0c1xuXHQvLyBcdGlmIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gVkVSVElDQUwpIHtcblx0Ly8gXHRcdHRoaXMuZGlyZWN0aW9uID0gVkVSVElDQUw7XG5cdC8vIFx0fSAvLyBkbyBub3RoaW5nOiB0aGUgZGVmYXVsdCBpcyBob3Jpem9udGFsXG5cdC8vXG5cdC8vIFx0Ly8gdmFsaWRhdGUgaGFtbWVyIGluc3RhbmNlIG9yIGNyZWF0ZSBsb2NhbFxuXHQvLyBcdGlmICgodG91Y2ggPSBvcHRpb25zLnRvdWNoKSAmJiAocGFuID0gdG91Y2guZ2V0KFwicGFuXCIpKSkge1xuXHQvLyBcdFx0Ly8gT3ZlcnJpZGUgZGlyZWN0aW9uIG9ubHkgaWYgc3BlY2lmaWNcblx0Ly8gXHRcdGlmIChwYW4ub3B0aW9ucy5kaXJlY3Rpb24gIT09IEhhbW1lci5ESVJFQ1RJT05fQUxMKSB7XG5cdC8vIFx0XHRcdHRoaXMuZGlyZWN0aW9uID0gcGFuLm9wdGlvbnMuZGlyZWN0aW9uO1xuXHQvLyBcdFx0fVxuXHQvLyBcdFx0dGhpcy5wYW5UaHJlc2hvbGQgPSBwYW4ub3B0aW9ucy50aHJlc2hvbGQ7XG5cdC8vIFx0fSBlbHNlIHtcblx0Ly8gXHRcdGNvbnNvbGUud2FybihcIiVzOjppbml0aWFsaXplSGFtbWVyIHVzaW5nIHByaXZhdGUgSGFtbWVyIGluc3RhbmNlXCIsIHRoaXMuY2lkKTtcblx0Ly8gXHRcdHRvdWNoID0gY3JlYXRlSGFtbWVySW5zdGFuY2UodGhpcy5lbCwgdGhpcy5wYW5UaHJlc2hvbGQsIHRoaXMuZGlyZWN0aW9uKTtcblx0Ly8gXHRcdHRoaXMub24oXCJ2aWV3OnJlbW92ZWRcIiwgdG91Y2guZGVzdHJveSwgdG91Y2gpO1xuXHQvLyBcdH1cblx0Ly8gXHR0aGlzLnRvdWNoID0gdG91Y2g7XG5cdC8vIH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0aGlzLl9zY3JvbGxQZW5kaW5nQWN0aW9uICYmIHRoaXMuX3Njcm9sbFBlbmRpbmdBY3Rpb24odHJ1ZSk7XG5cdFx0Ly8gaWYgKHRoaXMuX2VuYWJsZWQpIHtcblx0XHQvLyBcdHRoaXMudG91Y2gub2ZmKFwidGFwXCIsIHRoaXMuX29uVGFwKTtcblx0XHQvLyBcdHRoaXMudG91Y2gub2ZmKFwiaHBhbnN0YXJ0IGhwYW5tb3ZlIGhwYW5lbmQgaHBhbmNhbmNlbFwiLCB0aGlzLl9vblBhbik7XG5cdFx0Ly8gfVxuXHRcdHRoaXMuX3RvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuXHRcdHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHRWaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIGhlbHBlciBmdW5jdGlvbnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0ZGlyUHJvcDogZnVuY3Rpb24oaFByb3AsIHZQcm9wKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRpcmVjdGlvbiAmIEhPUklaT05UQUwpID8gaFByb3AgOiB2UHJvcDtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBSZW5kZXJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gcmVuZGVyOiBmdW5jdGlvbigpIHtcblx0Ly8gXHRpZiAodGhpcy5hdHRhY2hlZCkge1xuXHQvLyBcdFx0dGhpcy5za2lwVHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0Ly8gdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuXHQvLyBcdFx0dGhpcy5yZW5kZXJOb3codHJ1ZSk7XG5cdC8vIFx0fVxuXHQvLyB9LFxuXG5cdC8vIC8qKiBAb3ZlcnJpZGUgKi9cblx0Ly8gcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdC8vIFx0aWYgKCF0aGlzLmF0dGFjaGVkKSB7XG5cdC8vIFx0XHRpZiAoIXRoaXMuX3JlbmRlclBlbmRpbmcpIHtcblx0Ly8gXHRcdFx0dGhpcy5fcmVuZGVyUGVuZGluZyA9IHRydWU7XG5cdC8vIFx0XHRcdHRoaXMubGlzdGVuVG8odGhpcywgXCJ2aWV3OmF0dGFjaGVkXCIsIHRoaXMucmVuZGVyKTtcblx0Ly8gXHRcdH1cblx0Ly8gXHR9IGVsc2Uge1xuXHQvLyBcdFx0aWYgKHRoaXMuX3JlbmRlclBlbmRpbmcpIHtcblx0Ly8gXHRcdFx0dGhpcy5fcmVuZGVyUGVuZGluZyA9IGZhbHNlO1xuXHQvLyBcdFx0XHR0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcywgXCJ2aWV3OmF0dGFjaGVkXCIsIHRoaXMucmVuZGVyKTtcblx0Ly8gXHRcdH1cblx0Ly8gXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0Ly8gXHRcdHRoaXMuc2tpcFRyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcblx0Ly8gXHRcdC8vIHRoaXMuaW52YWxpZGF0ZUxheW91dCgpO1xuXHQvLyBcdFx0dGhpcy5yZW5kZXJOb3coKTtcblx0Ly8gXHR9XG5cdC8vIFx0cmV0dXJuIHRoaXM7XG5cdC8vIH0sXG5cblx0Ly8gcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdC8vIFx0dGhpcy5tZWFzdXJlTGF0ZXIoKTtcblx0Ly8gXHR0aGlzLnNjcm9sbEJ5KDAsIENhcm91c2VsLklNTUVESUFURSk7XG5cdC8vXG5cdC8vIFx0aWYgKHRoaXMuZWwucGFyZW50RWxlbWVudCkge1xuXHQvLyBcdFx0dGhpcy5yZW5kZXJOb3coKTtcblx0Ly8gXHR9XG5cdC8vIFx0cmV0dXJuIHRoaXM7XG5cdC8vIH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW5kZXJGcmFtZTogZnVuY3Rpb24odHN0YW1wLCBmbGFncykge1xuXHRcdGlmIChmbGFncyAmIFZpZXcuQ0hJTERSRU5fSU5WQUxJRCkge1xuXHRcdFx0dGhpcy5fY3JlYXRlQ2hpbGRyZW4oKTtcblx0XHRcdC8vIGNsZWFyIHRoaXMgZmxhZyBub3c6IHJlbmRlciBtYXkgYmUgZGVmZXJyZWQgdW50aWwgYXR0YWNoZWRcblx0XHRcdGZsYWdzICY9IH5WaWV3LkNISUxEUkVOX0lOVkFMSUQ7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmF0dGFjaGVkKSB7XG5cdFx0XHRpZiAoZmxhZ3MgJiBWaWV3LlNJWkVfSU5WQUxJRCkge1xuXHRcdFx0XHR0aGlzLl9tZWFzdXJlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmxhZ3MgJiAoVmlldy5MQVlPVVRfSU5WQUxJRCB8IFZpZXcuU0laRV9JTlZBTElEKSkge1xuXHRcdFx0XHR0aGlzLl9zY3JvbGxCeSh0aGlzLl9kZWx0YSwgdGhpcy5za2lwVHJhbnNpdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZmxhZ3MpIHtcblx0XHRcdHRoaXMubGlzdGVuVG9PbmNlKHRoaXMsIFwidmlldzphdHRhY2hlZFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKGZsYWdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBlbmFibGVkXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIC8qKiBAb3ZlcnJpZGUgKi9cblx0Ly8gX2VuYWJsZWQ6IHVuZGVmaW5lZCxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCAhPT0gZW5hYmxlZCkge1xuXHRcdFx0dGhpcy5fZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdFx0XHQvLyB0b2dnbGUgZXZlbnRzIGltbWVkaWF0ZWx5XG5cdFx0XHR0aGlzLl90b2dnbGVQb2ludGVyRXZlbnRzKGVuYWJsZWQpO1xuXHRcdFx0Ly8gZG9tIG1hbmlwdWxhdGlvbiBvbiByZW5kZXIgKF9yZW5kZXJFbmFibGVkKVxuXHRcdFx0Ly8gdGhpcy5fcmVuZGVyRmxhZ3MgfD0gVmlldy5TVFlMRVNfSU5WQUxJRDtcblx0XHRcdC8vIHRoaXMucmVxdWVzdFJlbmRlcigpO1xuXHRcdFx0dGhpcy5zZXRJbW1lZGlhdGUodGhpcy5fcmVuZGVyRW5hYmxlZCk7XG5cdFx0XHQvLyB0aGlzLl9yZW5kZXJFbmFibGVkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW5kZXJFbmFibGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhdGhpcy5lbmFibGVkKTtcblx0XHR0aGlzLml0ZW1WaWV3cy5lYWNoKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdHZpZXcuc2V0RW5hYmxlZCh0aGlzLmVuYWJsZWQpO1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIENyZWF0ZSBjaGlsZHJlblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfY3JlYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHZhciBzSW5kZXg7XG5cdFx0dmFyIGJ1ZmZlciwgcmVuZGVyZXIsIHZpZXcsIHZpZXdPcHRzO1xuXG5cdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXG5cdFx0aWYgKHRoaXMuY29sbGVjdGlvbi5sZW5ndGgpIHtcblx0XHRcdHZpZXdPcHRzID0ge1xuXHRcdFx0XHQvLyB2aWV3RGVwdGg6IHRoaXMudmlld0RlcHRoICsgMSxcblx0XHRcdFx0Ly8gcGFyZW50VmlldzogdGhpcyxcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5lbmFibGVkXG5cdFx0XHR9O1xuXHRcdFx0YnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0Ly8gYnVmZmVyID0gdGhpcy5lbDtcblxuXHRcdFx0aWYgKCF0aGlzLnJlcXVpcmVTZWxlY3Rpb24pIHtcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyRnVuY3Rpb24obnVsbCwgLTEsIHRoaXMuY29sbGVjdGlvbik7XG5cdFx0XHRcdHZpZXcgPSBuZXcgcmVuZGVyZXIodmlld09wdHMpO1xuXHRcdFx0XHR0aGlzLml0ZW1WaWV3cy5hZGQodmlldyk7XG5cdFx0XHRcdGJ1ZmZlci5hcHBlbmRDaGlsZCh2aWV3LmVsKTtcblx0XHRcdFx0dGhpcy5lbXB0eVZpZXcgPSB2aWV3O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCwgYXJyKSB7XG5cdFx0XHRcdHZpZXdPcHRzLm1vZGVsID0gaXRlbTtcblx0XHRcdFx0cmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyRnVuY3Rpb24oaXRlbSwgaW5kZXgsIGFycik7XG5cdFx0XHRcdHZpZXcgPSBuZXcgcmVuZGVyZXIodmlld09wdHMpO1xuXHRcdFx0XHR0aGlzLml0ZW1WaWV3cy5hZGQodmlldyk7XG5cdFx0XHRcdGJ1ZmZlci5hcHBlbmRDaGlsZCh2aWV3LmVsKTtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHQvLyBpZiAoIXRoaXMucmVxdWlyZVNlbGVjdGlvbikge1xuXHRcdFx0Ly8gXHRidWZmZXIgPSB0aGlzLmFwcGVuZEl0ZW1WaWV3KGJ1ZmZlciwgdGhpcy5tb2RlbCwgLTEsIHRoaXMuY29sbGVjdGlvbik7XG5cdFx0XHQvLyBcdHRoaXMuZW1wdHlWaWV3ID0gdGhpcy5pdGVtVmlld3MuZmlyc3QoKTtcblx0XHRcdC8vIH1cblx0XHRcdC8vIGJ1ZmZlciA9IHRoaXMuY29sbGVjdGlvbi5yZWR1Y2UodGhpcy5hcHBlbmRJdGVtVmlldywgYnVmZmVyLCB0aGlzKTtcblxuXHRcdFx0dGhpcy5hZGp1c3RUb1NlbGVjdGlvbigpO1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRWaWV3LmVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcblxuXHRcdFx0dGhpcy5lbC5hcHBlbmRDaGlsZChidWZmZXIpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBhcHBlbmRJdGVtVmlldzogZnVuY3Rpb24gKHBhcmVudEVsLCBtb2RlbCwgaW5kZXgsIGFycikge1xuXHQvLyBcdHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXJGdW5jdGlvbihtb2RlbCwgaW5kZXgsIGFycik7XG5cdC8vIFx0dmFyIHZpZXcgPSBuZXcgcmVuZGVyZXIoe1xuXHQvLyBcdFx0bW9kZWw6IG1vZGVsLFxuXHQvLyBcdFx0cGFyZW50VmlldzogdGhpcyxcblx0Ly8gXHRcdGVuYWJsZWQ6IHRoaXMuZW5hYmxlZFxuXHQvLyBcdH0pO1xuXHQvLyBcdHRoaXMuaXRlbVZpZXdzLmFkZCh2aWV3KTtcblx0Ly8gXHRwYXJlbnRFbC5hcHBlbmRDaGlsZCh2aWV3LmVsKTtcblx0Ly8gXHRyZXR1cm4gcGFyZW50RWw7XG5cdC8vIH0sXG5cblx0Ly8gY3JlYXRlSXRlbVZpZXc6IGZ1bmN0aW9uIChyZW5kZXJlciwgb3B0cykge1xuXHQvLyBcdHZhciB2aWV3ID0gbmV3IHJlbmRlcmVyKG9wdHMpO1xuXHQvLyBcdHRoaXMuaXRlbVZpZXdzLmFkZCh2aWV3KTtcblx0Ly8gXHRyZXR1cm4gdmlldztcblx0Ly8gfSxcblxuXHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pdGVtVmlld3MuZWFjaCh0aGlzLnJlbW92ZUl0ZW1WaWV3LCB0aGlzKTtcblx0XHR0aGlzLmVtcHR5VmlldyA9ICh2b2lkIDApO1xuXHR9LFxuXG5cdHJlbW92ZUl0ZW1WaWV3OiBmdW5jdGlvbih2aWV3KSB7XG5cdFx0dGhpcy5pdGVtVmlld3MucmVtb3ZlKHZpZXcpO1xuXHRcdHZpZXcucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIHZpZXc7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogbWVhc3VyZVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfbWVhc3VyZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG0sIG1tO1xuXHRcdHZhciBwb3MgPSAwLFxuXHRcdFx0cG9zSW5uZXIgPSAwO1xuXHRcdHZhciBtYXhBY3Jvc3MgPSAwLFxuXHRcdFx0bWF4T3V0ZXIgPSAwO1xuXHRcdHZhciBtYXhPdXRlclZpZXcsIG1heEFjcm9zc1ZpZXc7XG5cblx0XHRtYXhPdXRlclZpZXcgPSBtYXhBY3Jvc3NWaWV3ID0gdGhpcy5lbXB0eVZpZXcgfHwgdGhpcy5pdGVtVmlld3MuZmlyc3QoKTtcblxuXHRcdC8vIGNoaWRyZW4gbWV0cmljc1xuXHRcdHRoaXMuaXRlbVZpZXdzLmVhY2goZnVuY3Rpb24odmlldykge1xuXHRcdFx0dmlldy5yZW5kZXIoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuaXRlbVZpZXdzLmVhY2goZnVuY3Rpb24odmlldykge1xuXHRcdFx0bSA9IHRoaXMubWVhc3VyZUl0ZW1WaWV3KHZpZXcpO1xuXHRcdFx0bS5wb3MgPSBwb3M7XG5cdFx0XHRwb3MgKz0gbS5vdXRlcjsgLy8gKyB0aGlzLmNoaWxkR2FwO1xuXHRcdFx0bS5wb3NJbm5lciA9IHBvc0lubmVyO1xuXHRcdFx0cG9zSW5uZXIgKz0gbS5pbm5lcjsgLy8rIHRoaXMuY2hpbGRHYXA7XG5cdFx0XHRpZiAodmlldyAhPT0gdGhpcy5lbXB0eVZpZXcpIHtcblx0XHRcdFx0aWYgKG0uYWNyb3NzID4gbWF4QWNyb3NzKSB7XG5cdFx0XHRcdFx0bWF4QWNyb3NzID0gbS5hY3Jvc3M7XG5cdFx0XHRcdFx0bWF4QWNyb3NzVmlldyA9IHZpZXc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0ub3V0ZXIgPiBtYXhPdXRlcikge1xuXHRcdFx0XHRcdG1heE91dGVyID0gbS5vdXRlcjtcblx0XHRcdFx0XHRtYXhPdXRlclZpZXcgPSB2aWV3O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cblx0XHQvLyBtZWFzdXJlIHNlbGYgKyBtYXggY2hpbGQgbWV0cmljc1xuXHRcdG1tID0gdGhpcy5tZXRyaWNzW3RoaXMuY2lkXSB8fCAodGhpcy5tZXRyaWNzW3RoaXMuY2lkXSA9IHt9KTtcblx0XHRtbS5vdXRlciA9IHRoaXMuZWxbdGhpcy5kaXJQcm9wKFwib2Zmc2V0V2lkdGhcIiwgXCJvZmZzZXRIZWlnaHRcIildO1xuXHRcdG1tLmJlZm9yZSA9IG1heE91dGVyVmlldy5lbFt0aGlzLmRpclByb3AoXCJvZmZzZXRMZWZ0XCIsIFwib2Zmc2V0VG9wXCIpXTtcblx0XHRtbS5pbm5lciA9IG1heE91dGVyVmlldy5lbFt0aGlzLmRpclByb3AoXCJvZmZzZXRXaWR0aFwiLCBcIm9mZnNldEhlaWdodFwiKV07XG5cdFx0bW0uYWZ0ZXIgPSBtbS5vdXRlciAtIChtbS5pbm5lciArIG1tLmJlZm9yZSk7XG5cdFx0bW0uYWNyb3NzID0gbWF4QWNyb3NzO1xuXG5cdFx0Ly8gbSA9IHRoaXMubWV0cmljc1ttYXhPdXRlclZpZXcuY2lkXTtcblx0XHQvLyBtbS5pbm5lciA9IG0uaW5uZXI7XG5cblx0XHQvLyB0YXAgYXJlYVxuXHRcdHRoaXMuX3RhcEFjcm9zc0JlZm9yZSA9IG1heEFjcm9zc1ZpZXcuZWxbdGhpcy5kaXJQcm9wKFwib2Zmc2V0VG9wXCIsIFwib2Zmc2V0TGVmdFwiKV07XG5cdFx0dGhpcy5fdGFwQWNyb3NzQWZ0ZXIgPSB0aGlzLl90YXBBY3Jvc3NCZWZvcmUgKyBtYXhBY3Jvc3M7XG5cdFx0dGhpcy5fdGFwQmVmb3JlID0gbW0uYmVmb3JlICsgdGhpcy5fdGFwR3Jvdztcblx0XHR0aGlzLl90YXBBZnRlciA9IG1tLmJlZm9yZSArIG1tLmlubmVyIC0gdGhpcy5fdGFwR3JvdztcblxuXHRcdHRoaXMuc2VsZWN0VGhyZXNob2xkID0gTWF0aC5taW4oTUFYX1NFTEVDVF9USFJFU0hPTEQsIG1tLm91dGVyICogMC4xKTtcblx0fSxcblxuXHRtZWFzdXJlSXRlbVZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcblx0XHR2YXIgbSwgdmlld0VsO1xuXHRcdC8vIHZhciBzLCBzaXplRWw7XG5cblx0XHR2aWV3RWwgPSB2aWV3LmVsO1xuXHRcdG0gPSB0aGlzLm1ldHJpY3Nbdmlldy5jaWRdIHx8ICh0aGlzLm1ldHJpY3Nbdmlldy5jaWRdID0ge30pO1xuXG5cdFx0bS5vdXRlciA9IHZpZXdFbFt0aGlzLmRpclByb3AoXCJvZmZzZXRXaWR0aFwiLCBcIm9mZnNldEhlaWdodFwiKV07XG5cdFx0bS5hY3Jvc3MgPSB2aWV3RWxbdGhpcy5kaXJQcm9wKFwib2Zmc2V0SGVpZ2h0XCIsIFwib2Zmc2V0V2lkdGhcIildO1xuXG5cdFx0aWYgKHZpZXcubWV0cmljcykge1xuXHRcdFx0bS5iZWZvcmUgPSB2aWV3Lm1ldHJpY3NbdGhpcy5kaXJQcm9wKFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblRvcFwiKV07XG5cdFx0XHRtLm91dGVyICs9IG0uYmVmb3JlO1xuXHRcdFx0bS5vdXRlciArPSB2aWV3Lm1ldHJpY3NbdGhpcy5kaXJQcm9wKFwibWFyZ2luUmlnaHRcIiwgXCJtYXJnaW5Cb3R0b21cIildO1xuXHRcdFx0bS5pbm5lciA9IHZpZXcubWV0cmljcy5jb250ZW50W3RoaXMuZGlyUHJvcChcIndpZHRoXCIsIFwiaGVpZ2h0XCIpXTtcblx0XHRcdG0uYmVmb3JlICs9IHZpZXcubWV0cmljcy5jb250ZW50W3RoaXMuZGlyUHJvcChcInhcIiwgXCJ5XCIpXTtcblx0XHRcdG0uYWZ0ZXIgPSBtLm91dGVyIC0gKG0uaW5uZXIgKyBtLmJlZm9yZSk7XG5cblx0XHRcdC8vIHZhciBtYXJnaW5CZWZvcmUgPSB2aWV3Lm1ldHJpY3NbdGhpcy5kaXJQcm9wKFwibWFyZ2luTGVmdFwiLFwibWFyZ2luVG9wXCIpXTtcblx0XHRcdC8vIHZhciBtYXJnaW5BZnRlciA9IHZpZXcubWV0cmljc1t0aGlzLmRpclByb3AoXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luQm90dG9tXCIpXTtcblx0XHRcdC8vIHZhciBwb3MgPSB2aWV3Lm1ldHJpY3MuY29udGVudFt0aGlzLmRpclByb3AoXCJ4XCIsXCJ5XCIpXTtcblx0XHRcdC8vXG5cdFx0XHQvLyBtLmlubmVyID0gdmlldy5tZXRyaWNzLmNvbnRlbnRbdGhpcy5kaXJQcm9wKFwid2lkdGhcIixcImhlaWdodFwiKV07XG5cdFx0XHQvLyBtLmJlZm9yZSA9IG1hcmdpbkJlZm9yZSArIHBvcztcblx0XHRcdC8vIG0ub3V0ZXIgKz0gbWFyZ2luQmVmb3JlICsgbWFyZ2luQWZ0ZXI7XG5cdFx0XHQvLyBtLmFmdGVyID0gbS5vdXRlciAtIChtLmlubmVyICsgbS5iZWZvcmUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJlciBoYXMgbm8gbWV0cmljc1wiKTtcblx0XHRcdGNvbnNvbGUud2FybihcIiVzOjptZWFzdXJlSXRlbVZpZXcgdmlldyAnJXMnIGhhcyBubyBtZXRyaWNzXCIsIHRoaXMuY2lkLCB2aWV3LmNpZCk7XG5cdFx0XHRtLmlubmVyID0gbS5vdXRlcjtcblx0XHRcdG0uYWZ0ZXIgPSBtLmJlZm9yZSA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG07XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0Lyogc2Nyb2xsaW5nIHByb3BlcnR5XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9kZWx0YTogMCxcblxuXHRfc2Nyb2xsaW5nOiBmYWxzZSxcblxuXHRfc2V0U2Nyb2xsaW5nOiBmdW5jdGlvbihzY3JvbGxpbmcpIHtcblx0XHQvLyBjb25zb2xlLndhcm4oXCJfc2V0U2Nyb2xsaW5nIGN1cnJlbnQvcmVxdWVzdGVkXCIsIHRoaXMuX3Njcm9sbGluZywgc2Nyb2xsaW5nKTtcblx0XHRpZiAodGhpcy5fc2Nyb2xsaW5nICE9IHNjcm9sbGluZykge1xuXHRcdFx0dGhpcy5fc2Nyb2xsaW5nID0gc2Nyb2xsaW5nO1xuXHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwic2Nyb2xsaW5nXCIsIHNjcm9sbGluZyk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoc2Nyb2xsaW5nID8gXCJ2aWV3OnNjcm9sbHN0YXJ0XCIgOiBcInZpZXc6c2Nyb2xsZW5kXCIpO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBTY3JvbGwvbGF5b3V0XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbihkZWx0YSwgc2tpcFRyYW5zaXRpb25zKSB7XG5cdFx0dGhpcy5fZGVsdGEgPSBkZWx0YSB8fCAwO1xuXHRcdHRoaXMuc2tpcFRyYW5zaXRpb25zID0gISFza2lwVHJhbnNpdGlvbnM7XG5cdFx0Ly8gdGhpcy5pbnZhbGlkYXRlTGF5b3V0KCk7XG5cdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKFZpZXcuTEFZT1VUX0lOVkFMSUQpO1xuXHR9LFxuXG5cdF9zY3JvbGxCeTogZnVuY3Rpb24oZGVsdGEsIHNraXBUcmFuc2l0aW9ucykge1xuXHRcdHZhciBzTWV0cmljcywgbWV0cmljcywgcG9zO1xuXG5cdFx0c01ldHJpY3MgPSB0aGlzLm1ldHJpY3NbKHRoaXMuX3Njcm9sbENhbmRpZGF0ZVZpZXcgfHwgdGhpcy5fc2VsZWN0ZWRWaWV3KS5jaWRdO1xuXHRcdHRoaXMuaXRlbVZpZXdzLmVhY2goZnVuY3Rpb24odmlldykge1xuXHRcdFx0bWV0cmljcyA9IHRoaXMubWV0cmljc1t2aWV3LmNpZF07XG5cdFx0XHRwb3MgPSBNYXRoLmZsb29yKHRoaXMuX2dldFNjcm9sbE9mZnNldChkZWx0YSwgbWV0cmljcywgc01ldHJpY3MpKTtcblx0XHRcdHZpZXcubWV0cmljcy50cmFuc2xhdGVYID0gKHRoaXMuZGlyZWN0aW9uICYgSE9SSVpPTlRBTCkgPyBwb3MgOiAwO1xuXHRcdFx0dmlldy5tZXRyaWNzLnRyYW5zbGF0ZVkgPSAodGhpcy5kaXJlY3Rpb24gJiBIT1JJWk9OVEFMKSA/IDAgOiBwb3M7XG5cdFx0XHR2aWV3Lm1ldHJpY3MuX3RyYW5zZm9ybSA9IHRyYW5zbGF0ZVRlbXBsYXRlKHZpZXcubWV0cmljcy50cmFuc2xhdGVYLCB2aWV3Lm1ldHJpY3MudHJhbnNsYXRlWSk7XG5cdFx0XHR2aWV3LmVsLnN0eWxlW3RyYW5zZm9ybVByb3BlcnR5XSA9IHZpZXcubWV0cmljcy5fdHJhbnNmb3JtO1xuXHRcdFx0Ly8gdmlldy5lbC5zdHlsZVt0cmFuc2Zvcm1Qcm9wZXJ0eV0gPSAodGhpcy5kaXJlY3Rpb24gJiBIT1JJWk9OVEFMKT9cblx0XHRcdC8vIFx0XCJ0cmFuc2xhdGUzZChcIiArIHBvcyArIFwicHgsMCwwKVwiOlxuXHRcdFx0Ly8gXHRcInRyYW5zbGF0ZTNkKDAsXCIgKyBwb3MgKyBcInB4LDApXCI7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJza2lwLXRyYW5zaXRpb25zXCIsIHNraXBUcmFuc2l0aW9ucyk7XG5cdFx0dGhpcy5zZWxlY3RGcm9tVmlldygpO1xuXHR9LFxuXG5cdF9nZXRTY3JvbGxPZmZzZXQ6IGZ1bmN0aW9uKGRlbHRhLCBtQ3VyciwgbVNlbCkge1xuXHRcdHZhciBwb3MsIG9mZnNldCA9IDA7XG5cblx0XHRwb3MgPSBtQ3Vyci5wb3MgLSBtU2VsLnBvcyArIGRlbHRhO1xuXHRcdGlmIChwb3MgPCAwKSB7XG5cdFx0XHRpZiAoTWF0aC5hYnMocG9zKSA8IG1TZWwub3V0ZXIpIHtcblx0XHRcdFx0b2Zmc2V0ICs9ICgtbUN1cnIuYWZ0ZXIpIC8gbVNlbC5vdXRlciAqIHBvcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCArPSBtQ3Vyci5hZnRlcjtcblx0XHRcdH1cblx0XHR9IGVsc2Vcblx0XHRpZiAoMCA8PSBwb3MpIHtcblx0XHRcdGlmIChNYXRoLmFicyhwb3MpIDwgbVNlbC5vdXRlcikge1xuXHRcdFx0XHRvZmZzZXQgLT0gbUN1cnIuYmVmb3JlIC8gbVNlbC5vdXRlciAqIHBvcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCAtPSBtQ3Vyci5iZWZvcmU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwb3MgKyBvZmZzZXQ7XG5cdH0sXG5cblx0X29uU2Nyb2xsVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoZXYucHJvcGVydHlOYW1lID09PSB0cmFuc2Zvcm1TdHlsZU5hbWUgJiYgdGhpcy5zY3JvbGxpbmcpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9vblNjcm9sbFRyYW5zaXRpb25FbmQgc2VsZWN0ZWQ6ICVzXCIsIHRoaXMuY2lkLCBldi50YXJnZXQuY2lkKTtcblx0XHRcdHRoaXMuX3NldFNjcm9sbGluZyhmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHRvZ2dsZSB0b3VjaCBldmVudHNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X3RvZ2dsZVBvaW50ZXJFdmVudHM6IGZ1bmN0aW9uKGVuYWJsZSkge1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6Ol90b2dnbGVQb2ludGVyRXZlbnRzXCIsIHRoaXMuY2lkLCBlbmFibGUpO1xuXHRcdGlmICh0aGlzLl9wb2ludGVyRXZlbnRzRW5hYmxlZCA9PSBlbmFibGUpIHJldHVybjtcblxuXHRcdHRoaXMuX3BvaW50ZXJFdmVudHNFbmFibGVkID0gZW5hYmxlO1xuXHRcdGlmIChlbmFibGUpIHtcblx0XHRcdHRoaXMudG91Y2gub24oXCJocGFuc3RhcnQgaHBhbm1vdmUgaHBhbmVuZCBocGFuY2FuY2VsXCIsIHRoaXMuX29uUG9pbnRlckV2ZW50KTtcblx0XHRcdHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihWaWV3LkNMSUNLX0VWRU5ULCB0aGlzLl9vbkNsaWNrLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50b3VjaC5vZmYoXCJocGFuc3RhcnQgaHBhbm1vdmUgaHBhbmVuZCBocGFuY2FuY2VsXCIsIHRoaXMuX29uUG9pbnRlckV2ZW50KTtcblx0XHRcdHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihWaWV3LkNMSUNLX0VWRU5ULCB0aGlzLl9vbkNsaWNrLCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uUG9pbnRlckV2ZW50OiBmdW5jdGlvbihldikge1xuXHRcdC8vIE5PVEU6IGh0dHBzOi8vZ2l0aHViLmNvbS9oYW1tZXJqcy9oYW1tZXIuanMvcHVsbC8xMTE4XG5cdFx0aWYgKGV2LnNyY0V2ZW50LnR5cGUgPT09ICdwb2ludGVyY2FuY2VsJylcblx0XHRcdHJldHVybjtcblxuXHRcdGNvbnNvbGUubG9nKFwiJXM6WyVzICglcyldOl9vblBvaW50ZXJFdmVudCBvZmZzOiVzIFslc3wlcz09JXNdIFslc11cIiwgdGhpcy5jaWQsIGV2LnR5cGUsIGV2LnNyY0V2ZW50LnR5cGUsXG5cdFx0XHRkaXJUb1N0cihldi5vZmZzZXREaXJlY3Rpb24pLFxuXHRcdFx0ZGlyVG9TdHIoZXYuZGlyZWN0aW9uKSxcblx0XHRcdGRpclRvU3RyKHRoaXMuZGlyZWN0aW9uKSxcblx0XHRcdGRpclRvU3RyKGV2LmRpcmVjdGlvbiB8IHRoaXMuZGlyZWN0aW9uKSxcblx0XHRcdChldi5zcmNFdmVudC5kZWZhdWx0UHJldmVudGVkID8gXCJwcmV2ZW50ZWRcIiA6IFwiLVwiKSk7XG5cblx0XHQvLyBpZiAoZXYuZGlyZWN0aW9uICYgdGhpcy5kaXJlY3Rpb24pIHtcblx0XHRzd2l0Y2ggKGV2LnR5cGUpIHtcblx0XHRcdC8vIGNhc2UgVmlldy5DTElDS19FVkVOVDpcblx0XHRcdC8vIFx0cmV0dXJuIHRoaXMuX29uQ2xpY2soZXYpO1xuXHRcdFx0Ly8gY2FzZSBcInRhcFwiOlxuXHRcdFx0Ly8gXHRyZXR1cm4gdGhpcy5fb25UYXAoZXYpO1xuXHRcdFx0Y2FzZSBcImhwYW5zdGFydFwiOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb25QYW5TdGFydChldik7XG5cdFx0XHRjYXNlIFwiaHBhbm1vdmVcIjpcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29uUGFuTW92ZShldik7XG5cdFx0XHRjYXNlIFwiaHBhbmVuZFwiOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb25QYW5GaW5hbChldik7XG5cdFx0XHRjYXNlIFwiaHBhbmNhbmNlbFwiOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb25QYW5GaW5hbChldik7XG5cdFx0fVxuXHRcdC8vIH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiB0b3VjaCBldmVudDogcGFuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGdldFZpZXdBdFBhbkRpcjogZnVuY3Rpb24oZGlyKSB7XG5cdFx0Ly8gcmV0dXJuIChkaXIgJiB0aGlzLl9wcmVjZWRpbmdEaXIpID8gdGhpcy5fcHJlY2VkaW5nVmlldyA6IHRoaXMuX2ZvbGxvd2luZ1ZpZXc7XG5cdFx0cmV0dXJuIChkaXIgJiB0aGlzLl9mb2xsb3dpbmdEaXIpID8gdGhpcy5fcHJlY2VkaW5nVmlldyA6IHRoaXMuX2ZvbGxvd2luZ1ZpZXc7XG5cdH0sXG5cblx0Ly8gX3BhbkNhcHR1cmVkT2Zmc2V0OiAwLFxuXG5cdC8qKiBAcGFyYW0ge09iamVjdH0gZXYgKi9cblx0X29uUGFuU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy5zZWxlY3RGcm9tVmlldygpO1xuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcInBhbm5pbmdcIik7XG5cdFx0dGhpcy5fc2V0U2Nyb2xsaW5nKHRydWUpO1xuXHR9LFxuXG5cdC8qKiBAcGFyYW0ge09iamVjdH0gZXYgKi9cblx0X29uUGFuTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyB2YXIgZGVsdGEgPSAodGhpcy5kaXJlY3Rpb24gJiBIT1JJWk9OVEFMKSA/IGV2LnRocmVzaG9sZERlbHRhWCA6IGV2LnRocmVzaG9sZERlbHRhWTtcblx0XHR2YXIgZGVsdGEgPSAodGhpcy5kaXJlY3Rpb24gJiBIT1JJWk9OVEFMKSA/IGV2LmRlbHRhWCA6IGV2LmRlbHRhWTtcblx0XHR2YXIgdmlldyA9IHRoaXMuZ2V0Vmlld0F0UGFuRGlyKGV2Lm9mZnNldERpcmVjdGlvbik7XG5cdFx0dmFyIGNWaWV3ID0gdGhpcy5fcGFuQ2FuZGlkYXRlVmlldztcblxuXHRcdGlmIChjVmlldyAhPT0gdmlldykge1xuXHRcdFx0Y1ZpZXcgJiYgY1ZpZXcuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNhbmRpZGF0ZVwiKTtcblx0XHRcdHZpZXcgJiYgdmlldy5lbC5jbGFzc0xpc3QuYWRkKFwiY2FuZGlkYXRlXCIpO1xuXHRcdFx0dGhpcy5fcGFuQ2FuZGlkYXRlVmlldyA9IHZpZXc7XG5cdFx0fVxuXHRcdGlmIChjVmlldyA9PT0gKHZvaWQgMCkpIHtcblx0XHRcdGRlbHRhICo9IEdsb2JhbHMuSFBBTl9PVVRfRFJBRztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcmVuZGVyUmFmSWQgIT09IC0xKSB7XG5cdFx0XHR0aGlzLnNjcm9sbEJ5KGRlbHRhLCBDYXJvdXNlbC5JTU1FRElBVEUpO1xuXHRcdFx0dGhpcy5yZW5kZXJOb3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc2Nyb2xsQnkoZGVsdGEsIENhcm91c2VsLklNTUVESUFURSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBAcGFyYW0ge09iamVjdH0gZXYgKi9cblx0X29uUGFuRmluYWw6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHNjcm9sbENhbmRpZGF0ZTtcblx0XHQvLyBOT1RFOiB0aGlzIGRlbHRhIGlzIHVzZWQgZm9yIGRldGVybWluaW5nIHNlbGVjdGlvbiwgTk9UIGZvciBsYXlvdXRcblx0XHQvLyB2YXIgZGVsdGEgPSAodGhpcy5kaXJlY3Rpb24gJiBIT1JJWk9OVEFMKSA/IGV2LnRocmVzaG9sZERlbHRhWCA6IGV2LnRocmVzaG9sZERlbHRhWTtcblx0XHR2YXIgZGVsdGEgPSAodGhpcy5kaXJlY3Rpb24gJiBIT1JJWk9OVEFMKSA/IGV2LmRlbHRhWCA6IGV2LmRlbHRhWTtcblxuXHRcdGlmICgoZXYudHlwZSA9PSBcImhwYW5lbmRcIilcblx0XHRcdC8qIHBhbiBkaXJlY3Rpb24gKGN1cnJlbnQgZXZlbnQpIGFuZCBvZmZzZXREaXJlY3Rpb24gKHdob2xlIGdlc3R1cmUpIG11c3QgbWF0Y2ggKi9cblx0XHRcdCYmIChldi5kaXJlY3Rpb24gXiBldi5vZmZzZXREaXJlY3Rpb24gXiB0aGlzLmRpcmVjdGlvbilcblx0XHRcdC8vICYmIChldi5kaXJlY3Rpb24gJiBldi5vZmZzZXREaXJlY3Rpb24gJiB0aGlzLmRpcmVjdGlvbilcblx0XHRcdC8qIGdlc3R1cmUgbXVzdCBvdmVyc2hvb3Qgc2VsZWN0VGhyZXNob2xkICovXG5cdFx0XHQmJiAoTWF0aC5hYnMoZGVsdGEpID4gdGhpcy5zZWxlY3RUaHJlc2hvbGQpKSB7XG5cdFx0XHQvKiBjaG9vc2UgbmV4dCBzY3JvbGwgdGFyZ2V0ICovXG5cdFx0XHRzY3JvbGxDYW5kaWRhdGUgPSB0aGlzLmdldFZpZXdBdFBhbkRpcihldi5vZmZzZXREaXJlY3Rpb24pO1xuXHRcdH1cblx0XHR0aGlzLl9zY3JvbGxDYW5kaWRhdGVWaWV3ID0gc2Nyb2xsQ2FuZGlkYXRlIHx8ICh2b2lkIDApO1xuXG5cdFx0aWYgKHRoaXMuX3BhbkNhbmRpZGF0ZVZpZXcgJiYgKHRoaXMuX3BhbkNhbmRpZGF0ZVZpZXcgIT09IHNjcm9sbENhbmRpZGF0ZSkpIHtcblx0XHRcdHRoaXMuX3BhbkNhbmRpZGF0ZVZpZXcuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNhbmRpZGF0ZVwiKTtcblx0XHR9XG5cdFx0dGhpcy5fcGFuQ2FuZGlkYXRlVmlldyA9ICh2b2lkIDApO1xuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInBhbm5pbmdcIik7XG5cblx0XHRjb25zb2xlLmxvZyhcIiVzOlslc106X29uUGFuRmluYWwgdGhyZXM6KCVzPiVzKSBkaXI6KGU6JXMgbzolcyBjOiVzKT0lc1xcblwiLCB0aGlzLmNpZCwgZXYudHlwZSxcblx0XHRcdE1hdGguYWJzKGRlbHRhKSwgdGhpcy5zZWxlY3RUaHJlc2hvbGQsXG5cdFx0XHRkaXJUb1N0cihldi5kaXJlY3Rpb24pLFxuXHRcdFx0ZGlyVG9TdHIoZXYub2Zmc2V0RGlyZWN0aW9uKSxcblx0XHRcdGRpclRvU3RyKHRoaXMuZGlyZWN0aW9uKSxcblx0XHRcdGRpclRvU3RyKGV2LmRpcmVjdGlvbiBeIGV2Lm9mZnNldERpcmVjdGlvbiBeIHRoaXMuZGlyZWN0aW9uKSxcblx0XHRcdHNjcm9sbENhbmRpZGF0ZSA/IChzY3JvbGxDYW5kaWRhdGUuY2lkICsgXCI6XCIgKyBzY3JvbGxDYW5kaWRhdGUubW9kZWwuY2lkKSA6IFwibm9uZVwiKTtcblx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjpfb25QYW5GaW5hbFwiLCB0aGlzLmNpZCwgZXYpO1xuXG5cdFx0dGhpcy5zY3JvbGxCeSgwLCBDYXJvdXNlbC5BTklNQVRFRCk7XG5cdFx0dGhpcy5zZWxlY3RGcm9tVmlldygpO1xuXG5cdFx0Ly8gaWYgKHRoaXMuX3JlbmRlclJhZklkICE9PSAtMSkge1xuXHRcdC8vIFx0dGhpcy5zY3JvbGxCeSgwLCBDYXJvdXNlbC5BTklNQVRFRCk7XG5cdFx0Ly8gXHR0aGlzLnJlbmRlck5vdygpO1xuXHRcdC8vIH0gZWxzZSB7XG5cdFx0Ly8gXHR0aGlzLl9zY3JvbGxCeSgwLCBDYXJvdXNlbC5BTklNQVRFRCk7XG5cdFx0Ly8gfVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHRvdWNoIGV2ZW50OiB0YXBcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEB0eXBlIHtpbnR9IEluIHBpeGVscyAqL1xuXHRfdGFwR3JvdzogMTAsXG5cblx0Z2V0Vmlld0F0VGFwUG9zOiBmdW5jdGlvbihwb3NBbG9uZywgcG9zQWNyb3NzKSB7XG5cdFx0aWYgKCh0aGlzLl90YXBBY3Jvc3NCZWZvcmUgPCBwb3NBY3Jvc3MpICYmIChwb3NBY3Jvc3MgPCB0aGlzLl90YXBBY3Jvc3NBZnRlcikpIHtcblx0XHRcdGlmIChwb3NBbG9uZyA8IHRoaXMuX3RhcEJlZm9yZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcHJlY2VkaW5nVmlldztcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYgKHBvc0Fsb25nID4gdGhpcy5fdGFwQWZ0ZXIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2ZvbGxvd2luZ1ZpZXc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAodm9pZCAwKTtcblx0fSxcblxuXHRfb25DbGljazogZnVuY3Rpb24oZXYpIHtcblx0XHRjb25zb2xlLmxvZyhcIiVzOjpfb25DbGljayBbJXNdXCIsIHRoaXMuY2lkLCBldi50eXBlLCBldi5kZWZhdWx0UHJldmVudGVkID8gXCJwcmV2ZW50ZWRcIiA6IFwibm90LXByZXZlbnRlZFwiKTtcblx0XHR0aGlzLl9vblRhcChldik7XG5cdH0sXG5cblx0X29uVGFwOiBmdW5jdGlvbihldikge1xuXHRcdGlmIChldi5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cblx0XHR2YXIgdGFwQ2FuZGlkYXRlO1xuXHRcdHZhciB0YXJnZXRWaWV3ID0gVmlldy5maW5kQnlEZXNjZW5kYW50KGV2LnRhcmdldCk7XG5cdFx0Ly8gY29uc29sZS5sb2coXCIlczo6X29uVGFwICVvXCIsIHRoaXMuY2lkLCB0YXJnZXRWaWV3LmNpZCwgZXYudGFyZ2V0KTtcblx0XHQvLyBpZiAoIXRoaXMuaXRlbVZpZXdzLmNvbnRhaW5zKHRhcmdldFZpZXcpKSB7XG5cdFx0Ly8gXHRyZXR1cm47XG5cdFx0Ly8gfVxuXHRcdGRvIHtcblx0XHRcdGlmICh0aGlzLl9zZWxlY3RlZFZpZXcgPT09IHRhcmdldFZpZXcpIHtcblx0XHRcdFx0dGFwQ2FuZGlkYXRlID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldFZpZXcucGFyZW50Vmlldykge1xuXHRcdFx0XHR0YXBDYW5kaWRhdGUgPSB0YXJnZXRWaWV3O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0Vmlldykge1xuXHRcdFx0XHR2YXIgYm91bmRzLCB0YXBYLCB0YXBZO1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHR0YXBYID0gKGV2LnR5cGUgPT09IFwidGFwXCIgPyBldi5jZW50ZXIueCA6IGV2LmNsaWVudFgpIC0gYm91bmRzLmxlZnQ7XG5cdFx0XHRcdHRhcFkgPSAoZXYudHlwZSA9PT0gXCJ0YXBcIiA/IGV2LmNlbnRlci55IDogZXYuY2xpZW50WSkgLSBib3VuZHMudG9wO1xuXHRcdFx0XHR0YXBDYW5kaWRhdGUgPSB0aGlzLmdldFZpZXdBdFRhcFBvcyhcblx0XHRcdFx0XHR0aGlzLmRpclByb3AodGFwWCwgdGFwWSksXG5cdFx0XHRcdFx0dGhpcy5kaXJQcm9wKHRhcFksIHRhcFgpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCh0YXJnZXRWaWV3ID0gdGFyZ2V0Vmlldy5wYXJlbnRWaWV3KSlcblxuXHRcdGlmICh0YXBDYW5kaWRhdGUpIHtcblx0XHRcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHQvLyBldi5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0Ly8gdGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldyA9IHRhcENhbmRpZGF0ZTtcblx0XHRcdC8vIHRoaXMuX3NldFNjcm9sbGluZyh0cnVlKTtcblx0XHRcdC8vIHRoaXMuc2Nyb2xsQnkoMCwgQ2Fyb3VzZWwuQU5JTUFURUQpO1xuXHRcdFx0Ly8gdGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldy5lbC5jbGFzc0xpc3QuYWRkKFwiY2FuZGlkYXRlXCIpO1xuXHRcdFx0Ly8gdGhpcy5zZWxlY3RGcm9tVmlldygpO1xuXG5cdFx0XHQvLy8vIE5PVCB1c2luZyBpbnRlcm5hbFNlbGVjdGlvblxuXHRcdFx0Ly8gdGhpcy50cmlnZ2VyU2VsZWN0aW9uRXZlbnRzKHRhcENhbmRpZGF0ZSwgZmFsc2UpO1xuXG5cdFx0XHQvLyB1c2luZyBpbnRlcm5hbFNlbGVjdGlvblxuXHRcdFx0dGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldyA9IHRhcENhbmRpZGF0ZTtcblx0XHRcdHRoaXMuX3NldFNjcm9sbGluZyh0cnVlKTtcblx0XHRcdHRoaXMuc2Nyb2xsQnkoMCwgQ2Fyb3VzZWwuQU5JTUFURUQpO1xuXG5cdFx0XHR0aGlzLnRyaWdnZXJTZWxlY3Rpb25FdmVudHModGFwQ2FuZGlkYXRlLCB0cnVlKTtcblx0XHRcdC8vIHRoaXMucmVuZGVyTm93KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIFByaXZhdGVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0dHJpZ2dlclNlbGVjdGlvbkV2ZW50czogZnVuY3Rpb24odmlldywgaW50ZXJuYWwpIHtcblx0XHRpZiAodmlldyA9PT0gKHZvaWQgMCkgfHwgdGhpcy5faW50ZXJuYWxTZWxlY3Rpb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pbnRlcm5hbFNlbGVjdGlvbiA9ICEhaW50ZXJuYWw7XG5cdFx0aWYgKHZpZXcgPT09IHRoaXMuZW1wdHlWaWV3KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OnNlbGVjdDpub25lXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OnNlbGVjdDpvbmVcIiwgdmlldy5tb2RlbCk7XG5cdFx0fVxuXHRcdHRoaXMuX2ludGVybmFsU2VsZWN0aW9uID0gZmFsc2U7XG5cdH0sXG5cblx0c2VsZWN0RnJvbVZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9zY3JvbGxDYW5kaWRhdGVWaWV3KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXJTZWxlY3Rpb25FdmVudHModGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldywgdHJ1ZSk7XG5cdFx0fVxuXHRcdC8vIGlmICh0aGlzLl9zY3JvbGxDYW5kaWRhdGVWaWV3ID09PSAodm9pZCAwKSkge1xuXHRcdC8vIFx0cmV0dXJuO1xuXHRcdC8vIH1cblx0XHQvLyB2YXIgdmlldyA9IHRoaXMuX3Njcm9sbENhbmRpZGF0ZVZpZXc7XG5cdFx0Ly8gdGhpcy50cmlnZ2VyU2VsZWN0aW9uRXZlbnRzKHZpZXcsIHRydWUpO1xuXHR9LFxuXG5cdGFkanVzdFRvU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbSwgaSA9IHRoaXMuY29sbGVjdGlvbi5zZWxlY3RlZEluZGV4O1xuXHRcdC8vIGFzc3VtZSAtMSA8IGluZGV4IDwgdGhpcy5jb2xsZWN0aW9uLmxlbmd0aFxuXHRcdGlmICh0aGlzLnJlcXVpcmVTZWxlY3Rpb24pIHtcblx0XHRcdChpID09IC0xKSAmJiBpKys7IC8vIGlmIHNlbGVjdGlvbiBpcyBudWxsIChpbmRleCAtMSksIHNldCBfc2VsZWN0ZWRWaWV3IHRvIGZpcnN0IGl0ZW0gKGluZGV4IDApXG5cdFx0XHR0aGlzLl9zZWxlY3RlZFZpZXcgPSAobSA9IHRoaXMuY29sbGVjdGlvbi5hdChpKSkgJiYgdGhpcy5pdGVtVmlld3MuZmluZEJ5TW9kZWwobSk7XG5cdFx0XHR0aGlzLl9wcmVjZWRpbmdWaWV3ID0gKG0gPSB0aGlzLmNvbGxlY3Rpb24uYXQoaSAtIDEpKSAmJiB0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChtKTtcblx0XHRcdHRoaXMuX2ZvbGxvd2luZ1ZpZXcgPSAobSA9IHRoaXMuY29sbGVjdGlvbi5hdChpICsgMSkpICYmIHRoaXMuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKG0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZFZpZXcgPSAobSA9IHRoaXMuY29sbGVjdGlvbi5hdChpKSkgPyB0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChtKSA6IHRoaXMuZW1wdHlWaWV3O1xuXHRcdFx0dGhpcy5fcHJlY2VkaW5nVmlldyA9IG0gJiYgKChtID0gdGhpcy5jb2xsZWN0aW9uLmF0KGkgLSAxKSkgPyB0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChtKSA6IHRoaXMuZW1wdHlWaWV3KTtcblx0XHRcdHRoaXMuX2ZvbGxvd2luZ1ZpZXcgPSAobSA9IHRoaXMuY29sbGVjdGlvbi5hdChpICsgMSkpICYmIHRoaXMuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKG0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBNb2RlbCBsaXN0ZW5lcnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBwcml2YXRlICovXG5cdF9vblNlbGVjdE9uZTogZnVuY3Rpb24obW9kZWwpIHtcblx0XHRpZiAobW9kZWwgPT09IHRoaXMuX3NlbGVjdGVkVmlldy5tb2RlbCkge1xuXHRcdFx0Ly8gY29uc29sZS5pbmZvKFwiSU5URVJOQUxcIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX29uU2VsZWN0QW55KG1vZGVsKTtcblx0fSxcblxuXHQvKiogQHByaXZhdGUgKi9cblx0X29uU2VsZWN0Tm9uZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCh0aGlzLnJlcXVpcmVTZWxlY3Rpb24gPyB0aGlzLml0ZW1WaWV3cy5maXJzdCgpIDogdGhpcy5lbXB0eVZpZXcpID09PSB0aGlzLl9zZWxlY3RlZFZpZXcpIHtcblx0XHRcdC8vIGNvbnNvbGUuaW5mbyhcIklOVEVSTkFMXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9vblNlbGVjdEFueSgpO1xuXHR9LFxuXG5cdC8qKiBAcHJpdmF0ZSAqL1xuXHRfb25TZWxlY3RBbnk6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdFx0dGhpcy5fc2VsZWN0ZWRWaWV3LmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcblx0XHR0aGlzLmFkanVzdFRvU2VsZWN0aW9uKCk7XG5cdFx0dGhpcy5fc2VsZWN0ZWRWaWV3LmVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcblx0XHRpZiAodGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldykge1xuXHRcdFx0dGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiY2FuZGlkYXRlXCIpO1xuXHRcdFx0dGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldyA9ICh2b2lkIDApO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5faW50ZXJuYWxTZWxlY3Rpb24pIHtcblx0XHRcdHRoaXMuX3NldFNjcm9sbGluZyh0cnVlKTtcblx0XHRcdHRoaXMuc2Nyb2xsQnkoMCwgQ2Fyb3VzZWwuQU5JTUFURUQpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBfb25EZXNlbGVjdEFueTogZnVuY3Rpb24gKG1vZGVsKSB7fSxcblxuXHQvKiogQHByaXZhdGUgKi9cblx0X29uUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHRoaXMuX2NyZWF0ZUNoaWxkcmVuKCk7XG5cdFx0Ly8gdGhpcy5pbnZhbGlkYXRlQ2hpbGRyZW4oKTtcblx0XHR0aGlzLnJlcXVlc3RSZW5kZXIoVmlldy5DSElMRFJFTl9JTlZBTElEIHwgVmlldy5NT0RFTF9JTlZBTElEKTtcblx0fSxcblxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIFRFTVBcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gX3Njcm9sbEJ5MjogZnVuY3Rpb24gKGRlbHRhLCBza2lwVHJhbnNpdGlvbnMpIHtcblx0Ly8gXHR2YXIgbWV0cmljcywgcG9zO1xuXHQvLyBcdHZhciBzTWV0cmljcyA9IHRoaXMubWV0cmljc1sodGhpcy5fc2Nyb2xsQ2FuZGlkYXRlVmlldyB8fCB0aGlzLl9zZWxlY3RlZFZpZXcpLmNpZF07XG5cdC8vIFx0dmFyIGNNZXRyaWNzID0gdGhpcy5tZXRyaWNzWyh0aGlzLl9wYW5DYW5kaWRhdGVWaWV3IHx8IHRoaXMuX3NlbGVjdGVkVmlldykuY2lkXTtcblx0Ly9cblx0Ly8gXHR0aGlzLml0ZW1WaWV3cy5lYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG5cdC8vIFx0XHRtZXRyaWNzID0gdGhpcy5tZXRyaWNzW3ZpZXcuY2lkXTtcblx0Ly8gXHRcdHBvcyA9IE1hdGguZmxvb3IodGhpcy5fZ2V0U2Nyb2xsT2Zmc2V0KGRlbHRhLCBtZXRyaWNzLCBzTWV0cmljcywgY01ldHJpY3MpKTtcblx0Ly8gXHRcdHZpZXcuZWwuc3R5bGVbdHJhbnNmb3JtUHJvcGVydHldID0gKHRoaXMuZGlyZWN0aW9uICYgSE9SSVpPTlRBTCk/XG5cdC8vIFx0XHRcdFx0XCJ0cmFuc2xhdGUzZChcIiArIHBvcyArIFwicHgsMCwwKVwiIDogXCJ0cmFuc2xhdGUzZCgwLFwiICsgcG9zICsgXCJweCwwKVwiO1xuXHQvLyBcdFx0XHRcdC8vIFwidHJhbnNsYXRlKFwiICsgcG9zICsgXCJweCwwKVwiIDogXCJ0cmFuc2xhdGUoMCxcIiArIHBvcyArIFwicHgpXCI7XG5cdC8vIFx0XHRcdFx0Ly8gXCJ0cmFuc2xhdGVYKFwiICsgcG9zICsgXCJweClcIiA6IFwidHJhbnNsYXRlWShcIiArIHBvcyArIFwicHgpXCI7XG5cdC8vIFx0fSwgdGhpcyk7XG5cdC8vIFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwic2tpcC10cmFuc2l0aW9uc1wiLCBza2lwVHJhbnNpdGlvbnMpO1xuXHQvLyBcdHRoaXMuc2VsZWN0RnJvbVZpZXcoKTtcblx0Ly8gfSxcblxuXHQvLyBfZ2V0U2Nyb2xsT2Zmc2V0MjogZnVuY3Rpb24gKGRlbHRhLCBtQ3VyciwgbVNlbCwgbUNhbikge1xuXHQvLyBcdHZhciBvZmZzZXQgPSAwO1xuXHQvLyBcdHZhciBwb3NJbm5lciA9IG1DdXJyLnBvc0lubmVyIC0gbVNlbC5wb3NJbm5lciArIGRlbHRhO1xuXHQvL1xuXHQvLyBcdGlmIChwb3NJbm5lciA8IC1tU2VsLmlubmVyKSB7XG5cdC8vIFx0XHRvZmZzZXQgPSAtKG1DdXJyLmJlZm9yZSk7XG5cdC8vIFx0fSBlbHNlIGlmIChwb3NJbm5lciA+IG1TZWwuaW5uZXIpIHtcblx0Ly8gXHRcdG9mZnNldCA9IChtU2VsLmFmdGVyKTtcblx0Ly8gXHR9IGVsc2Uge1xuXHQvLyBcdFx0aWYgKHBvc0lubmVyIDwgMCkge1xuXHQvLyBcdFx0XHRvZmZzZXQgPSAobUN1cnIuYmVmb3JlKSAvIChtQ3Vyci5pbm5lcikgKiBwb3NJbm5lcjtcblx0Ly8gXHRcdH0gZWxzZSB7XG5cdC8vIFx0XHRcdG9mZnNldCA9IChtU2VsLmFmdGVyKSAvIChtQ2FuLmlubmVyKSAqIHBvc0lubmVyO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gXHRyZXR1cm4gcG9zSW5uZXIgKyBvZmZzZXQ7XG5cdC8vIH0sXG5cblx0Ly8gY2FwdHVyZVNlbGVjdGVkT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0Ly8gXHR2YXIgdmFsLCB2aWV3LCBjc3N2YWwsIG0sIG1tO1xuXHQvL1xuXHQvLyBcdHZhbCA9IDA7XG5cdC8vIFx0dmlldyA9IHRoaXMuX3Njcm9sbENhbmRpZGF0ZVZpZXcgfHwgdGhpcy5fc2VsZWN0ZWRWaWV3O1xuXHQvLyBcdGNzc3ZhbCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5lbClbdHJhbnNmb3JtUHJvcGVydHldO1xuXHQvL1xuXHQvLyBcdG1tID0gY3NzdmFsLm1hdGNoKC8obWF0cml4fG1hdHJpeDNkKVxcKChbXlxcKV0rKVxcKS8pO1xuXHQvLyBcdGlmIChtbSkge1xuXHQvLyBcdFx0bSA9IG1tWzJdLnNwbGl0KFwiLFwiKTtcblx0Ly8gXHRcdGlmICh0aGlzLmRpcmVjdGlvbiAmIEhPUklaT05UQUwpIHtcblx0Ly8gXHRcdFx0dmFsID0gbVttbVsxXT09XCJtYXRyaXhcIj8gNCA6IDEyXTtcblx0Ly8gXHRcdH0gZWxzZSB7XG5cdC8vIFx0XHRcdHZhbCA9IG1bbW1bMV09PVwibWF0cml4XCI/IDUgOiAxM107XG5cdC8vIFx0XHR9XG5cdC8vIFx0XHR2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG5cdC8vIFx0fVxuXHQvL1xuXHQvLyBcdGNvbnNvbGUubG9nKFwiJXM6OmNhcHR1cmVTZWxlY3RlZE9mZnNldFwiLCB0aGlzLmNpZCwgY3NzdmFsLCB2YWwsIGNzc3ZhbC5tYXRjaCgvbWF0cml4XFwoKD86XFxkXFwsKXszfShcXGQpXFwsKFxcZCl8bWF0cml4M2RcXCgoPzpcXGRcXCwpezExfShcXGQpXFwsKFxcZCkvKSk7XG5cdC8vXG5cdC8vIFx0cmV0dXJuIHZhbDtcblx0Ly8gfSxcblxuXHQvLyBfb25TY3JvbGxFbmQ6IGZ1bmN0aW9uKGV4ZWMpIHtcblx0Ly8gXHR0aGlzLl9zY3JvbGxFbmRDYW5jZWxsYWJsZSA9ICh2b2lkIDApO1xuXHQvLyBcdC8vIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImRpc2FibGVkLWNoYW5naW5nXCIpO1xuXHQvLyBcdGlmIChleGVjKSB7XG5cdC8vIFx0XHR0aGlzLl9zZXRTY3JvbGxpbmcoZmFsc2UpO1xuXHQvLyBcdFx0Ly8gdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwic2Nyb2xsaW5nXCIpO1xuXHQvLyBcdFx0Ly8gdGhpcy50cmlnZ2VyKFwidmlldzpzY3JvbGxlbmRcIik7XG5cdC8vIFx0XHRjb25zb2xlLmxvZyhcIiVzOjpfb25TY3JvbGxFbmRcIiwgdGhpcy5jaWQpO1xuXHQvLyBcdH1cblx0Ly8gfSxcblx0Ly8gX29uTW91c2VEb3duOiBmdW5jdGlvbihldikge1xuXHQvLyBcdGlmICh0aGlzLl9zY3JvbGxpbmcpIHtcblx0Ly8gXHRcdHRoaXMuX3BhbkNhcHR1cmVkT2Zmc2V0ID0gdGhpcy5jYXB0dXJlU2VsZWN0ZWRPZmZzZXQoKTtcblx0Ly8gXHRcdGNvbnNvbGUubG9nKFwiJXM6OmV2ZW50c1ttb3VzZWRvd25dIHNjcm9sbGluZyBpbnRlcnJ1cHRlZCAocG9zICVmKVwiLCB0aGlzLmNpZCwgdGhpcy5fcGFuQ2FwdHVyZWRPZmZzZXQpO1xuXHQvLyBcdH1cblx0Ly8gfSxcblx0Ly8gX29uTW91c2VVcDpmdW5jdGlvbihldikge1xuXHQvLyBcdHRoaXMuX3BhbkNhcHR1cmVkT2Zmc2V0ID0gMDtcblx0Ly8gfSxcblxufTtcblxuaWYgKERFQlVHKSB7XG5cdENhcm91c2VsUHJvdG8uX2xvZ0ZsYWdzID0gXCJcIjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYXJvdXNlbCA9IFZpZXcuZXh0ZW5kKENhcm91c2VsUHJvdG8sIENhcm91c2VsKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXI7XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlcnMuaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSkse1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSk7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L2NvbXBvbmVudC9Db2xsZWN0aW9uU3RhY2tcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcblxuLyoqIEB0eXBlIHtzdHJpbmd9ICovXG5jb25zdCB2aWV3VGVtcGxhdGUgPSByZXF1aXJlKFwiLi9Db2xsZWN0aW9uU3RhY2suaGJzXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvY29tcG9uZW50L0NvbGxlY3Rpb25TdGFja31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjaWRQcmVmaXg6IFwic3RhY2tcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0YWdOYW1lOiBcImRpdlwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJzdGFja1wiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRlbXBsYXRlOiB2aWV3VGVtcGxhdGUsXG5cblx0ZXZlbnRzOiB7XG5cdFx0XCJ0cmFuc2l0aW9uZW5kXCI6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjp0cmFuc2l0aW9uZW5kIFtpbnZhbGlkOiAlc10gW3RyYW5zaXRpb246ICVzXVwiLCB0aGlzLmNpZCwgdGhpcy5fY29udGVudEludmFsaWQsICh0aGlzLl9za2lwVHJhbnNpdGlvbnM/IFwic2tpcFwiOiBcInJ1blwiKSwgZXYudGFyZ2V0LmlkLCBldi50YXJnZXQuY2xhc3NOYW1lKTtcblx0XHRcdHRoaXMuX3JlbmRlckNvbnRlbnQoKTtcblx0XHR9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3NraXBUcmFuc2l0aW9ucyA9IHRydWU7XG5cdFx0dGhpcy5fY29udGVudEludmFsaWQgPSB0cnVlO1xuXG5cdFx0b3B0aW9ucy50ZW1wbGF0ZSAmJiAodGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUpO1xuXHRcdHRoaXMuY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0dGhpcy5jb250ZW50LmNsYXNzTmFtZSA9IFwic3RhY2staXRlbVwiO1xuXHRcdHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcblxuXHRcdHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCBcInNlbGVjdDpvbmUgc2VsZWN0Om5vbmVcIiwgdGhpcy5fb25TZWxlY3RDaGFuZ2UpO1xuXHR9LFxuXG5cdHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCAhPT0gZW5hYmxlZCkge1xuXHRcdFx0dGhpcy5fZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhdGhpcy5fZW5hYmxlZCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblNlbGVjdENoYW5nZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlZEl0ZW0gPT09IHRoaXMuY29sbGVjdGlvbi5zZWxlY3RlZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hhbmdlIGV2ZW50IHJlY2VpdmVkIGJ1dCBpdGVtIGlzIGlkZW50aWNhbFwiKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVuZGVyZWRJdGVtID0gdGhpcy5jb2xsZWN0aW9uLnNlbGVjdGVkO1xuXG5cdFx0dGhpcy5fY29udGVudEludmFsaWQgPSB0cnVlO1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogcmVuZGVyXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NraXBUcmFuc2l0aW9ucykge1xuXHRcdFx0Ly8gZXhlY3V0ZSBldmVuIGlmIGNvbnRlbnQgaGFzIG5vdCBjaGFuZ2VkIHRvIGFwcGx5IHN0eWxlcyBpbW1lZGlhdGVseVxuXHRcdFx0dGhpcy5fc2tpcFRyYW5zaXRpb25zID0gZmFsc2U7XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJza2lwLXRyYW5zaXRpb25zXCIpO1xuXHRcdFx0dGhpcy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInNraXAtdHJhbnNpdGlvbnNcIik7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gcmVuZGVyIGNoYW5nZWQgY29udGVudCBpbW1lZGlhdGVseVxuXHRcdFx0aWYgKHRoaXMuX2NvbnRlbnRJbnZhbGlkKSB7XG5cdFx0XHRcdHRoaXMuX3JlbmRlckNvbnRlbnQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZWxzZSByZW1vdmUgJ2N1cnJlbnQnIGNsYXNzIGFuZCByZW5kZXIgb24gdHJhbnNpdGlvbmVuZFxuXHRcdFx0aWYgKHRoaXMuX2NvbnRlbnRJbnZhbGlkKSB7XG5cdFx0XHRcdHRoaXMuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKFwiY3VycmVudFwiKTtcblx0XHRcdFx0Ly8gdGhpcy5jb250ZW50LmNsYXNzTmFtZSA9IFwic3RhY2staXRlbVwiO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVuZGVyQ29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRlbnRJbnZhbGlkKSB7XG5cdFx0XHR0aGlzLl9jb250ZW50SW52YWxpZCA9IGZhbHNlO1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLmNvbGxlY3Rpb24uc2VsZWN0ZWQ7XG5cdFx0XHR0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gaXRlbSA/IHRoaXMudGVtcGxhdGUoaXRlbS50b0pTT04oKSkgOiBcIlwiO1xuXHRcdFx0dGhpcy5jb250ZW50LmNsYXNzTGlzdC5hZGQoXCJjdXJyZW50XCIpO1xuXHRcdFx0Ly8gdGhpcy5jb250ZW50LmNsYXNzTmFtZSA9IFwic3RhY2staXRlbSBjdXJyZW50XCI7XG5cdFx0fVxuXHR9LFxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuLyogQG1vZHVsZSBhcHAvdmlldy9jb21wb25lbnQvRmlsdGVyYWJsZUxpc3RWaWV3XG4vKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmUuYmFieXNpdHRlcn0gKi9cbmNvbnN0IENvbnRhaW5lciA9IHJlcXVpcmUoXCJiYWNrYm9uZS5iYWJ5c2l0dGVyXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9DbGlja2FibGVSZW5kZXJlcn0gKi9cbmNvbnN0IENsaWNrYWJsZVJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9DbGlja2FibGVSZW5kZXJlclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3ByZWZpeGVkUHJvcGVydHl9ICovXG5jb25zdCBwcmVmaXhlZFByb3BlcnR5ID0gcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkUHJvcGVydHlcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9jc3MvZ2V0Qm94RWRnZVN0eWxlc30gKi9cbmNvbnN0IGdldEJveEVkZ2VTdHlsZXMgPSByZXF1aXJlKFwidXRpbHMvY3NzL2dldEJveEVkZ2VTdHlsZXNcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9hcnJheS9kaWZmZXJlbmNlfSAqL1xuY29uc3QgZGlmZiA9IHJlcXVpcmUoXCJ1dGlscy9hcnJheS9kaWZmZXJlbmNlXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJvbWlzZS9yZXNvbHZlQWxsfSAqL1xuY29uc3QgcmVzb2x2ZUFsbCA9IHJlcXVpcmUoXCJ1dGlscy9wcm9taXNlL3Jlc29sdmVBbGxcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9wcm9taXNlL3JlamVjdEFsbH0gKi9cbmNvbnN0IHJlamVjdEFsbCA9IHJlcXVpcmUoXCJ1dGlscy9wcm9taXNlL3JlamVjdEFsbFwiKTtcblxuLy8gdmFyIHJlc29sdmVBbGwgPSBmdW5jdGlvbihwcCwgcmVzdWx0KSB7XG4vLyBcdGlmIChwcC5sZW5ndGggIT0gMCkge1xuLy8gXHRcdHBwLmZvckVhY2goZnVuY3Rpb24ocCwgaSwgYSkge1xuLy8gXHRcdFx0cC5yZXNvbHZlKHJlc3VsdCk7XG4vLyBcdFx0XHRhW2ldID0gbnVsbDtcbi8vIFx0XHR9KTtcbi8vIFx0XHRwcC5sZW5ndGggPSAwO1xuLy8gXHR9XG4vLyBcdHJldHVybiBwcDtcbi8vIH07XG5cbi8vIHZhciByZWplY3RBbGwgPSBmdW5jdGlvbihwcCwgcmVhc29uKSB7XG4vLyBcdGlmIChwcC5sZW5ndGggIT0gMCkge1xuLy8gXHRcdHBwLmZvckVhY2goZnVuY3Rpb24ocCwgaSwgYSkge1xuLy8gXHRcdFx0cC5yZWplY3QocmVhc29uKTtcbi8vIFx0XHRcdGFbaV0gPSBudWxsO1xuLy8gXHRcdH0pO1xuLy8gXHRcdHBwLmxlbmd0aCA9IDA7XG4vLyBcdH1cbi8vIFx0cmV0dXJuIHBwO1xuLy8gfTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvR2xvYmFscy5UUkFOU0xBVEVfVEVNUExBVEV9ICovXG5jb25zdCB0cmFuc2xhdGVDc3NWYWx1ZSA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpLlRSQU5TTEFURV9URU1QTEFURTtcblxuLyoqIEBjb25zdCAqL1xudmFyIHRyYW5zZm9ybVByb3AgPSBwcmVmaXhlZFByb3BlcnR5KFwidHJhbnNmb3JtXCIpO1xuXG4vKipcbi8qIEBjb25zdHJ1Y3RvclxuLyogQHR5cGUge21vZHVsZTphcHAvdmlldy9jb21wb25lbnQvRmlsdGVyYWJsZUxpc3RWaWV3fVxuLyovXG52YXIgRmlsdGVyYWJsZUxpc3RWaWV3ID0gVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwiZmlsdGVyYWJsZUxpc3RcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0YWdOYW1lOiBcInVsXCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2xhc3NOYW1lOiBcImxpc3Qgc2VsZWN0YWJsZSBmaWx0ZXJhYmxlXCIsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRkZWZhdWx0czoge1xuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcblx0XHRmaWx0ZXJGbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdHJlbmRlcmVyOiBDbGlja2FibGVSZW5kZXJlci5leHRlbmQoe1xuXHRcdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0Y2lkUHJlZml4OiBcImxpc3RJdGVtXCIsXG5cdFx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0XHRjbGFzc05hbWU6IFwibGlzdC1pdGVtIGxpc3Qtbm9kZVwiLFxuXHRcdH0pLFxuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0cHJvcGVydGllczoge1xuXHRcdGNvbGxhcHNlZDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbGxhcHNlZDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuX3NldENvbGxhcHNlZCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3RlZEl0ZW06IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZEl0ZW07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9zZXRTZWxlY3Rpb24odmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZmlsdGVyZWRJdGVtczoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2ZpbHRlcmVkSXRlbXM7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtZXRyaWNzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWV0cmljcztcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRldmVudHM6IHtcblx0XHRcInRyYW5zaXRpb25lbmQgLmxpc3Qtbm9kZVwiOiBmdW5jdGlvbihldikge1xuXHRcdFx0Ly8gaWYgKCFldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwibGlzdC1ub2RlXCIpKSB7fVxuXHRcdFx0aWYgKGV2LnByb3BlcnR5TmFtZSA9PSB0cmFuc2Zvcm1Qcm9wXG5cdFx0XHRcdCYmIGV2LnRhcmdldC5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsKSB7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWRQb3NOdW0tLTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczpbJXMgKCVzKV0gWyVzXVwiLCB0aGlzLmNpZCwgZXYudHlwZSwgZXYudGFyZ2V0LmNsYXNzTmFtZSwgZXYucHJvcGVydHlOYW1lLCB0aGlzLl9jaGFuZ2VkUG9zTnVtLCBldik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuX2NvbGxhcHNlZENoYW5naW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2NoYW5nZWRQb3NOdW0gPT0gMCkge1xuXHRcdFx0XHQvLyBpZiAoKGV2LnByb3BlcnR5TmFtZSA9PSB0cmFuc2Zvcm1Qcm9wKSB8fFxuXHRcdFx0XHQvLyBcdChldi5wcm9wZXJ0eU5hbWUgPT0gXCJ2aXNpYmlsaXR5XCIpKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6WyVzIC5saXN0LWl0ZW1dIFslc10gY29sbGFwc2VkLWNoYW5naW5nIGVuZCAocmVzb2x2aW5nICVzIHByb21pc2VzKVwiLCB0aGlzLmNpZCwgZXYudHlwZSwgZXYucHJvcGVydHlOYW1lLCB0aGlzLl9jb2xsYXBzZVByb21pc2VzLmxlbmd0aCk7XG5cdFx0XHRcdHRoaXMuX2NvbGxhcHNlZENoYW5naW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbGxhcHNlZC1jaGFuZ2luZ1wiKTtcblx0XHRcdFx0cmVzb2x2ZUFsbCh0aGlzLl9jb2xsYXBzZVByb21pc2VzLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMuX2ZpbHRlcmVkSXRlbXMgPSBbXTtcblx0XHR0aGlzLl9maWx0ZXJlZEluY29taW5nID0gW107XG5cdFx0dGhpcy5fZmlsdGVyZWRPdXRnb2luZyA9IFtdO1xuXG5cdFx0dGhpcy5fbWV0cmljcyA9IHt9O1xuXHRcdHRoaXMuX2l0ZW1NZXRyaWNzID0gW107XG5cdFx0dGhpcy5fY29sbGFwc2VQcm9taXNlcyA9IFtdO1xuXHRcdHRoaXMuaXRlbVZpZXdzID0gbmV3IENvbnRhaW5lcigpO1xuXG5cdFx0Xy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLmRlZmF1bHRzKTtcblx0XHR0aGlzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlcjtcblx0XHR0aGlzLl9maWx0ZXJGbiA9IG9wdGlvbnMuZmlsdGVyRm47XG5cblx0XHQvLyB0aGlzLmNvbXB1dGVGaWx0ZXIoKTtcblx0XHQvLyB0aGlzLmNvbGxlY3Rpb24uZWFjaCh0aGlzLmNyZWF0ZUl0ZW1WaWV3LCB0aGlzKTtcblxuXHRcdHRoaXMuY29sbGVjdGlvbi5lYWNoKHRoaXMuY3JlYXRlSXRlbVZpZXcsIHRoaXMpO1xuXHRcdHRoaXMuX3NldFNlbGVjdGlvbih0aGlzLmNvbGxlY3Rpb24uc2VsZWN0ZWQpO1xuXHRcdHRoaXMuX3NldENvbGxhcHNlZChvcHRpb25zLmNvbGxhcHNlZCk7XG5cdFx0dGhpcy5yZWZyZXNoRmlsdGVyKCk7XG5cdFx0Ly8gdGhpcy5za2lwVHJhbnNpdGlvbnMgPSB0cnVlO1xuXHRcdC8vIHRoaXMucmVuZGVyTm93KCk7XG5cblx0XHQvLyB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgXCJzZWxlY3Q6b25lIHNlbGVjdDpub25lXCIsIHRoaXMuX3NldFNlbGVjdGlvbik7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sIFwicmVzZXRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hbGxJdGVtcyA9IG51bGw7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG5cdFx0fSk7XG5cblx0XHQvLyB3aWxsIHRyaWdnZXIgb24gcmV0dXJuIGlmIHRoaXMuZWwgaXMgYWxyZWFkeSBhdHRhY2hlZFxuXHRcdC8vIHRoaXMuc2tpcFRyYW5zaXRpb25zID0gdHJ1ZTtcblx0XHQvLyB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJza2lwLXRyYW5zaXRpb25zXCIpO1xuXHRcdC8vIHRoaXMucmVxdWVzdFJlbmRlcihWaWV3LkFMTF9JTlZBTElEKTtcblxuXHRcdGNvbnNvbGUubG9nKFwiJXM6OmluaXRpYWxpemUgYXR0YWNoZWQ6ICVvXCIsIHRoaXMuY2lkLCB0aGlzLmF0dGFjaGVkKTtcblxuXHRcdHRoaXMub25jZShcInZpZXc6YXR0YWNoZWRcIiwgZnVuY3Rpb24odmlldykge1xuXHRcdFx0Y29uc29sZS5sb2coXCIlczo6aW5pdGlhbGl6ZSAtPiBbdmlldzphdHRhY2hlZF0gYXR0YWNoZWQ6ICVvXCIsIHZpZXcuY2lkLCB2aWV3LmF0dGFjaGVkKTtcblx0XHRcdC8vIHZpZXcucmVxdWVzdFJlbmRlcihWaWV3LkFMTF9JTlZBTElEKS5yZW5kZXJOb3coKTtcblx0XHRcdHZpZXcuc2tpcFRyYW5zaXRpb25zID0gdHJ1ZTtcblx0XHRcdHZpZXcuZWwuY2xhc3NMaXN0LmFkZChcInNraXAtdHJhbnNpdGlvbnNcIik7XG5cdFx0XHR2aWV3LnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gdGhpcy5za2lwVHJhbnNpdGlvbnMgPSB0cnVlO1xuXHRcdFx0XHR2aWV3LnJlbmRlck5vdygpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbiBhcnJheSB3aXRoIGEgY29sbGVjdGlvbiBjb250ZW5zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0QWxsSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbGxJdGVtcyB8fCAodGhpcy5fYWxsSXRlbXMgPSB0aGlzLmNvbGxlY3Rpb24uc2xpY2UoKSk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogVHJhbnNpdGlvbiBwcm9taXNlc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfd2hlbkNvbGxhcHNlQ2hhbmdlRW5kczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NvbGxhcHNlZENoYW5nZWQpIHtcblx0XHRcdHZhciB2aWV3ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0dmlldy5vbihcInZpZXc6cmVuZGVyOmFmdGVyXCIsIHJlc29sdmUpO1xuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0d2hlbkNvbGxhcHNlQ2hhbmdlRW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGQsIHAsIHBwO1xuXHRcdGlmICh0aGlzLl9jb2xsYXBzZWRDaGFuZ2luZyB8fCB0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkKSB7XG5cdFx0XHRkID0ge307XG5cdFx0XHRwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdGQucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdGQucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFx0fSk7XG5cdFx0XHRwcCA9IHRoaXMuX2NvbGxhcHNlUHJvbWlzZXM7XG5cdFx0XHRwcC5wdXNoKGQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcDtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBSZW5kZXJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW5kZXJGcmFtZTogZnVuY3Rpb24odHN0YW1wLCBmbGFncykge1xuXHRcdC8vIGlmIChERUJVRykge1xuXHRcdC8vIFx0dmFyIGNoYW5nZWQgPSBbXTtcblx0XHQvLyBcdHRoaXMuX2NvbGxhcHNlZENoYW5nZWQgJiYgY2hhbmdlZC5wdXNoKFwiY29sbGFwc2VkXCIpO1xuXHRcdC8vIFx0dGhpcy5fc2VsZWN0aW9uQ2hhbmdlZCAmJiBjaGFuZ2VkLnB1c2goXCJzZWxlY3Rpb25cIik7XG5cdFx0Ly8gXHR0aGlzLl9maWx0ZXJDaGFuZ2VkICYmIGNoYW5nZWQucHVzaChcImZpbHRlclwiKTtcblx0XHQvLyBcdGNvbnNvbGUubG9nKFwiJXM6OnJlbmRlckZyYW1lIFslc11cIiwgdGhpcy5jaWQsIGNoYW5nZWQuam9pbihcIiBcIikpO1xuXHRcdC8vIH1cblxuXHRcdC8vIGNvbGxhcHNlZCB0cmFuc2l0aW9uIGZsYWdcblx0XHRpZiAodGhpcy5fY29sbGFwc2VkQ2hhbmdpbmcpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIiVzOjpyZW5kZXJGcmFtZSBjb2xsYXBzZWQgdHggaW50ZXJydXB0ZWRcIiwgdGhpcy5jaWQpO1xuXHRcdFx0dGhpcy5fY29sbGFwc2VkQ2hhbmdpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbGxhcHNlZC1jaGFuZ2luZ1wiKTtcblx0XHRcdHJlamVjdEFsbCh0aGlzLl9jb2xsYXBzZVByb21pc2VzLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2tpcFRyYW5zaXRpb25zKSB7XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJza2lwLXRyYW5zaXRpb25zXCIpO1xuXHRcdFx0Ly8gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5za2lwVHJhbnNpdGlvbnMgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwic2tpcC10cmFuc2l0aW9uc1wiKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkKSB7XG5cdFx0XHR0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRmbGFncyB8PSBWaWV3LlNJWkVfSU5WQUxJRDtcblx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImNvbGxhcHNlZFwiLCB0aGlzLl9jb2xsYXBzZWQpO1xuXG5cdFx0XHRpZiAodGhpcy5za2lwVHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fY29sbGFwc2VkQ2hhbmdpbmcgPSBmYWxzZTtcblx0XHRcdFx0Ly8gcmVzb2x2ZUFsbCh0aGlzLl9jb2xsYXBzZVByb21pc2VzLCB0aGlzLmVsKTtcblx0XHRcdFx0dGhpcy5vbmNlKFwidmlldzpyZW5kZXI6YWZ0ZXJcIiwgZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWRQb3NOdW0gPSAwO1xuXHRcdFx0XHRcdHJlc29sdmVBbGwodmlldy5fY29sbGFwc2VQcm9taXNlcywgdmlldyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fY29sbGFwc2VkQ2hhbmdpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJjb2xsYXBzZWQtY2hhbmdpbmdcIik7XG5cdFx0XHRcdC8vIHRoaXMgd2lsbCBiZSByZXNvbHZlZCBvbiB0cmFuc2l0aW9uZW5kXG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLmxvZyhcIiVzOltjb2xsYXBzZSBjaGFuZ2VkXSAlcyBwcm9taXNlc1wiLCB0aGlzLmNpZCxcblx0XHRcdFx0dGhpcy5fY29sbGFwc2VQcm9taXNlcy5sZW5ndGgsXG5cdFx0XHRcdHRoaXMuX2NvbGxhcHNlZENoYW5naW5nID8gXCJyZXNvbHZpbmcgbm93XCIgOiBcInJlc29sdmluZyBvbiB0cmFuc2l0aW9uZW5kXCJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQpIHtcblx0XHRcdHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdGZsYWdzIHw9IFZpZXcuTEFZT1VUX0lOVkFMSUQ7XG5cdFx0XHR0aGlzLnJlbmRlclNlbGVjdGlvbih0aGlzLmNvbGxlY3Rpb24uc2VsZWN0ZWQsIHRoaXMuY29sbGVjdGlvbi5sYXN0U2VsZWN0ZWQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9maWx0ZXJDaGFuZ2VkKSB7XG5cdFx0XHR0aGlzLl9maWx0ZXJDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRmbGFncyB8PSBWaWV3LkxBWU9VVF9JTlZBTElEO1xuXHRcdFx0dmFyIGxhc3RGaWx0ZXJlZEl0ZW1zID0gdGhpcy5maWx0ZXJlZEl0ZW1zO1xuXHRcdFx0Ly8gdGhpcy5fcHJpbnRTdGF0cyhsYXN0RmlsdGVyZWRJdGVtcyk7XG5cdFx0XHR0aGlzLmNvbXB1dGVGaWx0ZXIoKTtcblx0XHRcdHRoaXMuYXBwbHlGaWx0ZXIoKTtcblx0XHRcdGlmIChERUJVRykge1xuXHRcdFx0XHR0aGlzLl9wcmludFN0YXRzKGxhc3RGaWx0ZXJlZEl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZmxhZ3MgJiBWaWV3LlNJWkVfSU5WQUxJRCkge1xuXHRcdFx0dGhpcy5tZWFzdXJlKCk7IC8vIE5PVEU6IG1lYXN1cmVzIGNoaWxkcmVuXG5cdFx0fVxuXG5cdFx0aWYgKGZsYWdzICYgKFZpZXcuTEFZT1VUX0lOVkFMSUQgfCBWaWV3LlNJWkVfSU5WQUxJRCkpIHtcblx0XHRcdHRoaXMucmVuZGVyTGF5b3V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdG1lYXN1cmU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHZhciBpLCBpaSwgZWwsIGVscywgbSwgbW07XG5cdFx0Ly8gZWxzID0gdGhpcy5lbC5jaGlsZHJlbjtcblx0XHQvLyBpaSA9IGVscy5sZW5ndGg7XG5cdFx0Ly8gbW0gPSB0aGlzLl9pdGVtTWV0cmljcztcblx0XHQvLyBmb3IgKGkgPSAwOyBpIDwgaWk7IGkrKykge1xuXHRcdC8vIFx0bW1baV0gPSBfLnBpY2soZWxzW2ldLCBcIm9mZnNldFRvcFwiLCBcIm9mZnNldEhlaWdodFwiKTtcblx0XHQvLyB9XG5cblx0XHR0aGlzLl9tZXRyaWNzID0gZ2V0Qm94RWRnZVN0eWxlcyh0aGlzLmVsLCB0aGlzLl9tZXRyaWNzKTtcblxuXHRcdC8vIHZhciBpdGVtRWwsIGl0ZW1WaWV3LCBiYXNlbGluZSA9IDA7XG5cdFx0Ly8gaWYgKGl0ZW1FbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5saXN0LWl0ZW06bm90KC5leGNsdWRlZCkgLmxhYmVsXCIpKSB7XG5cdFx0Ly8gXHQvLyBpdGVtVmlldyA9IHRoaXMuaXRlbVZpZXdzLmZpbmRCeUNpZChpdGVtRWwuY2lkKTtcblx0XHQvLyBcdHZhciBlbEEgPSBpdGVtRWwsIGVsQiA9IGl0ZW1FbC5wYXJlbnRFbGVtZW50O1xuXHRcdC8vIFx0dmFyIHlBID0gZWxBLm9mZnNldFRvcCxcblx0XHQvLyBcdFx0aEEgPSBlbEEub2Zmc2V0SGVpZ2h0LFxuXHRcdC8vIFx0XHR5QiA9IGVsQi5vZmZzZXRUb3AsXG5cdFx0Ly8gXHRcdGhCID0gZWxCLm9mZnNldEhlaWdodDtcblx0XHQvLyBcdGJhc2VsaW5lID0gKCh5QSArIGhBKSAtICh5QiArIGhCKSk7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhcIiVzOjptZWFzdXJlIGZvbnRTaXplOiAlc3B4ICglcyslcyktKCVzKyVzKT0lc1wiLCB0aGlzLmNpZCwgdGhpcy5fbWV0cmljcy5mb250U2l6ZSxcblx0XHQvLyBcdFx0eUEsIGhBLCB5QiwgaEIsIGJhc2VsaW5lXG5cdFx0Ly8gXHQpO1xuXHRcdC8vIH1cblxuXHRcdHRoaXMuaXRlbVZpZXdzLmZvckVhY2goZnVuY3Rpb24odmlldykge1xuXHRcdFx0aWYgKCF2aWV3Ll9tZXRyaWNzKSB2aWV3Ll9tZXRyaWNzID0ge307XG5cdFx0XHQvLyB2aWV3Ll9tZXRyaWNzLmJhc2VsaW5lID0gdGhpcy5fbWV0cmljcy5mb250U2l6ZSAtIGJhc2VsaW5lO1xuXHRcdFx0dmlldy5fbWV0cmljcy5vZmZzZXRUb3AgPSB2aWV3LmVsLm9mZnNldFRvcDtcblx0XHRcdHZpZXcuX21ldHJpY3Mub2Zmc2V0SGVpZ2h0ID0gdmlldy5lbC5vZmZzZXRIZWlnaHQ7XG5cdFx0XHR2aWV3Ll9tZXRyaWNzLm9mZnNldExlZnQgPSB2aWV3LmVsLm9mZnNldExlZnQ7XG5cdFx0XHR2aWV3Ll9tZXRyaWNzLm9mZnNldFdpZHRoID0gdmlldy5lbC5vZmZzZXRXaWR0aDtcblx0XHRcdGlmICghdGhpcy5fY29sbGFwc2VkICYmIHZpZXcubGFiZWwpIHtcblx0XHRcdFx0dmlldy5fbWV0cmljcy50ZXh0TGVmdCA9IHZpZXcubGFiZWwub2Zmc2V0TGVmdDtcblx0XHRcdFx0dmlldy5fbWV0cmljcy50ZXh0V2lkdGggPSB2aWV3LmxhYmVsLm9mZnNldFdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmlldy5fbWV0cmljcy50ZXh0TGVmdCA9IHZpZXcuX21ldHJpY3Mub2Zmc2V0TGVmdDtcblx0XHRcdFx0dmlldy5fbWV0cmljcy50ZXh0V2lkdGggPSB2aWV3Ll9tZXRyaWNzLm9mZnNldFdpZHRoO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0Ly8gdGhpcy5fbWV0cmljcy5iYXNlbGluZSA9IHRoaXMuX21ldHJpY3MuZm9udFNpemUgLSBiYXNlbGluZTtcblx0fSxcblxuXHRyZW5kZXJMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb3NYLCBwb3NZLCBsYXN0WCwgbGFzdFk7XG5cdFx0cG9zWCA9IHRoaXMuX21ldHJpY3MucGFkZGluZ0xlZnQ7XG5cdFx0cG9zWSA9IHRoaXMuX21ldHJpY3MucGFkZGluZ1RvcDtcblxuXHRcdHRoaXMuX2NoYW5nZWRQb3NOdW0gPSAwO1xuXHRcdC8vIHVzZSBIVE1MRWxlbWVudC5jaGlsZHJlbiB0byBrZWVwIGxheW91dCBvcmRlclxuXHRcdGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuZWwuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGlzLml0ZW1WaWV3cy5maW5kQnlDaWQodGhpcy5lbC5jaGlsZHJlbltpXS5jaWQpO1xuXHRcdFx0bGFzdFggPSB2aWV3LnRyYW5zZm9ybS50eDtcblx0XHRcdGxhc3RZID0gdmlldy50cmFuc2Zvcm0udHk7XG5cdFx0XHRpZiAoKCh0aGlzLmNvbGxlY3Rpb24uc2VsZWN0ZWQgJiYgIXZpZXcubW9kZWwuc2VsZWN0ZWQpIHx8XG5cdFx0XHRcdFx0dmlldy5lbC5jbGFzc0xpc3QuY29udGFpbnMoXCJleGNsdWRlZFwiKSkgJiYgdGhpcy5fY29sbGFwc2VkKSB7XG5cdFx0XHRcdHZpZXcudHJhbnNmb3JtLnR4ID0gcG9zWDtcblx0XHRcdFx0dmlldy50cmFuc2Zvcm0udHkgPSBwb3NZO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHZpZXcuX21ldHJpY3Mub2Zmc2V0SGVpZ2h0ID09IDApIHtcblx0XHRcdFx0XHRwb3NZIC09IHZpZXcuX21ldHJpY3Mub2Zmc2V0VG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZpZXcudHJhbnNmb3JtLnR4ID0gcG9zWDtcblx0XHRcdFx0dmlldy50cmFuc2Zvcm0udHkgPSBwb3NZO1xuXHRcdFx0XHRwb3NZICs9IHZpZXcuX21ldHJpY3Mub2Zmc2V0SGVpZ2h0ICsgdmlldy5fbWV0cmljcy5vZmZzZXRUb3A7XG5cdFx0XHR9XG5cdFx0XHR2aWV3LmVsLnN0eWxlW3RyYW5zZm9ybVByb3BdID0gdHJhbnNsYXRlQ3NzVmFsdWUodmlldy50cmFuc2Zvcm0udHgsIHZpZXcudHJhbnNmb3JtLnR5KTtcblx0XHRcdGlmICh2aWV3LnRyYW5zZm9ybS50eCAhPSBsYXN0WCB8fCB2aWV3LnRyYW5zZm9ybS50eSAhPSBsYXN0WSkge1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkUG9zTnVtKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcG9zWSArPSB0aGlzLl9tZXRyaWNzLnBhZGRpbmdCb3R0b207XG5cdFx0dGhpcy5fbWV0cmljcy5oZWlnaHQgPSBNYXRoLm1heCgwLCBwb3NZICsgdGhpcy5fbWV0cmljcy5wYWRkaW5nQm90dG9tKTtcblx0XHR0aGlzLmVsLnN0eWxlLmhlaWdodCA9IHRoaXMuX21ldHJpY3MuaGVpZ2h0ICsgXCJweFwiO1xuXHRcdC8vIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gKHBvc1kgPiAwKSA/IHBvc1kgKyBcInB4XCIgOiBcIlwiO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIENoaWxkIHZpZXdzXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qKiBAcHJpdmF0ZSAqL1xuXHRjcmVhdGVJdGVtVmlldzogZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcblx0XHR2YXIgdmlldyA9IG5ldyB0aGlzLnJlbmRlcmVyKHtcblx0XHRcdG1vZGVsOiBpdGVtLFxuXHRcdFx0ZWw6IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5saXN0LWl0ZW1bZGF0YS1pZD1cXFwiXCIgKyBpdGVtLmlkICsgXCJcXFwiXVwiKVxuXHRcdH0pO1xuXHRcdC8vIGl0ZW0uc2V0KFwiZXhjbHVkZWRcIiwgZmFsc2UsIHsgc2lsZW50OiB0cnVlIH0pO1xuXHRcdC8vIHZpZXcubGlzdGVuVG8oaXRlbSwgXCJjaGFuZ2U6ZXhjbHVkZWRcIiwgZnVuY3Rpb24oaXRlbSwgbmV3VmFsKSB7XG5cdFx0Ly8gXHQvLyBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuXHRcdC8vIFx0aWYgKHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZXhjbHVkZWRcIikgIT09IG5ld1ZhbCkge1xuXHRcdC8vIFx0XHRjb25zb2xlLndhcm4oXCIlczpbY2hhbmdlOmV4Y2x1ZGVkXSBtOiVvIGNzczogJW9cIiwgdGhpcy5jaWQsIG5ld1ZhbCwgdGhpcy5lbC5jbGFzc0xpc3QuY29udGFpbnMoXCJleGNsdWRlZFwiKSk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHQvLyB0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJleGNsdWRlZFwiLCBleGNsdWRlZCk7XG5cdFx0Ly8gfSk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh2aWV3LCBcInJlbmRlcmVyOmNsaWNrXCIsIHRoaXMuX29uUmVuZGVyZXJDbGljayk7XG5cdFx0dGhpcy5pdGVtVmlld3MuYWRkKHZpZXcpO1xuXHRcdHJldHVybiB2aWV3O1xuXHR9LFxuXG5cdC8qKiBAcHJpdmF0ZSAqL1xuXHRfb25SZW5kZXJlckNsaWNrOiBmdW5jdGlvbihpdGVtLCBldikge1xuXHRcdGlmICh0aGlzLl9jb2xsYXBzZWRDaGFuZ2luZ1xuXHRcdFx0fHwgKHRoaXMuX2NvbGxhcHNlZCAmJiBpdGVtLmdldChcImV4Y2x1ZGVkXCIpKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodGhpcy5jb2xsZWN0aW9uLnNlbGVjdGVkICE9PSBpdGVtKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OnNlbGVjdDpvbmVcIiwgaXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChldi5hbHRLZXkpIHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwidmlldzpzZWxlY3Q6bm9uZVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcInZpZXc6c2VsZWN0OnNhbWVcIiwgaXRlbSk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0aGlzLnRyaWdnZXIoXCJ2aWV3OnNlbGVjdDpub25lXCIpO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBDb2xsYXBzZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBwcml2YXRlICovXG5cdF9jb2xsYXBzZWQ6IHVuZGVmaW5lZCxcblxuXHQvKipcblx0ICogQHBhcmFtIHtCb29sZWFufVxuXHQgKi9cblx0X3NldENvbGxhcHNlZDogZnVuY3Rpb24oY29sbGFwc2VkKSB7XG5cdFx0aWYgKGNvbGxhcHNlZCAhPT0gdGhpcy5fY29sbGFwc2VkKSB7XG5cdFx0XHR0aGlzLl9jb2xsYXBzZWQgPSBjb2xsYXBzZWQ7XG5cdFx0XHR0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMucmVxdWVzdFJlbmRlcigpO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBTZWxlY3Rpb25cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBwcml2YXRlICovXG5cdF9zZWxlY3RlZEl0ZW06IHVuZGVmaW5lZCxcblxuXHQvKiogQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbHxudWxsfSAqL1xuXHRfc2V0U2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKGl0ZW0gIT09IHRoaXMuX3NlbGVjdGVkSXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKFZpZXcuTU9ERUxfSU5WQUxJRCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBAcHJpdmF0ZSAqL1xuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKG5ld0l0ZW0sIG9sZEl0ZW0pIHtcblx0XHR2YXIgdmlldztcblx0XHRpZiAob2xkSXRlbSkge1xuXHRcdFx0dmlldyA9IHRoaXMuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKG9sZEl0ZW0pO1xuXHRcdFx0dmlldy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG5cdFx0XHQvLyB2aWV3LmxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJjb2xvci1mZ1wiKTtcblx0XHRcdC8vIHZpZXcubGFiZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbG9yLXJldmVyc2VcIik7XG5cdFx0fVxuXHRcdGlmIChuZXdJdGVtKSB7XG5cdFx0XHR2aWV3ID0gdGhpcy5pdGVtVmlld3MuZmluZEJ5TW9kZWwobmV3SXRlbSk7XG5cdFx0XHR2aWV3LmVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcblx0XHRcdC8vIHZpZXcubGFiZWwuY2xhc3NMaXN0LmFkZChcImNvbG9yLWZnXCIpO1xuXHRcdFx0Ly8gdmlldy5sYWJlbC5jbGFzc0xpc3QuYWRkKFwiY29sb3ItcmV2ZXJzZVwiKTtcblx0XHR9XG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiaGFzLXNlbGVjdGVkXCIsIHRoaXMuc2VsZWN0ZWRJdGVtICE9PSBudWxsKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBGaWx0ZXJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0cmVmcmVzaEZpbHRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2ZpbHRlckZuKSB7XG5cdFx0XHR0aGlzLl9maWx0ZXJDaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMucmVxdWVzdFJlbmRlcihWaWV3Lk1PREVMX0lOVkFMSUQpO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBGaWx0ZXIgaW1wbCAyXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGNvbXB1dGVGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdJdGVtcywgb2xkSXRlbXM7XG5cdFx0dmFyIGhhc05ldywgaGFzT2xkO1xuXHRcdHRoaXMuX2ZpbHRlcmVkSW5jb21pbmcubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9maWx0ZXJlZE91dGdvaW5nLmxlbmd0aCA9IDA7XG5cblx0XHRuZXdJdGVtcyA9IHRoaXMuX2ZpbHRlckZuID8gdGhpcy5jb2xsZWN0aW9uLmZpbHRlcih0aGlzLl9maWx0ZXJGbiwgdGhpcykgOiB0aGlzLl9nZXRBbGxJdGVtcygpO1xuXHRcdG9sZEl0ZW1zID0gdGhpcy5fZmlsdGVyZWRJdGVtcztcblx0XHRoYXNOZXcgPSAhIShuZXdJdGVtcyAmJiBuZXdJdGVtcy5sZW5ndGgpO1xuXHRcdGhhc09sZCA9ICEhKG9sZEl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCk7XG5cdFx0Ly8gTk9URTogZGlmZiB0aGlyZCBhcmcgaXMgZGVzdGluYXRpb24gYXJyYXlcblx0XHRpZiAoaGFzTmV3KSB7XG5cdFx0XHQvLyBpbmNvbWluZyBleGNsdXNpb25zXG5cdFx0XHRkaWZmKChoYXNPbGQgPyBvbGRJdGVtcyA6IHRoaXMuX2dldEFsbEl0ZW1zKCkpLCBuZXdJdGVtcywgdGhpcy5fZmlsdGVyZWRJbmNvbWluZyk7XG5cdFx0XHQvLyB0aGlzLl9maWx0ZXJlZEluY29taW5nLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0Ly8gXHRpdGVtLnNldChcImV4Y2x1ZGVkXCIsIHRydWUpO1xuXHRcdFx0Ly8gfSk7XG5cdFx0fVxuXHRcdGlmIChoYXNPbGQpIHtcblx0XHRcdC8vIG91dGdvaW5nIGV4Y2x1c2lvbnNcblx0XHRcdGRpZmYoKGhhc05ldyA/IG5ld0l0ZW1zIDogdGhpcy5fZ2V0QWxsSXRlbXMoKSksIG9sZEl0ZW1zLCB0aGlzLl9maWx0ZXJlZE91dGdvaW5nKTtcblx0XHRcdC8vIHRoaXMuX2ZpbHRlcmVkT3V0Z29pbmcuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHQvLyBcdGl0ZW0uc2V0KFwiZXhjbHVkZWRcIiwgZmFsc2UpO1xuXHRcdFx0Ly8gfSk7XG5cdFx0fVxuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OnJlbmRlckZpbHRlckZuXCIsIHRoaXMuY2lkLCBuZXdJdGVtcyk7XG5cdFx0dGhpcy5fZmlsdGVyZWRJdGVtcyA9IG5ld0l0ZW1zO1xuXHR9LFxuXG5cdGFwcGx5RmlsdGVyOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0aGlzLml0ZW1WaWV3cy5mb3JFYWNoKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHQvLyBcdHZpZXcuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImV4Y2x1ZGVkXCIsIHZpZXcubW9kZWwuZ2V0KFwiZXhjbHVkZWRcIikpO1xuXHRcdC8vIH0pO1xuXHRcdHRoaXMuX2ZpbHRlcmVkSW5jb21pbmcuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChpdGVtKS5lbC5jbGFzc0xpc3QuYWRkKFwiZXhjbHVkZWRcIik7XG5cdFx0XHRpdGVtLnNldChcImV4Y2x1ZGVkXCIsIHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHRoaXMuX2ZpbHRlcmVkT3V0Z29pbmcuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChpdGVtKS5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiZXhjbHVkZWRcIik7XG5cdFx0XHRpdGVtLnNldChcImV4Y2x1ZGVkXCIsIGZhbHNlKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImhhcy1leGNsdWRlZFwiLCB0aGlzLmZpbHRlcmVkSXRlbXMubGVuZ3RoID4gMCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogRmlsdGVyIGltcGwgMVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKlxuXHRjb21wdXRlRmlsdGVyXzE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2ZpbHRlckZuID8gdGhpcy5jb2xsZWN0aW9uLmZpbHRlcih0aGlzLl9maWx0ZXJGbiwgdGhpcykgOiB0aGlzLl9nZXRBbGxJdGVtcygpO1xuXHRcdHRoaXMucmVuZGVyRmlsdGVycyhpdGVtcywgdGhpcy5fZmlsdGVyZWRJdGVtcyk7XG5cdFx0dGhpcy5fZmlsdGVyZWRJdGVtcyA9IGl0ZW1zO1xuXHR9LFxuXG5cdHJlbmRlckZpbHRlcnM6IGZ1bmN0aW9uKG5ld0l0ZW1zLCBvbGRJdGVtcykge1xuXHRcdHZhciBoYXNOZXcgPSAhIShuZXdJdGVtcyAmJiBuZXdJdGVtcy5sZW5ndGgpO1xuXHRcdHZhciBoYXNPbGQgPSAhIShvbGRJdGVtcyAmJiBvbGRJdGVtcy5sZW5ndGgpO1xuXHRcdHZhciBpbkV4Y2wgPSBbXTtcblx0XHR2YXIgb3V0RXhjbCA9IFtdO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coXCIlczo6cmVuZGVyRmlsdGVyRm5cIiwgdGhpcy5jaWQsIG5ld0l0ZW1zKTtcblx0XHQvLyBOT1RFOiBkaWZmIHRoaXJkIGFyZyBpcyBkZXN0aW5hdGlvbiBhcnJheVxuXHRcdGlmIChoYXNOZXcpIHtcblx0XHRcdGRpZmYoKGhhc09sZCA/IG9sZEl0ZW1zIDogdGhpcy5fZ2V0QWxsSXRlbXMoKSksIG5ld0l0ZW1zLCBpbkV4Y2wpXG5cdFx0XHQvLyAuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHQvLyBcdHRoaXMuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKGl0ZW0pLmVsLmNsYXNzTGlzdC5hZGQoXCJleGNsdWRlZFwiKTtcblx0XHRcdC8vIFx0aXRlbS5zZXQoXCJleGNsdWRlZFwiLCB0cnVlKTtcblx0XHRcdC8vIH0sIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoaGFzT2xkKSB7XG5cdFx0XHRkaWZmKChoYXNOZXcgPyBuZXdJdGVtcyA6IHRoaXMuX2dldEFsbEl0ZW1zKCkpLCBvbGRJdGVtcywgb3V0RXhjbClcblx0XHRcdC8vIC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdC8vIFx0dGhpcy5pdGVtVmlld3MuZmluZEJ5TW9kZWwoaXRlbSkuZWwuY2xhc3NMaXN0LnJlbW92ZShcImV4Y2x1ZGVkXCIpO1xuXHRcdFx0Ly8gXHRpdGVtLnNldChcImV4Y2x1ZGVkXCIsIGZhbHNlKTtcblx0XHRcdC8vIH0sIHRoaXMpO1xuXHRcdH1cblx0XHR0aGlzLl9maWx0ZXJlZEluY29taW5nID0gaW5FeGNsO1xuXHRcdHRoaXMuX2ZpbHRlcmVkT3V0Z29pbmcgPSBvdXRFeGNsO1xuXHRcdC8vIHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImhhcy1leGNsdWRlZFwiLCBoYXNOZXcpO1xuXHRcdC8vIHRoaXMuYXBwbHlGaWx0ZXIoKTtcblx0fSxcblx0Ki9cblxuXHQvLyBjb21wdXRlRmlsdGVyZWQ6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdHRoaXMuX2ZpbHRlclJlc3VsdCA9IHRoaXMuY29sbGVjdGlvbi5tYXAodGhpcy5fZmlsdGVyRm4sIHRoaXMpO1xuXHQvLyB9LFxuXHQvL1xuXHQvLyByZW5kZXJGaWx0ZXJlZDogZnVuY3Rpb24oKSB7XG5cdC8vIFx0dGhpcy5jb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcblx0Ly8gXHRcdHRoaXMuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKGl0ZW0pLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJleGNsdWRlZFwiLCAhdGhpcy5fZmlsdGVyUmVzdWx0W2luZGV4XSk7XG5cdC8vIFx0fSwgdGhpcyk7XG5cdC8vIH0sXG5cbn0pO1xuXG5pZiAoREVCVUcpIHtcblx0RmlsdGVyYWJsZUxpc3RWaWV3LnByb3RvdHlwZS5fbG9nRmxhZ3MgPSBbXG5cdFx0XCJ2aWV3LnJlbmRlclwiLFxuXHRcdC8vIFwidmlldy50cmFjZVwiXG5cdF0uam9pbihcIiBcIik7XG5cblx0RmlsdGVyYWJsZUxpc3RWaWV3LnByb3RvdHlwZS5fcHJpbnRTdGF0cyA9IGZ1bmN0aW9uKGxhc3RGaWx0ZXJlZEl0ZW1zKSB7XG5cdFx0aWYgKHRoaXMuX2xvZ0ZsYWdzW1widmlldy50cmFjZVwiXSkgY29uc29sZS5sb2coXCIlczo6cmVuZGVyRnJhbWUgJXMgZmlsdGVyZWQ6JW8oPSVvKS8lbyAoY2hhbmdlZDolbywgaW46JW8sIG91dDolbylcIiwgdGhpcy5jaWQsXG5cdFx0XHR0aGlzLmZpbHRlcmVkSXRlbXMubGVuZ3RoID4gMCA/IFwiaGFzXCIgOiBcImhhcyBub3RcIixcblx0XHRcdHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGgsXG5cdFx0XHRsYXN0RmlsdGVyZWRJdGVtcyA/ICh0aGlzLmZpbHRlcmVkSXRlbXMubGVuZ3RoICsgdGhpcy5fZmlsdGVyZWRJbmNvbWluZy5sZW5ndGgpIC0gdGhpcy5fZmlsdGVyZWRPdXRnb2luZy5sZW5ndGggOiB0aGlzLmZpbHRlcmVkSXRlbXMubGVuZ3RoLFxuXHRcdFx0dGhpcy5jb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRcdCh0aGlzLl9maWx0ZXJlZEluY29taW5nLmxlbmd0aCArIHRoaXMuX2ZpbHRlcmVkT3V0Z29pbmcubGVuZ3RoKSxcblx0XHRcdHRoaXMuX2ZpbHRlcmVkSW5jb21pbmcubGVuZ3RoLFxuXHRcdFx0dGhpcy5fZmlsdGVyZWRPdXRnb2luZy5sZW5ndGgpO1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcmFibGVMaXN0VmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L2NvbXBvbmVudC9HcmFwaFZpZXdcbiAqL1xuXG4vKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuY29uc3QgQ29sb3IgPSByZXF1aXJlKFwiY29sb3JcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvQ2FudmFzVmlld30gKi9cbmNvbnN0IENhbnZhc1ZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9DYW52YXNWaWV3XCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuY29uc3QgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9jYW52YXMvY2FsY0FyY0hDb25uZWN0b3J9ICovXG5jb25zdCBjYWxjQXJjSENvbm5lY3RvciA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvY2FsY0FyY0hDb25uZWN0b3JcIik7XG5cbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2NhbnZhcy9DYW52YXNIZWxwZXJ9ICovXG5jb25zdCBDYW52YXNIZWxwZXIgPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL0NhbnZhc0hlbHBlclwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvZ2VvbS9pbmZsYXRlUmVjdH0gKi9cbmNvbnN0IGluZmxhdGVSZWN0ID0gcmVxdWlyZShcInV0aWxzL2dlb20vaW5mbGF0ZVJlY3RcIik7XG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2RvbS9nZXRBYnNvbHV0ZUNsaWVudFJlY3R9ICovXG4vLyB2YXIgZ2V0QWJzb2x1dGVDbGllbnRSZWN0ID0gcmVxdWlyZShcInV0aWxzL2RvbS9nZXRBYnNvbHV0ZUNsaWVudFJlY3RcIik7XG5cblxuLy8gdmFyIEJFWklFUl9DSVJDTEUgPSAwLjU1MTkxNTAyNDQ5NDtcbi8vIHZhciBNSU5fQ0FOVkFTX1JBVElPID0gMjtcbi8vIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxudmFyIHN0eWxlQmFzZSA9IHtcblx0bGluZUNhcDogXCJidXR0XCIsIC8vIHJvdW5kLCBidXR0LCBzcXVhcmVcblx0bGluZVdpZHRoOiAwLjc1LFxuXHRsaW5lRGFzaE9mZnNldDogMCxcblx0c2V0TGluZURhc2g6IFtbXV0sXG5cdC8vIHJhZGl1c0Jhc2U6IDIsXG5cdC8vIC8qIGZhY3RvcmVkIHRvIHJlbSB1bml0ICovIC8vNixcblx0Ly8gcmFkaXVzSW5jcmVtZW50OiAwLjIxLCAvLzMsIC8vMC4yNSxcblx0Ly8gLyogdXNlcyBsaW5lV2lkdGggbXVsdGlwbGllciAqL1xuXHQvLyBvdXRsaW5lV2lkdGg6IDMsXG5cdC8vIC8qIHVzZXMgbGluZVdpZHRoIG11bHRpcGxpZXIgKi9cblx0Ly8gYXJyb3dTaXplOiAwLjMsXG59O1xudmFyIHBhcmFtc0Jhc2UgPSB7XG5cdHJhZGl1c0Jhc2U6IDEuMjUsXG5cdC8qIGZhY3RvcmVkIHRvIHJlbSB1bml0ICovIC8vNixcblx0cmFkaXVzSW5jcmVtZW50OiAwLjIxLCAvLzMsIC8vMC4yNSxcblx0LyogdXNlcyBsaW5lV2lkdGggbXVsdGlwbGllciAqL1xuXHRvdXRsaW5lV2lkdGg6IDMsXG5cdC8qIGZhY3RvcmVkIHRvIHJlbSB1bml0ICovXG5cdGFycm93U2l6ZTogMC40LCAvLzAuMyxcbn07XG5cbi8vIHZhciBvdmVybGF5U3R5bGVCYXNlID0ge1xuLy8gXHRnbG9iYWxBbHBoYTogMC43NSxcbi8vIFx0Z2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiBcImRlc3RpbmF0aW9uLW91dFwiLFxuLy8gXHRsaW5lV2lkdGg6IDQsXG4vLyBcdGxpbmVKb2luOiBcInJvdW5kXCIsXG4vLyBcdHRleHRCYXNlbGluZTogXCJ0b3BcIixcbi8vIFx0dGV4dEFsaWduOiBcImxlZnRcIixcbi8vIH07XG5cbmlmIChERUJVRykge1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHR2YXIgX2RTdHlsZXMgPSB7XG5cdFx0ZGVmYXVsdHM6IHtcblx0XHRcdGdsb2JhbEFscGhhOiAwLjY2LFxuXHRcdFx0bGluZVdpZHRoOiAwLFxuXHRcdFx0ZmlsbFN0eWxlOiBcInRyYW5zcGFyZW50XCIsXG5cdFx0XHRzdHJva2VTdHlsZTogXCJ0cmFuc3BhcmVudFwiLFxuXHRcdFx0bGluZURhc2hPZmZzZXQ6IDAsXG5cdFx0XHRzZXRMaW5lRGFzaDogW1tdXVxuXHRcdH1cblx0fTtcblxuXHQvKiBTdHJva2UgKi9cblx0W1xuXHRcdFwicmVkXCIsIFwic2FsbW9uXCIsIFwic2llbm5hXCIsXG5cdFx0XCJncmVlblwiLCBcInllbGxvd2dyZWVuXCIsIFwib2xpdmVcIixcblx0XHRcImJsdWVcIiwgXCJsaWdodHNreWJsdWVcIiwgXCJtaWRuaWdodGJsdWVcIixcblx0XHRcImdyZXlcIiwgXCJzaWx2ZXJcIlxuXHRdXG5cdC5mb3JFYWNoKGZ1bmN0aW9uKGNvbG9yTmFtZSkge1xuXHRcdHZhciByZ2JhVmFsdWUgPSBDb2xvcihjb2xvck5hbWUpLmFscGhhKDAuNzUpLnN0cmluZygpO1xuXG5cdFx0X2RTdHlsZXNbY29sb3JOYW1lXSA9IF8uZGVmYXVsdHMoe1xuXHRcdFx0bGluZVdpZHRoOiAwLjc1LFxuXHRcdFx0c3Ryb2tlU3R5bGU6IHJnYmFWYWx1ZSxcblx0XHR9LCBfZFN0eWxlc1tcImRlZmF1bHRzXCJdKTtcblxuXHRcdF9kU3R5bGVzW2NvbG9yTmFtZSArIFwiX2Rhc2hlZFwiXSA9IF8uZGVmYXVsdHMoe1xuXHRcdFx0c2V0TGluZURhc2g6IFtbNCwgMl1dLFxuXHRcdFx0c3Ryb2tlU3R5bGU6IHJnYmFWYWx1ZSxcblx0XHR9LCBfZFN0eWxlc1tcImRlZmF1bHRzXCJdKTtcblxuXHRcdF9kU3R5bGVzW2NvbG9yTmFtZSArIFwiX3RoaWNrXCJdID0gXy5kZWZhdWx0cyh7XG5cdFx0XHRsaW5lV2lkdGg6IDUsXG5cdFx0XHRzdHJva2VTdHlsZTogcmdiYVZhbHVlLFxuXHRcdH0sIF9kU3R5bGVzW1wiZGVmYXVsdHNcIl0pO1xuXG5cdFx0X2RTdHlsZXNbY29sb3JOYW1lICsgXCJfZmlsbFwiXSA9IF8uZGVmYXVsdHMoe1xuXHRcdFx0ZmlsbFN0eWxlOiByZ2JhVmFsdWVcblx0XHR9LCBfZFN0eWxlc1tcImRlZmF1bHRzXCJdKTtcblx0fSlcblx0LyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xufVxuXG52YXIgZ2V0UmVjdERpclggPSBmdW5jdGlvbihyMSwgcjIpIHtcblx0aWYgKHIxLnJpZ2h0IDwgcjIubGVmdCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cdGlmIChyMi5yaWdodCA8IHIxLmxlZnQpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblx0cmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9jb21wb25lbnQvR3JhcGhWaWV3fVxuICovXG52YXIgR3JhcGhWaWV3ID0gQ2FudmFzVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwiZ3JhcGhcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0YWdOYW1lOiBcImNhbnZhc1wiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJncmFwaFwiLFxuXG5cdGRlZmF1bHRLZXk6IFwiYTJiXCIsXG5cblx0ZGVmYXVsdHM6IHtcblx0XHR2YWx1ZXM6IHtcblx0XHRcdGEyYjogMCxcblx0XHRcdGIyYTogMCxcblx0XHR9LFxuXHRcdG1heFZhbHVlczoge1xuXHRcdFx0YTJiOiAxLFxuXHRcdFx0YjJhOiAxLFxuXHRcdH0sXG5cdFx0Ly8gdXNlT3BhcXVlOiB0cnVlLFxuXHRcdC8vIGxhYmVsRm46IGZ1bmN0aW9uKHZhbHVlLCBtYXgpIHtcblx0XHQvLyBcdHJldHVybiAoKHZhbHVlIC8gbWF4KSAqIDEwMCkgfCAwO1xuXHRcdC8vIH0sXG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0Q2FudmFzVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0dGhpcy5fbGlzdEEgPSBvcHRpb25zLmxpc3RBO1xuXHRcdHRoaXMuX2xpc3RCID0gb3B0aW9ucy5saXN0Qjtcblx0XHR0aGlzLl9hMmIgPSB7XG5cdFx0XHRzcmNWaWV3OiBvcHRpb25zLmxpc3RBLFxuXHRcdFx0ZGVzdFZpZXc6IG9wdGlvbnMubGlzdEIsXG5cdFx0XHRzOiBfLmRlZmF1bHRzKHtcblx0XHRcdFx0bGluZVdpZHRoOiAwLjcsIC8vMS4yNVxuXHRcdFx0XHQvLyByYWRpdXNJbmNyZW1lbnQ6IDAuMjUsXG5cdFx0XHR9LCBzdHlsZUJhc2UsIHBhcmFtc0Jhc2UpLFxuXHRcdFx0cDogXy5kZWZhdWx0cyh7fSwgcGFyYW1zQmFzZSksXG5cdFx0XHRzdHJva2VTdHlsZUZuOiAoZmcsIGJnLCBsbikgPT4gQ29sb3IobG4pLm1peChiZywgMC4xKS5oZXgoKVxuXHRcdH07XG5cdFx0dGhpcy5fYjJhID0ge1xuXHRcdFx0c3JjVmlldzogb3B0aW9ucy5saXN0Qixcblx0XHRcdGRlc3RWaWV3OiBvcHRpb25zLmxpc3RBLFxuXHRcdFx0czogXy5kZWZhdWx0cyh7XG5cdFx0XHRcdGxpbmVXaWR0aDogMC43LFxuXHRcdFx0XHQvLyBhcnJvd1NpemU6IDAuMjUsXG5cdFx0XHRcdC8vIHJhZGl1c0luY3JlbWVudDogMCxcblx0XHRcdFx0Ly8gb3V0bGluZVdpZHRoOiAwLFxuXHRcdFx0fSwgc3R5bGVCYXNlLCBwYXJhbXNCYXNlKSxcblx0XHRcdHA6IF8uZGVmYXVsdHMoe30sIHBhcmFtc0Jhc2UpLFxuXHRcdFx0c3Ryb2tlU3R5bGVGbjogKGZnLCBiZywgbG4pID0+IENvbG9yKGZnKS5taXgoYmcsIDAuNCkuaGV4KClcblx0XHR9O1xuXG5cdFx0Ly8gdGhpcy5saXN0ZW5Ubyh0aGlzLl9hMmIuc3JjVmlldy5jb2xsZWN0aW9uLCBcInZpZXc6c2VsZWN0Om9uZSB2aWV3OnNlbGVjdDpub25lXCIsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHQvLyBcdHRoaXMuX2EyYi5jb25uZWN0b3JzT3V0ID0gdGhpcy5fYTJiLmNvbm5lY3RvcnM7XG5cdFx0Ly8gXHR0aGlzLl9hMmIuY29ubmVjdG9ycyA9IG51bGw7XG5cdFx0Ly8gfSk7XG5cdFx0Ly9cblx0XHQvLyB0aGlzLmxpc3RlblRvKHRoaXMuX2IyYS5zcmNWaWV3LmNvbGxlY3Rpb24sIFwidmlldzpzZWxlY3Q6b25lIHZpZXc6c2VsZWN0Om5vbmVcIiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdC8vIFx0dGhpcy5fYjJhLmNvbm5lY3RvcnNPdXQgPSB0aGlzLl9iMmEuY29ubmVjdG9ycztcblx0XHQvLyBcdHRoaXMuX2IyYS5jb25uZWN0b3JzID0gbnVsbDtcblx0XHQvLyB9KTtcblxuXHRcdC8vIHRoaXMubGlzdGVuVG8odGhpcywgXCJ2aWV3OnJlbmRlcjpiZWZvcmVcIiwgdGhpcy5fYmVmb3JlVmlld1JlbmRlcik7XG5cblx0XHQvLyB0aGlzLl90cmFjZVNjcm9sbCA9IF8uZGVib3VuY2UodGhpcy5fX3JhY2VTY3JvbGwsIDEwMCwgZmFsc2UpO1xuXG5cdFx0Ly8gdmFyIHZpZXdwb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZyhcIiVzOlslc11cIiwgdGhpcy5jaWQsIGV2LnR5cGUpO1xuXHRcdC8vXG5cdFx0Ly8gXHQvLyB0aGlzLl90cmFjZVNjcm9sbChldi50eXBlKTtcblx0XHQvLyBcdC8vIHRoaXMuX2xhYmVsT3ZlcmxheXMgPSBudWxsO1xuXHRcdC8vIFx0dGhpcy5pbnZhbGlkYXRlKENhbnZhc1ZpZXcuTEFZT1VUX0lOVkFMSUQgfCBDYW52YXNWaWV3LlNJWkVfSU5WQUxJRCk7XG5cdFx0Ly8gXHQvLyB0aGlzLnJlcXVlc3RSZW5kZXIoQ2FudmFzVmlldy5MQVlPVVRfSU5WQUxJRCB8IENhbnZhc1ZpZXcuU0laRV9JTlZBTElEKTtcblx0XHQvLyBcdC8vIHRoaXMucmVxdWVzdFJlbmRlcigpLnJlbmRlck5vdygpO1xuXHRcdC8vIH0uYmluZCh0aGlzKTtcblx0XHQvLyB2aWV3cG9ydENoYW5nZWQgPSBfLmRlYm91bmNlKHZpZXdwb3J0Q2hhbmdlZCwgNjAsIGZhbHNlKTtcblxuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsXG5cdFx0Ly8gXHRcdF8uZGVib3VuY2Uodmlld3BvcnRDaGFuZ2VkLCAxMDAsIGZhbHNlKSwgZmFsc2UpO1xuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIixcblx0XHQvLyBcdF8uZGVib3VuY2Uodmlld3BvcnRDaGFuZ2VkLCAxMDAsIGZhbHNlKSwgZmFsc2UpO1xuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHZpZXdwb3J0Q2hhbmdlZCwgZmFsc2UpO1xuXHRcdC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdmlld3BvcnRDaGFuZ2VkLCBmYWxzZSk7XG5cdFx0Ly8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdmlld3BvcnRDaGFuZ2VkLCBmYWxzZSk7XG5cdFx0Ly8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB2aWV3cG9ydENoYW5nZWQsIGZhbHNlKTtcblxuXHRcdC8vIHRoaXMuX2FkZExpc3RMaXN0ZW5lcnModGhpcy5fYTJiKTtcblx0XHQvLyB0aGlzLl9hZGRMaXN0TGlzdGVuZXJzKHRoaXMuX2IyYSk7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRtZWFzdXJlQ2FudmFzOiBmdW5jdGlvbih3LCBoLCBzKSB7XG5cdFx0Y29uc29sZS5sb2coXCIlczo6bWVhc3VyZUNhbnZhcyBzdHlsZTolbyBzY3JvbGw6JW8gb2Zmc2V0OiVvIGNsaWVudDolbyBhcmc6JW9cIiwgdGhpcy5jaWQsIHMuaGVpZ2h0LCB0aGlzLmVsLm9mZnNldEhlaWdodCwgdGhpcy5lbC5zY3JvbGxIZWlnaHQsIHRoaXMuZWwuY2xpZW50SGVpZ2h0LCBoKTtcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHVwZGF0ZUNhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdXBkYXRlTWV0cmljcygpO1xuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlcygpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHN0eWxlc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfdXBkYXRlU3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYiwgYmdDb2xvciwgbG5Db2xvcjtcblx0XHRpZiAodGhpcy5tb2RlbC5oYXMoXCJidW5kbGVcIikpIHtcblx0XHRcdGIgPSB0aGlzLm1vZGVsLmdldChcImJ1bmRsZVwiKTtcblx0XHRcdGxuQ29sb3IgPSBDb2xvcihiLmNvbG9ycy5sbkNvbG9yKTsgLy8uY2xvbmUoKTtcblx0XHRcdGJnQ29sb3IgPSBDb2xvcihiLmNvbG9ycy5iZ0NvbG9yKTsgLy8uY2xvbmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YmdDb2xvciA9IENvbG9yKEdsb2JhbHMuREVGQVVMVF9DT0xPUlNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdKTtcblx0XHRcdGxuQ29sb3IgPSBDb2xvcihHbG9iYWxzLkRFRkFVTFRfQ09MT1JTW1wibGluay1jb2xvclwiXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYTJiLnMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9hMmIucy5maWxsU3R5bGUgPVxuXHRcdFx0dGhpcy5fYTJiLnN0cm9rZVN0eWxlRm4odGhpcy5fY29sb3IsIGJnQ29sb3IsIGxuQ29sb3IpO1xuXHRcdHRoaXMuX2IyYS5zLnN0cm9rZVN0eWxlID0gdGhpcy5fYjJhLnMuZmlsbFN0eWxlID1cblx0XHRcdHRoaXMuX2IyYS5zdHJva2VTdHlsZUZuKHRoaXMuX2NvbG9yLCBiZ0NvbG9yLCBsbkNvbG9yKTtcblxuXHRcdGlmIChERUJVRykge1xuXHRcdFx0dGhpcy5fZGVidWdCbG9ja3MgPSB0aGlzLmVsLm1hdGNoZXMoXCIuZGVidWctYmxvY2tzIC5cIiArIHRoaXMuY2xhc3NOYW1lKTtcblx0XHRcdHRoaXMuX2RlYnVnR3JhcGggPSB0aGlzLmVsLm1hdGNoZXMoXCIuZGVidWctZ3JhcGggLlwiICsgdGhpcy5jbGFzc05hbWUpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0U3R5bGU6IGZ1bmN0aW9uKHMpIHtcblx0XHRpZiAodHlwZW9mIHMgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0cyA9IHRoaXMuX3N0eWxlRGF0YVtzXTtcblx0XHR9XG5cdFx0Q2FudmFzVmlldy5zZXRTdHlsZSh0aGlzLl9jdHgsIHMpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIG1ldHJpY3Ncblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X3VwZGF0ZU1ldHJpY3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBib3VuZHM7XG5cblx0XHR0aGlzLl9yb290Rm9udFNpemUgPSBwYXJzZUZsb2F0KFxuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplKTtcblxuXHRcdGJvdW5kcyA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Ly8gYm91bmRzID0gZ2V0QWJzb2x1dGVDbGllbnRSZWN0KHRoaXMuZWwpO1xuXHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0odGhpcy5fY2FudmFzUmF0aW8sIDAsIDAsIHRoaXMuX2NhbnZhc1JhdGlvLFxuXHRcdFx0KC0oYm91bmRzLmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQpICogdGhpcy5fY2FudmFzUmF0aW8pIC0gMC41LFxuXHRcdFx0KC0oYm91bmRzLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCkgKiB0aGlzLl9jYW52YXNSYXRpbykgLSAwLjVcblx0XHQpO1xuXG5cdFx0dmFyIGksIGlpLCBlbHM7XG5cdFx0dmFyIHNyY1JlY3QsIGRlc3RSZWN0O1xuXHRcdHZhciBzcmNNaW4sIGRlc3RNaW47XG5cblx0XHRzcmNSZWN0ID0gdGhpcy5fYTJiLnNyY1ZpZXcuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ZGVzdFJlY3QgPSB0aGlzLl9hMmIuZGVzdFZpZXcuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0dGhpcy5fYTJiLnF4ID0gZ2V0UmVjdERpclgoc3JjUmVjdCwgZGVzdFJlY3QpO1xuXG5cdFx0ZWxzID0gdGhpcy5fbGlzdEEuZWwucXVlcnlTZWxlY3RvckFsbChcIi5sYWJlbFwiKTtcblx0XHRzcmNNaW4gPSBzcmNSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG5cdFx0Zm9yIChpID0gMCwgaWkgPSBlbHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0c3JjTWluID0gTWF0aC5tYXgoc3JjTWluLFxuXHRcdFx0XHRlbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgKyB3aW5kb3cucGFnZVhPZmZzZXQpO1xuXHRcdH1cblx0XHR0aGlzLl9hMmIueE1pbiA9IHNyY01pbjtcblxuXHRcdGVscyA9IHRoaXMuX2xpc3RCLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGFiZWxcIik7XG5cdFx0ZGVzdE1pbiA9IGRlc3RSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG5cdFx0Zm9yIChpID0gMCwgaWkgPSBlbHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0ZGVzdE1pbiA9IE1hdGgubWluKGRlc3RNaW4sXG5cdFx0XHRcdGVsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0KTtcblx0XHR9XG5cdFx0dGhpcy5fYTJiLmRlc3RNaW5YID0gZGVzdE1pbjtcblxuXHRcdHRoaXMuX2IyYS5xeCA9IC10aGlzLl9hMmIucXg7XG5cdFx0dGhpcy5fYjJhLnhNaW4gPSB0aGlzLl9hMmIuZGVzdE1pblg7XG5cdFx0dGhpcy5fYjJhLmRlc3RNaW5YID0gdGhpcy5fYTJiLnhNaW47XG5cblx0XHQvLyB2YXIgcyA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblx0XHQvLyB0aGlzLl9yb290Rm9udFNpemUgPSBwYXJzZUZsb2F0KHMuZm9udFNpemUpOyAvLyAqIHRoaXMuX2NhbnZhc1JhdGlvO1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6Ol91cGRhdGVNZXRyaWNzIF9yb290Rm9udFNpemU6ICVzICVvXCIsIHRoaXMuY2lkLCB0aGlzLl9yb290Rm9udFNpemUsIHMpO1xuXG5cdFx0Ly8gdmFyIGMgPSBNYXRoLmFicyhzRGF0YS54TWluIC0gZERhdGEueE1pbikgLyA2O1xuXHRcdC8vIHNNaW4gPSBzRGF0YS54TWluICsgYyAqIHF4O1xuXHRcdC8vIGRNaW4gPSBkRGF0YS54TWluIC0gYyAqIHF4O1xuXG5cdFx0Ly8gdGhpcy5fYTJiLnRhcmdldHMgPSB0aGlzLl9tZWFzdXJlTGlzdEl0ZW1zKGxpc3RWaWV3KTtcblx0XHQvLyB0aGlzLl9iMmEudGFyZ2V0cyA9IHRoaXMuX21lYXN1cmVMaXN0SXRlbXMobGlzdFZpZXcpO1xuXG5cdFx0Ly8gLy8gY29ubmVjdG9yIG1pbmltdW0gYnJhbmNoIHgyXG5cdFx0Ly8gbGlzdFZpZXcgPSB0aGlzLl9saXN0Qjtcblx0XHQvLyBmb3IgKGkgPSAwLCBpaSA9IGxpc3RWaWV3Lmdyb3Vwcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0Ly8gXHRpdGVtVmlldyA9IGxpc3RWaWV3Lml0ZW1WaWV3cy5maW5kQnlNb2RlbChsaXN0Vmlldy5ncm91cHNbaV0pO1xuXHRcdC8vIFx0aXRlbVJlY3QgPSAoaXRlbVZpZXcubGFiZWwgfHwgaXRlbVZpZXcuZWwpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdC8vIFx0dGhpcy5fYjJhLnhNaW4gPSBNYXRoLm1pbih0aGlzLl9iMmEueE1pbiwgaXRlbVJlY3QubGVmdCk7XG5cdFx0Ly8gXHQvLyBpZiAoaXRlbVZpZXcuX21ldHJpY3MpIHRoaXMuX2IyYS5yZWN0LmxlZnQgKyBpdGVtVmlldy50cmFuc2Zvcm0udHggKyBpdGVtVmlldy5fbWV0cmljcy50ZXh0TGVmdDtcblx0XHQvLyB9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogcmVkcmF3XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHJlZHJhdzogZnVuY3Rpb24oY3R4LCBpbnRlcnAsIGZsYWdzKSB7XG5cdFx0dGhpcy5fY2xlYXJDYW52YXMoMCwgMCwgdGhpcy5fY2FudmFzV2lkdGgsIHRoaXMuX2NhbnZhc0hlaWdodCk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR0aGlzLl9yZWRyYXdfZnJvbUVsZW1lbnRzKGN0eCwgaW50ZXJwLCBmbGFncyk7XG5cdFx0Ly8gdGhpcy5fcmVkcmF3X2Zyb21WaWV3cyhjdHgsIGludGVycCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRfcmVkcmF3X2Zyb21FbGVtZW50czogZnVuY3Rpb24oY3R4LCBpbnRlcnAsIGZsYWdzKSB7XG5cdFx0Ly8gYjJhOiBrZXl3b3JkIHRvIGJ1bmRsZXMsIHJpZ2h0IHRvIGxlZnRcblx0XHQvLyBhMmI6IGJ1bmRsZSB0byBrZXl3b3JkcywgbGVmdCB0byByaWdodFxuXHRcdGlmIChmbGFncyAmIChDYW52YXNWaWV3LlNJWkVfSU5WQUxJRCB8IENhbnZhc1ZpZXcuTU9ERUxfSU5WQUxJRCkpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiJXM6OnJlZHJhdyBbdmFsdWVzQ2hhbmdlZDogJXNdIFtmbGFnczogJXNdXCIsIHRoaXMuY2lkLCBpbnRlcnAudmFsdWVzQ2hhbmdlZCwgQ2FudmFzVmlldy5mbGFnc1RvU3RyaW5nKGZsYWdzKSk7XG5cdFx0XHR0aGlzLl9hMmIuY29ubmVjdG9yc091dCA9IHRoaXMuX2EyYi5jb25uZWN0b3JzO1xuXHRcdFx0dGhpcy5fYjJhLmNvbm5lY3RvcnNPdXQgPSB0aGlzLl9iMmEuY29ubmVjdG9ycztcblx0XHRcdHRoaXMuX2IyYS5jb25uZWN0b3JzID0gdGhpcy5fY29tcHV0ZUNvbm5lY3RvcnModGhpcy5fYjJhKTtcblx0XHRcdHRoaXMuX2EyYi5jb25uZWN0b3JzID0gdGhpcy5fY29tcHV0ZUNvbm5lY3RvcnModGhpcy5fYTJiKTtcblx0XHRcdHRoaXMuX2xhYmVsT3ZlcmxheXMgPSB0aGlzLl9jb21wdXRlTGFiZWxPdmVybGF5cyh0aGlzLl9saXN0Qik7XG5cdFx0fVxuXG5cdFx0LyogbGluZSBkYXNoIHZhbHVlIGludGVycG9sYXRpb24gKi9cblx0XHR2YXIgYjJhVmFsLCBhMmJWYWw7XG5cdFx0YjJhVmFsID0gaW50ZXJwLmdldFJlbmRlcmVkVmFsdWUoXCJiMmFcIikgLyBpbnRlcnAuZ2V0T3B0aW9uKFwiYjJhXCIsIFwibWF4XCIpOyAvL192YWx1ZURhdGFbXCJiMmFcIl0uX21heFZhbDtcblx0XHQvLyBiMmFWYWwgPSBpbnRlcnAuX3ZhbHVlRGF0YVtcImIyYVwiXS5fcmVuZGVyZWRWYWx1ZSAvIGludGVycC5fdmFsdWVEYXRhW1wiYjJhXCJdLl9tYXhWYWw7XG5cdFx0YTJiVmFsID0gaW50ZXJwLmdldFJlbmRlcmVkVmFsdWUoXCJhMmJcIikgLyBpbnRlcnAuZ2V0T3B0aW9uKFwiYTJiXCIsIFwibWF4XCIpOyAvL2ludGVycC5fdmFsdWVEYXRhW1wiYTJiXCJdLl9tYXhWYWw7XG5cdFx0Ly8gYTJiVmFsID0gaW50ZXJwLl92YWx1ZURhdGFbXCJhMmJcIl0uX3JlbmRlcmVkVmFsdWUgLyBpbnRlcnAuX3ZhbHVlRGF0YVtcImEyYlwiXS5fbWF4VmFsO1xuXG5cdFx0LyogZHJhdyAqL1xuXHRcdHRoaXMuX2RyYXdDb25uZWN0b3JzKHRoaXMuX2IyYS5jb25uZWN0b3JzLCB0aGlzLl9iMmEucywgYjJhVmFsLCAxKTtcblx0XHR0aGlzLl9kcmF3Q29ubmVjdG9ycyh0aGlzLl9iMmEuY29ubmVjdG9yc091dCwgdGhpcy5fYjJhLnMsIDEgLSBiMmFWYWwsIDEpO1xuXHRcdHRoaXMuX2RyYXdDb25uZWN0b3JzKHRoaXMuX2EyYi5jb25uZWN0b3JzLCB0aGlzLl9hMmIucywgYTJiVmFsLCAyKTtcblx0XHQvLyB0aGlzLl9kcmF3Q29ubmVjdG9ycyh0aGlzLl9hMmIuY29ubmVjdG9yc091dCwgdGhpcy5fYTJiLnMsIDEgLSBhMmJWYWwsIDIpO1xuXHRcdHRoaXMuX2RyYXdMYWJlbE92ZXJsYXlzKHRoaXMuX2xhYmVsT3ZlcmxheXMpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIGxhYmVsIG92ZXJsYXlzXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9jb21wdXRlTGFiZWxPdmVybGF5czogZnVuY3Rpb24obGlzdCkge1xuXHRcdHZhciBkYXRhID0geyByZWN0czogW10gfTtcblx0XHR2YXIgZWxzID0gbGlzdC5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmxpc3QtZ3JvdXAgLmxhYmVsIHNwYW5cIik7XG5cblx0XHR2YXIgaSwgaWksIHI7XG5cdFx0Zm9yIChpID0gMCwgaWkgPSBlbHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0Ly8gciA9IGluZmxhdGVSZWN0KGVsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgMCwgMCk7XG5cdFx0XHRyID0gXy5jbG9uZShlbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuXHRcdFx0ci50b3AgKz0gd2luZG93LnBhZ2VZT2Zmc2V0OyAvLyAtIDAuNTtcblx0XHRcdHIubGVmdCArPSB3aW5kb3cucGFnZVhPZmZzZXQ7IC8vIC0gMC41O1xuXHRcdFx0Ly8gci5pbm5lclRleHQgPSBlbHNbaV0uaW5uZXJUZXh0O1xuXHRcdFx0ZGF0YS5yZWN0c1tpXSA9IHI7XG5cdFx0fVxuXHRcdC8vIGRhdGEuY3NzU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsc1swXSk7XG5cdFx0Ly8gZGF0YS5ib3hTdHlsZSA9IGdldEJveEVkZ2VTdHlsZXMob3ZlcmxheURhdGEuY3NzU3R5bGUpO1xuXHRcdC8vIGRhdGEuY3R4U3R5bGUgPSB7XG5cdFx0Ly8gXHRmb250OiBbcy5mb250V2VpZ2h0LCBzLmZvbnRTdHlsZSwgcy5mb250U2l6ZSArIFwiL1wiICsgcy5saW5lSGVpZ2h0LCBzLmZvbnRGYW1pbHldLmpvaW4oXCIgXCIpXG5cdFx0Ly8gfTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRfZHJhd0xhYmVsT3ZlcmxheXM6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdC8vIENhbnZhc1ZpZXcuc2V0U3R5bGUodGhpcy5fY3R4LCBzKTtcblx0XHR0aGlzLl9jdHguZ2xvYmFsQWxwaGEgPSAwLjg1O1xuXHRcdHRoaXMuX2N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW91dFwiO1xuXHRcdC8vIHRoaXMuX2N0eC5jYW52YXMuc3R5bGUubGV0dGVyU3BhY2luZyA9IG92ZXJsYXlEYXRhLmNzc1N0eWxlLmxldHRlclNwYWNpbmc7XG5cblx0XHRkYXRhLnJlY3RzLmZvckVhY2goZnVuY3Rpb24ocikge1xuXHRcdFx0Ly8gdGhpcy5fY3R4LmNsZWFyUmVjdChyLmxlZnQsIHIudG9wLCByLndpZHRoLCByLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHguZmlsbFJlY3Qoci5sZWZ0LCByLnRvcCwgci53aWR0aCwgci5oZWlnaHQpO1xuXHRcdFx0Ly8gdGhpcy5fY3R4LnN0cm9rZVRleHQoci5pbm5lclRleHQsIHIubGVmdCwgci50b3ApO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cblx0XHRpZiAoREVCVUcpIHtcblx0XHRcdGlmICh0aGlzLl9kZWJ1Z0dyYXBoIHx8IHRoaXMuX2RlYnVnQmxvY2tzKSB7XG5cdFx0XHRcdGRhdGEucmVjdHMuZm9yRWFjaChmdW5jdGlvbihyKSB7XG5cdFx0XHRcdFx0ciA9IGluZmxhdGVSZWN0KHIsIDAsIDApO1xuXHRcdFx0XHRcdENhbnZhc0hlbHBlci5kcmF3UmVjdCh0aGlzLl9jdHgsIF9kU3R5bGVzW1wic2lsdmVyX2Rhc2hlZFwiXSxcblx0XHRcdFx0XHRcdHIubGVmdCwgci50b3AsIHIud2lkdGgsIHIuaGVpZ2h0KTtcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIGNvbm5lY3RvcnNcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X2NvbXB1dGVDb25uZWN0b3JzOiBmdW5jdGlvbihkKSB7XG5cdFx0dmFyIHNNaW4gPSBkLnhNaW47XG5cdFx0dmFyIGRNaW4gPSBkLmRlc3RNaW5YO1xuXHRcdHZhciBxeCA9IGQucXg7XG5cblx0XHR2YXIgckJhc2UsIHJJbmM7XG5cdFx0ckJhc2UgPSB0aGlzLl9yb3VuZFRvKGQucy5yYWRpdXNCYXNlICogdGhpcy5fcm9vdEZvbnRTaXplLCAwLjUpO1xuXHRcdHJJbmMgPSB0aGlzLl9yb3VuZFRvKGQucy5yYWRpdXNJbmNyZW1lbnQgKiB0aGlzLl9yb290Rm9udFNpemUsIDAuNSk7XG5cblx0XHQvLyB2YXIgcm9vdCA9IHt9O1xuXHRcdHZhciBpLCBwLCBkZE51bSwgY29ubmVjdG9ycyA9IFtdO1xuXHRcdHZhciB4MSwgeTEsIHR4O1xuXG5cdFx0dmFyIHNWaWV3LCBkZFZpZXcsIGRkSXRlbXM7XG5cdFx0aWYgKGQuc3JjVmlldy5jb2xsZWN0aW9uLnNlbGVjdGVkICYmIGQuZGVzdFZpZXcuZmlsdGVyZWRJdGVtcykge1xuXHRcdFx0c1ZpZXcgPSBkLnNyY1ZpZXcuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKGQuc3JjVmlldy5jb2xsZWN0aW9uLnNlbGVjdGVkKTtcblxuXHRcdFx0dmFyIHJlY3QgPSBzVmlldy5sYWJlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdHgxID0gcmVjdC5sZWZ0O1xuXHRcdFx0eTEgPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMjtcblx0XHRcdGlmIChxeCA+IDApIHgxICs9IHJlY3Qud2lkdGg7XG5cdFx0XHR4MSArPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG5cdFx0XHR5MSArPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cblx0XHRcdC8vIGlmICghc1ZpZXcuX21ldHJpY3MpIHJldHVybjtcblx0XHRcdC8vIHgxID0gZC5yZWN0LmxlZnQgKyBzVmlldy50cmFuc2Zvcm0udHhcblx0XHRcdC8vIFx0KyBzVmlldy5fbWV0cmljcy50ZXh0TGVmdDtcblx0XHRcdC8vIHkxID0gZC5yZWN0LnRvcCArIHNWaWV3LnRyYW5zZm9ybS50eVxuXHRcdFx0Ly8gXHQrIHNWaWV3Ll9tZXRyaWNzLm9mZnNldEhlaWdodCAvIDI7XG5cdFx0XHQvLyBpZiAocXggPiAwKSB4MSArPSBzVmlldy5fbWV0cmljcy50ZXh0V2lkdGg7XG5cblx0XHRcdGRkSXRlbXMgPSBkLmRlc3RWaWV3LmZpbHRlcmVkSXRlbXM7XG5cdFx0XHRkZE51bSA9IGQuZGVzdFZpZXcuZmlsdGVyZWRJdGVtcy5sZW5ndGg7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZE51bTsgaSsrKSB7XG5cdFx0XHRcdHAgPSB7fTtcblx0XHRcdFx0ZGRWaWV3ID0gZC5kZXN0Vmlldy5pdGVtVmlld3MuZmluZEJ5TW9kZWwoZGRJdGVtc1tpXSk7XG5cblx0XHRcdFx0cmVjdCA9IGRkVmlldy5sYWJlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0cC54MiA9IHJlY3QubGVmdDtcblx0XHRcdFx0cC55MiA9IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyO1xuXHRcdFx0XHRpZiAocXggPCAwKSBwLngyICs9IHJlY3Qud2lkdGg7XG5cdFx0XHRcdHAueDIgKz0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXHRcdFx0XHRwLnkyICs9IHdpbmRvdy5wYWdlWU9mZnNldDtcblxuXHRcdFx0XHQvLyBwLngyID0gZC5kZXN0UmVjdC5sZWZ0ICsgZGRWaWV3LnRyYW5zZm9ybS50eFxuXHRcdFx0XHQvLyBcdCsgZGRWaWV3Ll9tZXRyaWNzLnRleHRMZWZ0O1xuXHRcdFx0XHQvLyBwLnkyID0gZC5kZXN0UmVjdC50b3AgKyBkZFZpZXcudHJhbnNmb3JtLnR5XG5cdFx0XHRcdC8vIFx0KyBkZFZpZXcuX21ldHJpY3Mub2Zmc2V0SGVpZ2h0IC8gMjtcblx0XHRcdFx0Ly8gaWYgKHF4IDwgMCkgcC54MiArPSBkZFZpZXcuX21ldHJpY3MudGV4dFdpZHRoO1xuXG5cdFx0XHRcdHAueDEgPSB4MTtcblx0XHRcdFx0cC55MSA9IHkxO1xuXHRcdFx0XHRwLnF4ID0gcXg7XG5cdFx0XHRcdGNvbm5lY3RvcnNbaV0gPSBwO1xuXHRcdFx0fVxuXHRcdFx0Y29ubmVjdG9ycy5zb3J0KChhLCBiKSA9PiBhLnkyIC0gYi55Mik7XG5cdFx0XHQvLyBzc0VsJ3MgbnVtYmVyIG9mIGl0ZW1zIGFib3ZlIGluIHRoZSBZIGF4aXNcblx0XHRcdHZhciBzaSA9IDA7XG5cdFx0XHQvLyBOb2RlIGZpcnN0IGFyYyAocjApIG1heCByYWRpdXMgKGN4MClcblx0XHRcdC8vIFRoZXkgYXJlIGNlbnRlcmVkIHRvIHRoZSBsYWJlbCwgc28gaGFsdmUgaXRcblx0XHRcdHZhciByTWF4MCA9IGRkTnVtICogckluYyAqIDAuNTtcblx0XHRcdC8vIGN5MSBvZmZzZXQgZnJvbSB5MVxuXHRcdFx0dmFyIGE7XG5cblx0XHRcdC8vIEZpcnN0IHBhc3MsIGNhbGMgZmlyc3QgcmFkaXVzIChyMCwgYXQgdGhlIHNvdXJjZSBvZiB0aGUgY29ubmVjdG9yKSxcblx0XHRcdC8vIGFuZCB0aGUgYW1vdW50IG9mIGRlc3QgY29ubmVjdG9ycyB2ZXJ0aWNhbGx5IGNsb3NlciB0byB0aGUgc291cmNlIChkaSlcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZE51bTsgaSsrKSB7XG5cdFx0XHRcdHAgPSBjb25uZWN0b3JzW2ldO1xuXG5cdFx0XHRcdGEgPSAoaSAtIChkZE51bSAtIDEpIC8gMikgKiBySW5jO1xuXHRcdFx0XHRwLmN5MSA9IHAueTEgKyBhO1xuXHRcdFx0XHRwLmN5MiA9IHAueTI7XG5cdFx0XHRcdHAucjAgPSBNYXRoLmFicyhhKTtcblx0XHRcdFx0cC5jeDAgPSBwLngxICsgKHJNYXgwIC0gcC5yMCkgKiBxeDtcblxuXHRcdFx0XHQvLyBJZiBzcmMgKGN5MSkgaXMgYWJvdmUgZGVzdCAoeTIpLCBkZWNyZWFzZSBpbmRleCBkaWZmIChkaSlcblx0XHRcdFx0cC5kaSA9ICgocC5jeTEgLSBwLnkyKSA+IDApID8gaSA6IGRkTnVtIC0gKGkgKyAxKTtcblx0XHRcdFx0c2kgPSBNYXRoLm1heChzaSwgcC5kaSk7XG5cblx0XHRcdFx0Ly8gcC5keCA9IHgxIC0gcC54Mjtcblx0XHRcdFx0Ly8gcC5keSA9IHkxIC0gcC55Mjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsYyBtYXggcmFkaXVzIHRoYXQgZml0cyBzTWluIHRvIGRNaW46XG5cdFx0XHQvLyBmcm9tIHNwYWNlIGJ0dyBzTWluIHRvIGRNaW4sIHJlbW92ZSBmaXJzdCBhcmMgYW5kIG1heCBhcmMgaW5jcmVhc2UsXG5cdFx0XHQvLyB0aGVuIGhhbHZlICh0aGVyZSdzIHR3byBhcmNzIGxlZnQpXG5cdFx0XHR2YXIgckJhc2VNYXggPSAoTWF0aC5hYnMoZE1pbiAtIHNNaW4pIC0gKHJNYXgwICsgKHNpICogckluYykpKSAvIDI7XG5cdFx0XHQvLyBFbnN1cmUgMCA+IHJCYXNlID4gckJhc2VNYXhcblx0XHRcdHJCYXNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ockJhc2UsIHJCYXNlTWF4KSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjpfY29tcHV0ZUNvbm5lY3RvcnMgMXJlbSA9ICVzcHggckJhc2U6JXMgckJhc2VNYXg6JXNcIiwgdGhpcy5jaWQsIHRoaXMuX3Jvb3RGb250U2l6ZSwgckJhc2UsIHJCYXNlTWF4KTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRkTnVtOyBpKyspIHtcblx0XHRcdFx0cCA9IGNvbm5lY3RvcnNbaV07XG5cdFx0XHRcdHAucjEgPSBwLmRpICogckluYyArIHJCYXNlO1xuXHRcdFx0XHRwLnIyID0gckJhc2U7XG5cblx0XHRcdFx0Ly8gcC5yMSA9IHAuZGkgKiBySW5jICsgckJhc2U7XG5cdFx0XHRcdC8vIHAucjIgPSAoc2kgLSBwLmRpKSAqIHJJbmMgKyByQmFzZTtcblxuXHRcdFx0XHRwLmN4MSA9IHNNaW4gKyAock1heDAgKiBxeCk7XG5cdFx0XHRcdHAuY3gyID0gZE1pbiAtICgoc2kgLSBwLmRpKSAqIHJJbmMpICogcXg7XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIHAuY3gxID0gc01pbiArIChyTWF4MCAqIHF4KTtcblx0XHRcdFx0Ly8gcC5jeDIgPSBkTWluO1xuXG5cdFx0XHRcdHR4ID0gY2FsY0FyY0hDb25uZWN0b3IocC5jeDEsIHAuY3kxLCBwLnIxLCBwLmN4MiwgcC5jeTIsIHAucjIsIDAuOSk7XG5cdFx0XHRcdGlmICh0eCkge1xuXHRcdFx0XHRcdHAudHgxID0gdHhbMF07XG5cdFx0XHRcdFx0cC50eDIgPSB0eFsxXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwLnR4MSA9IHAuY3gxO1xuXHRcdFx0XHRcdHAudHgyID0gcC5jeDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cC5sZW5ndGggPSBNYXRoLmFicyhwLngxIC0gcC54MikgKyBNYXRoLmFicyhwLmN5MSAtIHAuY3kyKTtcblxuXHRcdFx0XHQvLyBGaW5kIG91dCBsb25nZXN0IG5vZGUgY29ubmVjdGlvbiBmb3Igc2V0TGluZURhc2hcblx0XHRcdFx0Ly8gcm9vdC5tYXhMZW5ndGggPSBNYXRoLm1heChyb290Lm1heExlbmd0aCwgcC5sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdFx0Y29ubmVjdG9ycy5zb3J0KChhLCBiKSA9PlxuXHRcdFx0XHRhLmRpIC0gYi5kaSAvLyBTb3J0IGJ5IGluZGV4IGRpc3RhbmNlIHRvIGZyb20gc291cmNlIHBvaW50XG5cdFx0XHRcdC8vIGEucjAgLSBiLnIwIC8vIFNvcnQgYnkgZmlyc3QgYXJjIChjZW50ZXJlZClcblx0XHRcdFx0Ly8gKGEucjEgKyBhLnIyKSAtIChiLnIxICsgYi5yMilcblx0XHRcdFx0Ly8gYS50eDIgLSBiLnR4MlxuXHRcdFx0KTtcblxuXHRcdFx0Y29ubmVjdG9ycy5zaSA9IHNpO1xuXHRcdFx0Y29ubmVjdG9ycy5xeCA9IHF4O1xuXHRcdFx0Y29ubmVjdG9ycy5zTWluID0gc01pbjtcblx0XHRcdGNvbm5lY3RvcnMuZE1pbiA9IGRNaW47XG5cdFx0XHQvLyByb290LnggPSB4MTtcblx0XHRcdC8vIHJvb3QueSA9IHkxO1xuXHRcdFx0Ly8gcm9vdC5xeCA9IHF4O1xuXHRcdFx0Ly8gcm9vdC5yMCA9IHNpICogckluYztcblx0XHR9XG5cdFx0Ly8gZC5jb25uZWN0b3JzID0gY29ubmVjdG9ycztcblx0XHQvLyBkLnJvb3QgPSByb290O1xuXHRcdC8vIHJldHVybiBkO1xuXHRcdHJldHVybiBjb25uZWN0b3JzO1xuXHR9LFxuXG5cdF9kcmF3Q29ubmVjdG9yczogZnVuY3Rpb24ocHAsIHMsIGxWYWwsIGRpcikge1xuXHRcdHZhciBpLCBpaSwgcDtcblx0XHR2YXIgb3csIHJhMSwgcmEyLCB0YTtcblxuXHRcdGlmICghKHBwICYmIHBwLmxlbmd0aCAmJiBsVmFsKSkgcmV0dXJuO1xuXG5cdFx0aWkgPSBwcC5sZW5ndGg7XG5cblx0XHQvKiBvdXRsaW5lIHdpZHRoICovXG5cdFx0b3cgPSBzLmxpbmVXaWR0aCArIHMub3V0bGluZVdpZHRoO1xuXHRcdC8vIG93ID0gTWF0aC5taW4oXG5cdFx0Ly8gXHR0aGlzLl9yb3VuZFRvKHMucmFkaXVzSW5jcmVtZW50ICogdGhpcy5fcm9vdEZvbnRTaXplLCAwLjUpLFxuXHRcdC8vIFx0dGhpcy5fcm91bmRUbyhzLmxpbmVXaWR0aCAqICgxICsgcy5vdXRsaW5lV2lkdGgpLCAwLjUpXG5cdFx0Ly8gKTtcblxuXHRcdC8qIGFycm93IHJhZGl1c2VzLCBkaXJlY3Rpb24gKi9cblx0XHQvLyByYTEgPSAocy5yYWRpdXNJbmNyZW1lbnQgKiB0aGlzLl9yb290Rm9udFNpemUpICsgcy5saW5lV2lkdGg7XG5cdFx0cmExID0gcy5hcnJvd1NpemUgKiB0aGlzLl9yb290Rm9udFNpemU7XG5cdFx0cmEyID0gcmExICsgKG93IC0gcy5saW5lV2lkdGgpO1xuXHRcdHRhID0gTWF0aC5QSSAqIGRpcjtcblx0XHQvLyBkaXIgLT0gMjtcblxuXHRcdHRoaXMuX3NldFN0eWxlKHMpO1xuXG5cdFx0Ly8gaWYgKGxWYWwgPCAxKSB7XG5cdFx0Ly8gXHR0aGlzLl9jdHgubGluZURhc2hPZmZzZXQgPSBsTWF4ICogKDEgKyBsVmFsKTtcblx0XHQvLyBcdHRoaXMuX2N0eC5zZXRMaW5lRGFzaChbbE1heCwgbE1heF0pXG5cdFx0Ly8gXHQvLyB0aGlzLl9jdHgubGluZURhc2hPZmZzZXQgPSBsTWF4ICogKDEgKyBsVmFsKTs7XG5cdFx0Ly8gXHQvLyB0aGlzLl9jdHguc2V0TGluZURhc2goW2xNYXggKiAoMSAtIGxWYWwpLCBsTWF4XSk7XG5cdFx0Ly8gfVxuXG5cdFx0Ly8gZm9yIChpID0gMDsgaSA8IGlpOyBpKyspIHtcblx0XHQvLyBwID0gcHBbaV07XG5cdFx0aWYgKHMub3V0bGluZVdpZHRoKSB7XG5cdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tb3V0XCI7XG5cdFx0XHR0aGlzLl9jdHgubGluZVdpZHRoID0gb3c7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0XHRwID0gcHBbaV07XG5cblx0XHRcdFx0aWYgKGxWYWwgPCAxKSB7XG5cdFx0XHRcdFx0dGhpcy5fY3R4LmxpbmVEYXNoT2Zmc2V0ID0gcC5sZW5ndGggKiAoMSArIGxWYWwpO1xuXHRcdFx0XHRcdHRoaXMuX2N0eC5zZXRMaW5lRGFzaChbcC5sZW5ndGgsIHAubGVuZ3RoXSlcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9kcmF3Q29ubmVjdG9yKHAsIGksIHBwKTtcblx0XHRcdFx0aWYgKGxWYWwgPT0gMSkge1xuXHRcdFx0XHRcdHRoaXMuX2RyYXdBcnJvd2hlYWQocC54MiwgcC55MiwgcmEyLCBkaXIgKiB0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlpOyBpKyspIHtcblx0XHRcdHAgPSBwcFtpXTtcblx0XHRcdGlmIChsVmFsIDwgMSkge1xuXHRcdFx0XHR0aGlzLl9jdHgubGluZURhc2hPZmZzZXQgPSBwLmxlbmd0aCAqICgxICsgbFZhbCk7XG5cdFx0XHRcdHRoaXMuX2N0eC5zZXRMaW5lRGFzaChbcC5sZW5ndGgsIHAubGVuZ3RoXSlcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RyYXdDb25uZWN0b3IocCwgaSwgcHApO1xuXHRcdFx0aWYgKGxWYWwgPT0gMSkge1xuXHRcdFx0XHR0aGlzLl9kcmF3QXJyb3doZWFkKHAueDIsIHAueTIsIHJhMSwgZGlyICogdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZHJhd0Fycm93aGVhZDogZnVuY3Rpb24oeCwgeSwgciwgdCkge1xuXHRcdC8vIHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0Ly8gdGhpcy5fY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcblx0XHQvLyB0aGlzLl9jdHguc2V0TGluZURhc2goW10pO1xuXHRcdENhbnZhc0hlbHBlci5hcnJvd2hlYWQyKHRoaXMuX2N0eCwgeCwgeSwgciwgdCk7XG5cdFx0dGhpcy5fY3R4LnN0cm9rZSgpO1xuXHRcdC8vIHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0X2RyYXdBcnJvd2hlYWQyOiBmdW5jdGlvbih4LCB5LCByLCB0KSB7XG5cdFx0Q2FudmFzSGVscGVyLmFycm93aGVhZCh0aGlzLl9jdHgsIHgsIHksIHIsIHQpO1xuXHRcdHRoaXMuX2N0eC5maWxsKCk7XG5cdH0sXG5cblx0Ly8gX2RyYXdBcnJvd2hlYWRIOiBmdW5jdGlvbih4LCB5LCByLCBhKSB7XG5cdC8vIFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0Ly8gXHR0aGlzLl9jdHgubGluZURhc2hPZmZzZXQgPSAwO1xuXHQvLyBcdHRoaXMuX2N0eC5zZXRMaW5lRGFzaChbXSk7XG5cdC8vIFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHQvLyBcdHRoaXMuX2N0eC5tb3ZlVG8oeCArIHIgKiAxIC8gZGlyLCB5IC0gcik7XG5cdC8vIFx0dGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcblx0Ly8gXHR0aGlzLl9jdHgubGluZVRvKHggKyByICogMSAvIGRpciwgeSArIHIpO1xuXHQvLyBcdHRoaXMuX2N0eC5zdHJva2UoKTtcblx0Ly8gXHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHQvLyB9LFxuXG5cdF9kcmF3Q29ubmVjdG9yOiBmdW5jdGlvbihwLCBpLCBwcCkge1xuXHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHR0aGlzLl9jdHgubW92ZVRvKHAueDIsIHAuY3kyKTtcblx0XHR0aGlzLl9jdHguYXJjVG8ocC50eDIsIHAuY3kyLCBwLnR4MSwgcC5jeTEsIHAucjIpO1xuXHRcdHRoaXMuX2N0eC5hcmNUbyhwLnR4MSwgcC5jeTEsIHAuY3gxLCBwLmN5MSwgcC5yMSk7XG5cdFx0dGhpcy5fY3R4LmFyY1RvKHAuY3gwLCBwLmN5MSwgcC5jeDAsIHAueTEsIHAucjApO1xuXG5cdFx0Ly8gcC5jeDAwID0gcC54MSArICgocC5yMCArIHAuZGkpICogcC5xeCk7XG5cdFx0Ly8gcC5jeTAwID0gKHAuY3kxICsgcC55MSkgLyAyO1xuXHRcdC8vIHRoaXMuX2N0eC5hcmNUbyhwLmN4MDAsIHAuY3kxLCBwLmN4MDAsIHAuY3kwMCwgcC5yMCAvIDIpO1xuXHRcdC8vIHRoaXMuX2N0eC5hcmNUbyhwLmN4MDAsIHAueTEsIHAueDEsIHAueTEsIHAucjAgLyAyKTtcblx0XHQvLyB0aGlzLl9jdHgubGluZVRvKHAueDEsIHAueTEpO1xuXG5cdFx0Ly8gcC5jeDAwID0gcC54MSArIChwLnIwICogcC5xeCAqIDIpO1xuXHRcdC8vIHRoaXMuX2N0eC5saW5lVG8ocC5jeDAwLCBwLmN5MSk7XG5cdFx0Ly8gdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8ocC5jeDAsIHAuY3kxLCBwLmN4MCwgcC55MSk7XG5cblx0XHQvLyB0aGlzLl9jdHgubGluZVRvKHAuY3gwLCBwLnkxKTtcblx0XHR0aGlzLl9jdHguc3Ryb2tlKCk7XG5cdH0sXG5cblx0X3JvdW5kVG86IGZ1bmN0aW9uKG4sIHApIHtcblx0XHRpZiAocCA+IDEpIHAgPSAxIC8gcDtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChuIC8gcCkgKiBwO1xuXHR9LFxuXG5cdC8qXG5cdF9jb21wdXRlQ29ubmVjdG9yczogZnVuY3Rpb24oZCkge1xuXHRcdHZhciByQmFzZSA9IGQucy5yYWRpdXNCYXNlO1xuXHRcdHZhciBySW5jID0gZC5zLnJhZGl1c0luY3JlbWVudDtcblx0XHR2YXIgc01pbiA9IGQueE1pbjtcblx0XHR2YXIgZE1pbiA9IGQuZGVzdE1pblg7XG5cblx0XHR2YXIgbE1heCA9IDA7XG5cdFx0dmFyIHAsIGNvbm5lY3RvcnMgPSBbXTtcblx0XHR2YXIgcXgsIHgxLCB5MSwgdHg7XG5cdFx0dmFyIHNpOyAvLyBzc0VsJ3MgbnVtYmVyIG9mIGl0ZW1zIGFib3ZlIGluIHRoZSBZIGF4aXNcblxuXHRcdGlmIChkLnJlY3QucmlnaHQgPCBkLmRlc3RSZWN0LmxlZnQpIHtcblx0XHRcdHF4ID0gMTtcblx0XHR9IGVsc2UgaWYgKGQuZGVzdFJlY3QucmlnaHQgPCBkLnJlY3QubGVmdCkge1xuXHRcdFx0cXggPSAtMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXggPSAwO1xuXHRcdH1cblxuXHRcdHZhciBzc0VsLCBkZEVscywgZGROdW0sIHNzUmVjdCwgZGRSZWN0LCBpO1xuXHRcdHNzRWwgPSBkLnNyY1ZpZXcuZWwucXVlcnlTZWxlY3RvcihcIi5saXN0LWl0ZW0uc2VsZWN0ZWQgLmxhYmVsXCIpO1xuXHRcdGlmIChzc0VsKSB7XG5cdFx0XHRzc1JlY3QgPSBzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0eDEgPSBzc1JlY3QubGVmdDtcblx0XHRcdGlmIChxeCA+IDApIHgxICs9IHNzUmVjdC53aWR0aDtcblx0XHRcdHkxID0gc3NSZWN0LnRvcCArIHNzUmVjdC5oZWlnaHQgLyAyO1xuXHRcdFx0Ly8gcjIgPSByQmFzZTtcblx0XHRcdC8vIGN4MSA9IGQueE1pbjtcblxuXHRcdFx0c2kgPSAwO1xuXHRcdFx0ZGRFbHMgPSBkLmRlc3RWaWV3LmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGlzdC1pdGVtOm5vdCguZXhjbHVkZWQpIC5sYWJlbFwiKTtcblx0XHRcdGRkTnVtID0gZGRFbHMubGVuZ3RoO1xuXHRcdFx0Ly8gZHggPSBNYXRoLmFicyhkLnhNaW4gLSBkRGF0YS54TWluKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRkTnVtOyBpKyspIHtcblx0XHRcdFx0cCA9IHt9O1xuXHRcdFx0XHRkZFJlY3QgPSBkZEVsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0cC54MiA9IGRkUmVjdC5sZWZ0O1xuXHRcdFx0XHRpZiAocXggPCAwKSBwLngyICs9IGRkUmVjdC53aWR0aDtcblx0XHRcdFx0cC55MiA9IGRkUmVjdC50b3AgKyBkZFJlY3QuaGVpZ2h0IC8gMjtcblx0XHRcdFx0cC54MSA9IHgxO1xuXHRcdFx0XHRwLnkxID0geTE7XG5cdFx0XHRcdHAuZHggPSBwLngxIC0gcC54Mjtcblx0XHRcdFx0cC5keSA9IHAueTEgLSBwLnkyO1xuXHRcdFx0XHRwLnF4ID0gcXg7XG5cdFx0XHRcdHAucXkgPSBNYXRoLnNpZ24ocC5keSk7XG5cdFx0XHRcdC8vIHAuZExlbmd0aCA9IE1hdGguYWJzKHAueCkgKyBNYXRoLmFicyhwLnkpO1xuXHRcdFx0XHRwLmRpID0gcC5keSA+IDAgPyBpIDogZGROdW0gLSAoaSArIDEpO1xuXHRcdFx0XHRzaSA9IE1hdGgubWF4KHNpLCBwLmRpKTtcblx0XHRcdFx0Y29ubmVjdG9yc1tpXSA9IHA7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhLCByTWF4MCA9IGRkTnVtICogMC41ICogckluYztcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZE51bTsgaSsrKSB7XG5cdFx0XHRcdHAgPSBjb25uZWN0b3JzW2ldO1xuXHRcdFx0XHRwLnIxID0gcC5kaSAqIHJJbmMgKyByQmFzZTtcblx0XHRcdFx0cC5yMiA9IHJCYXNlO1xuXHRcdFx0XHQvLyBwLnIyID0gKHNpIC0gcC5kaSkgKiBySW5jICsgckJhc2U7XG5cblx0XHRcdFx0cC5jeDEgPSBzTWluO1xuXHRcdFx0XHRwLmN4MiA9IGRNaW4gLSAoKHNpIC0gcC5kaSkgKiBySW5jKSAqIHF4O1xuXHRcdFx0XHQvLyBwLmN4MiA9IGRNaW47XG5cblx0XHRcdFx0YSA9IChpIC0gKGRkTnVtIC0gMSkgLyAyKSAqIHJJbmM7XG5cdFx0XHRcdHAuY3kxID0gcC55MSArIGE7XG5cdFx0XHRcdHAuY3kyID0gcC55MjtcblxuXHRcdFx0XHRhID0gTWF0aC5hYnMoYSk7XG5cdFx0XHRcdHAucjAgPSBhO1xuXHRcdFx0XHRwLmN4MCA9IHAueDEgKyAock1heDAgLSBhKSAqIHF4O1xuXG5cdFx0XHRcdHR4ID0gY2FsY0FyY0hDb25uZWN0b3IocC5jeDEsIHAuY3kxLCBwLnIxLCBwLmN4MiwgcC5jeTIsIHAucjIsIDAuOCk7XG5cdFx0XHRcdHAudHgxID0gdHhbMF07XG5cdFx0XHRcdHAudHgyID0gdHhbMV07XG5cblx0XHRcdFx0Ly8gRmluZCBvdXQgbG9uZ2VzdCBub2RlIGNvbm5lY3Rpb24gZm9yIHNldExpbmVEYXNoXG5cdFx0XHRcdGxNYXggPSBNYXRoLm1heChsTWF4LCBNYXRoLmFicyhwLngxIC0gcC54MikgKyBNYXRoLmFicyhwLmN5MSAtIHAuY3kyKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTb3J0IGJ5IGRpc3RhbmNlIHkxIChvcmlnaW5hbCkgPiBjeTEgKHJJbmMgb2Zmc2V0KSBkaXN0YW5jZVxuXHRcdFx0Y29ubmVjdG9ycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0Ly8gcmV0dXJuIE1hdGguYWJzKGIueTEgLSBiLmN5MSkgLSBNYXRoLmFicyhhLnkxIC0gYS5jeTEpO1xuXHRcdFx0XHQvLyByZXR1cm4gYS5yMCAtIGIucjA7XG5cdFx0XHRcdHJldHVybiBiLmRpIC0gYS5kaTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRkLmNvbm5lY3RvcnMgPSBjb25uZWN0b3JzO1xuXHRcdGQubWF4TGVuZ3RoID0gbE1heDtcblx0XHRkLm1heExlbmd0aCA9IHF4O1xuXHR9LCAqL1xuXG59KTtcblxuaWYgKERFQlVHKSB7XG5cdC8vIEdyYXBoVmlldy5wcm90b3R5cGUuX2xvZ0ZsYWdzID0gXCJcIjtcblxuXHR2YXIgYXBwbHlGbiA9IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcblx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmFwcGx5KGFyZ3MpLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHR9XG5cblx0R3JhcGhWaWV3LnByb3RvdHlwZS5fZHJhd0Nvbm5lY3RvciA9IF8ud3JhcChHcmFwaFZpZXcucHJvdG90eXBlLl9kcmF3Q29ubmVjdG9yLCBmdW5jdGlvbihmbiwgcCwgaSwgcHApIHtcblx0XHRpZiAoIXRoaXMuX2RlYnVnR3JhcGgpIHtcblx0XHRcdC8vIHZpc3VhbCBkZWJ1ZyBhaWRzIGFyZSBvZmZcblx0XHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIHAsIGksIHBwKTtcblx0XHR9XG5cblx0XHQvLyB2YXIgaXNSdGwgPSBwLnF4IDwgMDtcblx0XHR2YXIgaXNGaXJzdCA9IGkgPT0gMDtcblx0XHR2YXIgaXNMYXN0ID0gaSA9PSAocHAubGVuZ3RoIC0gMSk7XG5cdFx0Ly8gZ3VpZGUgY29sb3Jcblx0XHR2YXIgZ3MgPSBfZFN0eWxlc1tpc0ZpcnN0ID8gXCJzYWxtb25fZGFzaGVkXCIgOiBcImxpZ2h0c2t5Ymx1ZV9kYXNoZWRcIl07XG5cblx0XHRpZiAoaXNGaXJzdCkge1xuXHRcdFx0Q2FudmFzSGVscGVyLmRyYXdWR3VpZGUodGhpcy5fY3R4LCBfZFN0eWxlc1tcImdyZXlcIl0sIHBwLnNNaW4pO1xuXHRcdFx0Q2FudmFzSGVscGVyLmRyYXdWR3VpZGUodGhpcy5fY3R4LCBfZFN0eWxlc1tcImdyZXlcIl0sIHBwLmRNaW4pO1xuXHRcdH1cblxuXHRcdGlmIChpc0ZpcnN0KSB7XG5cdFx0XHRDYW52YXNIZWxwZXIuZHJhd0hHdWlkZSh0aGlzLl9jdHgsIF9kU3R5bGVzW1wic2lsdmVyX2Rhc2hlZFwiXSwgcC55MSk7XG5cdFx0XHRDYW52YXNIZWxwZXIuZHJhd1ZHdWlkZSh0aGlzLl9jdHgsIF9kU3R5bGVzW1wic2lsdmVyX2Rhc2hlZFwiXSwgcC54MSk7XG5cdFx0XHRDYW52YXNIZWxwZXIuZHJhd0NpcmNsZSh0aGlzLl9jdHgsIF9kU3R5bGVzW1wibWlkbmlnaHRibHVlXCJdLCBwLngxLCBwLnkxLCAxMCk7XG5cdFx0fVxuXHRcdGlmIChpc0ZpcnN0IHx8IGlzTGFzdCkge1xuXHRcdFx0Ly8gQ2FudmFzSGVscGVyLmRyYXdWR3VpZGUodGhpcy5fY3R4LCBncywgcC5jeDEgKyAocC5yMSAqIHAucXgpKTtcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Vkd1aWRlKHRoaXMuX2N0eCwgZ3MsIHAudHgyKTtcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Vkd1aWRlKHRoaXMuX2N0eCwgZ3MsIHAuY3gyIC0gKHAucjIgKiBwLnF4KSk7XG5cdFx0XHQvLyBDYW52YXNIZWxwZXIuZHJhd1ZHdWlkZSh0aGlzLl9jdHgsIGdzLCBwLmN4Mik7XG5cdFx0XHQvLyBDYW52YXNIZWxwZXIuZHJhd0hHdWlkZSh0aGlzLl9jdHgsIGdzLCBwLmN5Mik7XG5cdFx0fVxuXHRcdGlmIChpc0ZpcnN0IHx8IGlzTGFzdCkge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IF9kU3R5bGVzWyhpc0ZpcnN0ID8gXCJyZWRcIiA6IFwiYmx1ZVwiKV0uc3Ryb2tlU3R5bGU7XG5cdFx0XHR0aGlzLl9jdHgubGluZVdpZHRoICo9IDEuNTtcblx0XHR9XG5cdFx0Ly8gfVxuXG5cdFx0Zm4uY2FsbCh0aGlzLCBwLCBpLCBwcCk7XG5cblx0XHQvLyBpZiAoaXNSdGwpIHtcblx0XHRpZiAoaXNGaXJzdCB8fCBpc0xhc3QpIHtcblx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHRcdC8vIHBvaW50IGNvbG9yXG5cdFx0dmFyIHBDb2wgPSBpc0xhc3QgPyBcIm1pZG5pZ2h0Ymx1ZVwiIDogaXNGaXJzdCA/IFwic2llbm5hXCIgOiBcImdyZXlcIjtcblx0XHR2YXIgcHMgPSBfZFN0eWxlc1twQ29sXTtcblx0XHR2YXIgcGYgPSBfZFN0eWxlc1twQ29sICsgXCJfZmlsbFwiXTtcblxuXHRcdC8vIENhbnZhc0hlbHBlci5kcmF3Q3Jvc3NoYWlyKHRoaXMuX2N0eCwgcHMsIHAueDEgKyAoKHAucjAgKyBwLmRpKSAqIHAucXgpLCBwLmN5MSwgMyk7XG5cblxuXHRcdGlmIChpc0ZpcnN0IHx8IGlzTGFzdCkge1xuXHRcdFx0Ly8gbW92ZVRvKHAueDIsIHAuY3kyKVxuXHRcdFx0Q2FudmFzSGVscGVyLmRyYXdDcm9zc2hhaXIodGhpcy5fY3R4LCBwcywgcC54MiwgcC5jeTIsIDEwKTtcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Q2lyY2xlKHRoaXMuX2N0eCwgcHMsIHAueDIsIHAuY3kyLCAzKTtcblxuXHRcdFx0Ly8gYXJjVG8gIzE6IChwLnR4MiwgcC5jeTIsIHAudHgxLCBwLmN5MSwgcC5yMilcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3U3F1YXJlKHRoaXMuX2N0eCwgcHMsIHAudHgyLCBwLmN5MiwgNCk7IC8vIHAxXG5cdFx0XHRDYW52YXNIZWxwZXIuZHJhd0NpcmNsZSh0aGlzLl9jdHgsIHBmLCBwLnR4MSwgcC5jeTEsIDIpOyAvLyBwMlxuXG5cdFx0XHQvLyBhcmNUbyAjMjogKHAudHgxLCBwLmN5MSwgcC5jeDEsIHAuY3kxLCBwLnIxKVxuXHRcdFx0Q2FudmFzSGVscGVyLmRyYXdTcXVhcmUodGhpcy5fY3R4LCBwcywgcC50eDEsIHAuY3kxLCA0KTsgLy8gcDFcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Q2lyY2xlKHRoaXMuX2N0eCwgcGYsIHAuY3gxLCBwLmN5MSwgMik7IC8vIHAyXG5cblx0XHRcdC8vIGFyY1RvICMyOiAocC5jeDAsIHAuY3kxLCBwLmN4MCwgcC55MSwgcC5yMClcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3U3F1YXJlKHRoaXMuX2N0eCwgcHMsIHAuY3gwLCBwLmN5MSwgNCk7IC8vIHAxXG5cdFx0XHRDYW52YXNIZWxwZXIuZHJhd0NpcmNsZSh0aGlzLl9jdHgsIHBmLCBwLmN4MCwgcC55MSwgMik7IC8vIHAyXG5cblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Q2lyY2xlKHRoaXMuX2N0eCwgX2RTdHlsZXNbXCJncmVlblwiXSwgcC50eDEsIHAuY3kxLCA0KTtcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Q2lyY2xlKHRoaXMuX2N0eCwgX2RTdHlsZXNbXCJncmVlblwiXSwgcC5jeDEsIHAuY3kxLCA0KTtcblx0XHRcdENhbnZhc0hlbHBlci5kcmF3Q2lyY2xlKHRoaXMuX2N0eCwgX2RTdHlsZXNbXCJncmVlblwiXSwgcC5jeDIsIHAuY3kyLCA0KTtcblx0XHR9XG5cdFx0Ly8gfVxuXHR9KTtcblxuXG5cdEdyYXBoVmlldy5wcm90b3R5cGUuX3RyYWNlU2Nyb2xsID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciB0cGwgPSBcIiVzOlslc10gRFBSOiVpIFwiICtcblx0XHRcdFwiW3dpbmRvdzogJWkgJWldIFwiICtcblx0XHRcdFwiW2h0bWw6ICVpICVpICVpXSBcIiArXG5cdFx0XHRcIltib2R5OiAlaSAlaSAlaV0gXCIgK1xuXHRcdFx0XCJbY29udGFpbmVyOiAlaSAlaSAlaV0gXCIgK1xuXHRcdFx0XCJbZ3JhcGg6ICVpICVpICVpXVwiO1xuXHRcdGNvbnNvbGUubG9nKHRwbCwgdGhpcy5jaWQsIHR5cGUsIHRoaXMuX2NhbnZhc1JhdGlvLFxuXHRcdFx0d2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0d2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0ZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQsXG5cdFx0XHRkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcblx0XHRcdGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0ZG9jdW1lbnQuYm9keS5maXJzdEVsZW1lbnRDaGlsZC5jbGllbnRIZWlnaHQsXG5cdFx0XHRkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLnNjcm9sbFRvcCxcblx0XHRcdGRvY3VtZW50LmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0dGhpcy5lbC5jbGllbnRIZWlnaHQsXG5cdFx0XHR0aGlzLmVsLnNjcm9sbFRvcCxcblx0XHRcdHRoaXMuZWwuc2Nyb2xsSGVpZ2h0XG5cdFx0KTtcblx0fTtcblxuXHRpZiAoR3JhcGhWaWV3LnByb3RvdHlwZS5fbG9nRmxhZ3Muc3BsaXQoXCIgXCIpW1widmlldy5yZW5kZXJcIl0pIHtcblx0XHQvLyBHcmFwaFZpZXcucHJvdG90eXBlLl9yZXF1ZXN0UmVuZGVyID0gXy53cmFwKENhbnZhc1ZpZXcucHJvdG90eXBlLl9yZXF1ZXN0UmVuZGVyLCBmdW5jdGlvbihmbikge1xuXHRcdC8vIFx0ZGVib3VuY2VkTG9nKFwiJXM6Ol9yZXF1ZXN0UmVuZGVyXCIsIHRoaXMuY2lkKTtcblx0XHQvLyBcdHJldHVybiBhcHBseU1ldGhvZCh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdC8vIH0pO1xuXHRcdHZhciBkZWJvdW5jZWRMb2cgPSBfLmRlYm91bmNlKF8uYmluZChjb25zb2xlLmxvZywgY29uc29sZSksIDUwMCwgdHJ1ZSk7XG5cblx0XHRHcmFwaFZpZXcucHJvdG90eXBlLl9hcHBseVJlbmRlciA9IF8ud3JhcChDYW52YXNWaWV3LnByb3RvdHlwZS5fYXBwbHlSZW5kZXIsIGZ1bmN0aW9uKGZuKSB7XG5cdFx0XHR2YXIgcmV0dmFsO1xuXHRcdFx0dGhpcy5fbG9nRmxhZ3NbXCJ2aWV3LnJlbmRlclwiXSA9IGZhbHNlO1xuXHRcdFx0ZGVib3VuY2VkTG9nKFwiJXM6Ol9hcHBseVJlbmRlciBbZGVib3VuY2VkXVwiLCB0aGlzLmNpZCk7XG5cdFx0XHRyZXR2YWwgPSBhcHBseUZuKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9sb2dGbGFnc1tcInZpZXcucmVuZGVyXCJdID0gdHJ1ZTtcblx0XHRcdHJldHVybiByZXR2YWw7XG5cdFx0fSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaFZpZXc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9jb21wb25lbnQvR3JvdXBpbmdMaXN0Vmlld1xuICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9GaWx0ZXJhYmxlTGlzdFZpZXd9ICovXG5jb25zdCBGaWx0ZXJhYmxlTGlzdFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvY29tcG9uZW50L0ZpbHRlcmFibGVMaXN0Vmlld1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9DbGlja2FibGVSZW5kZXJlcn0gKi9cbmNvbnN0IENsaWNrYWJsZVJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9DbGlja2FibGVSZW5kZXJlclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3JlbmRlci9MYWJlbFJlbmRlcmVyfSAqL1xuY29uc3QgTGFiZWxSZW5kZXJlciA9IHJlcXVpcmUoXCJhcHAvdmlldy9yZW5kZXIvTGFiZWxSZW5kZXJlclwiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2FycmF5L2RpZmZlcmVuY2V9ICovXG4vLyB2YXIgZGlmZiA9IHJlcXVpcmUoXCJ1dGlscy9hcnJheS9kaWZmZXJlbmNlXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9jb21wb25lbnQvR3JvdXBpbmdMaXN0Vmlld31cbiAqL1xudmFyIEdyb3VwaW5nTGlzdFZpZXcgPSBGaWx0ZXJhYmxlTGlzdFZpZXcuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2lkUHJlZml4OiBcImdyb3VwaW5nTGlzdFwiLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0dGFnTmFtZTogXCJkbFwiLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2xhc3NOYW1lOiBcImdyb3VwZWRcIixcblxuXHQvKiogQHR5cGUge0Z1bmN0aW9ufG51bGx9IGVtcHR5IGFycmF5ICovXG5cdF9ncm91cGluZ0ZuOiBudWxsLCAvL2Z1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGRlZmF1bHRzOiBfLmRlZmF1bHRzKHtcblx0XHQvLyBkZWZhdWx0czoge1xuXHRcdHJlbmRlcmVyOiBDbGlja2FibGVSZW5kZXJlci5leHRlbmQoe1xuXHRcdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0Y2lkUHJlZml4OiBcImdyb3VwaW5nTGlzdEl0ZW1cIixcblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdHRhZ05hbWU6IFwiZGxcIixcblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdGNsYXNzTmFtZTogXCJsaXN0LWl0ZW0gbGlzdC1ub2RlXCIsXG5cdFx0fSksXG5cdFx0Z3JvdXBpbmdSZW5kZXJlcjogTGFiZWxSZW5kZXJlci5leHRlbmQoe1xuXHRcdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0Y2lkUHJlZml4OiBcImdyb3VwaW5nTGlzdEdyb3VwXCIsXG5cdFx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0XHR0YWdOYW1lOiBcImR0XCIsXG5cdFx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0XHRjbGFzc05hbWU6IFwibGlzdC1ncm91cCBsaXN0LW5vZGVcIixcblx0XHR9KSxcblx0XHRncm91cGluZ0ZuOiBudWxsLFxuXHRcdC8vIH0sXG5cdH0sIEZpbHRlcmFibGVMaXN0Vmlldy5wcm90b3R5cGUuZGVmYXVsdHMpLFxuXG5cdHByb3BlcnRpZXM6IHtcblx0XHRncm91cHM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9ncm91cHM7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRmaWx0ZXJlZEdyb3Vwczoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2ZpbHRlcmVkR3JvdXBzO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0RmlsdGVyYWJsZUxpc3RWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR0aGlzLl9ncm91cHMgPSBbXTtcblx0XHR0aGlzLl9maWx0ZXJlZEdyb3VwcyA9IFtdO1xuXHRcdHRoaXMuX2NoYW5nZWRGaWx0ZXJlZEdyb3VwcyA9IFtdO1xuXHRcdHRoaXMuX2dyb3Vwc0J5SXRlbUNpZCA9IHt9O1xuXG5cdFx0dGhpcy5fZ3JvdXBpbmdGbiA9IG9wdGlvbnMuZ3JvdXBpbmdGbjtcblx0XHR0aGlzLmdyb3VwaW5nUmVuZGVyZXIgPSBvcHRpb25zLmdyb3VwaW5nUmVuZGVyZXI7XG5cdFx0dGhpcy5fY29tcHV0ZUdyb3VwcygpO1xuXHRcdGlmICh0aGlzLl9ncm91cGluZ0ZuKSB7XG5cdFx0XHR0aGlzLl9ncm91cHMuZm9yRWFjaCh0aGlzLmNyZWF0ZUdyb3VwaW5nVmlldywgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgb25jZSBvbiBjb2xsZWN0aW9uIGNoYW5nZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbXB1dGVHcm91cHM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHRoaXMuX2dyb3VwcyA9IF8udW5pcSh0aGlzLmNvbGxlY3Rpb24ubWFwKHRoaXMuX2dyb3VwaW5nRm4sIHRoaXMpKTtcblx0XHR0aGlzLl9ncm91cHMubGVuZ3RoID0gMDtcblx0XHQvLyB0aGlzLl9ncm91cEl0ZW1zLmxlbmd0aCA9IDA7XG5cdFx0aWYgKHRoaXMuX2dyb3VwaW5nRm4pIHtcblx0XHRcdHRoaXMuY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIGdJZHgsIGdPYmo7XG5cdFx0XHRcdGdPYmogPSB0aGlzLl9ncm91cGluZ0ZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGlmIChnT2JqKSB7XG5cdFx0XHRcdFx0Z0lkeCA9IHRoaXMuX2dyb3Vwcy5pbmRleE9mKGdPYmopO1xuXHRcdFx0XHRcdGlmIChnSWR4ID09IC0xKSB7XG5cdFx0XHRcdFx0XHRnSWR4ID0gdGhpcy5fZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHRoaXMuX2dyb3Vwc1tnSWR4XSA9IGdPYmo7XG5cdFx0XHRcdFx0XHQvLyB0aGlzLl9ncm91cEl0ZW1zW2dJZHhdID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHRoaXMuX2dyb3VwSXRlbXNbZ0lkeF0ucHVzaChpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9ncm91cHNCeUl0ZW1DaWRbaXRlbS5jaWRdID0gZ09iajtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHRoaXMuX2dyb3Vwc0J5SXRlbUNpZFtpdGVtLmNpZF0gPSBudWxsO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBAcHJpdmF0ZSBDcmVhdGUgY2hpbGRyZW4gdmlld3MgKi9cblx0Y3JlYXRlR3JvdXBpbmdWaWV3OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHZpZXcgPSBuZXcgdGhpcy5ncm91cGluZ1JlbmRlcmVyKHtcblx0XHRcdG1vZGVsOiBpdGVtLFxuXHRcdFx0ZWw6IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5saXN0LWdyb3VwW2RhdGEtaWQ9XFxcIlwiICsgaXRlbS5pZCArIFwiXFxcIl1cIilcblx0XHR9KTtcblx0XHR0aGlzLml0ZW1WaWV3cy5hZGQodmlldyk7XG5cdFx0cmV0dXJuIHZpZXc7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogRmlsdGVyIGltcGwgMVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQG92ZXJyaWRlICovXG5cdC8qXG5cdGNvbXB1dGVGaWx0ZXJfMTogZnVuY3Rpb24oKSB7XG5cdFx0RmlsdGVyYWJsZUxpc3RWaWV3LnByb3RvdHlwZS5jb21wdXRlRmlsdGVyXzEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdGlmICh0aGlzLl9ncm91cGluZ0ZuKSB7XG5cdFx0XHRpZiAodGhpcy5fZmlsdGVyZWRJdGVtcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHR0aGlzLl9maWx0ZXJlZEdyb3VwcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZmlsdGVyZWRHcm91cHMgPSBfLnVuaXEodGhpcy5fZmlsdGVyZWRJdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9ncm91cHNCeUl0ZW1DaWRbaXRlbS5jaWRdO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGlmICh0aGlzLl9ncm91cGluZ0ZuKSB7XG5cdFx0Ly8gXHRpZiAodGhpcy5fZmlsdGVyZWRJdGVtcy5sZW5ndGggPT0gMCkge1xuXHRcdC8vIFx0XHR0aGlzLl9maWx0ZXJlZEdyb3VwcyA9IFtdO1xuXHRcdC8vIFx0XHR0aGlzLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuXHRcdC8vIFx0XHRcdHRoaXMuaXRlbVZpZXdzLmZpbmRCeU1vZGVsKGdyb3VwKS5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiZXhjbHVkZWRcIik7XG5cdFx0Ly8gXHRcdH0sIHRoaXMpO1xuXHRcdC8vIFx0fSBlbHNlIHtcblx0XHQvLyBcdFx0dGhpcy5fZmlsdGVyZWRHcm91cHMgPSBfLnVuaXEodGhpcy5fZmlsdGVyZWRJdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHRcdC8vIFx0XHRcdHJldHVybiB0aGlzLl9ncm91cHNCeUl0ZW1DaWRbaXRlbS5jaWRdO1xuXHRcdC8vIFx0XHR9LCB0aGlzKSk7XG5cdFx0Ly8gXHRcdHRoaXMuX2dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG5cdFx0Ly8gXHRcdFx0dGhpcy5pdGVtVmlld3MuZmluZEJ5TW9kZWwoZ3JvdXApLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJleGNsdWRlZFwiLCB0aGlzLl9maWx0ZXJlZEdyb3Vwcy5pbmRleE9mKGdyb3VwKSA9PSAtMSk7XG5cdFx0Ly8gXHRcdH0sIHRoaXMpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblx0fSxcblx0Ki9cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBGaWx0ZXIgaW1wbCAyXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIC8qKiBAb3ZlcnJpZGUgKi9cblx0Ly8gcmVuZGVyRmlsdGVyRm5fMjogZnVuY3Rpb24oKSB7XG5cdC8vIFx0RmlsdGVyYWJsZUxpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJGaWx0ZXJGbl8yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdC8vIH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjb21wdXRlRmlsdGVyOiBmdW5jdGlvbigpIHtcblx0XHRGaWx0ZXJhYmxlTGlzdFZpZXcucHJvdG90eXBlLmNvbXB1dGVGaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdGlmICh0aGlzLl9ncm91cGluZ0ZuKSB7XG5cdFx0XHRpZiAodGhpcy5fZmlsdGVyZWRJdGVtcy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHR0aGlzLl9maWx0ZXJlZEdyb3VwcyA9IHRoaXMuX2dyb3Vwcy5jb25jYXQoKTsgLy9bXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2ZpbHRlcmVkR3JvdXBzID0gXy51bmlxKHRoaXMuX2ZpbHRlcmVkSXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fZ3JvdXBzQnlJdGVtQ2lkW2l0ZW0uY2lkXTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGFwcGx5RmlsdGVyOiBmdW5jdGlvbigpIHtcblx0XHRGaWx0ZXJhYmxlTGlzdFZpZXcucHJvdG90eXBlLmFwcGx5RmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR0aGlzLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuXHRcdFx0dGhpcy5pdGVtVmlld3MuZmluZEJ5TW9kZWwoZ3JvdXApLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJleGNsdWRlZFwiLCAodGhpcy5fZmlsdGVyZWRHcm91cHMuaW5kZXhPZihncm91cCkgPT0gLTEpKTtcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHQvLyBjb21wdXRlRmlsdGVyZWQ6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdEZpbHRlcmFibGVMaXN0Vmlldy5wcm90b3R5cGUuY29tcHV0ZUZpbHRlcmVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdC8vIH0sXG5cdC8vXG5cdC8vIHJlbmRlckZpbHRlcmVkOiBmdW5jdGlvbigpIHtcblx0Ly8gXHRGaWx0ZXJhYmxlTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlckZpbHRlcmVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdC8vIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwaW5nTGlzdFZpZXc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9jb21wb25lbnQvUGxheVRvZ2dsZVN5bWJvbFxuICovXG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9jb250cm9sL0dsb2JhbHN9ICovXG4vLyB2YXIgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9DYW52YXNWaWV3fSAqL1xuY29uc3QgQ2FudmFzVmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL0NhbnZhc1ZpZXdcIik7XG5cbi8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5jb25zdCBDb2xvciA9IHJlcXVpcmUoXCJjb2xvclwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2NhbnZhcy9iaXRtYXAvc3RhY2tCbHVyUkdCfSAqL1xuY29uc3Qgc3RhY2tCbHVyUkdCID0gcmVxdWlyZShcInV0aWxzL2NhbnZhcy9iaXRtYXAvc3RhY2tCbHVyUkdCXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvY2FudmFzL2JpdG1hcC9nZXRBdmVyYWdlUkdCfSAqL1xuY29uc3QgZ2V0QXZlcmFnZVJHQiA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvYml0bWFwL2dldEF2ZXJhZ2VSR0JcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9jYW52YXMvYml0bWFwL211bHRpcGx5fSAqL1xuY29uc3QgbXVsdGlwbHkgPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL2JpdG1hcC9tdWx0aXBseVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2NhbnZhcy9iaXRtYXAvZGVzYXR1cmF0ZX0gKi9cbmNvbnN0IGRlc2F0dXJhdGUgPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL2JpdG1hcC9kZXNhdHVyYXRlXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvY2FudmFzL0NhbnZhc0hlbHBlcn0gKi9cbmNvbnN0IHJvdW5kUmVjdCA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvQ2FudmFzSGVscGVyXCIpLnJvdW5kUmVjdDtcblxuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvZWFzZS9mbi9lYXNlSW5RdWFkfSAqL1xuY29uc3QgZWFzZUluID0gcmVxdWlyZShcInV0aWxzL2Vhc2UvZm4vZWFzZUluUXVhZFwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2Vhc2UvZm4vZWFzZU91dFF1YWR9ICovXG5jb25zdCBlYXNlT3V0ID0gcmVxdWlyZShcInV0aWxzL2Vhc2UvZm4vZWFzZU91dFF1YWRcIik7XG5cbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBMT09QX09GRlNFVCA9IDEuODMzMzMzO1xuY29uc3QgSU5URVBfTVMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKS5UUkFOU0lUSU9OX0RVUkFUSU9OO1xudmFyIEZJTFRFUl9SRUZSRVNIX1RIUkVTSE9MRCA9IDAuNTsgLy9zZWNvbmRzIGVsYXBzZWRcbnZhciBGSUxURVJfU0NBTEUgPSAxLjU7XG52YXIgRklMVEVSX1JBRElVUyA9IDMwOyAvL3BpeGVsc1xudmFyIEZJTFRFUl9NVUxUSVBMWSA9IDAuMTtcblxudmFyIFBsYXlUb2dnbGVTeW1ib2wgPSB7XG5cdFBMQVk6IFwicGxheWluZ1wiLFxuXHRQQVVTRTogXCJwYXVzZWRcIixcblx0V0FJVElORzogXCJ3YWl0aW5nXCIsXG5cdEVOREVEOiBcImVuZGVkXCIsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1ZpZXcuZXh0ZW5kKHtcblxuXHRcdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRcdGNpZFByZWZpeDogXCJwbGF5VG9nZ2xlU3ltYm9sXCIsXG5cdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdFx0Y2xhc3NOYW1lOiBcInBsYXktdG9nZ2xlXCIsXG5cblx0XHRkZWZhdWx0czoge1xuXHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdF9sb29wOiAwLFxuXHRcdFx0XHRfYXJjOiAwLFxuXHRcdFx0fSxcblx0XHRcdG1heFZhbHVlczoge1xuXHRcdFx0XHRfbG9vcDogMVxuXHRcdFx0fSxcblx0XHRcdGNvbG9yOiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBcInJnYmEoMCwwLDAsMC4yNSlcIixcblx0XHRcdHBhdXNlZDogdHJ1ZSxcblx0XHRcdHN5bWJvbE5hbWU6IFwiXCIsXG5cdFx0XHQvLyBib3JkZXJSYWRpdXM6IDMsXG5cdFx0XHQvLyBib3JkZXJXaWR0aDogMyxcblx0XHR9LFxuXG5cdFx0cHJvcGVydGllczoge1xuXHRcdFx0c3ltYm9sTmFtZToge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9zeW1ib2xOYW1lO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0U3ltYm9sTmFtZSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSxcblxuXHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHQvLyBUT0RPOiBjbGVhbnVwIG9wdGlvbnMgbWVzcyBpbiBDYW52YXNWaWV3XG5cdFx0XHRDYW52YXNWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9vcHRpb25zID0gXy5leHRlbmQodGhpcy5fb3B0aW9ucywgXy5waWNrKG9wdGlvbnMsIFwic3ltYm9sTmFtZVwiLCBcImJvcmRlclJhZGl1c1wiLCBcImJvcmRlcldpZHRoXCIpKTtcblx0XHRcdHRoaXMuc3ltYm9sTmFtZSA9IHRoaXMuX29wdGlvbnMuc3ltYm9sTmFtZTtcblx0XHR9LFxuXG5cdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdG1lYXN1cmVDYW52YXM6IGZ1bmN0aW9uKHcsIGgsIHMpIHtcblx0XHRcdC8vIG1ha2UgY2FudmFzIHNxdWFyZVxuXHRcdFx0dGhpcy5fY2FudmFzSGVpZ2h0ID0gdGhpcy5fY2FudmFzV2lkdGggPSBNYXRoLm1pbih3LCBoKTtcblx0XHR9LFxuXG5cdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdHVwZGF0ZUNhbnZhczogZnVuY3Rpb24oY3R4LCBzKSB7XG5cdFx0XHR2YXIgbU9iaiA9IHRoaXMuX2dldEZvbnRNZXRyaWNzKHRoaXMuX2ZvbnRGYW1pbHkpO1xuXHRcdFx0dGhpcy5fYmFzZWxpbmVTaGlmdCA9IG1PYmogPyAobU9iai5hc2NlbnQgKyBtT2JqLmRlc2NlbnQpIC8gbU9iai51bml0c1BlckVtIDogMC43OyAvLyBkZWZhdWx0IHZhbHVlXG5cdFx0XHR0aGlzLl9iYXNlbGluZVNoaWZ0ICo9IHRoaXMuX2ZvbnRTaXplICogMC41OyAvLyBhcHBseSB0byBmb250LXNpemUsIGhhbHZlIGl0XG5cdFx0XHR0aGlzLl9iYXNlbGluZVNoaWZ0ID0gTWF0aC5yb3VuZCh0aGlzLl9iYXNlbGluZVNoaWZ0KTtcblxuXHRcdFx0dGhpcy5fY2FudmFzT2Zmc2V0WCA9IHRoaXMuX2NhbnZhc09mZnNldFkgPSB0aGlzLl9jYW52YXNXaWR0aCAvIDI7XG5cdFx0XHQvLyBkb3VibGUgU1FSVDFfMjogc3F1YXJlIHdpdGhpbiBjaXJjbGUgd2l0aGluIHNxdWFyZVxuXHRcdFx0dGhpcy5fcmFkaXVzID0gKHRoaXMuX2NhbnZhc1dpZHRoIC8gMikgKiBNYXRoLlNRUlQxXzIgKiBNYXRoLlNRUlQxXzIgKiBNYXRoLlNRUlQxXzI7XG5cdFx0XHR0aGlzLl9zaWRlID0gdGhpcy5fcmFkaXVzOyAvLyAqIE1hdGguU1FSVDFfMjsgLy8gKiBNYXRoLlNRUlQxXzI7XG5cdFx0XHQvLyB0aGlzLl9ib3JkZXJXaWR0aCA9IHRoaXMuX29wdGlvbnMuYm9yZGVyV2lkdGggKiB0aGlzLl9jYW52YXNSYXRpbztcblx0XHRcdC8vIHRoaXMuX2JvcmRlclJhZGl1cyA9IHRoaXMuX2NhbnZhc1dpZHRoICogdGhpcy5fY2FudmFzUmF0aW8gLyAyOyAvL3RoaXMuX29wdGlvbnMuYm9yZGVyUmFkaXVzICogdGhpcy5fY2FudmFzUmF0aW87XG5cblx0XHRcdC8vIHJlc2V0IG1hdHJpeCBhbmQgdHJhbnNsYXRlIDAsMCB0byBjZW50ZXJcblx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgdGhpcy5fY2FudmFzT2Zmc2V0WCwgdGhpcy5fY2FudmFzT2Zmc2V0WSk7XG5cdFx0XHQvLyB0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdFx0Ly8gdGhpcy5fY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0XHR0aGlzLl9jdHgubGluZVdpZHRoID0gdGhpcy5fcmFkaXVzICogKDEgLSBNYXRoLlNRUlQxXzIpO1xuXHRcdFx0Ly8gdGhpcy5fY3R4LmZpbGxTdHlsZSA9IFwiI0ZGRlwiO1xuXHRcdFx0dGhpcy5fY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDAuNzUpXCI7XG5cdFx0XHR0aGlzLl9jdHguc2hhZG93Qmx1ciA9IDE7XG5cdFx0XHR0aGlzLl9jdHguc2hhZG93T2Zmc2V0WCA9IDI7XG5cdFx0XHR0aGlzLl9jdHguc2hhZG93T2Zmc2V0WSA9IDI7XG5cdFx0XHQvLyB0aGlzLl9jdHguc2F2ZSgpO1xuXG5cdFx0XHR0aGlzLl9pc0ltYWdlRGF0YUludmFsaWQgPSB0cnVlO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIiVzOjp1cGRhdGVDYW52YXMgJXNcIiwgdGhpcy5jaWQsIHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cdFx0fSxcblxuXHRcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdFx0ICogc3ltYm9sTmFtZVxuXHRcdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdFx0X3N5bWJvbE5hbWU6IFwiXCIsXG5cdFx0X3NldFN5bWJvbE5hbWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy5fc3ltYm9sTmFtZSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fbGFzdFN5bWJvbE5hbWUgPSB0aGlzLl9zeW1ib2xOYW1lO1xuXHRcdFx0XHR0aGlzLl9zeW1ib2xOYW1lID0gdmFsdWU7XG5cblx0XHRcdFx0dGhpcy5yZWZyZXNoSW1hZ2VTb3VyY2UoKTtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKENhbnZhc1ZpZXcuTEFZT1VUX0lOVkFMSUQpO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIiVzOjpbc2V0XSBzeW1ib2wgJW8gKGZyb20gJW8pXCIsIHRoaXMuYXR0YWNoZWQgPyB0aGlzLnBhcmVudFZpZXcuY2lkIDogdGhpcy5jaWQsIHRoaXMuX3N5bWJvbE5hbWUsIHRoaXMuX2xhc3RTeW1ib2xOYW1lLCB0aGlzLnBhdXNlZCA/IFwicGF1c2VkXCIgOiBcIlwiKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0XHQgKiBzZXRJbWFnZVNvdXJjZS9yZWZyZXNoSW1hZ2VTb3VyY2Vcblx0XHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdF9pbWFnZVNvdXJjZTogbnVsbCxcblx0XHRzZXRJbWFnZVNvdXJjZTogZnVuY3Rpb24oaW1hZ2VTb3VyY2UpIHtcblx0XHRcdGlmICh0aGlzLl9pbWFnZVNvdXJjZSAhPT0gaW1hZ2VTb3VyY2UpIHtcblx0XHRcdFx0dGhpcy5faW1hZ2VTb3VyY2UgPSBpbWFnZVNvdXJjZTtcblx0XHRcdFx0dGhpcy5faXNJbWFnZURhdGFJbnZhbGlkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKENhbnZhc1ZpZXcuU0laRV9JTlZBTElEKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2ltYWdlRGF0YVRDOiBudWxsLFxuXHRcdHJlZnJlc2hJbWFnZVNvdXJjZTogZnVuY3Rpb24odGhyZXNob2xkKSB7XG5cdFx0XHRpZiAodGhpcy5faXNJbWFnZURhdGFJbnZhbGlkIHx8ICEodGhpcy5faW1hZ2VTb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuXHRcdFx0XHRyZXR1cm47IC8vIGRhdGEgaXMgbWFya2VkIGZvciByZWZyZXNoIGFscmVhZHksIG9yIG5vdCBhIHZpZGVvXG5cdFx0XHR9XG5cdFx0XHRpZiAoIV8uaXNOdW1iZXIodGhyZXNob2xkKSkge1xuXHRcdFx0XHR0aHJlc2hvbGQgPSBGSUxURVJfUkVGUkVTSF9USFJFU0hPTEQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyZXNob2xkIDwgTWF0aC5hYnModGhpcy5faW1hZ2VEYXRhVEMgLSB0aGlzLl9pbWFnZVNvdXJjZS5jdXJyZW50VGltZSkpIHtcblx0XHRcdFx0dGhpcy5faXNJbWFnZURhdGFJbnZhbGlkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0UmVuZGVyKENhbnZhc1ZpZXcuU0laRV9JTlZBTElEKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2ltYWdlRGF0YTogbnVsbCxcblx0XHRfdXBkYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9pbWFnZVNvdXJjZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9pbWFnZURhdGEgPSBudWxsO1xuXHRcdFx0XHR0aGlzLl9pbWFnZURhdGFUQyA9IG51bGw7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIHNvdXJjZSBzY2FsZSwgc291cmNlIHJlY3QsIGRlc3Qgc2NhbGUsIGRlc3QgcmVjdCwgY3VycmVudCB0aW1lY29kZVxuXHRcdFx0dmFyIHMsIHNyLCBkLCBkciwgdGM7XG5cblx0XHRcdC8vIEdldCBzb3VyY2UvZGVzdCBvZmZzZXRzLCBpbnRyaW5zaWMgc2NhbGUgYW5kIHRpbWVjb2RlXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcdHNyID0gdGhpcy5faW1hZ2VTb3VyY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRkciA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGlmICh0aGlzLl9pbWFnZVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdFx0cyA9IHRoaXMuX2ltYWdlU291cmNlLnZpZGVvV2lkdGggLyBzci53aWR0aDtcblx0XHRcdFx0dGMgPSB0aGlzLl9pbWFnZVNvdXJjZS5jdXJyZW50VGltZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSB0aGlzLl9pbWFnZVNvdXJjZS5uYXR1cmFsV2lkdGggLyBzci53aWR0aDtcblx0XHRcdFx0dGMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0ZCA9IHMgKiBGSUxURVJfU0NBTEU7XG5cblx0XHRcdC8vIGRyYXcgc291cmNlIGNhbnZhcyBtYWludGFpbmluZyBwb3NpdGlvblxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdHRoaXMuX2N0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2VTb3VyY2UsXG5cdFx0XHRcdChkci5sZWZ0IC0gc3IubGVmdCkgKiBzICsgKGRyLndpZHRoIC8gMikgKiBzIC0gKGRyLndpZHRoIC8gMikgKiBkLFxuXHRcdFx0XHQoZHIudG9wIC0gc3IudG9wKSAqIHMgKyAoZHIuaGVpZ2h0IC8gMikgKiBzIC0gKGRyLmhlaWdodCAvIDIpICogZCxcblx0XHRcdFx0ZHIud2lkdGggKiBkLCBkci5oZWlnaHQgKiBkLFxuXHRcdFx0XHQwLCAwLCB0aGlzLmVsLndpZHRoLCB0aGlzLmVsLmhlaWdodFxuXHRcdFx0KTtcblx0XHRcdC8vIGlmIChkID09IHMpXG5cdFx0XHQvLyB0aGlzLl9jdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlU291cmNlLFxuXHRcdFx0Ly8gXHQoZHIubGVmdCAtIHNyLmxlZnQpICogcywgKGRyLnRvcCAtIHNyLnRvcCkgKiBzLFxuXHRcdFx0Ly8gXHRkci53aWR0aCAqIHMsIGRyLmhlaWdodCAqIHMsXG5cdFx0XHQvLyBcdDAsIDAsIHRoaXMuZWwud2lkdGgsIHRoaXMuZWwuaGVpZ2h0XG5cdFx0XHQvLyApO1xuXG5cdFx0XHQvLyBnZXQgSW1hZ2VEYXRhXG5cdFx0XHQvLyBmaW5kIGx1bWlub3NpdHkgdGhyZXNob2xkIGZvcm0gYXZlcmFnZSBjb2xvclxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHR2YXIgaW1nZGF0YSwgaXNEYXJrO1xuXG5cdFx0XHRpbWdkYXRhID0gdGhpcy5fY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmVsLndpZHRoLCB0aGlzLmVsLmhlaWdodCk7XG5cdFx0XHQvLyBpc0RhcmsgPSAhQ29sb3IoKS5yZ2IoZ2V0QXZlcmFnZVJHQihpbWdkYXRhKSkuZGFyaygpO1xuXG5cdFx0XHQvLyB0aGlzLl9jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJsdW1pbm9zaXR5XCI7XG5cdFx0XHQvLyB0aGlzLl9jdHguZ2xvYmFsQWxwaGEgPSAwLjI1O1xuXHRcdFx0Ly8gdGhpcy5fY3R4LmZpbGxTdHlsZSA9IChpc0RhcmsgPyBcImJsYWNrXCIgOiBcIndoaXRlXCIpO1xuXHRcdFx0Ly8gdGhpcy5fY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuZWwud2lkdGgsIHRoaXMuZWwuaGVpZ2h0KTtcblxuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmVsLndpZHRoLCB0aGlzLmVsLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXG5cdFx0XHQvLyBTdG9yZSBhcHByb3BpYXRlIGNvbG9yIHZhbHVlc1xuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHR0aGlzLl9jb2xvciA9IGlzRGFyayA/IFwid2hpdGVcIiA6IFwiYmxhY2tcIjtcblx0XHRcdC8vIHRoaXMuX2NvbG9yID0gaXNEYXJrID8gXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNzUpXCIgOiBcInJnYmEoMCwwLDAsMC43NSlcIjtcblx0XHRcdC8vIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IGlzRGFyayA/IFwicmdiYSgwLDAsMCwwLjc1KVwiIDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNzQpXCI7XG5cblx0XHRcdC8vIHRoaXMuZWwuc3R5bGUuY29sb3IgPVxuXHRcdFx0Ly8gXHR0aGlzLl9jdHguZmlsbFN0eWxlID1cblx0XHRcdC8vIFx0dGhpcy5fY3R4LnN0cm9rZVN0eWxlID1cblx0XHRcdC8vIFx0dGhpcy5fY29sb3I7XG5cdFx0XHQvLyB0aGlzLmVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9XG5cdFx0XHQvLyBcdHRoaXMuX2N0eC5zaGFkb3dDb2xvciA9XG5cdFx0XHQvLyBcdHRoaXMuX2JhY2tncm91bmRDb2xvcjtcblxuXHRcdFx0Ly8gdGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwibG9kXCIsIGlzRGFyayk7XG5cdFx0XHQvLyB0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJkb2xcIiwgIWlzRGFyayk7XG5cblx0XHRcdC8vIEFwcGx5IGZpbHRlcnMgYW5kIHNhdmUgcmVzdWx0c1xuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHQvLyBpbWdkYXRhID0gdGhpcy5fY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmVsLndpZHRoLCB0aGlzLmVsLmhlaWdodCk7XG5cdFx0XHQvLyBpbWdkYXRhID0gbXVsdGlwbHkoaW1nZGF0YSwgKGlzRGFyayA/IDEgLSBGSUxURVJfTVVMVElQTFkgOiAxICsgRklMVEVSX01VTFRJUExZKSk7XG5cdFx0XHQvLyBpbWdkYXRhID0gZGVzYXR1cmF0ZShpbWdkYXRhLCAwLjUpO1xuXG5cdFx0XHRpbWdkYXRhID0gbXVsdGlwbHkoaW1nZGF0YSwgMSArIEZJTFRFUl9NVUxUSVBMWSk7XG5cdFx0XHRpbWdkYXRhID0gc3RhY2tCbHVyUkdCKGltZ2RhdGEsIEZJTFRFUl9SQURJVVMpO1xuXHRcdFx0Ly8gaW1nZGF0YSA9IG51bGw7XG5cblx0XHRcdHRoaXMuX2ltYWdlRGF0YSA9IGltZ2RhdGE7XG5cdFx0XHR0aGlzLl9pbWFnZURhdGFUQyA9IHRjO1xuXHRcdH0sXG5cblx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0cmVkcmF3OiBmdW5jdGlvbihjdHgsIGludHJwLCBmbGFncykge1xuXHRcdFx0dGhpcy5fY2xlYXJDYW52YXMoKTtcblxuXHRcdFx0aWYgKHRoaXMuX3N5bWJvbE5hbWUgPT09ICd3YWl0aW5nJykge1xuXHRcdFx0XHRpZiAoaW50cnAuZ2V0VGFyZ2V0VmFsdWUoJ19hcmMnKSA9PT0gMCkge1xuXHRcdFx0XHRcdGludHJwLnZhbHVlVG8oJ19hcmMnLCAxLCAwICogSU5URVBfTVMsIGVhc2VJbilcblx0XHRcdFx0XHRcdC51cGRhdGVWYWx1ZSgnX2FyYycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaW50cnAuZ2V0VGFyZ2V0VmFsdWUoJ19hcmMnKSA9PT0gMSkge1xuXHRcdFx0XHRcdGludHJwLnZhbHVlVG8oJ19hcmMnLCAwLCAwICogSU5URVBfTVMsIGVhc2VPdXQpXG5cdFx0XHRcdFx0XHQudXBkYXRlVmFsdWUoJ19hcmMnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBpbnRycC5nZXRSZW5kZXJlZFZhbHVlKFwiX2FyY1wiKTtcblx0XHRcdC8vIHdoaWxlIGFyYyBpcyA+IDAsIGxvb3AgaW5kZWZpbml0ZWx5IHdoaWxlIHNwaW5uaW5nIGFuZCByZXN0YXJ0XG5cdFx0XHQvLyBpZiBhdCBlbmQuIE90aGVyd2lzZSBsZXQgaW50ZXJwIGV4aGF1c3QgYXJjIGR1cmF0aW9uXG5cdFx0XHRpZiAoYSA+IDApIHtcblx0XHRcdFx0aWYgKCFpbnRycC5wYXVzZWQgJiYgaW50cnAuaXNBdFRhcmdldCgnX2xvb3AnKSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OnJlZHJhdyBbbG9vcF1cIiwgdGhpcy5jaWQsIHRoaXMucGFyZW50Vmlldy5jaWQpO1xuXHRcdFx0XHRcdGludHJwXG5cdFx0XHRcdFx0XHQudmFsdWVUbygnX2xvb3AnLCAwLCAwKVxuXHRcdFx0XHRcdFx0LnZhbHVlVG8oJ19sb29wJywgMSwgMiAqIElOVEVQX01TKVxuXHRcdFx0XHRcdFx0LnVwZGF0ZVZhbHVlKCdfbG9vcCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgbCA9IGludHJwLmdldFJlbmRlcmVkVmFsdWUoXCJfbG9vcFwiKTtcblxuXHRcdFx0Ly8gaWYgKHRoaXMuX2lzSW1hZ2VEYXRhSW52YWxpZCkge1xuXHRcdFx0Ly8gXHR0aGlzLl9pc0ltYWdlRGF0YUludmFsaWQgPSBmYWxzZTtcblx0XHRcdC8vIFx0dGhpcy5fdXBkYXRlSW1hZ2VEYXRhKCk7XG5cdFx0XHQvLyB9XG5cdFx0XHQvLyBpZiAodGhpcy5faW1hZ2VEYXRhICE9PSBudWxsKSB7XG5cdFx0XHQvLyBcdGN0eC5wdXRJbWFnZURhdGEodGhpcy5faW1hZ2VEYXRhLCAwLCAwKTtcblx0XHRcdC8vIH1cblxuXHRcdFx0Ly8gYWx3YXlzIHJlbmRlciB3aGlsZSBhcmMgaXMgPiAwXG5cdFx0XHRpZiAoYSA+IDApIHtcblx0XHRcdFx0Ly8gYXJjIHNwYW4gYm91bmNlXG5cdFx0XHRcdHZhciBiID0gKGwgPCAwLjUgPyAobCAlIDAuNSkgOiAwLjUgLSAobCAlIDAuNSkpICogMjtcblx0XHRcdFx0Ly8gYm91bmNlICsgbWFpbiBhcmMgc3BhblxuXHRcdFx0XHR2YXIgYWEgPSAoYSAqIGIgKiAwLjI1KSArIChhICogMC4xMjUpICsgLjAwMDE7XG5cdFx0XHRcdC8vIHJvdGF0aW9uIGxvb3Bcblx0XHRcdFx0dmFyIGxsID0gbCArIExPT1BfT0ZGU0VUO1xuXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYygwLCAwLCB0aGlzLl9yYWRpdXMsICgoMSAtIGFhKSArIGxsKSAqIFBJMiwgKGFhICsgbGwpICogUEkyLCBmYWxzZSk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICh0aGlzLl9zeW1ib2xOYW1lKSB7XG5cdFx0XHRcdGNhc2UgXCJyZXBsYXlcIjpcblx0XHRcdFx0Y2FzZSBcImVuZGVkXCI6XG5cdFx0XHRcdGNhc2UgXCJwbGF5XCI6XG5cdFx0XHRcdFx0Ly8gdGhpcy5kcmF3UGxheShjdHgsICgxIC0gYSkgKiBzKTtcblx0XHRcdFx0XHR0aGlzLmRyYXdQbGF5KGN0eCwgdGhpcy5fc2lkZSk7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInBhdXNlXCI6XG5cdFx0XHRcdFx0Ly8gdGhpcy5kcmF3UGF1c2UoY3R4LCAoMSAtIGEpICogcyk7XG5cdFx0XHRcdFx0dGhpcy5kcmF3UGF1c2UoY3R4LCB0aGlzLl9zaWRlKTtcblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwid2FpdGluZ1wiOlxuXHRcdFx0XHRcdHN3aXRjaCAodGhpcy5fbGFzdFN5bWJvbE5hbWUpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJyZXBsYXlcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJlbmRlZFwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcInBsYXlcIjpcblx0XHRcdFx0XHRcdFx0dGhpcy5kcmF3UGxheShjdHgsICgxIC0gYSkgKiB0aGlzLl9zaWRlKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwicGF1c2VcIjpcblx0XHRcdFx0XHRcdFx0dGhpcy5kcmF3UGF1c2UoY3R4LCAoMSAtIGEpICogdGhpcy5fc2lkZSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkcmF3UGxheTogZnVuY3Rpb24oY3R4LCByKSB7XG5cdFx0XHR2YXIgdHggPSAoMSAtIE1hdGguU1FSVDFfMikgKiByO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyh0eCArIHIsIDApO1xuXHRcdFx0Y3R4LmxpbmVUbyh0eCAtIHIsIC1yKTtcblx0XHRcdGN0eC5saW5lVG8odHggLSByLCByKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHR9LFxuXG5cdFx0ZHJhd1BhdXNlOiBmdW5jdGlvbihjdHgsIHIpIHtcblx0XHRcdHZhciB3ID0gciAqIDAuNzU7XG5cdFx0XHR2YXIgaCA9IHIgKiAyO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4LnJlY3QoLXIsIC1yLCB3LCBoKTtcblx0XHRcdGN0eC5yZWN0KHIgLSB3LCAtciwgdywgaCk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fSxcblxuXHRcdGRyYXdMYWJlbDogZnVuY3Rpb24obGFiZWxTdHJpbmcpIHtcblx0XHRcdHZhciBsYWJlbFdpZHRoID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KGxhYmVsU3RyaW5nKS53aWR0aDtcblx0XHRcdHRoaXMuX2N0eC5maWxsVGV4dChsYWJlbFN0cmluZyxcblx0XHRcdFx0bGFiZWxXaWR0aCAqIC0wLjUsXG5cdFx0XHRcdC8vIDAsIGxhYmVsV2lkdGgpO1xuXHRcdFx0XHR0aGlzLl9iYXNlbGluZVNoaWZ0LCBsYWJlbFdpZHRoKTtcblx0XHR9LFxuXHR9LFxuXHRQbGF5VG9nZ2xlU3ltYm9sKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L2NvbXBvbmVudC9TZWxlY3RhYmxlTGlzdFZpZXdcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5jb25zdCBWaWV3ID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld1wiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmUuYmFieXNpdHRlcn0gKi9cbmNvbnN0IENvbnRhaW5lciA9IHJlcXVpcmUoXCJiYWNrYm9uZS5iYWJ5c2l0dGVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0RlZmF1bHRTZWxlY3RhYmxlUmVuZGVyZXJ9ICovXG5jb25zdCBEZWZhdWx0U2VsZWN0YWJsZVJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9EZWZhdWx0U2VsZWN0YWJsZVJlbmRlcmVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0NsaWNrYWJsZVJlbmRlcmVyfSAqL1xuY29uc3QgQ2xpY2thYmxlUmVuZGVyZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcmVuZGVyL0NsaWNrYWJsZVJlbmRlcmVyXCIpO1xuXG52YXIgU2VsZWN0YWJsZUxpc3RWaWV3ID0gVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwic2VsZWN0YWJsZUxpc3RcIixcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRhZ05hbWU6IFwidWxcIixcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJsaXN0IHNlbGVjdGFibGVcIixcblxuXHQvKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9jb21wb25lbnQvRGVmYXVsdFNlbGVjdGFibGVSZW5kZXJlcn0gKi9cblx0cmVuZGVyZXI6IERlZmF1bHRTZWxlY3RhYmxlUmVuZGVyZXIsXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5fY2hpbGRyZW5JbnZhbGlkID0gdHJ1ZTtcblxuXHRcdG9wdGlvbnMucmVuZGVyZXIgJiYgKHRoaXMucmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyKTtcblx0XHR0aGlzLnNob3dFbXB0eSA9ICEhb3B0aW9ucy5zaG93RW1wdHk7XG5cdFx0dGhpcy5pdGVtVmlld3MgPSBuZXcgQ29udGFpbmVyKCk7XG5cblx0XHR0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgXCJhZGQgcmVtb3ZlIHJlc2V0XCIsIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHRWaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25Db2xsZWN0aW9uQ2hhbmdlOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMuX2NoaWxkcmVuSW52YWxpZCA9IHRydWU7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuSW52YWxpZCkge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW5JbnZhbGlkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmNyZWF0ZUNoaWxkcmVuKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0c2V0RW5hYmxlZDogZnVuY3Rpb24oZW5hYmxlZCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkICE9PSBlbmFibGVkKSB7XG5cdFx0XHR0aGlzLl9lbmFibGVkID0gZW5hYmxlZDtcblx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICF0aGlzLl9lbmFibGVkKTtcblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogQ2hpbGQgdmlld3Ncblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Y3JlYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbHRCdWZmZXIsIHZpZXc7XG5cblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5lbC5pbm5lckhUTUwgPSBcIlwiO1xuXG5cdFx0aWYgKHRoaXMuY29sbGVjdGlvbi5sZW5ndGgpIHtcblx0XHRcdGVsdEJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdGlmICh0aGlzLnNob3dFbXB0eSkge1xuXHRcdFx0XHR2aWV3ID0gdGhpcy5jcmVhdGVFbXB0eVZpZXcoKTtcblx0XHRcdFx0ZWx0QnVmZmVyLmFwcGVuZENoaWxkKHZpZXcucmVuZGVyKCkuZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24obW9kZWwsIGluZGV4LCBhcnIpIHtcblx0XHRcdFx0dmlldyA9IHRoaXMuY3JlYXRlSXRlbVZpZXcobW9kZWwsIGluZGV4KTtcblx0XHRcdFx0ZWx0QnVmZmVyLmFwcGVuZENoaWxkKHZpZXcucmVuZGVyKCkuZWwpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR0aGlzLmVsLmFwcGVuZENoaWxkKGVsdEJ1ZmZlcik7XG5cdFx0fVxuXHR9LFxuXG5cdGNyZWF0ZUl0ZW1WaWV3OiBmdW5jdGlvbihtb2RlbCwgaW5kZXgpIHtcblx0XHR2YXIgdmlldyA9IG5ldyh0aGlzLnJlbmRlcmVyKSh7XG5cdFx0XHRtb2RlbDogbW9kZWxcblx0XHR9KTtcblx0XHR0aGlzLml0ZW1WaWV3cy5hZGQodmlldyk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh2aWV3LCBcInJlbmRlcmVyOmNsaWNrXCIsIHRoaXMub25JdGVtVmlld0NsaWNrKTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pdGVtVmlld3MuZWFjaCh0aGlzLnJlbW92ZUl0ZW1WaWV3LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVJdGVtVmlldzogZnVuY3Rpb24odmlldykge1xuXHRcdHRoaXMuc3RvcExpc3RlbmluZyh2aWV3KTtcblx0XHR0aGlzLml0ZW1WaWV3cy5yZW1vdmUodmlldyk7XG5cdFx0dmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBDaGlsZCBldmVudCBoYW5kbGVyc1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQHByaXZhdGUgKi9cblx0b25JdGVtVmlld0NsaWNrOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHRoaXMuY29sbGVjdGlvbi5zZWxlY3RlZCAhPT0gaXRlbSAmJiB0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJ2aWV3OnNlbGVjdDpvbmVcIiwgaXRlbSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIEVtcHR5IHZpZXdcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Y3JlYXRlRW1wdHlWaWV3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IG5ldyBTZWxlY3RhYmxlTGlzdFZpZXcuRW1wdHlSZW5kZXJlcih7XG5cdFx0XHRtb2RlbDogdGhpcy5jb2xsZWN0aW9uXG5cdFx0fSk7XG5cdFx0dGhpcy5pdGVtVmlld3MuYWRkKHZpZXcpO1xuXHRcdHRoaXMubGlzdGVuVG8odmlldywgXCJyZW5kZXJlcjpjbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2VuYWJsZWQgJiYgdGhpcy50cmlnZ2VyKFwidmlldzpzZWxlY3Q6bm9uZVwiKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcbn0sIHtcblx0RW1wdHlSZW5kZXJlcjogQ2xpY2thYmxlUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHR0YWdOYW1lOiBcImxpXCIsXG5cdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdGNsYXNzTmFtZTogXCJsaXN0LWl0ZW0gZW1wdHktaXRlbVwiLFxuXG5cdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJzZWxlY3RlZCBkZXNlbGVjdGVkXCIsIHRoaXMucmVuZGVyQ2xhc3NMaXN0KTtcblx0XHRcdHRoaXMucmVuZGVyQ2xhc3NMaXN0KCk7XG5cdFx0fSxcblxuXHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5lbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9XFxcIiNjbGVhclxcXCI+PGI+IDwvYj48L2E+XCI7XG5cdFx0XHR0aGlzLnJlbmRlckNsYXNzTGlzdCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHJlbmRlckNsYXNzTGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCB0aGlzLm1vZGVsLnNlbGVjdGVkSW5kZXggPT09IC0xKTtcblx0XHR9LFxuXHR9KVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0YWJsZUxpc3RWaWV3O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuY29uc3QgQ29sb3IgPSByZXF1aXJlKFwiY29sb3JcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuY29uc3QgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvbn0gKi9cbmNvbnN0IGJ1bmRsZXMgPSByZXF1aXJlKFwiYXBwL21vZGVsL2NvbGxlY3Rpb24vQnVuZGxlQ29sbGVjdGlvblwiKTtcblxuLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuLy8gIHV0aWxzXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cbmZ1bmN0aW9uIGluc2VydENTU1J1bGUoc2hlZXQsIHNlbGVjdG9yLCBzdHlsZSkge1xuXHR2YXIgY3NzVGV4dCA9IFwiXCI7XG5cdGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcblx0XHRjc3NUZXh0ICs9IHByb3AgKyBcIjpcIiArIHN0eWxlW3Byb3BdICsgXCI7XCI7XG5cdH1cblx0c2hlZXQuaW5zZXJ0UnVsZShzZWxlY3RvciArIFwie1wiICsgY3NzVGV4dCArIFwifVwiLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBzZWxmQW5kRGVzY2VuZGFudChzZWxmQ2xzLCBjbHMpIHtcblx0cmV0dXJuIHNlbGZDbHMgKyBcIiBcIiArIGNscyArIFwiLCBcIiArIHNlbGZDbHMgKyBjbHM7XG59XG5cbi8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8vICByb290IHJ1bGVzXG4vLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cbnZhciByb290U3R5bGVzID0gW1xuXHRcImNvbG9yXCIsXG5cdFwiYmFja2dyb3VuZFwiLFxuXHRcImJhY2tncm91bmQtY29sb3JcIixcblx0Ly8gXCItLWxpbmstY29sb3JcIlxuXTtcblxuZnVuY3Rpb24gaW5pdFJvb3RTdHlsZXMoc2hlZXQsIHJvb3RTZWxlY3RvciwgYXR0cnMsIGZnQ29sb3IsIGJnQ29sb3IsIGxuQ29sb3IsIGhhc0RhcmtCZykge1xuXHR2YXIgcywgcmV2U2VsZWN0b3IsIGZnQ29sb3JWYWwsIGJnQ29sb3JWYWw7XG5cdC8vIHZhciByZXZGZ0NvbG9yVmFsLCByZXZCZ0NvbG9yVmFsO1xuXG5cdHMgPSBfLnBpY2soYXR0cnMsIHJvb3RTdHlsZXMpO1xuXHQvLyBzW1wiLXdlYmtpdC1mb250LXNtb290aGluZ1wiXSA9IChoYXNEYXJrQmcgPyBcImFudGlhbGlhc2VkXCIgOiBcImF1dG9cIik7XG5cdC8qIE5PVEU6IEluIEZpcmVmb3ggJy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7J1xuXHQvKiB3b3JrcyBib3RoIGluIGxpZ2h0IG92ZXIgZGFyayBhbmQgZGFyayBvdmVyIGxpZ2h0LCBoYXJkY29kZWQgaW4gX2Jhc2Uuc2NzcyAqL1xuXHQvL3NbXCItbW96LW9zeC1mb250LXNtb290aGluZ1wiXSA9IChoYXNEYXJrQmc/IFwiZ3JheXNjYWxlXCIgOiBcImF1dG9cIik7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHJvb3RTZWxlY3Rvciwgcyk7XG5cblx0Ly8gQSBlbGVtZW50XG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0cyA9IHt9XG5cdHNbXCJjb2xvclwiXSA9IGxuQ29sb3IucmdiKCkuc3RyaW5nKCk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHJvb3RTZWxlY3RvciArIFwiIGFcIiwgcyk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHJvb3RTZWxlY3RvciArIFwiIC5jb2xvci1sblwiLCBzKTtcblxuXHQvLyAuY29sb3ItZmcwNVxuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdHMgPSB7fTtcblx0c1tcImNvbG9yXCJdID0gQ29sb3IoZmdDb2xvcikubWl4KGJnQ29sb3IsIDAuNSkucmdiKCkuc3RyaW5nKCk7XG5cdHNbXCJib3JkZXItY29sb3JcIl0gPSBDb2xvcihmZ0NvbG9yKS5taXgoYmdDb2xvciwgMC4zKS5yZ2IoKS5zdHJpbmcoKTtcblx0aW5zZXJ0Q1NTUnVsZShzaGVldCwgcm9vdFNlbGVjdG9yICsgXCIgLmNvbG9yLWZnMDVcIiwgcyk7XG5cblx0ZmdDb2xvclZhbCA9IGZnQ29sb3IucmdiKCkuc3RyaW5nKCk7XG5cdGJnQ29sb3JWYWwgPSBiZ0NvbG9yLnJnYigpLnN0cmluZygpO1xuXHQvLyByZXZGZ0NvbG9yVmFsID0gQ29sb3IoYmdDb2xvcikubWl4KGZnQ29sb3IsIDAuOSkucmdiKCkuc3RyaW5nKCk7XG5cdC8vIHJldkJnQ29sb3JWYWwgPSBDb2xvcihmZ0NvbG9yKS5taXgoYmdDb2xvciwgMC42KS5yZ2IoKS5zdHJpbmcoKTtcblx0cmV2U2VsZWN0b3IgPSByb290U2VsZWN0b3IgKyBcIiAuY29sb3ItcmV2ZXJzZVwiO1xuXG5cdC8vIC5jb2xvci1mZyAuY29sb3ItYmdcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRzID0ge1xuXHRcdFwiY29sb3JcIjogZmdDb2xvclZhbFxuXHR9O1xuXHRpbnNlcnRDU1NSdWxlKHNoZWV0LCByb290U2VsZWN0b3IgKyBcIiAuY29sb3ItZmdcIiwgcyk7XG5cdHMgPSB7XG5cdFx0XCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGJnQ29sb3JWYWxcblx0fTtcblx0aW5zZXJ0Q1NTUnVsZShzaGVldCwgcm9vdFNlbGVjdG9yICsgXCIgLmNvbG9yLWJnXCIsIHMpO1xuXHQvLyBodG1sIGludmVydGVkIHRleHQvYmFja2dyb3VuZFxuXHRzID0ge1xuXHRcdFwiY29sb3JcIjogYmdDb2xvclZhbFxuXHR9OyAvLyBzID0geyBcImNvbG9yXCIgOiByZXZGZ0NvbG9yVmFsIH07XG5cdC8vIHNbXCItd2Via2l0LWZvbnQtc21vb3RoaW5nXCJdID0gKGhhc0RhcmtCZyA/IFwiYXV0b1wiIDogXCJhbnRpYWxpYXNlZFwiKTtcblx0Ly8gaW5zZXJ0Q1NTUnVsZShzaGVldCwgcmV2U2VsZWN0b3IgKyBcIiAuY29sb3ItZmdcIiwgcyk7XG5cdC8vIGluc2VydENTU1J1bGUoc2hlZXQsIHJldlNlbGVjdG9yICsgXCIuY29sb3ItZmdcIiwgcyk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHNlbGZBbmREZXNjZW5kYW50KHJldlNlbGVjdG9yLCBcIi5jb2xvci1mZ1wiKSwgcyk7XG5cblx0cyA9IHtcblx0XHRcImJhY2tncm91bmQtY29sb3JcIjogZmdDb2xvclZhbFxuXHR9O1xuXHQvLyBzID0geyBcImJhY2tncm91bmQtY29sb3JcIiA6IHJldkJnQ29sb3JWYWwgfTtcblx0Ly8gaW5zZXJ0Q1NTUnVsZShzaGVldCwgcmV2U2VsZWN0b3IgKyBcIiAuY29sb3ItYmdcIiwgcyk7XG5cdC8vIGluc2VydENTU1J1bGUoc2hlZXQsIHJldlNlbGVjdG9yICsgXCIuY29sb3ItYmdcIiwgcyk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHNlbGZBbmREZXNjZW5kYW50KHJldlNlbGVjdG9yLCBcIi5jb2xvci1iZ1wiKSwgcyk7XG5cblx0Ly8gLmNvbG9yLXN0cm9rZSAuY29sb3ItZmlsbCAoU1ZHKVxuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdHMgPSB7XG5cdFx0XCJzdHJva2VcIjogZmdDb2xvclZhbFxuXHR9O1xuXHRpbnNlcnRDU1NSdWxlKHNoZWV0LCByb290U2VsZWN0b3IgKyBcIiAuY29sb3Itc3Ryb2tlXCIsIHMpO1xuXHRzID0ge1xuXHRcdFwiZmlsbFwiOiBiZ0NvbG9yVmFsXG5cdH07XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHJvb3RTZWxlY3RvciArIFwiIC5jb2xvci1maWxsXCIsIHMpO1xuXHQvLyBzdmcgaW52ZXJ0ZWQgZmlsbC9zdHJva2Vcblx0cyA9IHtcblx0XHRcInN0cm9rZVwiOiBiZ0NvbG9yVmFsXG5cdH07XG5cdC8vIGluc2VydENTU1J1bGUoc2hlZXQsIHJldlNlbGVjdG9yICsgXCIgLmNvbG9yLXN0cm9rZVwiLCBzKTtcblx0Ly8gaW5zZXJ0Q1NTUnVsZShzaGVldCwgcmV2U2VsZWN0b3IgKyBcIi5jb2xvci1zdHJva2VcIiwgcyk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIHNlbGZBbmREZXNjZW5kYW50KHJldlNlbGVjdG9yLCBcIi5jb2xvci1zdHJva2VcIiksIHMpO1xuXHRzID0ge1xuXHRcdFwiZmlsbFwiOiBmZ0NvbG9yVmFsXG5cdH07XG5cdC8vIGluc2VydENTU1J1bGUoc2hlZXQsIHJldlNlbGVjdG9yICsgXCIgLmNvbG9yLWZpbGxcIiwgcyk7XG5cdC8vIGluc2VydENTU1J1bGUoc2hlZXQsIHJldlNlbGVjdG9yICsgXCIuY29sb3ItZmlsbFwiLCBzKTtcblx0aW5zZXJ0Q1NTUnVsZShzaGVldCwgc2VsZkFuZERlc2NlbmRhbnQocmV2U2VsZWN0b3IsIFwiLmNvbG9yLWZpbGxcIiksIHMpO1xuXG5cdC8vIC50ZXh0LW91dGxpbmVcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHQvLyBzID0ge1xuXHQvLyBcdFwidGV4dC1zaGFkb3dcIjogXCItMXB4IC0xcHggMCBcIiArIGJnQ29sb3JWYWwgK1xuXHQvLyBcdFx0XCIsIDFweCAtMXB4IDAgXCIgKyBiZ0NvbG9yVmFsICtcblx0Ly8gXHRcdFwiLCAtMXB4IDFweCAwIFwiICsgYmdDb2xvclZhbCArXG5cdC8vIFx0XHRcIiwgMXB4IDFweCAwIFwiICsgYmdDb2xvclZhbFxuXHQvLyB9O1xuXHQvLyBpbnNlcnRDU1NSdWxlKHNoZWV0LCByb290U2VsZWN0b3IgKyBcIiA6bm90KC4uY29sbGFwc2VkLWNoYW5naW5nKSAudGV4dC1vdXRsaW5lLWJnXCIsIHMpO1xuXG59XG5cbi8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cbi8vIGNhcm91c2VsIHN0eWxlc1xuLy8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXG52YXIgY2Fyb3VzZWxTdHlsZXMgPSBbXCJib3gtc2hhZG93XCIsIFwiYm9yZGVyXCIsIFwiYm9yZGVyLXJhZGl1c1wiXTtcblxuZnVuY3Rpb24gaW5pdENhcm91c2VsU3R5bGVzKHNoZWV0LCBjYXJvdXNlbFNlbGVjdG9yLCBhdHRycywgZmdDb2xvciwgYmdDb2xvciwgbG5Db2xvciwgaGFzRGFya0JnKSB7XG5cdHZhciBzID0gXy5waWNrKGF0dHJzLCBjYXJvdXNlbFN0eWxlcyk7IC8vLCBcImJhY2tncm91bmQtY29sb3JcIl0pO1xuXHRpbnNlcnRDU1NSdWxlKHNoZWV0LCBjYXJvdXNlbFNlbGVjdG9yICsgXCIgLm1lZGlhLWl0ZW0gLmNvbnRlbnRcIiwgcyk7XG5cblx0Ly8gLm1lZGlhLWl0ZW0gLmNvbG9yLWJnMDlcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRzID0ge307XG5cdHNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gQ29sb3IoYmdDb2xvcikubWl4KGZnQ29sb3IsIDAuMDUpLnJnYigpLnN0cmluZygpO1xuXHQvLyBzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IENvbG9yKGJnQ29sb3IpW2hhc0RhcmtCZyA/IFwiZGFya2VuXCIgOiBcImxpZ2h0ZW5cIl0oMC4wNDUpLnJnYigpLnN0cmluZygpO1xuXHQvLyBzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IENvbG9yKGJnQ29sb3IpW2hhc0RhcmtCZyA/IFwibGlnaHRlblwiIDogXCJkYXJrZW5cIl0oMC4wMykucmdiKCkuc3RyaW5nKCk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIGNhcm91c2VsU2VsZWN0b3IgKyBcIiAubWVkaWEtaXRlbSAuY29sb3ItYmcwOVwiLCBzKTtcblxuXHQvLyAubWVkaWEtaXRlbSAucGxhY2Vob2xkZXJcblx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRzID0ge307XG5cdC8vIHNbXCItd2Via2l0LWZvbnQtc21vb3RoaW5nXCJdID0gKGhhc0RhcmtCZyA/IFwiYXV0b1wiIDogXCJhbnRpYWxpYXNlZFwiKTtcblx0Ly8gdGV4dCBjb2xvciBsdW1pbm9zaXR5IGlzIGludmVyc2UgZnJvbSBib2R5LCBhcHBseSBvcG9zaXRlIHJlbmRlcmluZyBtb2RlXG5cdHNbXCJjb2xvclwiXSA9IGJnQ29sb3IucmdiKCkuc3RyaW5nKCk7XG5cdC8vIHNbXCJjb2xvclwiXSA9IENvbG9yKGJnQ29sb3IpW2hhc0RhcmtCZyA/IFwiZGFya2VuXCIgOiBcImxpZ2h0ZW5cIl0oMC4wNDUpLnJnYigpLnN0cmluZygpO1xuXHRzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IENvbG9yKGJnQ29sb3IpLm1peChmZ0NvbG9yLCAwLjA1KS5yZ2IoKS5zdHJpbmcoKTtcblx0Ly8gc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBDb2xvcihiZ0NvbG9yKS5taXgoZmdDb2xvciwgMC44KS5hbHBoYSgwLjMpLnJnYmEoKS5zdHJpbmcoKTtcblx0Ly8gc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBDb2xvcihiZ0NvbG9yKVtoYXNEYXJrQmcgPyBcImxpZ2h0ZW5cIiA6IFwiZGFya2VuXCJdKDAuMDMpLnJnYigpLnN0cmluZygpO1xuXHQoXCJib3JkZXItcmFkaXVzXCIgaW4gYXR0cnMpICYmIChzW1wiYm9yZGVyLXJhZGl1c1wiXSA9IGF0dHJzW1wiYm9yZGVyLXJhZGl1c1wiXSk7XG5cdGluc2VydENTU1J1bGUoc2hlZXQsIGNhcm91c2VsU2VsZWN0b3IgKyBcIiAubWVkaWEtaXRlbSAucGxhY2Vob2xkZXJcIiwgcyk7XG5cblx0Ly8gLmVtcHR5LWl0ZW0gQVxuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdHMgPSB7fTtcblx0c1tcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiXSA9IENvbG9yKGZnQ29sb3IpLm1peChiZ0NvbG9yLCAwLjcpLnJnYigpLnN0cmluZygpO1xuXHRpbnNlcnRDU1NSdWxlKHNoZWV0LCBjYXJvdXNlbFNlbGVjdG9yICsgXCIgLmVtcHR5LWl0ZW0gQVwiLCBzKTtcblx0Ly8gLy8gLmNvbG9yLWdyYWRpZW50XG5cdC8vIC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0Ly8gcyA9IHt9O1xuXHQvLyBzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwidHJhbnNwYXJlbnRcIjtcblx0Ly8gc1tcImJhY2tncm91bmRcIl0gPSBcImxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIFwiICtcblx0Ly8gXHRcdENvbG9yKGJnQ29sb3IpLmFscGhhKDAuMDApLnJnYmEoKS5zdHJpbmcoKSArIFwiIDAlLCBcIiArXG5cdC8vIFx0XHRDb2xvcihiZ0NvbG9yKS5hbHBoYSgwLjExKS5yZ2JhKCkuc3RyaW5nKCkgKyBcIiAxMDAlKVwiO1xuXHQvLyBpbnNlcnRDU1NSdWxlKHNoZWV0LCByb290U2VsZWN0b3IgKyBcIiAuY29sb3ItZ3JhZGllbnRcIiwgcyk7XG5cdC8vIHMgPSB7fTtcblx0Ly8gc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBcInRyYW5zcGFyZW50XCI7XG5cdC8vIHNbXCJiYWNrZ3JvdW5kXCJdID0gXCJsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCBcIiArXG5cdC8vIFx0XHRDb2xvcihmZ0NvbG9yKS5hbHBoYSgwLjAwKS5yZ2JhKCkuc3RyaW5nKCkgKyBcIiAwJSwgXCIgK1xuXHQvLyBcdFx0Q29sb3IoZmdDb2xvcikuYWxwaGEoMC4xMSkucmdiYSgpLnN0cmluZygpICsgXCIgMTAwJSlcIjtcblx0Ly8gaW5zZXJ0Q1NTUnVsZShzaGVldCwgcmV2U2VsZWN0b3IgKyBcIiAuY29sb3ItZ3JhZGllbnRcIiwgcyk7XG5cdC8vIGluc2VydENTU1J1bGUoc2hlZXQsIHJldlNlbGVjdG9yICsgXCIuY29sb3ItZ3JhZGllbnRcIiwgcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBhdHRycywgZmdDb2xvciwgYmdDb2xvciwgbG5Db2xvciwgaGFzRGFya0JnO1xuXG5cdGF0dHJzID0gR2xvYmFscy5ERUZBVUxUX0NPTE9SUztcblx0ZmdDb2xvciA9IG5ldyBDb2xvcihHbG9iYWxzLkRFRkFVTFRfQ09MT1JTW1wiY29sb3JcIl0pO1xuXHRiZ0NvbG9yID0gbmV3IENvbG9yKEdsb2JhbHMuREVGQVVMVF9DT0xPUlNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdKTtcblx0bG5Db2xvciA9IG5ldyBDb2xvcihHbG9iYWxzLkRFRkFVTFRfQ09MT1JTW1wibGluay1jb2xvclwiXSlcblx0aGFzRGFya0JnID0gZmdDb2xvci5sdW1pbm9zaXR5KCkgPiBiZ0NvbG9yLmx1bWlub3NpdHkoKTtcblxuXHR2YXIgY29sb3JTdHlsZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdGNvbG9yU3R5bGVzLmlkID0gXCJjb2xvcnNcIjtcblx0Y29sb3JTdHlsZXMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChjb2xvclN0eWxlcyk7XG5cdC8vIHZhciBjb2xvclN0eWxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsaW5rI2ZvbGlvXCIpO1xuXG5cdGluaXRSb290U3R5bGVzKGNvbG9yU3R5bGVzLnNoZWV0LCBcIi5hcHBcIixcblx0XHRhdHRycywgZmdDb2xvciwgYmdDb2xvciwgbG5Db2xvciwgaGFzRGFya0JnKTtcblx0aW5pdENhcm91c2VsU3R5bGVzKGNvbG9yU3R5bGVzLnNoZWV0LCBcIi5jYXJvdXNlbFwiLFxuXHRcdGF0dHJzLCBmZ0NvbG9yLCBiZ0NvbG9yLCBsbkNvbG9yLCBoYXNEYXJrQmcpO1xuXG5cdC8vIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0Ly8gcGVyLWJ1bmRsZSBydWxlc1xuXHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXG5cdGJ1bmRsZXMuZWFjaChmdW5jdGlvbihidW5kbGUpIHtcblx0XHRhdHRycyA9IGJ1bmRsZS5hdHRycygpOyAvL2dldChcImF0dHJzXCIpO1xuXHRcdGZnQ29sb3IgPSBidW5kbGUuY29sb3JzLmZnQ29sb3I7XG5cdFx0YmdDb2xvciA9IGJ1bmRsZS5jb2xvcnMuYmdDb2xvcjtcblx0XHRsbkNvbG9yID0gYnVuZGxlLmNvbG9ycy5sbkNvbG9yO1xuXHRcdGhhc0RhcmtCZyA9IGJ1bmRsZS5jb2xvcnMuaGFzRGFya0JnO1xuXG5cdFx0aW5pdFJvb3RTdHlsZXMoY29sb3JTdHlsZXMuc2hlZXQsXG5cdFx0XHRcIi5hcHAuXCIgKyBidW5kbGUuZ2V0KFwiZG9taWRcIiksXG5cdFx0XHRhdHRycywgZmdDb2xvciwgYmdDb2xvciwgbG5Db2xvciwgaGFzRGFya0JnKTtcblx0XHRpbml0Q2Fyb3VzZWxTdHlsZXMoY29sb3JTdHlsZXMuc2hlZXQsXG5cdFx0XHRcIi5jYXJvdXNlbC5cIiArIGJ1bmRsZS5nZXQoXCJkb21pZFwiKSxcblx0XHRcdGF0dHJzLCBmZ0NvbG9yLCBiZ0NvbG9yLCBsbkNvbG9yLCBoYXNEYXJrQmcpO1xuXHR9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qZ2xvYmFsIFhNTEh0dHBSZXF1ZXN0ICovXG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnVuZGVyc2NvcmUuc3RyaW5nL2xwYWR9ICovXG4vLyB2YXIgY2xhc3NpZnkgPSByZXF1aXJlKFwidW5kZXJzY29yZS5zdHJpbmcvY2xhc3NpZnlcIik7XG5cbi8vIHZhciBzdGF0dXNNc2cgPSBfLnRlbXBsYXRlKFwiPCU9IHN0YXR1cyAlPiByZWNlaXZlZCBmcm9tIDwlPSB1cmwgJT4gKDwlPSBzdGF0dXNUZXh0ICU+KVwiKTtcbi8vIHZhciBlcnJNc2cgPSBfLnRlbXBsYXRlKFwiJzwlPSBlcnJOYW1lICU+JyBvY3VycmVkIGR1cmluZyByZXF1ZXN0IDwlPSB1cmwgJT5cIik7XG5cbmlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgd2luZG93LlVSTCAmJiB3aW5kb3cuQmxvYikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcHJvZ3Jlc3NGbikge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcblx0XHRcdC8vIHJlcXVlc3QudGltZW91dCA9IDEwMDAwOyAvLyBpbiBtaWxsaXNlY29uZHNcblx0XHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJibG9iXCI7XG5cblx0XHRcdHZhciBlcnJvckZyb21FdmVudCA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgRXJyb3IoKGV2LnRhcmdldC5zdGF0dXMgPiAwID9cblx0XHRcdFx0XHRcImh0dHBfXCIgKyByZXF1ZXN0LnN0YXR1c1RleHQucmVwbGFjZSgvXFxzL2csIFwiX1wiKSA6XG5cdFx0XHRcdFx0ZXYudHlwZSArIFwiX2V2ZW50XCIpLnRvVXBwZXJDYXNlKCkpO1xuXHRcdFx0XHRlcnIuaW5mb0NvZGUgPSBldi50YXJnZXQuc3RhdHVzO1xuXHRcdFx0XHRlcnIuaW5mb1NyYyA9IHVybDtcblx0XHRcdFx0ZXJyLmxvZ0V2ZW50ID0gZXY7XG5cdFx0XHRcdGVyci5sb2dNZXNzYWdlID0gXCJfbG9hZEltYWdlQXNPYmplY3RVUkw6OlwiICsgZXYudHlwZSArIFwiIFtyZWplY3RdXCI7XG5cdFx0XHRcdHJldHVybiBlcnI7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBpZiBwcm9ncmVzc0ZuIGlzIHN1cHBsaWVkXG5cdFx0XHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcdFx0aWYgKHByb2dyZXNzRm4pIHtcblx0XHRcdFx0cmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0XHRwcm9ncmVzc0ZuKGV2LmxvYWRlZCAvIGV2LnRvdGFsLCByZXF1ZXN0KTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzb2x2ZWQvc3VjY2Vzc1xuXHRcdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XHRcdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0Ly8gV2hlbiB0aGUgcmVxdWVzdCBsb2FkcywgY2hlY2sgd2hldGhlciBpdCB3YXMgc3VjY2Vzc2Z1bFxuXHRcdFx0XHRpZiAocmVxdWVzdC5zdGF0dXMgPT0gMjAwKSB7XG5cdFx0XHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgcmVzb2x2ZSB0aGUgcHJvbWlzZSBieSBwYXNzaW5nIGJhY2sgYSByZWZlcmVuY2UgdXJsXG5cdFx0XHRcdFx0cmVzb2x2ZShVUkwuY3JlYXRlT2JqZWN0VVJMKHJlcXVlc3QucmVzcG9uc2UpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3JGcm9tRXZlbnQoZXYpKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdC8vIG5vcm1hbCBhYm9ydFxuXHRcdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XHRcdHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHJlc29sdmUodm9pZCAwKTtcblx0XHRcdH07XG5cdFx0XHQvLyByZWplY3QvZmFpbHVyZVxuXHRcdFx0Ly8gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cblx0XHRcdHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHJlamVjdChlcnJvckZyb21FdmVudChldikpO1xuXHRcdFx0fTtcblx0XHRcdHJlcXVlc3Qub250aW1lb3V0ID0gcmVxdWVzdC5vbmVycm9yO1xuXG5cdFx0XHQvLyBmaW5hbGx5XG5cdFx0XHQvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxuXHRcdFx0cmVxdWVzdC5vbmxvYWRlbmQgPSBmdW5jdGlvbihldikge1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiX2xvYWRJbWFnZUFzT2JqZWN0VVJMOjolcyBbY2xlYW51cF0gKCVzKVwiLCBldiA/IGV2LnR5cGUgOiBcIm5vIGV2ZW50XCIsIHVybCk7XG5cdFx0XHRcdHJlcXVlc3Qub25hYm9ydCA9IHJlcXVlc3Qub250aW1lb3V0ID0gcmVxdWVzdC5vbmVycm9yID0gdm9pZCAwO1xuXHRcdFx0XHRyZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25sb2FkZW5kID0gdm9pZCAwO1xuXHRcdFx0XHRpZiAocHJvZ3Jlc3NGbikge1xuXHRcdFx0XHRcdHJlcXVlc3Qub25wcm9ncmVzcyA9IHZvaWQgMDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0cmVxdWVzdC5zZW5kKCk7XG5cdFx0fSk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcHJvZ3Jlc3NGbikge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodXJsKTtcblx0fTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbWFnZSwgcmVzb2x2ZUVtcHR5KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRpZiAoIShpbWFnZSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSW1hZ2VFbGVtZW50KSkge1xuXHRcdFx0Ly9yZWplY3QobmV3IEVycm9yKFwibm90IGFuIEhUTUxJbWFnZUVsZW1lbnRcIikpO1xuXHRcdFx0cmVqZWN0KFwiRXJyb3I6IG5vdCBhbiBIVE1MSW1hZ2VFbGVtZW50XCIpO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2UuY29tcGxldGUgJiYgKGltYWdlLnNyYy5sZW5ndGggPiAwIHx8IHJlc29sdmVFbXB0eSkpIHtcblx0XHRcdC8vIGlmIChpbWFnZS5zcmMgPT09IFwiXCIpIGNvbnNvbGUud2FybihcIl93aGVuSW1hZ2VMb2FkcyByZXNvbHZlZCB3aXRoIGVtcHR5IHNyY1wiKTtcblx0XHRcdC8vIGVsc2UgY29uc29sZS5sb2coXCJfd2hlbkltYWdlTG9hZHMgcmVzb2x2ZS1zeW5jXCIsIGltYWdlLnNyYyk7XG5cdFx0XHRyZXNvbHZlKGltYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGhhbmRsZXJzID0ge1xuXHRcdFx0XHRsb2FkOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiX3doZW5JbWFnZUxvYWRzX2RvbSByZXNvbHZlLWFzeW5jXCIsIGV2LnR5cGUsIGltYWdlLnNyYyk7XG5cdFx0XHRcdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblx0XHRcdFx0XHRyZXNvbHZlKGltYWdlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdFx0dmFyIGVyciA9IG5ldyBFcnJvcihcIkxvYWRpbmcgZmFpbGVkIChcIiArIGV2LnR5cGUgKyBcIiBldmVudClcIik7XG5cdFx0XHRcdFx0ZXJyLmluZm9Db2RlID0gLTE7XG5cdFx0XHRcdFx0ZXJyLmluZm9TcmMgPSBpbWFnZS5zcmM7XG5cdFx0XHRcdFx0ZXJyLmxvZ0V2ZW50ID0gZXY7XG5cdFx0XHRcdFx0ZXJyLmxvZ01lc3NhZ2UgPSBcIl93aGVuSW1hZ2VMb2Fkczo6XCIgKyBldi50eXBlICsgXCIgW3JlamVjdF1cIjtcblx0XHRcdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xuXHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0aGFuZGxlcnMuYWJvcnQgPSBoYW5kbGVycy5lcnJvcjtcblx0XHRcdHZhciByZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKHZhciBldmVudCBpbiBoYW5kbGVycykge1xuXHRcdFx0XHRcdGlmIChoYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblx0XHRcdFx0XHRcdGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJzW2V2ZW50XSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGZvciAodmFyIGV2ZW50IGluIGhhbmRsZXJzKSB7XG5cdFx0XHRcdGlmIChoYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblx0XHRcdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9wcm9taXNlL193aGVuSW1hZ2VMb2Fkc30gKi9cbmNvbnN0IF93aGVuSW1hZ2VMb2FkcyA9IHJlcXVpcmUoXCJhcHAvdmlldy9wcm9taXNlL193aGVuSW1hZ2VMb2Fkc1wiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3Byb21pc2UvX2xvYWRJbWFnZUFzT2JqZWN0VVJMfSAqL1xuY29uc3QgX2xvYWRJbWFnZUFzT2JqZWN0VVJMID0gcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2UvX2xvYWRJbWFnZUFzT2JqZWN0VVJMXCIpO1xuXG4vLyB2YXIgaXNCbG9iUkUgPSAvXmJsb2JcXDouKi87XG5cbi8vIHZhciBsb2dNZXNzYWdlID0gXCIlczo6d2hlbkRlZmF1bHRJbWFnZUxvYWRzIFslc106ICVzXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmlldykge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0dmFyIHNvdXJjZSA9IHZpZXcubW9kZWwuZ2V0KFwic291cmNlXCIpO1xuXHRcdGlmIChzb3VyY2UuaGFzKFwicHJlZmV0Y2hlZFwiKSkge1xuXHRcdFx0dmlldy5kZWZhdWx0SW1hZ2Uuc3JjID0gc291cmNlLmdldChcInByZWZldGNoZWRcIik7XG5cdFx0XHRfd2hlbkltYWdlTG9hZHModmlldy5kZWZhdWx0SW1hZ2UpXG5cdFx0XHRcdC50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHRhcmdldEVsKSB7XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhsb2dNZXNzYWdlLCB2aWV3LmNpZCwgXCJyZXNvbHZlZFwiLCBcInByZWZldGNoZWRcIik7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHZpZXcpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3Lm1lZGlhU3RhdGUgPSBcInBlbmRpbmdcIjtcblxuXHRcdFx0dmFyIHNVcmwgPSBzb3VyY2UuZ2V0KFwib3JpZ2luYWxcIik7XG5cdFx0XHR2YXIgcHJvZ3Jlc3NGbiA9IGZ1bmN0aW9uKHByb2dyZXNzLCBldikge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhsb2dNZXNzYWdlLCB2aWV3LmNpZCwgXCJwcm9ncmVzc1wiLCBwcm9ncmVzcyk7XG5cdFx0XHRcdHZpZXcudXBkYXRlTWVkaWFQcm9ncmVzcyhwcm9ncmVzcywgc1VybCk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvZ3Jlc3NGbiA9IF8udGhyb3R0bGUocHJvZ3Jlc3NGbiwgMTAwLCB7XG5cdFx0XHRcdGxlYWRpbmc6IHRydWUsXG5cdFx0XHRcdHRyYWlsaW5nOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRfbG9hZEltYWdlQXNPYmplY3RVUkwoc1VybCwgcHJvZ3Jlc3NGbilcblx0XHRcdFx0LnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24odXJsKSB7XG5cdFx0XHRcdFx0XHRpZiAoL15ibG9iXFw6LiovLnRlc3QodXJsKSkge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2Uuc2V0KFwicHJlZmV0Y2hlZFwiLCB1cmwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmlldy5kZWZhdWx0SW1hZ2Uuc3JjID0gdXJsO1xuXHRcdFx0XHRcdFx0Ly8gVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZpZXcuZGVmYXVsdEltYWdlO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKF93aGVuSW1hZ2VMb2Fkcylcblx0XHRcdFx0LnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24odGFyZ2V0RWwpIHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGxvZ01lc3NhZ2UsIHZpZXcuY2lkLCBcInJlc29sdmVkXCIsIHRhcmdldEVsLnNyYyk7XG5cdFx0XHRcdFx0XHR2aWV3Lm9uKFwidmlldzpyZW1vdmVkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJlZmV0Y2hlZCA9IHNvdXJjZS5nZXQoXCJwcmVmZXRjaGVkXCIpO1xuXHRcdFx0XHRcdFx0XHRpZiAocHJlZmV0Y2hlZCAmJiAvXmJsb2JcXDovLnRlc3QocHJlZmV0Y2hlZCkpIHtcblx0XHRcdFx0XHRcdFx0XHRzb3VyY2UudW5zZXQoXCJwcmVmZXRjaGVkXCIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNpbGVudDogdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwocHJlZmV0Y2hlZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Ly8gdmlldy5wbGFjZWhvbGRlci5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXByb2dyZXNzXCIpO1xuXHRcdFx0XHRcdFx0Ly8gdmlldy51cGRhdGVNZWRpYVByb2dyZXNzKGltYWdlVXJsLCBcImNvbXBsZXRlXCIpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSh2aWV3KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8vIFx0fSlcblx0XHRcdFx0XHQvLyAuY2F0Y2goXG5cdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLndhcm4obG9nTWVzc2FnZSwgdmlldy5jaWQsIFwicmVqZWN0ZWRcIiwgZXJyLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0Ly8gdmlldy5wbGFjZWhvbGRlci5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXByb2dyZXNzXCIpO1xuXHRcdFx0XHRcdFx0Ly8gdmlldy51cGRhdGVNZWRpYVByb2dyZXNzKGltYWdlVXJsLCBwcm9ncmVzcyk7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIFByb21pc2UgKi9cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld0Vycm9yfSAqL1xuY29uc3QgVmlld0Vycm9yID0gcmVxdWlyZShcImFwcC92aWV3L2Jhc2UvVmlld0Vycm9yXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXdFcnJvcn0gKi9cbmNvbnN0IHdoZW5WaWV3SXNBdHRhY2hlZCA9IHJlcXVpcmUoXCJhcHAvdmlldy9wcm9taXNlL3doZW5WaWV3SXNBdHRhY2hlZFwiKTtcblxuZnVuY3Rpb24gd2hlblNjcm9sbGluZ0VuZHModmlldykge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0dmFyIHBhcmVudCA9IHZpZXcucGFyZW50Vmlldztcblx0XHRpZiAocGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiJXM6OndoZW5TY3JvbGxpbmdFbmRzIFslc10gKHN5bmMpXCIsIHZpZXcuY2lkLCBcInJlamVjdGVkXCIsIHZpZXcuYXR0YWNoZWQpO1xuXHRcdFx0cmVqZWN0KG5ldyBWaWV3RXJyb3IodmlldywgbmV3IEVycm9yKFwid2hlblNjcm9sbGluZ0VuZHM6IHZpZXcgaGFzIG5vIHBhcmVudFwiKSkpO1xuXHRcdH0gZWxzZSBpZiAoIXBhcmVudC5zY3JvbGxpbmcpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OndoZW5TY3JvbGxpbmdFbmRzIFslc10gKHN5bmMpXCIsIHZpZXcuY2lkLCBcInJlc29sdmVkXCIsIHZpZXcuYXR0YWNoZWQpO1xuXHRcdFx0cmVzb2x2ZSh2aWV3KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cGFyZW50Lm9mZihcInZpZXc6c2Nyb2xsZW5kXCIsIG9uU2Nyb2xsZW5kKTtcblx0XHRcdFx0cGFyZW50Lm9mZihcInZpZXc6cmVtb3ZlXCIsIG9uUmVtb3ZlKTtcblx0XHRcdH07XG5cdFx0XHR2YXIgb25TY3JvbGxlbmQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczo6d2hlblNjcm9sbGluZ0VuZHMgWyVzXVwiLCB2aWV3LmNpZCwgXCJyZXNvbHZlZFwiLCB2aWV3LmF0dGFjaGVkKTtcblx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRyZXNvbHZlKHZpZXcpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBvblJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjp3aGVuU2Nyb2xsaW5nRW5kcyBbJXNdXCIsIHZpZXcuY2lkLCBcInJlamVjdGVkXCIsIHZpZXcuYXR0YWNoZWQpO1xuXHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdHJlamVjdChuZXcgVmlld0Vycm9yKHZpZXcsIG5ldyBFcnJvcihcIndoZW5TY3JvbGxpbmdFbmRzOiB2aWV3IHdhcyByZW1vdmVkXCIpKSk7XG5cdFx0XHR9O1xuXHRcdFx0cGFyZW50Lm9uKFwidmlldzpzY3JvbGxlbmRcIiwgb25TY3JvbGxlbmQpO1xuXHRcdFx0cGFyZW50Lm9uKFwidmlldzpyZW1vdmVcIiwgb25SZW1vdmUpO1xuXHRcdH1cblx0fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmlldykge1xuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZpZXcpXG5cdFx0LnRoZW4od2hlblZpZXdJc0F0dGFjaGVkKVxuXHRcdC50aGVuKHdoZW5TY3JvbGxpbmdFbmRzKTtcbn07XG5cbi8qXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZpZXcpIHtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2aWV3KVxuXHRcdC50aGVuKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdGlmICh2aWV3LmF0dGFjaGVkKSB7XG5cdFx0XHRcdHJldHVybiB2aWV3O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRcdHZpZXcub25jZShcInZpZXc6YXR0YWNoZWRcIiwgZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSh2aWV3KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHQudGhlbihmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRpZiAoIXZpZXcucGFyZW50Vmlldy5zY3JvbGxpbmcpIHtcblx0XHRcdFx0cmV0dXJuIHZpZXc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIHJlc29sdmVPblNjcm9sbGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczo6d2hlblNjcm9sbGluZ0VuZHMgWyVzXVwiLCB2aWV3LmNpZCwgXCJyZXNvbHZlZFwiKTtcblx0XHRcdFx0XHRcdHZpZXcub2ZmKFwidmlldzpyZW1vdmVcIiwgcmVqZWN0T25SZW1vdmUpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSh2aWV3KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHZhciByZWplY3RPblJlbW92ZSA9IGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OndoZW5TY3JvbGxpbmdFbmRzIFslc11cIiwgdmlldy5jaWQsIFwicmVqZWN0ZWRcIik7XG5cdFx0XHRcdFx0XHR2aWV3LnBhcmVudFZpZXcub2ZmKFwidmlldzpzY3JvbGxlbmRcIiwgcmVzb2x2ZU9uU2Nyb2xsZW5kKTtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgVmlld0Vycm9yKHZpZXcsXG5cdFx0XHRcdFx0XHRcdG5ldyBFcnJvcihcIndoZW5TZWxlY3RTY3JvbGxpbmdFbmRzOiB2aWV3IHdhcyByZW1vdmVkIChcIisgdmlldy5jaWQgK1wiKVwiKSkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dmlldy5wYXJlbnRWaWV3Lm9uY2UoXCJ2aWV3OnNjcm9sbGVuZFwiLCByZXNvbHZlT25TY3JvbGxlbmQpO1xuXHRcdFx0XHRcdHZpZXcub25jZShcInZpZXc6cmVtb3ZlXCIsIHJlamVjdE9uUmVtb3ZlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG59O1xuKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9WaWV3RXJyb3J9ICovXG5jb25zdCBWaWV3RXJyb3IgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3RXJyb3JcIik7XG5cbi8vIHZhciBsb2dNZXNzYWdlID0gXCIlczo6d2hlblNlbGVjdGlvbkRpc3RhbmNlSXMgWyVzXTogJXNcIjtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2aWV3LCBkaXN0YW5jZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0Ly8gaWYgKCEodmlldy5tb2RlbCAmJiB2aWV3Lm1vZGVsLmNvbGxlY3Rpb24pKSB7XG5cdFx0Ly8gXHRyZWplY3QobmV3IFZpZXdFcnJvcih2aWV3LCBuZXcgRXJyb3IoXCJ3aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzOiBtb2RlbC5jb2xsZWN0aW9uIGlzIGVtcHR5XCIpKSk7XG5cdFx0Ly8gfVxuXHRcdHZhciBtb2RlbCA9IHZpZXcubW9kZWw7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSBtb2RlbC5jb2xsZWN0aW9uO1xuXG5cdFx0dmFyIGNoZWNrID0gZnVuY3Rpb24obikgeyAvLyBDaGVjayBpbmRpY2VzIGZvciBjb250aWd1aXR5XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoY29sbGVjdGlvbi5pbmRleE9mKG1vZGVsKSAtIGNvbGxlY3Rpb24uc2VsZWN0ZWRJbmRleCkgPD0gZGlzdGFuY2U7XG5cdFx0fTtcblxuXHRcdGlmIChjaGVjaygpKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhsb2dNZXNzYWdlLCB2aWV3LmNpZCwgXCJyZXNvbHZlXCIsIFwic3luY1wiKTtcblx0XHRcdHJlc29sdmUodmlldyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjbGVhbnVwT25TZXR0bGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2cobG9nTWVzc2FnZSwgdmlldy5jaWQsIFwiY2xlYW51cFwiLCBcImFzeW5jXCIpO1xuXHRcdFx0XHRjb2xsZWN0aW9uLm9mZihcInNlbGVjdDpvbmUgc2VsZWN0Om5vbmVcIiwgcmVzb2x2ZU9uU2VsZWN0KTtcblx0XHRcdFx0dmlldy5vZmYoXCJ2aWV3OnJlbW92ZWRcIiwgcmVqZWN0T25SZW1vdmUpO1xuXHRcdFx0fTtcblx0XHRcdHZhciByZXNvbHZlT25TZWxlY3QgPSBmdW5jdGlvbihtb2RlbCkge1xuXHRcdFx0XHRpZiAoY2hlY2soKSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGxvZ01lc3NhZ2UsIHZpZXcuY2lkLCBcInJlc29sdmVcIiwgXCJhc3luY1wiKTtcblx0XHRcdFx0XHRjbGVhbnVwT25TZXR0bGUoKTtcblx0XHRcdFx0XHRyZXNvbHZlKHZpZXcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0dmFyIHJlamVjdE9uUmVtb3ZlID0gZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHRjbGVhbnVwT25TZXR0bGUoKTtcblx0XHRcdFx0cmVqZWN0KG5ldyBWaWV3RXJyb3IodmlldywgbmV3IEVycm9yKFwid2hlblNlbGVjdGlvbkRpc3RhbmNlSXM6IHZpZXcgd2FzIHJlbW92ZWRcIikpKTtcblx0XHRcdH07XG5cdFx0XHRjb2xsZWN0aW9uLm9uKFwic2VsZWN0Om9uZSBzZWxlY3Q6bm9uZVwiLCByZXNvbHZlT25TZWxlY3QpO1xuXHRcdFx0dmlldy5vbihcInZpZXc6cmVtb3ZlZFwiLCByZWplY3RPblJlbW92ZSk7XG5cdFx0fVxuXHR9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld0Vycm9yfSAqL1xuLy8gdmFyIFZpZXdFcnJvciA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL1ZpZXdFcnJvclwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcHJvbWlzZS93aGVuU2VsZWN0aW9uRGlzdGFuY2VJc30gKi9cbmNvbnN0IHdoZW5TZWxlY3Rpb25EaXN0YW5jZUlzID0gcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlblNlbGVjdGlvbkRpc3RhbmNlSXNcIik7XG5cbi8qKiBAcGFyYW0ge21vZHVsZTphcHAvdmlldy9iYXNlL1ZpZXd9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZpZXcpIHtcblx0cmV0dXJuIHdoZW5TZWxlY3Rpb25EaXN0YW5jZUlzKHZpZXcsIDEpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2aWV3KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRpZiAodmlldy5hdHRhY2hlZCkge1xuXHRcdFx0cmVzb2x2ZSh2aWV3KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmlldy5vbihcInZpZXc6YXR0YWNoZWRcIiwgZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHRyZXNvbHZlKHZpZXcpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmlldykge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0aWYgKCF2aWV3LmludmFsaWRhdGVkKSB7XG5cdFx0XHRyZXNvbHZlKHZpZXcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3Lm9uY2UoXCJ2aWV3OnJlbmRlcjphZnRlclwiLCBmdW5jdGlvbih2aWV3LCBmbGFncykge1xuXHRcdFx0XHRyZXNvbHZlKHZpZXcpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9yZW5kZXIvQ2Fyb3VzZWxSZW5kZXJlclxuICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2Jhc2UvVmlld30gKi9cbmNvbnN0IFZpZXcgPSByZXF1aXJlKFwiYXBwL3ZpZXcvYmFzZS9WaWV3XCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTp1bmRlcnNjb3JlfSAqL1xuY29uc3QgZ2V0Qm94RWRnZVN0eWxlcyA9IHJlcXVpcmUoXCJ1dGlscy9jc3MvZ2V0Qm94RWRnZVN0eWxlc1wiKTtcblxuLy8gRklYTUU6IHRoaXMgZml4dXAgc2hvdWxkIG5vdCBiZSBkb25lIGhlcmVcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL25ldC90b0Fic29sdXRlVVJMfSAqL1xuLy8gdmFyIHRvQWJzb2x1dGVVUkwgPSByZXF1aXJlKFwidXRpbHMvbmV0L3RvQWJzb2x1dGVVUkxcIik7XG4vLyAvKiogQHR5cGUge3N0cmluZ30gKi9cbi8vIHZhciBBQlNfQVBQX1JPT1QgPSB0b0Fic29sdXRlVVJMKHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpLkFQUF9ST09UKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL0Nhcm91c2VsUmVuZGVyZXJ9XG4gKi9cbnZhciBDYXJvdXNlbFJlbmRlcmVyID0gVmlldy5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwiY2Fyb3VzZWxSZW5kZXJlclwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRhZ05hbWU6IFwiZGl2XCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y2xhc3NOYW1lOiBcImNhcm91c2VsLWl0ZW1cIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0ZW1wbGF0ZTogXy50ZW1wbGF0ZShcIjxkaXYgY2xhc3M9XFxcImNvbnRlbnQgc2l6aW5nXFxcIj48JT0gbmFtZSAlPjwvZGl2PlwiKSxcblxuXHRwcm9wZXJ0aWVzOiB7XG5cdFx0Y29udGVudDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgfHwgKHRoaXMuX2NvbnRlbnQgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuY29udGVudFwiKSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0c2l6aW5nOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2l6aW5nIHx8ICh0aGlzLl9zaXppbmcgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuc2l6aW5nXCIpKTtcblx0XHRcdH0sXG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdGlmICh0aGlzLm1vZGVsLmF0dHIoXCJAY2xhc3NuYW1lXCIpICE9PSB2b2lkIDApIHtcblx0XHRcdHZhciBjbHNBdHRyID0gdGhpcy5tb2RlbC5hdHRyKFwiQGNsYXNzbmFtZVwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNsc0F0dHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKGNsc0F0dHJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRvcHRpb25zLnBhcmVudFZpZXcgJiYgKHRoaXMucGFyZW50VmlldyA9IG9wdGlvbnMucGFyZW50Vmlldyk7XG5cdFx0dGhpcy5tZXRyaWNzID0ge307XG5cdFx0dGhpcy5tZXRyaWNzLmNvbnRlbnQgPSB7fTtcblx0XHR0aGlzLmNyZWF0ZUNoaWxkcmVuKCk7XG5cdFx0Ly8gdGhpcy5lbmFibGVkID0gISFvcHRpb25zLmVuYWJsZWQ7IC8vIGZvcmNlIGJvb2xcblx0XHR0aGlzLnNldEVuYWJsZWQoISFvcHRpb25zLmVuYWJsZWQpO1xuXHR9LFxuXG5cdGNyZWF0ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmlubmVySFRNTCA9IHRoaXMudGVtcGxhdGUodGhpcy5tb2RlbC50b0pTT04oKSk7XG5cdFx0Ly8gRklYTUU6IHRoaXMgZml4dXAgc2hvdWxkIG5vdCBiZSBkb25lIGhlcmVcblx0XHQvLyBGSVhFRDogbm93IGRvbmUgaW4geHNsdFxuXHRcdC8qdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiYVtocmVmXVwiKS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgdXJsID0gdG9BYnNvbHV0ZVVSTChlbC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKTtcblx0XHRcdGlmICh1cmwuaW5kZXhPZihBQlNfQVBQX1JPT1QpICE9PSAwKSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcblx0XHRcdH1cblx0XHR9KTsqL1xuXHR9LFxuXG5cdC8qKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gKi9cblx0Z2V0U2l6aW5nRWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXppbmcgfHwgKHRoaXMuX3NpemluZyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5zaXppbmdcIikpO1xuXHR9LFxuXG5cdC8qKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gKi9cblx0Z2V0Q29udGVudEVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudCB8fCAodGhpcy5fY29udGVudCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5jb250ZW50XCIpKTtcblx0fSxcblxuXHQvKiogQHJldHVybiB7dGhpc30gKi9cblx0bWVhc3VyZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemluZyA9IHRoaXMuZ2V0U2l6aW5nRWwoKTtcblxuXHRcdHRoaXMubWV0cmljcyA9IGdldEJveEVkZ2VTdHlsZXModGhpcy5lbCwgdGhpcy5tZXRyaWNzKTtcblx0XHR0aGlzLm1ldHJpY3MuY29udGVudCA9IGdldEJveEVkZ2VTdHlsZXModGhpcy5nZXRDb250ZW50RWwoKSwgdGhpcy5tZXRyaWNzLmNvbnRlbnQpO1xuXG5cdFx0c2l6aW5nLnN0eWxlLm1heFdpZHRoID0gXCJcIjtcblx0XHRzaXppbmcuc3R5bGUubWF4SGVpZ2h0ID0gXCJcIjtcblxuXHRcdHRoaXMubWV0cmljcy5jb250ZW50LnggPSBzaXppbmcub2Zmc2V0TGVmdCArIHNpemluZy5jbGllbnRMZWZ0O1xuXHRcdHRoaXMubWV0cmljcy5jb250ZW50LnkgPSBzaXppbmcub2Zmc2V0VG9wICsgc2l6aW5nLmNsaWVudFRvcDtcblx0XHR0aGlzLm1ldHJpY3MuY29udGVudC53aWR0aCA9IHNpemluZy5jbGllbnRXaWR0aDtcblx0XHR0aGlzLm1ldHJpY3MuY29udGVudC5oZWlnaHQgPSBzaXppbmcuY2xpZW50SGVpZ2h0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWVhc3VyZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFNlbGVjdGlvbkRpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy5tb2RlbC5jb2xsZWN0aW9uLmluZGV4T2YodGhpcy5tb2RlbCkgLSB0aGlzLm1vZGVsLmNvbGxlY3Rpb24uc2VsZWN0ZWRJbmRleCk7XG5cdH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXJvdXNlbFJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvcmVuZGVyL0NsaWNrYWJsZVJlbmRlcmVyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL0xhYmVsUmVuZGVyZXJ9ICovXG5jb25zdCBMYWJlbFJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9MYWJlbFJlbmRlcmVyXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9yZW5kZXIvQ2xpY2thYmxlUmVuZGVyZXJ9XG4gKi9cbnZhciBDbGlja2FibGVSZW5kZXJlciA9IExhYmVsUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2lkUHJlZml4OiBcImNsaWNrYWJsZVJlbmRlcmVyXCIsXG5cblx0Ly8gZGVmYXVsdHM6IHtcblx0Ly8gXHR0YXJnZXQ6IFwiLmxhYmVsXCJcblx0Ly8gfSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGV2ZW50czoge1xuXHRcdFwiY2xpY2sgLmxhYmVsXCI6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG5cdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy50cmlnZ2VyKFwicmVuZGVyZXI6Y2xpY2tcIiwgdGhpcy5tb2RlbCwgZXYpO1xuXHRcdH0sXG5cdFx0XCJjbGljayBhXCI6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRldi5kZWZhdWx0UHJldmVudGVkIHx8IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0Ly8gXHRvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXHQvLyBcdC8vIGlmIChvcHRpb25zKSB7XG5cdC8vIFx0b3B0aW9ucyA9IF8uZGVmYXVsdHMoe30sIG9wdGlvbnMsIF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKTtcblx0Ly8gXHQvLyB9IGVsc2Uge1xuXHQvLyBcdC8vIFx0IF8uZGVmYXVsdHMoe30sIF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKTtcblx0Ly8gXHQvLyB9XG5cdC8vIFx0dGhpcy5ldmVudHNbXCJjbGljayBcIiArIG9wdGlvbnMudGFyZ2V0XSA9IHRoaXMuY2xpY2tIYW5kbGVyO1xuXHQvLyB9LFxuXHQvL1xuXHQvLyBjbGlja0hhbmRsZXI6IGZ1bmN0aW9uKGV2KSB7XG5cdC8vIFx0aWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblx0Ly9cblx0Ly8gXHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHQvLyBcdHRoaXMudHJpZ2dlcihcInJlbmRlcmVyOmNsaWNrXCIsIHRoaXMubW9kZWwsIGV2KTtcblx0Ly8gfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpY2thYmxlUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiO1xuXG4gIHJldHVybiBcIjxhIGhyZWY9XFxcIiNcIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5kb21pZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZG9taWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImRvbWlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCI+PHNwYW4gY2xhc3M9XFxcImxhYmVsXFxcIj5cIlxuICAgICsgKChzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvc3Bhbj48L2E+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L3JlbmRlci9EZWZhdWx0U2VsZWN0YWJsZVJlbmRlcmVyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0NsaWNrYWJsZVJlbmRlcmVyfSAqL1xuY29uc3QgQ2xpY2thYmxlUmVuZGVyZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcmVuZGVyL0NsaWNrYWJsZVJlbmRlcmVyXCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9yZW5kZXIvRGVmYXVsdFNlbGVjdGFibGVSZW5kZXJlcn1cbiAqL1xudmFyIERlZmF1bHRTZWxlY3RhYmxlUmVuZGVyZXIgPSBDbGlja2FibGVSZW5kZXJlci5leHRlbmQoe1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0dGFnTmFtZTogXCJsaVwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJsaXN0LWl0ZW1cIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0ZW1wbGF0ZTogcmVxdWlyZShcIi4vRGVmYXVsdFNlbGVjdGFibGVSZW5kZXJlci5oYnNcIiksXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwgXCJzZWxlY3RlZCBkZXNlbGVjdGVkXCIsIHRoaXMuX3JlbmRlckNsYXNzTGlzdCk7XG5cdFx0dGhpcy5fcmVuZGVyQ2xhc3NMaXN0KCk7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWwuaW5uZXJIVE1MID0gdGhpcy50ZW1wbGF0ZSh0aGlzLm1vZGVsLnRvSlNPTigpKTtcblx0XHR0aGlzLl9yZW5kZXJDbGFzc0xpc3QoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVuZGVyQ2xhc3NMaXN0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCB0aGlzLm1vZGVsLnNlbGVjdGVkKTtcblx0fSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRTZWxlY3RhYmxlUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KSwgYWxpYXMyPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIHJldHVybiBcIjxzcGFuIGNsYXNzPVxcXCJsYWJlbFxcXCI+XCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9zcGFuPjxhIGhyZWY9XFxcIiNcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZG9taWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRvbWlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJkb21pZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiPjxiPiA8L2I+PC9hPlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBhcHAvdmlldy9yZW5kZXIvRG90TmF2aWdhdGlvblJlbmRlcmVyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9WaWV3fSAqL1xuY29uc3QgVmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL1ZpZXdcIik7XG5cbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9DbGlja2FibGVSZW5kZXJlcn0gKi9cbi8vIHZhciBDbGlja2FibGVSZW5kZXJlciA9IHJlcXVpcmUoXCJhcHAvdmlldy9yZW5kZXIvTGFiZWxSZW5kZXJlclwiKTtcbi8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuY29uc3Qgdmlld1RlbXBsYXRlID0gcmVxdWlyZShcIi4vRG90TmF2aWdhdGlvblJlbmRlcmVyLmhic1wiKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL0RvdE5hdmlnYXRpb25SZW5kZXJlcn1cbiAqL1xudmFyIERvdE5hdmlnYXRpb25SZW5kZXJlciA9IFZpZXcuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2lkUHJlZml4OiBcImRvdFJlbmRlcmVyXCIsXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0dGFnTmFtZTogXCJsaVwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdGNsYXNzTmFtZTogXCJsaXN0LWl0ZW1cIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHR0ZW1wbGF0ZTogdmlld1RlbXBsYXRlLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0ZXZlbnRzOiB7XG5cdFx0XCJjbGlja1wiOiBmdW5jdGlvbihldikge1xuXHRcdFx0aWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuXHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMudHJpZ2dlcihcInJlbmRlcmVyOmNsaWNrXCIsIHRoaXMubW9kZWwsIGV2KTtcblx0XHR9LFxuXHRcdFwiY2xpY2sgYVwiOiBmdW5jdGlvbihldikge1xuXHRcdFx0ZXYuZGVmYXVsdFByZXZlbnRlZCB8fCBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwic2VsZWN0ZWQgZGVzZWxlY3RlZFwiLCB0aGlzLnJlbmRlckNsYXNzTGlzdCk7XG5cdFx0dGhpcy5yZW5kZXJDbGFzc0xpc3QoKTtcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbC5pbm5lckhUTUwgPSB0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwudG9KU09OKCkpO1xuXHRcdHRoaXMucmVuZGVyQ2xhc3NMaXN0KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVuZGVyQ2xhc3NMaXN0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiLCB0aGlzLm1vZGVsLnNlbGVjdGVkKTtcblx0fSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvdE5hdmlnYXRpb25SZW5kZXJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwicGxhY2Vob2xkZXIgc2l6aW5nXFxcIj48L2Rpdj5cXG48aW1nIGNsYXNzPVxcXCJjb250ZW50IG1lZGlhLWJvcmRlciBkZWZhdWx0XFxcIiBhbHQ9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50ZXh0IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50ZXh0IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJ0ZXh0XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCIgbG9uZ2Rlc2M9XFxcIiNkZXNjX21cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIC8+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L3JlbmRlci9JbWFnZVJlbmRlcmVyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvTWVkaWFSZW5kZXJlcn0gKi9cbmNvbnN0IE1lZGlhUmVuZGVyZXIgPSByZXF1aXJlKFwiLi9NZWRpYVJlbmRlcmVyXCIpO1xuXG4vKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuY29uc3Qgdmlld1RlbXBsYXRlID0gcmVxdWlyZShcIi4vSW1hZ2VSZW5kZXJlci5oYnNcIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3JlbmRlci9JbWFnZVJlbmRlcmVyfVxuICovXG52YXIgSW1hZ2VSZW5kZXJlciA9IE1lZGlhUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2lkUHJlZml4OiBcImltYWdlUmVuZGVyZXJcIixcblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdGNsYXNzTmFtZTogTWVkaWFSZW5kZXJlci5wcm90b3R5cGUuY2xhc3NOYW1lICsgXCIgaW1hZ2UtaXRlbVwiLFxuXHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuXHR0ZW1wbGF0ZTogdmlld1RlbXBsYXRlLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0cykge1xuXHRcdE1lZGlhUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHQvLyB0aGlzLmNyZWF0ZUNoaWxkcmVuKCk7XG5cdFx0Ly8gdGhpcy5pbml0aWFsaXplQXN5bmMoKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBjaGlsZHJlbi9sYXlvdXRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjcmVhdGVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0TWVkaWFSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ2hpbGRyZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHQvLyB0aGlzLmVsLmlubmVySFRNTCA9IHRoaXMudGVtcGxhdGUodGhpcy5tb2RlbC50b0pTT04oKSk7XG5cdFx0dGhpcy5wbGFjZWhvbGRlciA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5wbGFjZWhvbGRlclwiKTtcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0TWVkaWFSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHQvLyB0aGlzLm1lYXN1cmUoKTtcblxuXHRcdHZhciBpbWcgPSB0aGlzLmdldERlZmF1bHRJbWFnZSgpO1xuXHRcdGltZy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLm1ldHJpY3MubWVkaWEud2lkdGgpO1xuXHRcdGltZy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5tZXRyaWNzLm1lZGlhLmhlaWdodCk7XG5cblx0XHR2YXIgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEVsKCk7XG5cdFx0Y29udGVudC5zdHlsZS5sZWZ0ID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQueCArIFwicHhcIjtcblx0XHRjb250ZW50LnN0eWxlLnRvcCA9IHRoaXMubWV0cmljcy5jb250ZW50LnkgKyBcInB4XCI7XG5cblx0XHQvLyB2YXIgc2l6aW5nID0gdGhpcy5nZXRTaXppbmdFbCgpO1xuXHRcdC8vIHNpemluZy5zdHlsZS5tYXhXaWR0aCA9IHRoaXMubWV0cmljcy5jb250ZW50LndpZHRoICsgXCJweFwiO1xuXHRcdC8vIHNpemluZy5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLm1ldHJpY3MuY29udGVudC5oZWlnaHQgKyBcInB4XCI7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBpbml0aWFsaXplQXN5bmNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0aW5pdGlhbGl6ZUFzeW5jOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWVkaWFSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZUFzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0XHQvLyByZXR1cm4gTWVkaWFSZW5kZXJlci53aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzKHRoaXMpXG5cdFx0Ly8gLy8gcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKVxuXHRcdC8vIC8vIFx0LnRoZW4oTWVkaWFSZW5kZXJlci53aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzKVxuXHRcdC8vIFx0LnRoZW4oTWVkaWFSZW5kZXJlci53aGVuU2VsZWN0VHJhbnNpdGlvbkVuZHMpXG5cdFx0Ly8gXHQudGhlbihNZWRpYVJlbmRlcmVyLndoZW5EZWZhdWx0SW1hZ2VMb2Fkcylcblx0XHQvLyAudGhlbihcblx0XHQvLyBcdGZ1bmN0aW9uKHZpZXcpIHtcblx0XHQvLyBcdFx0dmlldy5tZWRpYVN0YXRlID0gXCJyZWFkeVwiO1xuXHRcdC8vIFx0fSlcblx0XHQvLyAuY2F0Y2goXG5cdFx0Ly8gXHRmdW5jdGlvbihlcnIpIHtcblx0XHQvLyBcdFx0aWYgKGVyciBpbnN0YW5jZW9mIFZpZXdFcnJvcikge1xuXHRcdC8vIFx0XHRcdC8vIE5PVEU6IGlnbm9yZSBWaWV3RXJyb3IgdHlwZVxuXHRcdC8vIFx0XHRcdC8vIGNvbnNvbGUubG9nKGVyci52aWV3LmNpZCwgZXJyLnZpZXcubW9kZWwuY2lkLCBcIkltYWdlUmVuZGVyZXI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuXHRcdC8vIFx0XHR9IGVsc2Uge1xuXHRcdC8vIFx0XHRcdGNvbnNvbGUuZXJyb3IodGhpcy5jaWQsIGVyci5uYW1lLCBlcnIpO1xuXHRcdC8vIFx0XHRcdHRoaXMucGxhY2Vob2xkZXIuaW5uZXJIVE1MID0gXCI8cCBjbGFzcz1cXFwiY29sb3ItZmdcXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtwYWRkaW5nOjNyZW07XFxcIj48c3Ryb25nPlwiICsgZXJyLm5hbWUgKyBcIjwvc3Ryb25nPiBcIiArIGVyci5tZXNzYWdlICsgXCI8L3A+XCI7XG5cdFx0Ly8gXHRcdFx0dGhpcy5tZWRpYVN0YXRlID0gXCJlcnJvclwiO1xuXHRcdC8vIFx0XHR9XG5cdFx0Ly8gXHR9LmJpbmQodGhpcykpXG5cdFx0O1xuXHR9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VSZW5kZXJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L3JlbmRlci9MYWJlbFJlbmRlcmVyXG4gKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9WaWV3fSAqL1xuY29uc3QgVmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL1ZpZXdcIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3JlbmRlci9MYWJlbFJlbmRlcmVyfVxuICovXG52YXIgTGFiZWxSZW5kZXJlciA9IFZpZXcuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2lkUHJlZml4OiBcImxhYmVsUmVuZGVyZXJcIixcblxuXHRwcm9wZXJ0aWVzOiB7XG5cdFx0bGFiZWw6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYWJlbCB8fCAodGhpcy5fbGFiZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIubGFiZWxcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBtZWFzdXJlZFdpZHRoOiB7XG5cdFx0Ly8gXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHRyZXR1cm4gdGhpcy5fbWVhc3VyZWRXaWR0aDtcblx0XHQvLyBcdH1cblx0XHQvLyB9LFxuXHRcdC8vIG1lYXN1cmVkSGVpZ2h0OiB7XG5cdFx0Ly8gXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHRyZXR1cm4gdGhpcy5fbWVhc3VyZWRIZWlnaHQ7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSxcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIG1lYXN1cmVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIF9tZWFzdXJlZFdpZHRoOiBudWxsLFxuXHQvLyBfbWVhc3VyZWRIZWlnaHQ6IG51bGwsXG5cdC8vIG1lYXN1cmU6IGZ1bmN0aW9uKCkge30sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYWJlbFJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKmdsb2JhbCBYTUxIdHRwUmVxdWVzdCwgSFRNTE1lZGlhRWxlbWVudCwgTWVkaWFFcnJvciovXG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvcmVuZGVyL01lZGlhUmVuZGVyZXJcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTp1bmRlcnNjb3JlLnN0cmluZ3MvbHBhZH0gKi9cbmNvbnN0IGxwYWQgPSByZXF1aXJlKFwidW5kZXJzY29yZS5zdHJpbmcvbHBhZFwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL21vZGVsL2l0ZW0vTWVkaWFJdGVtfSAqL1xuY29uc3QgTWVkaWFJdGVtID0gcmVxdWlyZShcImFwcC9tb2RlbC9pdGVtL01lZGlhSXRlbVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L0Nhcm91c2VsUmVuZGVyZXJ9ICovXG5jb25zdCBDYXJvdXNlbFJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9DYXJvdXNlbFJlbmRlcmVyXCIpO1xuXG4vLyB2YXIgZXJyb3JUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuLi90ZW1wbGF0ZS9FcnJvckJsb2NrLmhic1wiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2Nzcy9nZXRCb3hFZGdlU3R5bGVzfSAqL1xuLy8gdmFyIGdldEJveEVkZ2VTdHlsZXMgPSByZXF1aXJlKFwidXRpbHMvY3NzL2dldEJveEVkZ2VTdHlsZXNcIik7XG5cbnZhciBNZWRpYVJlbmRlcmVyID0gQ2Fyb3VzZWxSZW5kZXJlci5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwibWVkaWFSZW5kZXJlclwiLFxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2xhc3NOYW1lOiBDYXJvdXNlbFJlbmRlcmVyLnByb3RvdHlwZS5jbGFzc05hbWUgKyBcIiBtZWRpYS1pdGVtXCIsXG5cdC8qKiBAdHlwZSB7bW9kdWxlOmFwcC9tb2RlbC9NZWRpYUl0ZW19ICovXG5cdG1vZGVsOiBNZWRpYUl0ZW0sXG5cblx0cHJvcGVydGllczoge1xuXHRcdGRlZmF1bHRJbWFnZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2RlZmF1bHRJbWFnZSB8fCAodGhpcy5fZGVmYXVsdEltYWdlID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiaW1nLmRlZmF1bHRcIikpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWVkaWFTdGF0ZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21lZGlhU3RhdGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdFx0XHR0aGlzLl9zZXRNZWRpYVN0YXRlKHN0YXRlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRzKSB7XG5cdFx0Ly8gaWYgKHRoaXMubW9kZWwuYXR0cnMoKS5oYXNPd25Qcm9wZXJ0eShcIkBjbGFzc25hbWVcIikpIHtcblx0XHQvLyBcdHRoaXMuZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgdGhpcy5tb2RlbC5hdHRyKFwiQGNsYXNzbmFtZVwiKTtcblx0XHQvLyB9XG5cblx0XHQvLyBOT1RFOiBAY2xhc3NuYW1lIGF0dHIgaGFuZGxpbmcgbW92ZWQgdG8gQ2Fyb3VzZWxSZW5kZXJlclxuXHRcdC8vIGlmICh0aGlzLm1vZGVsLmF0dHIoXCJAY2xhc3NuYW1lXCIpICE9PSB2b2lkIDApIHtcblx0XHQvLyBcdHZhciBjbHNBdHRyID0gdGhpcy5tb2RlbC5hdHRyKFwiQGNsYXNzbmFtZVwiKS5zcGxpdChcIiBcIik7XG5cdFx0Ly8gXHRmb3IgKHZhciBpID0gMDsgaSA8IGNsc0F0dHIubGVuZ3RoOyBpKyspIHtcblx0XHQvLyBcdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKGNsc0F0dHJbaV0pO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblx0XHRDYXJvdXNlbFJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR0aGlzLm1ldHJpY3MubWVkaWEgPSB7fTtcblx0XHR0aGlzLm1lZGlhU3RhdGUgPSBcImlkbGVcIjtcblxuXHRcdHRoaXMuaW5pdGlhbGl6ZUFzeW5jKClcblx0XHRcdC50aGVuKHRoaXMud2hlbkluaXRpYWxpemVkKVxuXHRcdFx0LmNhdGNoKHRoaXMud2hlbkluaXRpYWxpemVFcnJvci5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHRpbml0aWFsaXplQXN5bmM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHZhciBNZWRpYVJlbmRlcmVyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcylcblx0XHRcdC50aGVuKE1lZGlhUmVuZGVyZXIud2hlblNlbGVjdGlvbklzQ29udGlndW91cylcblx0XHRcdC50aGVuKE1lZGlhUmVuZGVyZXIud2hlblNjcm9sbGluZ0VuZHMpXG5cdFx0XHQudGhlbihNZWRpYVJlbmRlcmVyLndoZW5EZWZhdWx0SW1hZ2VMb2Fkcyk7XG5cdH0sXG5cblx0d2hlbkluaXRpYWxpemVkOiBmdW5jdGlvbih2aWV3KSB7XG5cdFx0Ly8gY29uc29sZS5sb2coXCIlczo6d2hlbkluaXRpYWxpemVkIFslc11cIiwgdmlldy5jaWQsIFwicmVzb2x2ZWRcIik7XG5cdFx0dmlldy5tZWRpYVN0YXRlID0gXCJyZWFkeVwiO1xuXHRcdHZpZXcucGxhY2Vob2xkZXIucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1wcm9ncmVzc1wiKTtcblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHR3aGVuSW5pdGlhbGl6ZUVycm9yOiBmdW5jdGlvbihlcnIpIHtcblx0XHRpZiAoZXJyIGluc3RhbmNlb2YgQ2Fyb3VzZWxSZW5kZXJlci5WaWV3RXJyb3IpIHtcblx0XHRcdC8vIE5PVEU6IGlnbm9yZSBWaWV3RXJyb3IgdHlwZVxuXHRcdFx0cmV0dXJuO1xuXHRcdH0gZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcblx0XHR9XG5cdFx0dGhpcy5wbGFjZWhvbGRlci5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXByb2dyZXNzXCIpO1xuXHRcdHRoaXMubWVkaWFTdGF0ZSA9IFwiZXJyb3JcIjtcblx0fSxcblxuXHR1cGRhdGVNZWRpYVByb2dyZXNzOiBmdW5jdGlvbihwcm9ncmVzcywgaWQpIHtcblx0XHRpZiAoXy5pc051bWJlcihwcm9ncmVzcykpIHtcblx0XHRcdHRoaXMucGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1wcm9ncmVzc1wiLCBscGFkKE1hdGguZmxvb3IocHJvZ3Jlc3MgKiAxMDApLCAyLCAnMCcpKTtcblx0XHR9XG5cdFx0Ly8gZWxzZSBpZiAocHJvZ3Jlc3MgPT09IFwiY29tcGxldGVcIikge1xuXHRcdC8vIFx0dGhpcy5wbGFjZWhvbGRlci5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXByb2dyZXNzXCIpO1xuXHRcdC8vIH1cblx0fSxcblxuXHQvLyB3aGVuTWVkaWFJc1JlYWR5OiBmdW5jdGlvbih2aWV3KSB7XG5cdC8vIFx0cmV0dXJuIE1lZGlhUmVuZGVyZXIud2hlbkRlZmF1bHRJbWFnZUxvYWRzKHRoaXMsIHRoaXMudXBkYXRlTWVkaWFQcm9ncmVzcy5iaW5kKHRoaXMpKTtcblx0Ly8gfSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBjaGlsZCBnZXR0ZXJzXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gKi9cblx0Z2V0RGVmYXVsdEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kZWZhdWx0SW1hZ2U7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogY2hpbGRyZW4vbGF5b3V0XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGNyZWF0ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmlubmVySFRNTCA9IHRoaXMudGVtcGxhdGUodGhpcy5tb2RlbC50b0pTT04oKSk7XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRtZWFzdXJlOiBmdW5jdGlvbigpIHtcblx0XHRDYXJvdXNlbFJlbmRlcmVyLnByb3RvdHlwZS5tZWFzdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgc3csIHNoOyAvLyBzb3VyY2UgZGltZW5zaW9uc1xuXHRcdHZhciBwY3csIHBjaDsgLy8gbWVhc3VyZWQgdmFsdWVzXG5cdFx0dmFyIGN4LCBjeSwgY3csIGNoLCBjczsgLy8gY29tcHV0ZWQgdmFsdWVzXG5cdFx0dmFyIGV3LCBlaDsgLy8gY29udGVudCBlZGdlIHRvdGFsc1xuXHRcdHZhciBjbTsgLy8gY29udGVudCBtZXRyaWNzXG5cblx0XHRjbSA9IHRoaXMubWV0cmljcy5jb250ZW50O1xuXHRcdGN4ID0gY20ueDtcblx0XHRjeSA9IGNtLnk7XG5cdFx0cGN3ID0gY20ud2lkdGg7XG5cdFx0cGNoID0gY20uaGVpZ2h0O1xuXG5cdFx0ZXcgPSAoY20ucGFkZGluZ0xlZnQgKyBjbS5wYWRkaW5nUmlnaHQgKyBjbS5ib3JkZXJMZWZ0V2lkdGggKyBjbS5ib3JkZXJSaWdodFdpZHRoKTtcblx0XHRlaCA9IChjbS5wYWRkaW5nVG9wICsgY20ucGFkZGluZ0JvdHRvbSArIGNtLmJvcmRlclRvcFdpZHRoICsgY20uYm9yZGVyQm90dG9tV2lkdGgpO1xuXHRcdHBjdyAtPSBldztcblx0XHRwY2ggLT0gZWg7XG5cblx0XHRzdyA9IHRoaXMubW9kZWwuZ2V0KFwic291cmNlXCIpLmdldChcIndcIik7XG5cdFx0c2ggPSB0aGlzLm1vZGVsLmdldChcInNvdXJjZVwiKS5nZXQoXCJoXCIpO1xuXG5cdFx0Ly8gVW5sZXNzIGJvdGggY2xpZW50IGRpbWVuc2lvbnMgYXJlIGxhcmdlciB0aGFuIHRoZSBzb3VyY2Unc1xuXHRcdC8vIGNob29zZSBjb25zdHJhaW50IGRpcmVjdGlvbiBieSBhc3BlY3QgcmF0aW9cblx0XHRpZiAoc3cgPCBwY3cgJiYgc2ggPCBwY2gpIHtcblx0XHRcdGNzID0gMTtcblx0XHRcdGN3ID0gc3c7XG5cdFx0XHRjaCA9IHNoO1xuXHRcdFx0dGhpcy5tZXRyaWNzLmZpdERpcmVjdGlvbiA9IFwiYm90aFwiO1xuXHRcdH0gZWxzZSBpZiAoKHBjdyAvIHBjaCkgPCAoc3cgLyBzaCkpIHtcblx0XHRcdC8vIGZpdCB3aWR0aFxuXHRcdFx0Y3cgPSBwY3c7XG5cdFx0XHRjcyA9IGN3IC8gc3c7XG5cdFx0XHQvLyBjaCA9IGNzICogc2g7XG5cdFx0XHRjaCA9IE1hdGgucm91bmQoY3MgKiBzaCk7XG5cdFx0XHR0aGlzLm1ldHJpY3MuZml0RGlyZWN0aW9uID0gXCJ3aWR0aFwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBmaXQgaGVpZ2h0XG5cdFx0XHRjaCA9IHBjaDtcblx0XHRcdGNzID0gY2ggLyBzaDtcblx0XHRcdC8vIGN3ID0gY3MgKiBzdztcblx0XHRcdGN3ID0gTWF0aC5yb3VuZChjcyAqIHN3KTtcblx0XHRcdHRoaXMubWV0cmljcy5maXREaXJlY3Rpb24gPSBcImhlaWdodFwiO1xuXHRcdH1cblxuXHRcdHRoaXMubWV0cmljcy5jb250ZW50LnggPSBjeDtcblx0XHR0aGlzLm1ldHJpY3MuY29udGVudC55ID0gY3k7XG5cdFx0dGhpcy5tZXRyaWNzLmNvbnRlbnQud2lkdGggPSBjdyArIGV3O1xuXHRcdHRoaXMubWV0cmljcy5jb250ZW50LmhlaWdodCA9IGNoICsgZWg7XG5cblx0XHR0aGlzLm1ldHJpY3MubWVkaWEueCA9IGN4ICsgY20ucGFkZGluZ0xlZnQgKyBjbS5ib3JkZXJMZWZ0V2lkdGg7XG5cdFx0dGhpcy5tZXRyaWNzLm1lZGlhLnkgPSBjeSArIGNtLnBhZGRpbmdUb3AgKyBjbS5ib3JkZXJUb3BXaWR0aDtcblx0XHR0aGlzLm1ldHJpY3MubWVkaWEud2lkdGggPSBjdztcblx0XHR0aGlzLm1ldHJpY3MubWVkaWEuaGVpZ2h0ID0gY2g7XG5cdFx0dGhpcy5tZXRyaWNzLm1lZGlhLnNjYWxlID0gY3M7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjptZWFzdXJlIG13OiVzIG1oOiVzIGZpdDogJXMgbWV0cmljczogJW9cIiwgdGhpcy5jaWQsIHBjdywgcGNoLCB0aGlzLm1ldHJpY3MuZml0RGlyZWN0aW9uLCB0aGlzLm1ldHJpY3MpO1xuXHRcdC8vIHZhciBzaXppbmcgPSB0aGlzLmdldFNpemluZ0VsKCk7XG5cdFx0Ly8gc2l6aW5nLnN0eWxlLm1heFdpZHRoID0gKGN3ICsgZXcpICsgXCJweFwiO1xuXHRcdC8vIHNpemluZy5zdHlsZS5tYXhIZWlnaHQgPSAoY2ggKyBlaCkgKyBcInB4XCI7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIE5PVEU6IG5vdCBjYWxsaW5nIHN1cGVyLnJlbmRlciwgY2FsbGluZyBtZWFzdXJlIG91cnNlbHZlc1xuXHRcdHRoaXMubWVhc3VyZSgpO1xuXG5cdFx0dmFyIHNpemluZyA9IHRoaXMuZ2V0U2l6aW5nRWwoKTtcblx0XHRzaXppbmcuc3R5bGUubWF4V2lkdGggPSB0aGlzLm1ldHJpY3MuY29udGVudC53aWR0aCArIFwicHhcIjtcblx0XHRzaXppbmcuc3R5bGUubWF4SGVpZ2h0ID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQuaGVpZ2h0ICsgXCJweFwiO1xuXG5cdFx0dGhpcy5lbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWZpdC1kaXJcIiwgdGhpcy5tZXRyaWNzLmZpdERpcmVjdGlvbik7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBtZWRpYVN0YXRlXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9tZWRpYVN0YXRlRW51bTogW1wiaWRsZVwiLCBcInBlbmRpbmdcIiwgXCJyZWFkeVwiLCBcImVycm9yXCJdLFxuXG5cdF9zZXRNZWRpYVN0YXRlOiBmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAodGhpcy5fbWVkaWFTdGF0ZUVudW0uaW5kZXhPZihrZXkpID09PSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgXCIgKyBrZXkgKyBcIiBpbnZhbGlkLiBNdXN0IGJlIG9uZSBvZjogXCIgKyB0aGlzLl9tZWRpYVN0YXRlRW51bS5qb2luKFwiLCBcIikpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fbWVkaWFTdGF0ZSAhPT0ga2V5KSB7XG5cdFx0XHRpZiAodGhpcy5fbWVkaWFTdGF0ZSkge1xuXHRcdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fbWVkaWFTdGF0ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC5hZGQoa2V5KTtcblx0XHRcdHRoaXMuX21lZGlhU3RhdGUgPSBrZXk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJtZWRpYTpcIiArIGtleSk7XG5cdFx0fVxuXHR9LFxufSwge1xuXHRMT0dfVE9fU0NSRUVOOiB0cnVlLFxuXHQvKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9wcm9taXNlL3doZW5TZWxlY3Rpb25EaXN0YW5jZUlzfSAqL1xuXHR3aGVuU2VsZWN0aW9uRGlzdGFuY2VJczogcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlblNlbGVjdGlvbkRpc3RhbmNlSXNcIiksXG5cblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcHJvbWlzZS93aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzfSAqL1xuXHR3aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzOiByZXF1aXJlKFwiYXBwL3ZpZXcvcHJvbWlzZS93aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzXCIpLFxuXG5cdC8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3Byb21pc2Uvd2hlblNlbGVjdFRyYW5zaXRpb25FbmRzfSAqL1xuXHQvLyB3aGVuU2VsZWN0VHJhbnNpdGlvbkVuZHM6IHJlcXVpcmUoXCJhcHAvdmlldy9wcm9taXNlL3doZW5TZWxlY3RUcmFuc2l0aW9uRW5kc1wiKSxcblxuXHQvKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9wcm9taXNlL3doZW5TY3JvbGxpbmdFbmRzfSAqL1xuXHR3aGVuU2Nyb2xsaW5nRW5kczogcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlblNjcm9sbGluZ0VuZHNcIiksXG5cblx0LyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcHJvbWlzZS93aGVuRGVmYXVsdEltYWdlTG9hZHN9ICovXG5cdHdoZW5EZWZhdWx0SW1hZ2VMb2FkczogcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlbkRlZmF1bHRJbWFnZUxvYWRzXCIpLFxufSk7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogbG9nIHRvIHNjcmVlblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5pZiAoREVCVUcpIHtcblxuXHRNZWRpYVJlbmRlcmVyID0gKGZ1bmN0aW9uKE1lZGlhUmVuZGVyZXIpIHtcblx0XHRpZiAoIU1lZGlhUmVuZGVyZXIuTE9HX1RPX1NDUkVFTikgcmV0dXJuIE1lZGlhUmVuZGVyZXI7XG5cblx0XHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuXHRcdHZhciBDb2xvciA9IHJlcXVpcmUoXCJjb2xvclwiKTtcblx0XHQvLyAvKiogQHR5cGUge21vZHVsZTp1bmRlcnNjb3JlLnN0cmluZy9scGFkfSAqL1xuXHRcdC8vIHZhciBscGFkID0gcmVxdWlyZShcInVuZGVyc2NvcmUuc3RyaW5nL2xwYWRcIik7XG5cdFx0Ly8gLyoqIEB0eXBlIHttb2R1bGU6dW5kZXJzY29yZS5zdHJpbmcvcnBhZH0gKi9cblx0XHQvLyB2YXIgcnBhZCA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlLnN0cmluZy9ycGFkXCIpO1xuXG5cdFx0cmV0dXJuIE1lZGlhUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRcdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0dmFyIGZnQ29sb3IgPSBuZXcgQ29sb3IodGhpcy5tb2RlbC5hdHRyKFwiY29sb3JcIikpO1xuXHRcdFx0XHR2YXIgYmdDb2xvciA9IG5ldyBDb2xvcih0aGlzLm1vZGVsLmF0dHIoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpKTtcblx0XHRcdFx0dGhpcy5fX2xvZ0NvbG9ycyA9IHtcblx0XHRcdFx0XHRub3JtYWw6IENvbG9yKGZnQ29sb3IpLm1peChiZ0NvbG9yLCAwLjc1KS5oc2woKS5zdHJpbmcoKSxcblx0XHRcdFx0XHRpZ25vcmVkOiBDb2xvcihmZ0NvbG9yKS5taXgoYmdDb2xvciwgMC4yNSkuaHNsKCkuc3RyaW5nKCksXG5cdFx0XHRcdFx0ZXJyb3I6IFwiYnJvd25cIixcblx0XHRcdFx0XHRhYm9ydDogXCJvcmFuZ2VcIlxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLl9fbG9nRnJhbWVTdHlsZSA9IFwiMXB4IGRhc2hlZCBcIiArIENvbG9yKGZnQ29sb3IpLm1peChiZ0NvbG9yLCAwLjUpLmhzbCgpLnN0cmluZygpO1xuXHRcdFx0XHR0aGlzLl9fbG9nU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0dGhpcy5fX3JhZklkID0gLTE7XG5cdFx0XHRcdHRoaXMuX19vbkZyYW1lID0gdGhpcy5fX29uRnJhbWUuYmluZCh0aGlzKTtcblx0XHRcdFx0TWVkaWFSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0aW5pdGlhbGl6ZUFzeW5jOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIE1lZGlhUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemVBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdGlmICghKGVyciBpbnN0YW5jZW9mIE1lZGlhUmVuZGVyZXIuVmlld0Vycm9yKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fX2xvZ01lc3NhZ2UoZXJyLm1lc3NhZ2UsIGVyci5uYW1lLCB0aGlzLl9fbG9nQ29sb3JzW1wiZXJyb3JcIl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdGNyZWF0ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJldCA9IE1lZGlhUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNoaWxkcmVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0dGhpcy5fX2xvZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0XHR0aGlzLl9fbG9nRWxlbWVudC5jbGFzc05hbWUgPSBcImRlYnVnLWxvZ1wiO1xuXHRcdFx0XHQvLyB0aGlzLl9fbG9nRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwicGFuLXlcIjtcblx0XHRcdFx0dGhpcy5fX2xvZ0hlYWRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcblx0XHRcdFx0dGhpcy5fX2xvZ0hlYWRlckVsLmNsYXNzTmFtZSA9IFwibG9nLWhlYWRlciBjb2xvci1iZ1wiO1xuXHRcdFx0XHQvLyBDb2xvcih0aGlzLm1vZGVsLmNvbG9ycy5mZ0NvbG9yKS5taXgoZmdDb2xvciwgMC45KS5yZ2IoKS5zdHJpbmcoKVxuXHRcdFx0XHQvLyBDb2xvcih0aGlzLm1vZGVsLmNvbG9ycy5mZ0NvbG9yKS5hbHBoYVxuXHRcdFx0XHR0aGlzLl9fbG9nSGVhZGVyRWwudGV4dENvbnRlbnQgPSB0aGlzLl9fZ2V0SGVhZGVyVGV4dCgpO1xuXHRcdFx0XHR0aGlzLl9fbG9nRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fbG9nSGVhZGVyRWwpO1xuXHRcdFx0XHR0aGlzLmVsLmluc2VydEJlZm9yZSh0aGlzLl9fbG9nRWxlbWVudCwgdGhpcy5lbC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmV0ID0gTWVkaWFSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0dGhpcy5fX2xvZ0VsZW1lbnQuc3R5bGUudG9wID0gKHRoaXMubWV0cmljcy5jb250ZW50LmhlaWdodCArIHRoaXMubWV0cmljcy5jb250ZW50LnkpICsgXCJweFwiO1xuXHRcdFx0XHR0aGlzLl9fbG9nRWxlbWVudC5zdHlsZS5sZWZ0ID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQueCArIFwicHhcIjtcblx0XHRcdFx0dGhpcy5fX2xvZ0VsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLm1ldHJpY3MuY29udGVudC53aWR0aCArIFwicHhcIjtcblx0XHRcdFx0dGhpcy5fX2xvZ0VsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5fX2xvZ0VsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHR3aGVuSW5pdGlhbGl6ZUVycm9yOiBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0Ly8gTk9URTogbm90IGNhbGxpbmcgc3VwZXJcblx0XHRcdFx0Ly8gTWVkaWFSZW5kZXJlci5wcm90b3R5cGUud2hlbkluaXRpYWxpemVFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAoZXJyIGluc3RhbmNlb2YgQ2Fyb3VzZWxSZW5kZXJlci5WaWV3RXJyb3IpIHtcblx0XHRcdFx0XHQvLyBOT1RFOiBpZ25vcmUgVmlld0Vycm9yIHR5cGVcblx0XHRcdFx0XHQvLyBjb25zb2xlLndhcm4oXCIlczo6d2hlbkluaXRpYWxpemVFcnJvciBcIiwgZXJyLnZpZXcuY2lkLCBlcnIubWVzc2FnZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKGVyci5zdGFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdGhpcy5wbGFjZWhvbGRlci5pbm5lckhUTUwgPSBlcnIgPyBlcnJvclRlbXBsYXRlKGVycikgOiBcIlwiO1xuXHRcdFx0XHR0aGlzLnBsYWNlaG9sZGVyLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtcHJvZ3Jlc3NcIik7XG5cdFx0XHRcdHRoaXMubWVkaWFTdGF0ZSA9IFwiZXJyb3JcIjtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmVycm9yKFwiJXM6OmluaXRpYWxpemVBc3luYyBbJXMgKGNhdWdodCldOiAlc1wiLCB0aGlzLmNpZCwgZXJyLm5hbWUsIChlcnIuaW5mbyAmJiBlcnIuaW5mby5sb2dNZXNzYWdlKSB8fCBlcnIubWVzc2FnZSk7XG5cdFx0XHRcdC8vIGVyci5sb2dFdmVudCAmJiBjb25zb2xlLmxvZyhlcnIubG9nRXZlbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0XHRcdC8qIGxvZyBtZXRob2RzXG5cdFx0XHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdFx0X19sb2dNZXNzYWdlOiBmdW5jdGlvbihtc2csIGxvZ3R5cGUsIGNvbG9yKSB7XG5cdFx0XHRcdHZhciBsb2dFbnRyeUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcblxuXHRcdFx0XHRsb2d0eXBlIHx8IChsb2d0eXBlID0gXCItXCIpXG5cdFx0XHRcdGxvZ0VudHJ5RWwudGV4dENvbnRlbnQgPSB0aGlzLl9fZ2V0VFN0YW1wKCkgKyBcIiBcIiArIG1zZztcblx0XHRcdFx0bG9nRW50cnlFbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWxvZ3R5cGVcIiwgbG9ndHlwZSk7XG5cdFx0XHRcdGxvZ0VudHJ5RWwuc3R5bGUuY29sb3IgPSBjb2xvciB8fCB0aGlzLl9fbG9nQ29sb3JzW2xvZ3R5cGVdIHx8IHRoaXMuX19sb2dDb2xvcnMubm9ybWFsO1xuXG5cdFx0XHRcdHRoaXMuX19sb2dFbGVtZW50LmFwcGVuZENoaWxkKGxvZ0VudHJ5RWwpO1xuXHRcdFx0XHR0aGlzLl9fbG9nRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9fbG9nRWxlbWVudC5zY3JvbGxIZWlnaHQ7XG5cblx0XHRcdFx0aWYgKHRoaXMuX19yYWZJZCA9PSAtMSkge1xuXHRcdFx0XHRcdHRoaXMuX19yYWZJZCA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX19vbkZyYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X19vbkZyYW1lOiBmdW5jdGlvbih0c3RhbXApIHtcblx0XHRcdFx0dGhpcy5fX3JhZklkID0gLTE7XG5cdFx0XHRcdHRoaXMuX19sb2dFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQuc3R5bGUuYm9yZGVyQm90dG9tID0gdGhpcy5fX2xvZ0ZyYW1lU3R5bGU7XG5cdFx0XHRcdHRoaXMuX19sb2dFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMnB4XCI7XG5cdFx0XHRcdHRoaXMuX19sb2dFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQuc3R5bGUubWFyZ2luQm90dG9tID0gXCIycHhcIjtcblx0XHRcdH0sXG5cblx0XHRcdF9fZ2V0VFN0YW1wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gcmV0dXJuIG5ldyBEYXRlKERhdGUubm93KCkgLSB0aGlzLl9fbG9nU3RhcnRUaW1lKS50b0lTT1N0cmluZygpLnN1YnN0cigxMSwgMTIpO1xuXHRcdFx0XHRyZXR1cm4gbHBhZCgoKERhdGUubm93KCkgLSB0aGlzLl9fbG9nU3RhcnRUaW1lKSAvIDEwMDApLnRvRml4ZWQoMyksIDgsIFwiMFwiKTtcblx0XHRcdH0sXG5cblx0XHRcdF9fZ2V0SGVhZGVyVGV4dDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH0pKE1lZGlhUmVuZGVyZXIpO1xuXG59IC8vIGVuZCBkZWJ1Z1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9yZW5kZXIvTWVkaWFSZW5kZXJlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBNZWRpYVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvcmVuZGVyL1BsYXlhYmxlUmVuZGVyZXJcbiAqL1xuXG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9NZWRpYVJlbmRlcmVyfSAqL1xuY29uc3QgTWVkaWFSZW5kZXJlciA9IHJlcXVpcmUoXCJhcHAvdmlldy9yZW5kZXIvTWVkaWFSZW5kZXJlclwiKTtcbi8vIC8qKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L2NvbXBvbmVudC9DYW52YXNQcm9ncmVzc01ldGVyfSAqL1xuLy8gdmFyIFByb2dyZXNzTWV0ZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvY29tcG9uZW50L0NhbnZhc1Byb2dyZXNzTWV0ZXJcIik7XG5cbi8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5jb25zdCBwcmVmaXhlZFByb3BlcnR5ID0gcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkUHJvcGVydHlcIik7XG4vKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuY29uc3QgcHJlZml4ZWRFdmVudCA9IHJlcXVpcmUoXCJ1dGlscy9wcmVmaXhlZEV2ZW50XCIpO1xuXG4vLyB2YXIgdmlzaWJpbGl0eUhpZGRlblByb3AgPSBwcmVmaXhlZFByb3BlcnR5KFwiaGlkZGVuXCIsIGRvY3VtZW50KTtcbi8qKiBAdHlwZSB7U3RyaW5nfSAqL1xudmFyIHZpc2liaWxpdHlTdGF0ZVByb3AgPSBwcmVmaXhlZFByb3BlcnR5KFwidmlzaWJpbGl0eVN0YXRlXCIsIGRvY3VtZW50KTtcbi8qKiBAdHlwZSB7U3RyaW5nfSAqL1xudmFyIHZpc2liaWxpdHlDaGFuZ2VFdmVudCA9IHByZWZpeGVkRXZlbnQoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGRvY3VtZW50LCBcImhpZGRlblwiKTtcblxuLy8gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbi8vIHZhciBDb2xvciA9IHJlcXVpcmUoXCJjb2xvclwiKTtcbi8vXG4vLyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuLy8gLy8gdmFyIGR1b3RvbmUgPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL2JpdG1hcC9kdW90b25lXCIpO1xuLy8gLy8gdmFyIHN0YWNrQmx1ck1vbm8gPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL2JpdG1hcC9zdGFja0JsdXJNb25vXCIpO1xuLy8gdmFyIHN0YWNrQmx1clJHQiA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvYml0bWFwL3N0YWNrQmx1clJHQlwiKTtcbi8vIC8vIHZhciBnZXRBdmVyYWdlUkdCQSA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvYml0bWFwL2dldEF2ZXJhZ2VSR0JBXCIpO1xuLy8gdmFyIGdldEF2ZXJhZ2VSR0IgPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL2JpdG1hcC9nZXRBdmVyYWdlUkdCXCIpO1xuLy8gLy8gdmFyIGluZmxhdGVSZWN0ID0gcmVxdWlyZShcInV0aWxzL2dlb20vaW5mbGF0ZVJlY3RcIik7XG4vL1xuXG4vLyB2YXIgV0FJVF9ERUJPVU5DRV9NUyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpLlRSQU5TSVRJT05fRFVSQVRJT047XG5cbi8vIC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovXG4vLyB2YXIgX3NoYXJlZENhbnZhcyA9IG51bGw7XG4vLyAvKiogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9ICovXG4vLyB2YXIgZ2V0U2hhcmVkQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4vLyBcdGlmIChfc2hhcmVkQ2FudmFzID09PSBudWxsKSB7XG4vLyBcdFx0X3NoYXJlZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4vLyBcdH1cbi8vIFx0cmV0dXJuIF9zaGFyZWRDYW52YXM7XG4vLyB9O1xuXG4vLyB2YXIgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuLy8gdmFyIFhMSU5LX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG4vL1xuLy8gdmFyIHVzZUlkU2VlZCA9IDBcbi8vIHZhciBjcmVhdGVTVkdVc2VFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4vLyBcdHZhciBzdmdFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwidXNlXCIpO1xuLy8gXHRzdmdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIG5hbWUgKyAodXNlSWRTZWVkKyspKTtcbi8vIFx0c3ZnRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGFzc1wiLCBbbmFtZSwgXCJzeW1ib2xcIl0uam9pbihcIiBcIikpO1xuLy8gXHRzdmdFbC5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgXCJ4bGluazpocmVmXCIsIFwiI1wiICsgbmFtZSk7XG4vLyBcdHJldHVybiBzdmdFbDtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGxvZ0F0dGFjaEluZm8odmlldywgbmFtZSwgbGV2ZWwpIHtcbi8vIFx0aWYgKFtcImxvZ1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsZXZlbCkgIT0gLTEpIHtcbi8vIFx0XHRsZXZlbCA9IFwibG9nXCI7XG4vLyBcdH1cbi8vIFx0Y29uc29sZVtsZXZlbF0uY2FsbChjb25zb2xlLCBcIiVzOjolcyBbcGFyZW50OiVzICVzICVzIGRlcHRoOiVzXVwiLCB2aWV3LmNpZCwgbmFtZSwgdmlldy5wYXJlbnRWaWV3ICYmIHZpZXcucGFyZW50Vmlldy5jaWQsIHZpZXcuYXR0YWNoZWQgPyBcImF0dGFjaGVkXCIgOiBcImRldGFjaGVkXCIsIHZpZXcuX3ZpZXdQaGFzZSwgdmlldy52aWV3RGVwdGgpO1xuLy8gfVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9yZW5kZXIvUGxheWFibGVSZW5kZXJlcn1cbiAqL1xudmFyIFBsYXlhYmxlUmVuZGVyZXIgPSBNZWRpYVJlbmRlcmVyLmV4dGVuZCh7XG5cblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdGNpZFByZWZpeDogXCJwbGF5YWJsZVJlbmRlcmVyXCIsXG5cblx0LyoqIEB0eXBlIHtzdHJpbmd8RnVuY3Rpb259ICovXG5cdGNsYXNzTmFtZTogTWVkaWFSZW5kZXJlci5wcm90b3R5cGUuY2xhc3NOYW1lICsgXCIgcGxheWFibGUtaXRlbVwiLFxuXG5cdHByb3BlcnRpZXM6IHtcblx0XHRtZWRpYVBhdXNlZDoge1xuXHRcdFx0LyoqIEByZXR1cm4ge0Jvb2xlYW59ICovXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faXNNZWRpYVBhdXNlZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWVkaWFXYWl0aW5nOiB7XG5cdFx0XHQvKiogQHJldHVybiB7Qm9vbGVhbn0gKi9cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pc01lZGlhV2FpdGluZygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cGxheWJhY2tSZXF1ZXN0ZWQ6IHtcblx0XHRcdC8qKiBAcmV0dXJuIHtCb29sZWFufSAqL1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BsYXliYWNrUmVxdWVzdGVkO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fc2V0UGxheWJhY2tSZXF1ZXN0ZWQodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b3ZlcmxheToge1xuXHRcdFx0LyoqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAqL1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX292ZXJsYXkgfHwgKHRoaXMuX292ZXJsYXkgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIub3ZlcmxheVwiKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBwbGF5VG9nZ2xlOiB7XG5cdFx0Ly8gXHQvKiogQHJldHVybiB7SFRNTEVsZW1lbnR9ICovXG5cdFx0Ly8gXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHRyZXR1cm4gdGhpcy5fcGxheVRvZ2dsZSB8fCAodGhpcy5fcGxheVRvZ2dsZSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5wbGF5LXRvZ2dsZVwiKSk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSxcblx0XHQvLyBwbGF5VG9nZ2xlU3ltYm9sOiB7XG5cdFx0Ly8gXHQvKiogQHJldHVybiB7SFRNTEVsZW1lbnR9ICovXG5cdFx0Ly8gXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHRyZXR1cm4gdGhpcy5fcGxheVRvZ2dsZVN5bWJvbCB8fCAodGhpcy5fcGxheVRvZ2dsZVN5bWJvbCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5wbGF5LXRvZ2dsZS1zeW1ib2xcIikpO1xuXHRcdC8vIFx0fVxuXHRcdC8vIH0sXG5cdFx0cGxheVRvZ2dsZUhpdGFyZWE6IHtcblx0XHRcdC8qKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gKi9cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wbGF5VG9nZ2xlSGl0YXJlYSB8fCAodGhpcy5fcGxheVRvZ2dsZUhpdGFyZWEgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIucGxheS10b2dnbGUtaGl0YXJlYVwiKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHR0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sID0ge307XG5cdFx0Ly8gdGhpcy5fdG9nZ2xlV2FpdGluZyA9IF8uZGVib3VuY2UodGhpcy5fdG9nZ2xlV2FpdGluZywgNTAwKTtcblx0XHQvLyB0aGlzLl90b2dnbGVXYWl0aW5nID0gXy50aHJvdHRsZSh0aGlzLl90b2dnbGVXYWl0aW5nLCBXQUlUX0RFQk9VTkNFX01TLCB7IGxlYWRpbmc6IHRydWUsIHRyYWlsaW5nOiB0cnVlIH0pO1xuXG5cdFx0Xy5iaW5kQWxsKHRoaXMsXG5cdFx0XHRcIl9vblBsYXliYWNrVG9nZ2xlXCIsXG5cdFx0XHRcIl9vblZpc2liaWxpdHlDaGFuZ2VcIlxuXHRcdCk7XG5cdFx0TWVkaWFSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NldFBsYXliYWNrUmVxdWVzdGVkKHRoaXMuX3BsYXliYWNrUmVxdWVzdGVkKTtcblxuXHRcdC8vIHRoaXMubGlzdGVuVG8odGhpcywgXCJ2aWV3OnBhcmVudENoYW5nZVwiLCBmdW5jdGlvbihjaGlsZFZpZXcsIG5ld1BhcmVudCwgb2xkUGFyZW50KSB7XG5cdFx0Ly8gXHQvLyBsb2dBdHRhY2hJbmZvKHRoaXMsIFwiW3ZpZXc6cGFyZW50Q2hhbmdlXVwiLCBcImluZm9cIik7XG5cdFx0Ly8gXHRjb25zb2xlLmluZm8oXCIlczo6W3ZpZXc6cGFyZW50Q2hhbmdlXSAnJXMnIHRvICclcydcIiwgdGhpcy5jaWQsIG9sZFBhcmVudCAmJiBvbGRQYXJlbnQuY2lkLCBuZXdQYXJlbnQgJiYgbmV3UGFyZW50LmNpZCk7XG5cdFx0Ly8gfSk7XG5cdH0sXG5cblx0Ly8gLyoqIEBvdmVycmlkZSAqL1xuXHQvLyBpbml0aWFsaXplQXN5bmM6IGZ1bmN0aW9uKCkge1xuXHQvLyBcdHJldHVybiBNZWRpYVJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplLmluaXRpYWxpemVBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQvLyB9LFxuXG5cdC8vIC8qKiBAb3ZlcnJpZGUgKi9cblx0Ly8gcmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0Ly8gXHRNZWRpYVJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0Ly8gXHRyZXR1cm4gdGhpcztcblx0Ly8gfSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBjaGlsZHJlbi9sYXlvdXRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gY3JlYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHQvLyB9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHNldEVuYWJsZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRzZXRFbmFibGVkOiBmdW5jdGlvbihlbmFibGVkKSB7XG5cdFx0TWVkaWFSZW5kZXJlci5wcm90b3R5cGUuc2V0RW5hYmxlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdC8vIHRoaXMuX3ZhbGlkYXRlUGxheWJhY2soZW5hYmxlZCk7XG5cdFx0Ly8gaWYgKGVuYWJsZWQpIHtcblx0XHR0aGlzLl92YWxpZGF0ZVBsYXliYWNrKCk7XG5cdFx0Ly8gfSBlbHNlIHtcblx0XHQvLyBcdC8vIGlmIHNlbGVjdGVkLCBwYXVzZSBtZWRpYVxuXHRcdC8vIFx0dGhpcy5tb2RlbC5zZWxlY3RlZCAmJiB0aGlzLl90b2dnbGVQbGF5YmFjayhmYWxzZSk7XG5cdFx0Ly8gXHQvLyB0aGlzLl90b2dnbGVQbGF5YmFjayhmYWxzZSk7XG5cdFx0Ly8gfVxuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OnNldEVuYWJsZWRcIiwgdGhpcy5jaWQsIHRoaXMuZW5hYmxlZCk7XG5cdFx0Ly8gdGhpcy5fcGxheVRvZ2dsZVN5bWJvbC5wYXVzZWQgPSAodGhpcy5lbmFibGVkICYmIHRoaXMubW9kZWwuc2VsZWN0ZWQpO1xuXHRcdC8vfVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBzZWxlY3Rpb24gaGFuZGxlcnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0bGlzdGVuVG9TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl92aWV3UGhhc2UgIT0gXCJpbml0aWFsaXplZFwiKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHRoaXMuY2lkICsgXCI6Omxpc3RlblRvU2VsZWN0aW9uIGNhbGxlZCB3aGlsZSBcIiArIHRoaXMuX3ZpZXdQaGFzZSk7XG5cblx0XHQvLyBsb2dBdHRhY2hJbmZvKHRoaXMsIFwibGlzdGVuVG9TZWxlY3Rpb25cIiwgXCJsb2dcIik7XG5cdFx0Ly8gdGhpcy5saXN0ZW5Ubyh0aGlzLCBcInZpZXc6cmVtb3ZlZFwiLCB0aGlzLnJlbW92ZVNlbGVjdGlvbkxpc3RlbmVycyk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInNlbGVjdGVkXCIsIHRoaXMuX29uTW9kZWxTZWxlY3RlZCk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcImRlc2VsZWN0ZWRcIiwgdGhpcy5fb25Nb2RlbERlc2VsZWN0ZWQpO1xuXHRcdGlmICh0aGlzLm1vZGVsLnNlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLl9vbk1vZGVsU2VsZWN0ZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogbW9kZWwgc2VsZWN0ZWQgaGFuZGxlcnM6XG5cdC8qIG1vZGVsIHNlbGVjdGlvbiB0b2dnbGVzIHBsYXliYWNrXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9vbk1vZGVsU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9vbk1vZGVsU2VsZWN0ZWQgX3BsYXliYWNrUmVxdWVzdGVkOiAlcywgZXZlbnQ6ICVzXCIsIHRoaXMuY2lkLCB0aGlzLl9wbGF5YmFja1JlcXVlc3RlZCwgdGhpcy5fdG9nZ2xlRXZlbnQpO1xuXHRcdHRoaXMubGlzdGVuVG8odGhpcywgXCJ2aWV3OnBhcmVudENoYW5nZVwiLCB0aGlzLl9vblBhcmVudENoYW5nZSk7XG5cdFx0aWYgKHRoaXMucGFyZW50VmlldykgdGhpcy5fb25QYXJlbnRDaGFuZ2UodGhpcywgdGhpcy5wYXJlbnRWaWV3LCBudWxsKTtcblxuXHRcdC8vIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5fcGxheVRvZ2dsZVN5bWJvbC5wYXVzZWQgPSAhdGhpcy5lbmFibGVkO1xuXG5cdFx0dGhpcy5fbGlzdGVuV2hpbGVTZWxlY3RlZCgpO1xuXHRcdHRoaXMuX3ZhbGlkYXRlUGxheWJhY2soKTtcblx0fSxcblxuXHRfb25Nb2RlbERlc2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKFwiJXM6Ol9vbk1vZGVsRGVzZWxlY3RlZCBfcGxheWJhY2tSZXF1ZXN0ZWQ6ICVzLCBldmVudDogJXNcIiwgdGhpcy5jaWQsIHRoaXMuX3BsYXliYWNrUmVxdWVzdGVkLCB0aGlzLl90b2dnbGVFdmVudCk7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMsIFwidmlldzpwYXJlbnRDaGFuZ2VcIiwgdGhpcy5fb25QYXJlbnRDaGFuZ2UpO1xuXHRcdGlmICh0aGlzLnBhcmVudFZpZXcpIHRoaXMuX29uUGFyZW50Q2hhbmdlKHRoaXMsIG51bGwsIHRoaXMucGFyZW50Vmlldyk7XG5cblx0XHR0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sLnBhdXNlZCA9IHRydWU7XG5cblx0XHR0aGlzLl9zdG9wTGlzdGVuaW5nV2hpbGVTZWxlY3RlZCgpO1xuXHRcdHRoaXMuX3ZhbGlkYXRlUGxheWJhY2soZmFsc2UpO1xuXHRcdC8vIHRoaXMuX3RvZ2dsZVBsYXliYWNrKGZhbHNlKTtcblx0fSxcblxuXHQvKiB2aWV3OnBhcmVudENoYW5nZSBoYW5kbGVycyAzXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRfb25QYXJlbnRDaGFuZ2U6IGZ1bmN0aW9uKGNoaWxkVmlldywgbmV3UGFyZW50LCBvbGRQYXJlbnQpIHtcblx0XHQvLyBjb25zb2xlLmxvZyhcIltzY3JvbGxdICVzOjpfb25QYXJlbnRDaGFuZ2UgJyVzJyB0byAnJXMnXCIsIHRoaXMuY2lkLCBvbGRQYXJlbnQgJiYgb2xkUGFyZW50LmNpZCwgbmV3UGFyZW50ICYmIG5ld1BhcmVudC5jaWQpO1xuXHRcdGlmIChvbGRQYXJlbnQpIHRoaXMuc3RvcExpc3RlbmluZyhvbGRQYXJlbnQsIFwidmlldzpzY3JvbGxzdGFydCB2aWV3OnNjcm9sbGVuZFwiLCB0aGlzLl9vblNjcm9sbENoYW5nZSk7XG5cdFx0aWYgKG5ld1BhcmVudCkgdGhpcy5saXN0ZW5UbyhuZXdQYXJlbnQsIFwidmlldzpzY3JvbGxzdGFydCB2aWV3OnNjcm9sbGVuZFwiLCB0aGlzLl9vblNjcm9sbENoYW5nZSk7XG5cdH0sXG5cblx0X29uU2Nyb2xsQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5wYXJlbnRWaWV3ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IodGhpcy5jaWQgKyBcIjo6X29uU2Nyb2xsQ2hhbmdlIHBhcmVudFZpZXcgaXMgbnVsbFwiKTtcblx0XHR9XG5cdFx0dGhpcy5fdmFsaWRhdGVQbGF5YmFjaygpO1xuXHR9LFxuXG5cdC8qIHZpc2liaWxpdHkgZG9tIGV2ZW50XG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRfb25WaXNpYmlsaXR5Q2hhbmdlOiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMuX3ZhbGlkYXRlUGxheWJhY2soKTtcblx0fSxcblxuXHQvKiBsaXN0ZW4gdG8gRE9NIGV2ZW50c1xuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfbGlzdGVuV2hpbGVTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLCBcInZpZXc6cmVtb3ZlZFwiLCB0aGlzLl9zdG9wTGlzdGVuaW5nV2hpbGVTZWxlY3RlZCk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlRXZlbnQsIHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSwgZmFsc2UpO1xuXHRcdHRoaXMucGxheVRvZ2dsZUhpdGFyZWEuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl90b2dnbGVFdmVudCwgdGhpcy5fb25QbGF5YmFja1RvZ2dsZSwgZmFsc2UpO1xuXHR9LFxuXG5cdF9zdG9wTGlzdGVuaW5nV2hpbGVTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMsIFwidmlldzpyZW1vdmVkXCIsIHRoaXMuX3N0b3BMaXN0ZW5pbmdXaGlsZVNlbGVjdGVkKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2VFdmVudCwgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlLCBmYWxzZSk7XG5cdFx0dGhpcy5wbGF5VG9nZ2xlSGl0YXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3RvZ2dsZUV2ZW50LCB0aGlzLl9vblBsYXliYWNrVG9nZ2xlLCBmYWxzZSk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogcGxheS10b2dnbGVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyoqIEB0eXBlIHtTdHJpbmd9ICovXG5cdF90b2dnbGVFdmVudDogTWVkaWFSZW5kZXJlci5DTElDS19FVkVOVCwgLy93aW5kb3cuaGFzT3duUHJvcGVydHkoXCJvbnBvaW50ZXJ1cFwiKSA/IFwicG9pbnRlcnVwXCIgOiBcIm1vdXNldXBcIixcblxuXHRfb25QbGF5YmFja1RvZ2dsZTogZnVuY3Rpb24oZXYpIHtcblx0XHQvL2NvbnNvbGUubG9nKFwiJXNbJXNhYmxlZF06Ol9vblBsYXliYWNrVG9nZ2xlWyVzXSBkZWZhdWx0UHJldmVudGVkOiAlc1wiLCB0aGlzLmNpZCwgdGhpcy5lbmFibGVkID8gXCJlblwiIDogXCJkaXNcIiwgZXYudHlwZSwgZXYuZGVmYXVsdFByZXZlbnRlZCk7XG5cdFx0Ly8gTk9URTogUGVyZm9ybSBhY3Rpb24gaWYgTW91c2VFdmVudC5idXR0b24gaXMgMCBvciB1bmRlZmluZWQgKDA6IGxlZnQtYnV0dG9uKVxuXHRcdGlmICh0aGlzLmVuYWJsZWQgJiYgIWV2LmRlZmF1bHRQcmV2ZW50ZWQgJiYgIWV2LmJ1dHRvbikge1xuXHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMucGxheWJhY2tSZXF1ZXN0ZWQgPSAhdGhpcy5wbGF5YmFja1JlcXVlc3RlZDtcblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogcGxheWJhY2tSZXF1ZXN0ZWRcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X3BsYXliYWNrQ291bnQ6IDAsXG5cblx0LyoqIEB0eXBlIHtCb29sZWFuP30gKi9cblx0X3BsYXliYWNrUmVxdWVzdGVkOiBudWxsLFxuXG5cdF9zZXRQbGF5YmFja1JlcXVlc3RlZDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLl9wbGF5YmFja1JlcXVlc3RlZCA9IHZhbHVlO1xuXG5cdFx0dmFyIGNsYXNzTGlzdCA9IHRoaXMuY29udGVudC5jbGFzc0xpc3Q7XG5cdFx0Y2xhc3NMaXN0LnRvZ2dsZShcInBsYXlpbmdcIiwgdmFsdWUgPT09IHRydWUpO1xuXHRcdGNsYXNzTGlzdC50b2dnbGUoXCJwYXVzZWRcIiwgdmFsdWUgPT09IGZhbHNlKTtcblx0XHRjbGFzc0xpc3QudG9nZ2xlKFwicmVxdWVzdGVkXCIsIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSk7XG5cblx0XHR0aGlzLl9yZW5kZXJQbGF5YmFja1N0YXRlKCk7XG5cblx0XHQvLyB0aGlzLl92YWxpZGF0ZVBsYXliYWNrKHRoaXMucGxheWJhY2tSZXF1ZXN0ZWQpO1xuXHRcdC8vIGlmICh0aGlzLnBsYXliYWNrUmVxdWVzdGVkKSB7XG5cdFx0dGhpcy5fdmFsaWRhdGVQbGF5YmFjaygpO1xuXHRcdC8vIH0gZWxzZSB7XG5cdFx0Ly8gXHR0aGlzLl90b2dnbGVQbGF5YmFjayhmYWxzZSk7XG5cdFx0Ly8gfVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIF90b2dnbGVQbGF5YmFja1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQHBhcmFtIHtCb29sZWFufSAqL1xuXHRfdG9nZ2xlUGxheWJhY2s6IGZ1bmN0aW9uKG5ld1BsYXlTdGF0ZSkge1xuXHRcdGlmIChERUJVRykgdGhpcy5fX2xvZ01lc3NhZ2UoW1xuXHRcdFx0XHRcImFyZ3M6XCIsIEFycmF5LnByb3RvdHlwZS5qb2luLmFwcGx5KGFyZ3VtZW50cyksXG5cdFx0XHRcdFwicGF1c2VkOlwiLCAodGhpcy5faXNNZWRpYVBhdXNlZCgpID8gXCJwYXVzZVwiIDogXCJwbGF5XCIpLFxuXHRcdFx0XHRcIm1lZGlhLXN0YXRlOlwiLCB0aGlzLm1lZGlhU3RhdGUsXG5cdFx0XHRcdF0uam9pbihcIiBcIiksXG5cdFx0XHRcInRvZ2dsZS1wbGF5YmFja1wiKTtcblxuXHRcdGlmIChfLmlzQm9vbGVhbihuZXdQbGF5U3RhdGUpICYmIG5ld1BsYXlTdGF0ZSAhPT0gdGhpcy5faXNNZWRpYVBhdXNlZCgpKSB7XG5cdFx0XHRyZXR1cm47IC8vIHJlcXVlc3RlZCBzdGF0ZSBpcyBjdXJyZW50LCBkbyBub3RoaW5nXG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld1BsYXlTdGF0ZSA9IHRoaXMuX2lzTWVkaWFQYXVzZWQoKTtcblx0XHR9XG5cdFx0aWYgKG5ld1BsYXlTdGF0ZSkgeyAvLyBjaGFuZ2luZyB0byB3aGF0P1xuXHRcdFx0Ly8gdGhpcy5fcGxheWJhY2tDb3VudCsrO1xuXHRcdFx0dGhpcy5fcGxheU1lZGlhKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BhdXNlTWVkaWEoKTtcblx0XHR9XG5cdFx0LyogTk9URTogY2FsbGVkIGZyb20gX3NldFBsYXliYWNrUmVxdWVzdGVkICovXG5cdFx0Ly8gdGhpcy5fcmVuZGVyUGxheWJhY2tTdGF0ZSgpO1xuXHR9LFxuXG5cdF9jYW5SZXN1bWVQbGF5YmFjazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhKFxuXHRcdFx0dGhpcy5lbmFibGVkICYmXG5cdFx0XHR0aGlzLm1vZGVsLnNlbGVjdGVkICYmXG5cdFx0XHR0aGlzLnBsYXliYWNrUmVxdWVzdGVkICYmXG5cdFx0XHQodGhpcy5tZWRpYVN0YXRlID09PSBcInJlYWR5XCIpICYmXG5cdFx0XHR0aGlzLmF0dGFjaGVkICYmXG5cdFx0XHQodGhpcy5wYXJlbnRWaWV3ICE9PSBudWxsKSAmJlxuXHRcdFx0KCF0aGlzLnBhcmVudFZpZXcuc2Nyb2xsaW5nKSAmJlxuXHRcdFx0KGRvY3VtZW50W3Zpc2liaWxpdHlTdGF0ZVByb3BdICE9IFwiaGlkZGVuXCIpXG5cdFx0KTtcblx0fSxcblxuXHRfdmFsaWRhdGVQbGF5YmFjazogZnVuY3Rpb24oc2hvcnRjaXJjdWl0KSB7XG5cdFx0Ly8gYSAnc2hvcnRjaXJjdWl0JyBib29sZWFuIGFyZ3VtZW50IGNhbiBiZSBwYXNzZWQsIGFuZCBpZiBmYWxzZSxcblx0XHQvLyBza2lwIF9jYW5SZXN1bWVQbGF5YmFjayBhbmQgcGF1c2UgcGxheWJhY2sgcmlnaHQgYXdheVxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAwICYmICFzaG9ydGNpcmN1aXQpIHtcblx0XHRcdHRoaXMuX3RvZ2dsZVBsYXliYWNrKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdG9nZ2xlUGxheWJhY2sodGhpcy5fY2FuUmVzdW1lUGxheWJhY2soKSk7XG5cdFx0fVxuXHRcdHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wucGF1c2VkID0gISh0aGlzLmF0dGFjaGVkICYmIHRoaXMuZW5hYmxlZCAmJiB0aGlzLm1vZGVsLnNlbGVjdGVkKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogX3NldFBsYXlUb2dnbGVTeW1ib2xcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X3JlbmRlclBsYXliYWNrU3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5hdHRhY2hlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wcm9ncmVzc01ldGVyKSB7XG5cdFx0XHR0aGlzLnByb2dyZXNzTWV0ZXIuc3RhbGxlZCA9IHRoaXMuX2lzTWVkaWFXYWl0aW5nKCk7XG5cdFx0fVxuXHRcdC8vIHRoaXMuX3NldFBsYXlUb2dnbGVTeW1ib2woXCJ3YWl0aW5nXCIpO1xuXHRcdC8vIHRoaXMuY29udGVudC5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCB0cnVlKTtcblxuXHRcdC8vIGlmICghdGhpcy5jb250ZW50LmNsYXNzTGlzdC5jb250YWlucyhcInN0YXJ0ZWRcIikpIHtcblx0XHQvLyBcdHRoaXMuX3NldFBsYXlUb2dnbGVTeW1ib2woXCJwbGF5XCIpO1xuXHRcdC8vIH0gZWxzZVxuXHRcdHZhciB3YWl0aW5nID0gIXRoaXMucGFyZW50Vmlldy5zY3JvbGxpbmcgJiYgdGhpcy5faXNNZWRpYVdhaXRpbmcoKTtcblxuXHRcdGlmICh0aGlzLnBsYXliYWNrUmVxdWVzdGVkKSB7XG5cdFx0XHRpZiAod2FpdGluZykge1xuXHRcdFx0XHR0aGlzLl9zZXRQbGF5VG9nZ2xlU3ltYm9sKFwid2FpdGluZ1wiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NldFBsYXlUb2dnbGVTeW1ib2woXCJwbGF5XCIpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5jb250ZW50LmNsYXNzTGlzdC5jb250YWlucyhcInN0YXJ0ZWRcIikpIHtcblx0XHRcdFx0dGhpcy5fc2V0UGxheVRvZ2dsZVN5bWJvbChcInBhdXNlXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2V0UGxheVRvZ2dsZVN5bWJvbChcInBsYXlcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBjbHMgPSB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0O1xuXHRcdGNscy50b2dnbGUoXCJwbGF5aW5nXCIsIHRoaXMucGxheWJhY2tSZXF1ZXN0ZWQpO1xuXHRcdGNscy50b2dnbGUoXCJwYXVzZWRcIiwgIXRoaXMucGxheWJhY2tSZXF1ZXN0ZWQpO1xuXHRcdGNscy50b2dnbGUoXCJ3YWl0aW5nXCIsIHdhaXRpbmcpO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIiVzOjpfcmVuZGVyUGxheWJhY2tTdGF0ZSBbcGxheTogJXNdIFt3YWl0OiAlc10gW3N5bWJvbDogJXNdXCIsIHRoaXMuY2lkLCB0aGlzLnBsYXliYWNrUmVxdWVzdGVkLCB0aGlzLl9pc01lZGlhV2FpdGluZygpLCB0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sLnN5bWJvbE5hbWUpO1xuXHR9LFxuXG5cdF9zZXRQbGF5VG9nZ2xlU3ltYm9sOiBmdW5jdGlvbihzeW1ib2xOYW1lKSB7XG5cdFx0Ly9jb25zb2xlLmxvZyhcIiVzOjpfc2V0UGxheVRvZ2dsZVN5bWJvbCBbZW5hYmxlZDogJXNdIFtzZWxlY3RlZDogJXNdIFtzeW1ib2w6ICVzXVwiLCB0aGlzLmNpZCwgdGhpcy5lbmFibGVkLCAhISh0aGlzLm1vZGVsLnNlbGVjdGVkKSwgc3ltYm9sTmFtZSk7XG5cblx0XHQvLyB0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sLnBhdXNlZCA9ICEodGhpcy5hdHRhY2hlZCAmJiB0aGlzLmVuYWJsZWQgJiYgISEodGhpcy5tb2RlbC5zZWxlY3RlZCkpO1xuXHRcdHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wuc3ltYm9sTmFtZSA9IHN5bWJvbE5hbWU7XG5cdFx0aWYgKHRoaXMubWVkaWFTdGF0ZSA9PT0gXCJyZWFkeVwiKSB7IC8vdGhpcy5fcGxheVRvZ2dsZVN5bWJvbC5yZW5kZXJGbGFncykge1xuXHRcdFx0dGhpcy5fcGxheVRvZ2dsZVN5bWJvbC5yZW5kZXJOb3coKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gX3BsYXlUb2dnbGVTeW1ib2xTdmc6IG51bGwsXG5cdC8vIF9wbGF5VG9nZ2xlU3ltYm9sTmFtZTogbnVsbCxcblx0Ly8gX3NldFBsYXlUb2dnbGVTeW1ib2xfc3ZnOiBmdW5jdGlvbihzeW1ib2xOYW1lKSB7XG5cdC8vIFx0aWYgKHRoaXMuX3BsYXlUb2dnbGVTeW1ib2xOYW1lICE9PSBzeW1ib2xOYW1lKSB7XG5cdC8vIFx0XHR2YXIgc3ZnRG9jID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwic3ZnLnBsYXktdG9nZ2xlLXN5bWJvbFwiKTtcblx0Ly8gXHRcdGlmICh0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sU3ZnKSB7XG5cdC8vIFx0XHRcdHN2Z0RvYy5yZW1vdmVDaGlsZCh0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sU3ZnKTtcblx0Ly8gXHRcdH1cblx0Ly8gXHRcdHZhciBzdmdTeW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInVzZVwiKTtcblx0Ly8gXHRcdHN2Z1N5bS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJ4bGluazpocmVmXCIsIFwiI1wiICsgc3ltYm9sTmFtZSk7XG5cdC8vIFx0XHRzdmdEb2MuYXBwZW5kQ2hpbGQoc3ZnU3ltKTtcblx0Ly8gXHRcdHN2Z0RvYy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsYXNzXCIsIHN5bWJvbE5hbWUgKyBcIi1zeW1ib2wgcGxheS10b2dnbGUtc3ltYm9sXCIpO1xuXHQvL1xuXHQvLyBcdFx0dGhpcy5fcGxheVRvZ2dsZVN5bWJvbFN2ZyA9IHN2Z1N5bTtcblx0Ly8gXHRcdHRoaXMuX3BsYXlUb2dnbGVTeW1ib2xOYW1lID0gc3ltYm9sTmFtZTtcblx0Ly8gXHR9XG5cdC8vIH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0Lyogd2FpdGluZ1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRfaXNXYWl0aW5nOiBmYWxzZSxcblxuXHRfaXNNZWRpYVdhaXRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pc1dhaXRpbmc7XG5cdH0sXG5cblx0X3RvZ2dsZVdhaXRpbmc6IGZ1bmN0aW9uKHdhaXRpbmcpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0d2FpdGluZyA9ICF0aGlzLl9pc1dhaXRpbmc7XG5cdFx0fVxuXHRcdC8vIGlmICh0aGlzLl9pc01lZGlhUGF1c2VkKCkpIHtcblx0XHQvLyBcdHdhaXRpbmcgPSBmYWxzZTtcblx0XHQvLyB9XG5cdFx0aWYgKHRoaXMuX2lzV2FpdGluZyAhPT0gd2FpdGluZykge1xuXHRcdFx0dGhpcy5faXNXYWl0aW5nID0gd2FpdGluZztcblx0XHRcdHRoaXMuX3JlbmRlclBsYXliYWNrU3RhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0LyogYWJzdHJhY3Rcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X2lzTWVkaWFQYXVzZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUud2FybihcIiVzOjpfaXNNZWRpYVBhdXNlZCBOb3QgaW1wbGVtZW50ZWRcIiwgdGhpcy5jaWQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9wbGF5TWVkaWE6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUud2FybihcIiVzOjpfcGxheU1lZGlhIE5vdCBpbXBsZW1lbnRlZFwiLCB0aGlzLmNpZCk7XG5cdH0sXG5cblx0X3BhdXNlTWVkaWE6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUud2FybihcIiVzOjpfcGF1c2VNZWRpYSBOb3QgaW1wbGVtZW50ZWRcIiwgdGhpcy5jaWQpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHV0aWxcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0dXBkYXRlT3ZlcmxheTogZnVuY3Rpb24obWVkaWFFbCwgdGFyZ2V0RWwsIHJlY3RFbCkge1xuXHRcdC8vIHRoaXMgbWV0aG9kIGlzIG5vdCBjcml0aWNhbCwganVzdCBjYXRjaCBhbmQgbG9nIGFsbCBlcnJvcnNcblx0XHQvLyB0cnkge1xuXHRcdC8vIFx0dGhpcy5fdXBkYXRlT3ZlcmxheShtZWRpYUVsLCB0YXJnZXRFbCwgcmVjdEVsKVxuXHRcdC8vIH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFx0Y29uc29sZS5lcnJvcihcIiVzOjp1cGRhdGVPdmVybGF5XCIsIHRoaXMuY2lkLCBlcnIpO1xuXHRcdC8vIH1cblx0fSxcblxuXHQvKipcXC9cblx0X2RyYXdNZWRpYUVsZW1lbnQ6IGZ1bmN0aW9uKGN0eCwgbWVkaWFFbCwgZGVzdCkge1xuXHRcdC8vIGRlc3RpbmF0aW9uIHJlY3Rcblx0XHQvLyBOT1RFOiBtZWRpYUVsIGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBpbiB0aGlzLm1ldHJpY3MubWVkaWFcblx0XHRtZWRpYUVsIHx8IChtZWRpYUVsID0gdGhpcy5kZWZhdWx0SW1hZ2UpO1xuXHRcdGRlc3QgfHwgKGRlc3QgPSB7XG5cdFx0XHR4OiAwLFxuXHRcdFx0eTogMCxcblx0XHRcdHdpZHRoOiB0aGlzLm1ldHJpY3MubWVkaWEud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHRoaXMubWV0cmljcy5tZWRpYS5oZWlnaHRcblx0XHR9KTtcblxuXHRcdC8vIG5hdGl2ZS9kaXNwbGF5IHNjYWxlXG5cdFx0dmFyIHNXID0gdGhpcy5tb2RlbC5nZXQoXCJzb3VyY2VcIikuZ2V0KFwid1wiKSxcblx0XHRcdHNIID0gdGhpcy5tb2RlbC5nZXQoXCJzb3VyY2VcIikuZ2V0KFwiaFwiKSxcblx0XHRcdHJzWCA9IHNXIC8gdGhpcy5tZXRyaWNzLm1lZGlhLndpZHRoLFxuXHRcdFx0cnNZID0gc0ggLyB0aGlzLm1ldHJpY3MubWVkaWEuaGVpZ2h0O1xuXG5cdFx0Ly8gZGVzdCwgc2NhbGVkIHRvIG5hdGl2ZVxuXHRcdHZhciBzcmMgPSB7XG5cdFx0XHR4OiBNYXRoLm1heCgwLCBkZXN0LnggKiByc1gpLFxuXHRcdFx0eTogTWF0aC5tYXgoMCwgZGVzdC55ICogcnNZKSxcblx0XHRcdHdpZHRoOiBNYXRoLm1pbihzVywgZGVzdC53aWR0aCAqIHJzWCksXG5cdFx0XHRoZWlnaHQ6IE1hdGgubWluKHNILCBkZXN0LmhlaWdodCAqIHJzWSlcblx0XHR9O1xuXG5cdFx0Ly8gcmVzaXplIGNhbnZhc1xuXHRcdC8vIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdC8vIGlmIChjYW52YXMud2lkdGggIT09IGRlc3Qud2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gZGVzdC5oZWlnaHQpIHtcblx0XHQvLyBcdGNhbnZhcy53aWR0aCA9IGRlc3Qud2lkdGg7XG5cdFx0Ly8gXHRjYW52YXMuaGVpZ2h0ID0gZGVzdC5oZWlnaHQ7XG5cdFx0Ly8gfVxuXHRcdGN0eC5jYW52YXMud2lkdGggPSBkZXN0LndpZHRoO1xuXHRcdGN0eC5jYW52YXMuaGVpZ2h0ID0gZGVzdC5oZWlnaHQ7XG5cblx0XHQvLyBjb3B5IGltYWdlIHRvIGNhbnZhc1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQpO1xuXHRcdGN0eC5kcmF3SW1hZ2UobWVkaWFFbCxcblx0XHRcdHNyYy54LCBzcmMueSwgc3JjLndpZHRoLCBzcmMuaGVpZ2h0LFxuXHRcdFx0MCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQgLy8gZGVzdGluYXRpb24gcmVjdFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gY3R4O1xuXHR9LFxuXG5cdF9nZXRJbWFnZURhdGE6IGZ1bmN0aW9uKG1lZGlhRWwsIHRhcmdldEVsLCByZWN0RWwpIHtcblx0XHQvLyBzcmMvZGVzdCByZWN0c1xuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHJlY3RFbCB8fCAocmVjdEVsID0gdGFyZ2V0RWwpO1xuXG5cdFx0Ly8gTk9URTogZG9lcyBub3Qgd29yayB3aXRoIHN2ZyBlbGVtZW50XG5cdFx0Ly8gdmFyIHRSZWN0ID0gcmVjdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdC8vIHZhciBjUmVjdCA9IG1lZGlhRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Ly8gdmFyIHRYID0gdFJlY3QueCAtIGNSZWN0LngsXG5cdFx0Ly8gXHR0WSA9IHRSZWN0LnkgLSBjUmVjdC55LFxuXHRcdC8vIFx0dFcgPSB0UmVjdC53aWR0aCxcblx0XHQvLyBcdHRIID0gdFJlY3QuaGVpZ2h0O1xuXG5cdFx0Ly8gdGFyZ2V0IGJvdW5kc1xuXHRcdHZhciB0WCA9IHJlY3RFbC5vZmZzZXRMZWZ0LFxuXHRcdFx0dFkgPSByZWN0RWwub2Zmc2V0VG9wLFxuXHRcdFx0dFcgPSByZWN0RWwub2Zmc2V0V2lkdGgsXG5cdFx0XHR0SCA9IHJlY3RFbC5vZmZzZXRIZWlnaHQ7XG5cblx0XHRpZiAodFggPT09IHZvaWQgMCB8fCB0WSA9PT0gdm9pZCAwIHx8IHRXID09PSB2b2lkIDAgfHwgdEggPT09IHZvaWQgMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGRlc3RpbmF0aW9uIHJlY3Rcblx0XHR2YXIgUkVDVF9HUk9XID0gMDtcblx0XHR2YXIgZGVzdCA9IHtcblx0XHRcdHg6IHRYIC0gUkVDVF9HUk9XLFxuXHRcdFx0eTogdFkgLSBSRUNUX0dST1csXG5cdFx0XHR3aWR0aDogdFcgKyBSRUNUX0dST1cgKiAyLFxuXHRcdFx0aGVpZ2h0OiB0SCArIFJFQ1RfR1JPVyAqIDJcblx0XHR9O1xuXG5cdFx0Ly8gbmF0aXZlL2Rpc3BsYXkgc2NhbGVcblx0XHR2YXIgc1cgPSB0aGlzLm1vZGVsLmdldChcInNvdXJjZVwiKS5nZXQoXCJ3XCIpLFxuXHRcdFx0c0ggPSB0aGlzLm1vZGVsLmdldChcInNvdXJjZVwiKS5nZXQoXCJoXCIpLFxuXHRcdFx0cnNYID0gc1cgLyB0aGlzLm1ldHJpY3MubWVkaWEud2lkdGgsXG5cdFx0XHRyc1kgPSBzSCAvIHRoaXMubWV0cmljcy5tZWRpYS5oZWlnaHQ7XG5cblx0XHQvLyBkZXN0LCBzY2FsZWQgdG8gbmF0aXZlXG5cdFx0dmFyIHNyYyA9IHtcblx0XHRcdHg6IE1hdGgubWF4KDAsIGRlc3QueCAqIHJzWCksXG5cdFx0XHR5OiBNYXRoLm1heCgwLCBkZXN0LnkgKiByc1kpLFxuXHRcdFx0d2lkdGg6IE1hdGgubWluKHNXLCBkZXN0LndpZHRoICogcnNYKSxcblx0XHRcdGhlaWdodDogTWF0aC5taW4oc0gsIGRlc3QuaGVpZ2h0ICogcnNZKVxuXHRcdH07XG5cblx0XHQvLyBDb3B5IGltYWdlIHRvIGNhbnZhc1xuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0Ly8gY2FudmFzLnN0eWxlLndpZHRoICA9IGRlc3Qud2lkdGggKyBcInB4XCI7XG5cdFx0Ly8gY2FudmFzLnN0eWxlLmhlaWdodCA9IGRlc3QuaGVpZ2h0ICsgXCJweFwiO1xuXG5cdFx0dmFyIGNhbnZhcyA9IGdldFNoYXJlZENhbnZhcygpO1xuXHRcdGlmIChjYW52YXMud2lkdGggIT09IGRlc3Qud2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gZGVzdC5oZWlnaHQpIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IGRlc3Qud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGVzdC5oZWlnaHQ7XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQpO1xuXHRcdGN0eC5kcmF3SW1hZ2UobWVkaWFFbCxcblx0XHRcdHNyYy54LCBzcmMueSwgc3JjLndpZHRoLCBzcmMuaGVpZ2h0LFxuXHRcdFx0MCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQgLy8gZGVzdGluYXRpb24gcmVjdFxuXHRcdCk7XG5cdFx0cmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZGVzdC53aWR0aCwgZGVzdC5oZWlnaHQpO1xuXHR9LFxuXG5cdF91cGRhdGVPdmVybGF5OiBmdW5jdGlvbihtZWRpYUVsLCB0YXJnZXRFbCwgcmVjdEVsKSB7XG5cdFx0dmFyIGNhbnZhcywgY3R4O1xuXHRcdHZhciBpbWFnZURhdGEgPSB0aGlzLl9nZXRJbWFnZURhdGEobWVkaWFFbCwgdGFyZ2V0RWwsIHJlY3RFbCk7XG5cdFx0dmFyIGF2Z0NvbG9yID0gQ29sb3IoKS5yZ2IoZ2V0QXZlcmFnZVJHQihpbWFnZURhdGEpKTtcblxuXHRcdC8vIHZhciBhdmdIZXggPSBhdmdDb2xvci5oZXgoKS5zdHJpbmcoKSwgZWxzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nLCB2aWRlb1wiKTtcblx0XHQvLyBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuXHRcdC8vIFx0ZWxzLml0ZW0oaSkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYXZnSGV4O1xuXHRcdC8vIH1cblxuXHRcdHRhcmdldEVsLmNsYXNzTGlzdC50b2dnbGUoXCJvdmVyLWRhcmtcIiwgYXZnQ29sb3IuZGFyaygpKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OnVwZGF0ZU92ZXJsYXkoKSBhdmdDb2xvcjolcyAoJXMpXCIsIHRoaXMuY2lkLCBhdmdDb2xvci5yZ2IoKS5zdHJpbmcoKSwgYXZnQ29sb3IuZGFyaygpP1wiZGFya1wiOlwibGlnaHRcIiwgdGFyZ2V0RWwpO1xuXG5cdFx0Ly8gQ29sb3IsIGZpbHRlciBvcHRzXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHR0aGlzLmZnQ29sb3IgfHwgKHRoaXMuZmdDb2xvciA9IG5ldyBDb2xvcih0aGlzLm1vZGVsLmF0dHIoXCJjb2xvclwiKSkpO1xuXHRcdHRoaXMuYmdDb2xvciB8fCAodGhpcy5iZ0NvbG9yID0gbmV3IENvbG9yKHRoaXMubW9kZWwuYXR0cihcImJhY2tncm91bmQtY29sb3JcIikpKTtcblxuXHRcdHZhciBvcHRzID0geyByYWRpdXM6IDIwIH07XG5cdFx0dmFyIGlzRmdEYXJrID0gdGhpcy5mZ0NvbG9yLmx1bWlub3NpdHkoKSA8IHRoaXMuYmdDb2xvci5sdW1pbm9zaXR5KCk7XG5cdFx0b3B0cy54MDAgPSBpc0ZnRGFyayA/IENvbG9yKHRoaXMuZmdDb2xvcikubGlnaHRlbigwLjUpIDogQ29sb3IodGhpcy5iZ0NvbG9yKS5kYXJrZW4oMC41KTtcblx0XHRvcHRzLnhGRiA9IGlzRmdEYXJrID8gQ29sb3IodGhpcy5iZ0NvbG9yKS5saWdodGVuKDAuNSkgOiBDb2xvcih0aGlzLmZnQ29sb3IpLmRhcmtlbigwLjUpO1xuXG5cdFx0c3RhY2tCbHVyUkdCKGltYWdlRGF0YSwgeyByYWRpdXM6IDQwIH0pO1xuXHRcdC8vIHN0YWNrQmx1ck1vbm8oaW1hZ2VEYXRhLCBvcHRzKTtcblx0XHQvLyBkdW90b25lKGltYWdlRGF0YSwgb3B0cyk7XG5cblx0XHRjdHggPSBnZXRTaGFyZWRDYW52YXMoKTtcblx0XHRpZiAoY2FudmFzLndpZHRoICE9PSBpbWFnZURhdGEud2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaW1hZ2VEYXRhLmhlaWdodCkge1xuXHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG5cdFx0fVxuXHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXHRcdHRhcmdldEVsLnN0eWxlLmJhY2tncm91bmRPcmlnaW4gPSBcImJvcmRlci1ib3hcIjtcblx0XHR0YXJnZXRFbC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0XHR0YXJnZXRFbC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IFwiMTAwJVwiO1xuXHRcdC8vIHRhcmdldEVsLnN0eWxlLnBhZGRpbmcgPSBcIjAgMCA1cmVtIDBcIjtcblx0XHR0YXJnZXRFbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIiArIGNhbnZhcy50b0RhdGFVUkwoKSArIFwiKVwiO1xuXHR9IC8qKi9cbn0pO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIEdvb2dsZSBBbmFseXRpY3Ncbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuaWYgKHdpbmRvdy5HQV9FTkFCTEVEKSB7XG5cdFBsYXlhYmxlUmVuZGVyZXIgPSAoZnVuY3Rpb24oUGxheWFibGVSZW5kZXJlcikge1xuXG5cdFx0LyoqIEB0eXBlIHttb2R1bGU6dW5kZXJzY29yZS5zdHJpbmdzL2Rhc2hlcml6ZX0gKi9cblx0XHR2YXIgZGFzaGVyaXplID0gcmVxdWlyZShcInVuZGVyc2NvcmUuc3RyaW5nL2Rhc2hlcml6ZVwiKTtcblxuXHRcdC8vIHZhciByZWFkeUV2ZW50cyA9IFtcInBsYXlpbmdcIiwgXCJ3YWl0aW5nXCIsIFwiZW5kZWRcIl07XG5cdFx0Ly8gdmFyIHVzZXJFdmVudHMgPSBbXCJwbGF5XCIsIFwicGF1c2VcIl07XG5cblx0XHRyZXR1cm4gUGxheWFibGVSZW5kZXJlci5leHRlbmQoe1xuXG5cdFx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJldHZhbCA9IFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZ2FFdmVudFN1ZmZpeCA9IHRoaXMucGxheWJhY2tSZXF1ZXN0ZWQgPyBcIi1hdXRvcGxheVwiIDogXCJcIjtcblx0XHRcdFx0cmV0dXJuIHJldHZhbDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdF9vblBsYXliYWNrVG9nZ2xlOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHR2YXIgcmV0dmFsID0gUGxheWFibGVSZW5kZXJlci5wcm90b3R5cGUuX29uUGxheWJhY2tUb2dnbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0aWYgKHdpbmRvdy5nYSkge1xuXHRcdFx0XHRcdHdpbmRvdy5nYShcInNlbmRcIiwge1xuXHRcdFx0XHRcdFx0aGl0VHlwZTogXCJldmVudFwiLFxuXHRcdFx0XHRcdFx0ZXZlbnRDYXRlZ29yeTogZGFzaGVyaXplKHRoaXMuY2lkUHJlZml4KSxcblx0XHRcdFx0XHRcdGV2ZW50QWN0aW9uOiAodGhpcy5wbGF5YmFja1JlcXVlc3RlZCA/IFwicGxheVwiIDogXCJwYXVzZVwiKSArIHRoaXMuX2dhRXZlbnRTdWZmaXgsXG5cdFx0XHRcdFx0XHRldmVudExhYmVsOiB0aGlzLm1vZGVsLmdldChcInRleHRcIiksXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiJXM6Ol9vblBsYXliYWNrVG9nZ2xlIHdpbmRvdy5nYSBpcyAlc1wiLCB0aGlzLmNpZCwgd2luZG93LmdhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0dmFsO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gLyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0Ly8gX3RvZ2dsZVBsYXliYWNrOiBmdW5jdGlvbihuZXdQbGF5U3RhdGUpIHtcblx0XHRcdC8vIFx0dmFyIHJldHZhbCA9IFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLl90b2dnbGVQbGF5YmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gXHR3aW5kb3cuZ2EoXCJzZW5kXCIsIHtcblx0XHRcdC8vIFx0XHRoaXRUeXBlOiBcImV2ZW50XCIsXG5cdFx0XHQvLyBcdFx0ZXZlbnRDYXRlZ29yeTogXCJQbGF5YWJsZVwiLFxuXHRcdFx0Ly8gXHRcdGV2ZW50QWN0aW9uOiB0aGlzLnBsYXliYWNrUmVxdWVzdGVkID8gXCJwbGF5XCIgOiBcInBhdXNlXCIsXG5cdFx0XHQvLyBcdFx0ZXZlbnRMYWJlbDogdGhpcy5tb2RlbC5nZXQoXCJ0ZXh0XCIpLFxuXHRcdFx0Ly8gXHR9KTtcblx0XHRcdC8vIFx0cmV0dXJuIHJldHZhbDtcblx0XHRcdC8vIH0sXG5cdFx0fSk7XG5cdH0pKFBsYXlhYmxlUmVuZGVyZXIpO1xufVxuXG4vLyBpZiAoREVCVUcpIHtcbi8vIFx0UGxheWFibGVSZW5kZXJlci5wcm90b3R5cGUuX2xvZ0ZsYWdzID0gXCJcIjtcbi8vXG4vLyBcdFBsYXlhYmxlUmVuZGVyZXIgPSAoZnVuY3Rpb24oUGxheWFibGVSZW5kZXJlcikge1xuLy8gXHRcdGlmICghUGxheWFibGVSZW5kZXJlci5MT0dfVE9fU0NSRUVOKSByZXR1cm4gUGxheWFibGVSZW5kZXJlcjtcbi8vXG4vLyBcdFx0LyoqIEB0eXBlIHttb2R1bGU6dW5kZXJzY29yZS5zdHJpbmdzL2xwYWR9ICovXG4vLyBcdFx0dmFyIGxwYWQgPSByZXF1aXJlKFwidW5kZXJzY29yZS5zdHJpbmcvbHBhZFwiKTtcbi8vXG4vLyBcdFx0cmV0dXJuIFBsYXlhYmxlUmVuZGVyZXIuZXh0ZW5kKHtcbi8vIFx0XHRcdF9jYW5SZXN1bWVQbGF5YmFjazogZnVuY3Rpb24oKSB7XG4vLyBcdFx0XHRcdHZhciByZXR2YWwgPSBQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5fY2FuUmVzdW1lUGxheWJhY2suYXBwbHkodGhpcy5hcmd1bWVudHMpO1xuLy8gXHRcdFx0XHRjb25zb2xlLmxvZyhcIltzY3JvbGxdICVzOjpfY2FuUmVzdW1lUGxheWJhY2soKTolc1wiLCB0aGlzLmNpZCwgcmV0dmFsLCB7XG4vLyBcdFx0XHRcdFx0XCJlbmFibGVkXCI6IHRoaXMuZW5hYmxlZCxcbi8vIFx0XHRcdFx0XHRcInNlbGVjdGVkXCI6ICghIXRoaXMubW9kZWwuc2VsZWN0ZWQpLFxuLy8gXHRcdFx0XHRcdFwicGxheWJhY2tSZXF1ZXN0ZWRcIjogdGhpcy5wbGF5YmFja1JlcXVlc3RlZCxcbi8vIFx0XHRcdFx0XHRcImF0dGFjaGVkXCI6IHRoaXMuYXR0YWNoZWQsXG4vLyBcdFx0XHRcdFx0XCJwYXJlbnRWaWV3XCI6ICh0aGlzLnBhcmVudFZpZXcgJiYgdGhpcy5wYXJlbnRWaWV3LmNpZCksXG4vLyBcdFx0XHRcdFx0XCIhc2Nyb2xsaW5nXCI6ICh0aGlzLnBhcmVudFZpZXcgJiYgIXRoaXMucGFyZW50Vmlldy5zY3JvbGxpbmcpLFxuLy8gXHRcdFx0XHRcdFwibWVkaWFTdGF0ZVwiOiB0aGlzLm1lZGlhU3RhdGUsXG4vLyBcdFx0XHRcdFx0Ly8gXCIhZG9jdW1lbnQuaGlkZGVuXCI6ICFkb2N1bWVudFt2aXNpYmlsaXR5SGlkZGVuUHJvcF0sXG4vLyBcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5U3RhdGVcIjogZG9jdW1lbnRbdmlzaWJpbGl0eVN0YXRlUHJvcF1cbi8vIFx0XHRcdFx0fSk7XG4vLyBcdFx0XHRcdHJldHVybiByZXR2YWw7XG4vLyBcdFx0XHR9LFxuLy8gXHRcdH0pO1xuLy8gXHR9KShQbGF5YWJsZVJlbmRlcmVyKTtcbi8vIH1cblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5YWJsZVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJwbGFjZWhvbGRlciBzaXppbmdcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPlxcblx0PGRpdiBjbGFzcz1cXFwibWVkaWEtYm9yZGVyIGNvbnRlbnQtc2l6ZVxcXCI+PC9kaXY+XFxuXHQ8ZGl2IGNsYXNzPVxcXCJjb250cm9scyBjb250ZW50LXNpemVcXFwiPlxcblx0XHQ8Y2FudmFzIGNsYXNzPVxcXCJwcm9ncmVzcy1tZXRlclxcXCI+PC9jYW52YXM+XFxuXHQ8L2Rpdj5cXG5cdDxkaXYgY2xhc3M9XFxcInNlcXVlbmNlIG1lZGlhLXNpemVcXFwiPlxcblx0XHQ8aW1nIGNsYXNzPVxcXCJzZXF1ZW5jZS1zdGVwIGN1cnJlbnQgZGVmYXVsdFxcXCIgYWx0PVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGV4dCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGV4dCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwidGV4dFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIGxvbmdkZXNjPVxcXCIjZGVzY19tXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiAvPlxcblx0PC9kaXY+XFxuXHQ8ZGl2IGNsYXNzPVxcXCJvdmVybGF5IG1lZGlhLXNpemUgcGxheS10b2dnbGUtaGl0YXJlYVxcXCI+XFxuXHRcdDxjYW52YXMgY2xhc3M9XFxcInBsYXktdG9nZ2xlXFxcIi8+XFxuXHQ8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvcmVuZGVyL1NlcXVlbmNlUmVuZGVyZXJcbiAqL1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogSW1wb3J0c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOmJhY2tib25lLmJhYnlzaXR0ZXJ9ICovXG5jb25zdCBDb250YWluZXIgPSByZXF1aXJlKFwiYmFja2JvbmUuYmFieXNpdHRlclwiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvYmFzZS9WaWV3fSAqL1xuY29uc3QgVmlldyA9IHJlcXVpcmUoXCJhcHAvdmlldy9iYXNlL1ZpZXdcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9yZW5kZXIvUGxheWFibGVSZW5kZXJlcn0gKi9cbmNvbnN0IFBsYXlhYmxlUmVuZGVyZXIgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcmVuZGVyL1BsYXlhYmxlUmVuZGVyZXJcIik7XG4vLyAvKiogQHR5cGUge21vZHVsZTphcHAvbW9kZWwvU2VsZWN0YWJsZUNvbGxlY3Rpb259ICovXG4vLyB2YXIgU2VsZWN0YWJsZUNvbGxlY3Rpb24gPSByZXF1aXJlKFwiYXBwL21vZGVsL1NlbGVjdGFibGVDb2xsZWN0aW9uXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL2NvbnRyb2wvR2xvYmFsc30gKi9cbmNvbnN0IEdsb2JhbHMgPSByZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKTtcblxuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0NhbnZhc1Byb2dyZXNzTWV0ZXJ9ICovXG5jb25zdCBQcm9ncmVzc01ldGVyID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9DYW52YXNQcm9ncmVzc01ldGVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L1BsYXlUb2dnbGVTeW1ib2x9ICovXG5jb25zdCBQbGF5VG9nZ2xlU3ltYm9sID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9QbGF5VG9nZ2xlU3ltYm9sXCIpO1xuXG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9UaW1lcn0gKi9cbmNvbnN0IFRpbWVyID0gcmVxdWlyZShcInV0aWxzL1RpbWVyXCIpO1xuLy8gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbi8vIHZhciB0cmFuc2l0aW9uRW5kID0gcmVxdWlyZShcInV0aWxzL2V2ZW50L3RyYW5zaXRpb25FbmRcIik7XG4vLyAvKiogQHR5cGUge21vZHVsZTp1dGlscy9wcmVmaXhlZFByb3BlcnR5fSAqL1xuLy8gdmFyIHByZWZpeGVkID0gcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkUHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5jb25zdCBfd2hlbkltYWdlTG9hZHMgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcHJvbWlzZS9fd2hlbkltYWdlTG9hZHNcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvdmlldy9wcm9taXNlL19sb2FkSW1hZ2VBc09iamVjdFVSTH0gKi9cbmNvbnN0IF9sb2FkSW1hZ2VBc09iamVjdFVSTCA9IHJlcXVpcmUoXCJhcHAvdmlldy9wcm9taXNlL19sb2FkSW1hZ2VBc09iamVjdFVSTFwiKTtcbi8vIC8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG4vLyB2YXIgd2hlblNlbGVjdGlvbkRpc3RhbmNlSXMgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcHJvbWlzZS93aGVuU2VsZWN0aW9uRGlzdGFuY2VJc1wiKTtcbi8vIHZhciB3aGVuU2VsZWN0VHJhbnNpdGlvbkVuZHMgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcHJvbWlzZS93aGVuU2VsZWN0VHJhbnNpdGlvbkVuZHNcIik7XG4vLyB2YXIgd2hlbkRlZmF1bHRJbWFnZUxvYWRzID0gcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlbkRlZmF1bHRJbWFnZUxvYWRzXCIpO1xuXG4vLyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuLy8gdmFyIENvbG9yID0gcmVxdWlyZShcImNvbG9yXCIpO1xuLy8gdmFyIGR1b3RvbmUgPSByZXF1aXJlKFwidXRpbHMvY2FudmFzL2JpdG1hcC9kdW90b25lXCIpO1xuLy8gdmFyIHN0YWNrQmx1clJHQiA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvYml0bWFwL3N0YWNrQmx1clJHQlwiKTtcbi8vIHZhciBzdGFja0JsdXJNb25vID0gcmVxdWlyZShcInV0aWxzL2NhbnZhcy9iaXRtYXAvc3RhY2tCbHVyTW9ub1wiKTtcbi8vIHZhciBnZXRBdmVyYWdlUkdCQSA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvYml0bWFwL2dldEF2ZXJhZ2VSR0JBXCIpO1xuXG5jb25zdCBlcnJvclRlbXBsYXRlID0gcmVxdWlyZShcIi4uL3RlbXBsYXRlL0Vycm9yQmxvY2suaGJzXCIpO1xuXG52YXIgTUlOX1NURVBfSU5URVJWQUwgPSAyICogR2xvYmFscy5UUkFOU0lUSU9OX0RVUkFUSU9OICsgR2xvYmFscy5UUkFOU0lUSU9OX0RFTEFZX0lOVEVSVkFMO1xudmFyIERFRkFVTFRfU1RFUF9JTlRFUlZBTCA9IDYgKiBHbG9iYWxzLlRSQU5TSVRJT05fRFVSQVRJT04gKyBHbG9iYWxzLlRSQU5TSVRJT05fREVMQVlfSU5URVJWQUw7XG5cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIFByaXZhdGUgY2xhc3Nlc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAdHlwZSB7bW9kdWxlOmFwcC92aWV3L3JlbmRlci9TZXF1ZW5jZVJlbmRlcmVyLlByZWZldGVjaGVkU291cmNlUmVuZGVyZXJ9XG4gKi9cbnZhciBQcmVmZXRlY2hlZFNvdXJjZVJlbmRlcmVyID0gVmlldy5leHRlbmQoe1xuXG5cdGNpZFByZWZpeDogXCJzZXF1ZW5jZVN0ZXBSZW5kZXJlclwiLFxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2xhc3NOYW1lOiBcInNlcXVlbmNlLXN0ZXBcIixcblx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdHRhZ05hbWU6IFwiaW1nXCIsXG5cblx0cHJvcGVydGllczoge1xuXHRcdHJlYWR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVhZHk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0cykge1xuXHRcdCF0aGlzLmVsLmhhc0F0dHJpYnV0ZShcImFsdFwiKSAmJiB0aGlzLmVsLnNldEF0dHJpYnV0ZShcImFsdFwiLCB0aGlzLm1vZGVsLmdldChcInNyY1wiKSk7XG5cdFx0Ly8gdGhpcy5lbC5zZXRBdHRyaWJ1dGUoXCJsb25nZGVzY1wiLCB0aGlzLm1vZGVsLmdldChcIm9yaWdpbmFsXCIpKTtcblxuXHRcdGlmICh0aGlzLm1vZGVsLmhhcyhcInByZWZldGNoZWRcIikpIHtcblx0XHRcdHRoaXMuX3JlbmRlclByZWZldGNoZWQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcImNoYW5nZTpwcmVmZXRjaGVkXCIsIHRoaXMuX3JlbmRlclByZWZldGNoZWQpO1xuXHRcdH1cblx0XHR0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwic2VsZWN0ZWQgZGVzZWxlY3RlZFwiLCB0aGlzLl9yZW5kZXJTZWxlY3Rpb24pO1xuXHRcdHRoaXMuX3JlbmRlclNlbGVjdGlvbigpO1xuXHR9LFxuXG5cdF9yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZShcImN1cnJlbnRcIiwgISF0aGlzLm1vZGVsLnNlbGVjdGVkKTtcblx0fSxcblxuXHRfcmVuZGVyUHJlZmV0Y2hlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWZldGNoZWQgPSB0aGlzLm1vZGVsLmdldChcInByZWZldGNoZWRcIik7XG5cdFx0aWYgKHByZWZldGNoZWQgIT09IHRoaXMuZWwuc3JjKSB7XG5cdFx0XHR0aGlzLmVsLnNyYyA9IHByZWZldGNoZWQ7XG5cdFx0fVxuXHRcdF93aGVuSW1hZ2VMb2Fkcyh0aGlzLmVsKS50aGVuKFxuXHRcdFx0ZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24odHN0YW1wKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0UmVhZHkodHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fS5iaW5kKHRoaXMpLFxuXHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdC8vIHRoaXMuX3NldFJlYWR5KGZhbHNlKTtcblx0XHRcdFx0KGVyciBpbnN0YW5jZW9mIEVycm9yKSB8fCAoZXJyID0gbmV3IEVycm9yKFwiY2Fubm90IGxvYWQgcHJlZmV0Y2hlZCB1cmxcIikpO1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9LmJpbmQodGhpcylcblx0XHQpO1xuXHR9LFxuXG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0X3JlYWR5OiBmYWxzZSxcblxuXHRfc2V0UmVhZHk6IGZ1bmN0aW9uKHJlYWR5KSB7XG5cdFx0aWYgKHRoaXMuX3JlYWR5ICE9PSByZWFkeSkge1xuXHRcdFx0dGhpcy5fcmVhZHkgPSAhIShyZWFkeSk7IC8vIG1ha2UgYm9vbFxuXHRcdFx0dGhpcy50cmlnZ2VyKFwicmVuZGVyZXI6cmVhZHlcIiwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaWYgKHRoaXMubW9kZWwuaGFzKFwicHJlZmV0Y2hlZFwiKSkge1xuXHRcdC8vIFx0dGhpcy5fcmVuZGVyUHJlZmV0Y2hlZCgpO1xuXHRcdC8vIH1cblx0XHQvLyB0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJjdXJyZW50XCIsICEhdGhpcy5tb2RlbC5zZWxlY3RlZCk7XG5cdFx0Y29uc29sZS5sb2coXCIlczo6cmVuZGVyXCIsIHRoaXMuY2lkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcbn0pO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHR5cGUge21vZHVsZTphcHAvdmlldy9yZW5kZXIvU2VxdWVuY2VSZW5kZXJlci5TaW1wbGVTb3VyY2VSZW5kZXJlcn1cbiAqL1xuLy8gdmFyIFNpbXBsZVNvdXJjZVJlbmRlcmVyID0gVmlldy5leHRlbmQoe1xuLy9cbi8vIFx0Y2lkUHJlZml4OiBcInNlcXVlbmNlU3RlcFJlbmRlcmVyXCIsXG4vLyBcdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuLy8gXHRjbGFzc05hbWU6IFwic2VxdWVuY2Utc3RlcFwiLFxuLy8gXHQvKiogQHR5cGUge3N0cmluZ30gKi9cbi8vIFx0dGFnTmFtZTogXCJpbWdcIixcbi8vXG4vLyBcdC8qKiBAb3ZlcnJpZGUgKi9cbi8vIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbi8vIFx0XHQvLyB0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJjdXJyZW50XCIsIHRoaXMubW9kZWwuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSk7XG4vLyBcdFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiY3VycmVudFwiLCAhIXRoaXMubW9kZWwuc2VsZWN0ZWQpO1xuLy8gXHRcdHRoaXMubGlzdGVuVG8odGhpcy5tb2RlbCwge1xuLy8gXHRcdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiAoKSB7XG4vLyBcdFx0XHRcdHRoaXMuZWwuY2xhc3NMaXN0LmFkZChcImN1cnJlbnRcIik7XG4vLyBcdFx0XHR9LFxuLy8gXHRcdFx0XCJkZXNlbGVjdGVkXCI6IGZ1bmN0aW9uICgpIHtcbi8vIFx0XHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiY3VycmVudFwiKTtcbi8vIFx0XHRcdH1cbi8vIFx0XHR9KTtcbi8vIFx0XHRpZiAodGhpcy5lbC5zcmMgPT09IFwiXCIpIHtcbi8vIFx0XHRcdHRoaXMuZWwuc3JjID0gR2xvYmFscy5NRURJQV9ESVIgKyBcIi9cIiArIHRoaXMubW9kZWwuZ2V0KFwic3JjXCIpO1xuLy8gXHRcdH1cbi8vXG4vLyBcdFx0aWYgKHRoaXMubW9kZWwuaGFzKFwiZXJyb3JcIikpIHtcbi8vIFx0XHRcdHRoaXMuX29uTW9kZWxFcnJvcigpO1xuLy8gXHRcdH0gZWxzZSB7XG4vLyBcdFx0XHR0aGlzLmxpc3RlblRvT25jZSh0aGlzLm1vZGVsLCBcImNoYW5nZTplcnJvclwiLCB0aGlzLl9vbk1vZGVsRXJyb3IpO1xuLy8gXHRcdFx0Ly8gdGhpcy5saXN0ZW5Ub09uY2UodGhpcy5tb2RlbCwge1xuLy8gXHRcdFx0Ly8gXHRcImNoYW5nZTpzb3VyY2VcIjogdGhpcy5fb25Nb2RlbFNvdXJjZSxcbi8vIFx0XHRcdC8vIFx0XCJjaGFuZ2U6ZXJyb3JcIjogdGhpcy5fb25Nb2RlbEVycm9yLFxuLy8gXHRcdFx0Ly8gfSk7XG4vLyBcdFx0fVxuLy8gXHR9LFxuLy9cbi8vIFx0Ly8gX29uTW9kZWxTb3VyY2U6IGZ1bmN0aW9uKCkge1xuLy8gXHQvLyBcdHRoaXMuZWwuc3JjID0gR2xvYmFscy5NRURJQV9ESVIgKyBcIi9cIiArIHRoaXMubW9kZWwuZ2V0KFwic3JjXCIpO1xuLy8gXHQvLyBcdC8vIGNvbnNvbGUubG9nKFwiJXM6OmNoYW5nZTpzcmNcIiwgdGhpcy5jaWQsIHRoaXMubW9kZWwuZ2V0KFwic3JjXCIpKTtcbi8vIFx0Ly8gfSxcbi8vXG4vLyBcdF9vbk1vZGVsRXJyb3I6IGZ1bmN0aW9uKCkge1xuLy8gXHRcdHZhciBlcnIgPSB0aGlzLm1vZGVsLmdldChcImVycm9yXCIpO1xuLy8gXHRcdHZhciBlcnJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4vLyBcdFx0ZXJyRWwuY2xhc3NOYW1lID0gXCJlcnJvciBjb2xvci1iZ1wiICsgKHRoaXMubW9kZWwuc2VsZWN0ZWQ/IFwiIGN1cnJlbnRcIiA6IFwiXCIpO1xuLy8gXHRcdGVyckVsLmlubmVySFRNTCA9IGVycm9yVGVtcGxhdGUoZXJyKTtcbi8vIFx0XHR0aGlzLnNldEVsZW1lbnQoZXJyRWwsIHRydWUpO1xuLy8gXHRcdGNvbnNvbGUubG9nKFwiJXM6OmNoYW5nZTplcnJvclwiLCB0aGlzLmNpZCwgZXJyLm1lc3NhZ2UsIGVyci5pbmZvU3JjKTtcbi8vIFx0fSxcbi8vIH0pO1xuXG52YXIgU291cmNlRXJyb3JSZW5kZXJlciA9IFZpZXcuZXh0ZW5kKHtcblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2xhc3NOYW1lOiBcInNlcXVlbmNlLXN0ZXAgZXJyb3JcIixcblx0LyoqIEBvdmVycmlkZSAqL1xuXHRjaWRQcmVmaXg6IFwic291cmNlRXJyb3JSZW5kZXJlclwiLFxuXHQvKiogQG92ZXJyaWRlICovXG5cdHRlbXBsYXRlOiBlcnJvclRlbXBsYXRlLFxuXHQvKiogQHR5cGUge2Jvb2xlYW59ICovXG5cdHJlYWR5OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHQvLyB2YXIgaGFuZGxlU2VsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25TZWxlY3Rpb25DaGFuZ2UgKCkge1xuXHRcdC8vIFx0dGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKFwiY3VycmVudFwiLCAhIXRoaXMubW9kZWwuc2VsZWN0ZWQpO1xuXHRcdC8vIH07XG5cdFx0Ly8gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInNlbGVjdGVkIGRlc2VsZWN0ZWRcIiwgaGFuZGxlU2VsZWN0aW9uQ2hhbmdlKTtcblx0XHQvLyAvLyB0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJjdXJyZW50XCIsICEhdGhpcy5tb2RlbC5zZWxlY3RlZCk7XG5cdFx0Ly8gaGFuZGxlU2VsZWN0aW9uQ2hhbmdlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcInNlbGVjdGVkIGRlc2VsZWN0ZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJjdXJyZW50XCIsICEhdGhpcy5tb2RlbC5zZWxlY3RlZCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoXCJjdXJyZW50XCIsICEhdGhpcy5tb2RlbC5zZWxlY3RlZCk7XG5cdFx0dGhpcy5lbC5pbm5lckhUTUwgPSB0aGlzLnRlbXBsYXRlKHRoaXMubW9kZWwuZ2V0KFwiZXJyb3JcIikpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxufSk7XG5cbnZhciBTZXF1ZW5jZVN0ZXBSZW5kZXJlciA9IFByZWZldGVjaGVkU291cmNlUmVuZGVyZXI7XG4vLyB2YXIgU2VxdWVuY2VTdGVwUmVuZGVyZXIgPSBTaW1wbGVTb3VyY2VSZW5kZXJlcjtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL1NlcXVlbmNlUmVuZGVyZXJ9XG4gKi9cbnZhciBTZXF1ZW5jZVJlbmRlcmVyID0gUGxheWFibGVSZW5kZXJlci5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwic2VxdWVuY2VSZW5kZXJlclwiLFxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2xhc3NOYW1lOiBQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5jbGFzc05hbWUgKyBcIiBzZXF1ZW5jZS1pdGVtXCIsXG5cdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5cdHRlbXBsYXRlOiByZXF1aXJlKFwiLi9TZXF1ZW5jZVJlbmRlcmVyLmhic1wiKSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBpbml0aWFsaXplXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHR0aGlzLnNvdXJjZXMgPSB0aGlzLm1vZGVsLmdldChcInNvdXJjZXNcIik7XG5cdFx0UGxheWFibGVSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIGNoaWxkcmVuXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y3JlYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNoaWxkcmVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR0aGlzLnBsYWNlaG9sZGVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLnBsYWNlaG9sZGVyXCIpO1xuXHRcdHRoaXMuc2VxdWVuY2UgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5zZXF1ZW5jZVwiKTtcblxuXHRcdC8vIHN0eWxlc1xuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHZhciBzLCBhdHRycyA9IHRoaXMubW9kZWwuYXR0cnMoKTtcblx0XHQvLyB2YXIgcywgYXR0cnMgPSB0aGlzLm1vZGVsLmdldChcImF0dHJzXCIpO1xuXHRcdHMgPSBfLnBpY2soYXR0cnMsIFwiYm94LXNoYWRvd1wiLCBcImJvcmRlclwiLCBcImJvcmRlci1yYWRpdXNcIik7XG5cdFx0Xy5leHRlbmQodGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIubWVkaWEtYm9yZGVyXCIpLnN0eWxlLCBzKTtcblx0XHRzID0gXy5waWNrKGF0dHJzLCBcImJvcmRlci1yYWRpdXNcIik7XG5cdFx0Xy5leHRlbmQodGhpcy5zZXF1ZW5jZS5zdHlsZSwgcyk7XG5cdFx0Xy5leHRlbmQodGhpcy5wbGFjZWhvbGRlci5zdHlsZSwgcyk7XG5cblx0XHQvLyBtb2RlbFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHRoaXMuc291cmNlcy5zZWxlY3QodGhpcy5tb2RlbC5nZXQoXCJzb3VyY2VcIikpO1xuXG5cdFx0Ly8gaXRlbVZpZXdzXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0dGhpcy5pdGVtVmlld3MgPSBuZXcgQ29udGFpbmVyKCk7XG5cdFx0Ly8gYWRkIGRlZmF1bHQgaW1hZ2UgYXMgcmVuZGVyZXIgKGFscmVhZHkgaW4gRE9NKVxuXHRcdHRoaXMuaXRlbVZpZXdzLmFkZChuZXcgU2VxdWVuY2VTdGVwUmVuZGVyZXIoe1xuXHRcdFx0ZWw6IHRoaXMuZ2V0RGVmYXVsdEltYWdlKCksXG5cdFx0XHRtb2RlbDogdGhpcy5tb2RlbC5nZXQoXCJzb3VyY2VcIilcblx0XHR9KSk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogbGF5b3V0L3JlbmRlclxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0UGxheWFibGVSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgZWxzLCBlbCwgaSwgY3NzVywgY3NzSDtcblx0XHR2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcblxuXHRcdC8vIG1lZGlhLXNpemVcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRjc3NXID0gdGhpcy5tZXRyaWNzLm1lZGlhLndpZHRoICsgXCJweFwiO1xuXHRcdGNzc0ggPSB0aGlzLm1ldHJpY3MubWVkaWEuaGVpZ2h0ICsgXCJweFwiO1xuXG5cdFx0ZWxzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKFwiLm1lZGlhLXNpemVcIik7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZWwgPSBlbHMuaXRlbShpKTtcblx0XHRcdGVsLnN0eWxlLndpZHRoID0gY3NzVztcblx0XHRcdGVsLnN0eWxlLmhlaWdodCA9IGNzc0g7XG5cdFx0fVxuXHRcdGNvbnRlbnQuc3R5bGUud2lkdGggPSBjc3NXO1xuXHRcdGNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gY3NzSDtcblxuXHRcdC8vIGNvbnRlbnQtcG9zaXRpb25cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR2YXIgY3NzWCwgY3NzWTtcblx0XHRjc3NYID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQueCArIFwicHhcIjtcblx0XHRjc3NZID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQueSArIFwicHhcIjtcblx0XHRjb250ZW50LnN0eWxlLmxlZnQgPSBjc3NYO1xuXHRcdGNvbnRlbnQuc3R5bGUudG9wID0gY3NzWTtcblxuXHRcdGVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRyb2xzXCIpO1xuXHRcdC8vIGVsLnN0eWxlLmxlZnQgPSBjc3NYO1xuXHRcdC8vIGVsLnN0eWxlLnRvcCA9IGNzc1k7XG5cdFx0ZWwuc3R5bGUud2lkdGggPSB0aGlzLm1ldHJpY3MuY29udGVudC53aWR0aCArIFwicHhcIjtcblx0XHRlbC5zdHlsZS5oZWlnaHQgPSB0aGlzLm1ldHJpY3MuY29udGVudC5oZWlnaHQgKyBcInB4XCI7XG5cblx0XHQvLyAvLyBjb250ZW50LXNpemVcblx0XHQvLyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyBjc3NXID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQud2lkdGggKyBcInB4XCI7XG5cdFx0Ly8gY3NzSCA9IHRoaXMubWV0cmljcy5jb250ZW50LmhlaWdodCArIFwicHhcIjtcblx0XHQvL1xuXHRcdC8vIGVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcIi5jb250ZW50LXNpemVcIik7XG5cdFx0Ly8gZm9yIChpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuXHRcdC8vIFx0ZWwgPSBlbHMuaXRlbShpKTtcblx0XHQvLyBcdGVsLnN0eWxlLndpZHRoID0gY3NzVztcblx0XHQvLyBcdGVsLnN0eWxlLmhlaWdodCA9IGNzc0g7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogaW5pdGlhbGl6ZUFzeW5jXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGluaXRpYWxpemVQbGF5YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gbW9kZWxcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyB0aGlzLnNvdXJjZXMuc2VsZWN0KHRoaXMubW9kZWwuZ2V0KFwic291cmNlXCIpKTtcblx0XHR0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmFkZChcInN0YXJ0ZWRcIik7XG5cblx0XHQvLyBTZXF1ZW5jZSBtb2RlbFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFBsYXlhYmxlUmVuZGVyZXIud2hlblNlbGVjdGlvbkRpc3RhbmNlSXModGhpcywgMClcblx0XHRcdC8vIC50aGVuKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdC8vIFx0LyogZGVmYXVsdEltYWdlIGlzIGxvYWRlZCwgYWRkIGBzdGFydGVkYCByaWdodGF3YXkgKi9cblx0XHRcdC8vIFx0dmlldy5jb250ZW50LmNsYXNzTGlzdC5hZGQoXCJzdGFydGVkXCIpO1xuXHRcdFx0Ly8gXHRyZXR1cm4gdmlldztcblx0XHRcdC8vIH0pXG5cdFx0XHQudGhlbih0aGlzLl9wcmVsb2FkQWxsSXRlbXMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRyZXR1cm4gKGVyciBpbnN0YW5jZW9mIFZpZXcuVmlld0Vycm9yKSA/ICh2b2lkIDApIDogZXJyOyAvLyBJZ25vcmUgVmlld0Vycm9yXG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuX3NlcXVlbmNlSW50ZXJ2YWwgPSBNYXRoLm1heChwYXJzZUludCh0aGlzLm1vZGVsLmF0dHIoXCJAc2VxdWVuY2UtaW50ZXJ2YWxcIikpLCBNSU5fU1RFUF9JTlRFUlZBTCkgfHwgREVGQVVMVF9TVEVQX0lOVEVSVkFMO1xuXG5cdFx0Ly8gdGltZXJcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvKiB0aW1lciB3aWxsIGJlIHN0YXJ0ZWQgd2hlbiBfdmFsaWRhdGVQbGF5YmFjayBpcyBjYWxsZWQgZnJvbSBfb25Nb2RlbFNlbGVjdGVkICovXG5cdFx0dGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xuXHRcdHRoaXMubGlzdGVuVG8odGhpcywgXCJ2aWV3OnJlbW92ZWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnRpbWVyLnN0b3AoKTtcblx0XHRcdHRoaXMuc3RvcExpc3RlbmluZyh0aGlzLnRpbWVyKTtcblx0XHR9KTtcblxuXHRcdHRoaXMubGlzdGVuVG8odGhpcy50aW1lciwge1xuXHRcdFx0XCJzdGFydFwiOiB0aGlzLl9vblRpbWVyU3RhcnQsXG5cdFx0XHRcInJlc3VtZVwiOiB0aGlzLl9vblRpbWVyUmVzdW1lLFxuXHRcdFx0XCJwYXVzZVwiOiB0aGlzLl9vblRpbWVyUGF1c2UsXG5cdFx0XHRcImVuZFwiOiB0aGlzLl9vblRpbWVyRW5kLFxuXHRcdFx0Ly8gXCJzdG9wXCI6IGZ1bmN0aW9uICgpIHt9LCAvLyBzdG9wIGlzIG9ubHkgY2FsbGVkIG9uIHZpZXcgcmVtb3ZlXG5cdFx0fSk7XG5cblx0XHQvLyBwbGF5LXRvZ2dsZS1zeW1ib2xcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sID0gbmV3IFBsYXlUb2dnbGVTeW1ib2woXy5leHRlbmQoe1xuXHRcdFx0ZWw6IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5wbGF5LXRvZ2dsZVwiKVxuXHRcdH0sIHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wgfHwge30pKTtcblxuXHRcdC8vIHByb2dyZXNzLW1ldGVyIG1vZGVsXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0dGhpcy5fc291cmNlUHJvZ3Jlc3NCeUlkeCA9IHRoaXMuc291cmNlcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9KTtcblx0XHR0aGlzLl9zb3VyY2VQcm9ncmVzc0J5SWR4WzBdID0gMTsgLy8gZmlyc3QgaXRlbSBpcyBhbHJlYWR5IGxvYWRlZFxuXG5cdFx0Ly8gcHJvZ3Jlc3MtbWV0ZXJcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR0aGlzLnByb2dyZXNzTWV0ZXIgPSBuZXcgUHJvZ3Jlc3NNZXRlcih7XG5cdFx0XHRlbDogdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLnByb2dyZXNzLW1ldGVyXCIpLFxuXHRcdFx0Y29sb3I6IHRoaXMubW9kZWwuYXR0cihcImNvbG9yXCIpLFxuXHRcdFx0Ly8gYmFja2dyb3VuZENvbG9yOiB0aGlzLm1vZGVsLmF0dHIoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpLFxuXHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdGF2YWlsYWJsZTogdGhpcy5fc291cmNlUHJvZ3Jlc3NCeUlkeC5jb25jYXQoKSxcblx0XHRcdH0sXG5cdFx0XHRtYXhWYWx1ZXM6IHtcblx0XHRcdFx0YW1vdW50OiB0aGlzLnNvdXJjZXMubGVuZ3RoLFxuXHRcdFx0XHRhdmFpbGFibGU6IHRoaXMuc291cmNlcy5sZW5ndGgsXG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxGbjogKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5wbGF5YmFja1JlcXVlc3RlZCA9PT0gZmFsc2UpIHJldHVybiBHbG9iYWxzLlBBVVNFX0NIQVI7XG5cdFx0XHRcdHJldHVybiAodGhpcy5zb3VyY2VzLnNlbGVjdGVkSW5kZXggKyAxKSArIFwiL1wiICsgdGhpcy5zb3VyY2VzLmxlbmd0aDtcblx0XHRcdH0pLmJpbmQodGhpcylcblx0XHR9KTtcblx0XHQvLyB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIudG9wLWJhclwiKVxuXHRcdC8vXHRcdC5hcHBlbmRDaGlsZCh0aGlzLnByb2dyZXNzTWV0ZXIucmVuZGVyKCkuZWwpO1xuXHR9LFxuXG5cdGluaXRpYWxpemVBc3luYzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemVBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdFx0XHQudGhlbihcblx0XHRcdFx0ZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHRcdHJldHVybiB2aWV3LndoZW5BdHRhY2hlZCgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0LnRoZW4oZnVuY3Rpb24odmlldykge1xuXHRcdFx0XHR2aWV3LmluaXRpYWxpemVQbGF5YWJsZSgpO1xuXHRcdFx0XHQvLyB2aWV3LnVwZGF0ZU92ZXJsYXkodmlldy5kZWZhdWx0SW1hZ2UsIHZpZXcucGxheVRvZ2dsZSk7IC8vdmlldy5vdmVybGF5KTtcblx0XHRcdFx0dmlldy5saXN0ZW5Ub1NlbGVjdGlvbigpO1xuXHRcdFx0XHRyZXR1cm4gdmlldztcblx0XHRcdH0pO1xuXHR9LFxuXG5cdHdoZW5Jbml0aWFsaXplZDogZnVuY3Rpb24odmlldykge1xuXHRcdHZhciByZXR2YWwgPSBQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS53aGVuSW5pdGlhbGl6ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR2aWV3Ll92YWxpZGF0ZVBsYXliYWNrKCk7XG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiBfcHJlbG9hZEFsbEl0ZW1zXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF9wcmVsb2FkQWxsSXRlbXM6IGZ1bmN0aW9uKHZpZXcpIHtcblx0XHR2aWV3Lm9uY2UoXCJ2aWV3OnJlbW92ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzaWxlbnQgPSB7IHNpbGVudDogdHJ1ZSB9O1xuXHRcdFx0dmlldy5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgsIHNvdXJjZXMpIHtcblx0XHRcdFx0Ly8gdmlldy5zdG9wTGlzdGVuaW5nKGl0ZW0sIFwiY2hhbmdlOnByb2dyZXNzXCIpO1xuXHRcdFx0XHR2YXIgcHJlZmV0Y2hlZCA9IGl0ZW0uZ2V0KFwicHJlZmV0Y2hlZFwiKTtcblx0XHRcdFx0aWYgKHByZWZldGNoZWQgJiYgL15ibG9iXFw6Ly50ZXN0KHByZWZldGNoZWQpKSB7XG5cdFx0XHRcdFx0aXRlbS5zZXQoXCJwcm9ncmVzc1wiLCAwLCBzaWxlbnQpO1xuXHRcdFx0XHRcdGl0ZW0udW5zZXQoXCJwcmVmZXRjaGVkXCIsIHNpbGVudCk7XG5cdFx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChwcmVmZXRjaGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHZpZXcuc291cmNlcy5yZWR1Y2UoZnVuY3Rpb24obGFzdFByb21pc2UsIGl0ZW0sIGluZGV4LCBzb3VyY2VzKSB7XG5cdFx0XHRyZXR1cm4gbGFzdFByb21pc2UudGhlbihmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRcdGlmICh2aWV3Ll92aWV3UGhhc2UgPT09IFwiZGlzcG9zZWRcIikge1xuXHRcdFx0XHRcdC8qKiBkbyBub3RoaW5nICovXG5cdFx0XHRcdFx0cmV0dXJuIHZpZXc7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRpZiAoaXRlbS5oYXMoXCJwcmVmZXRjaGVkXCIpKSB7XG5cdFx0XHRcdFx0dmlldy5fdXBkYXRlSXRlbVByb2dyZXNzKDEsIGluZGV4KTtcblx0XHRcdFx0XHRyZXR1cm4gdmlldztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgb25JdGVtUHJvZ3Jlc3MgPSBmdW5jdGlvbihpdGVtLCBwcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0dmlldy5fdXBkYXRlSXRlbVByb2dyZXNzKHByb2dyZXNzLCBpbmRleCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR2aWV3Lmxpc3RlblRvKGl0ZW0sIFwiY2hhbmdlOnByb2dyZXNzXCIsIG9uSXRlbVByb2dyZXNzKTtcblx0XHRcdFx0XHR2aWV3Lm9uY2UoXCJ2aWV3OnJlbW92ZVwiLCBmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRcdFx0XHR2aWV3LnN0b3BMaXN0ZW5pbmcoaXRlbSwgXCJjaGFuZ2U6cHJvZ3Jlc3NcIiwgb25JdGVtUHJvZ3Jlc3MpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBfbG9hZEltYWdlQXNPYmplY3RVUkwoaXRlbS5nZXQoXCJvcmlnaW5hbFwiKSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24ocHJvZ3Jlc3MsIHJlcXVlc3QpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBOT1RFOiBTaW5jZSB3ZSBhcmUgY2FsbGluZyBVUkwucmV2b2tlT2JqZWN0VVJMIHdoZW4gdmlldyBpcyByZW1vdmVkLCBhbHNvIGFib3J0IGluY29tcGxldGUgcmVxdWVzdHMuIE90aGVyd2lzZSwgY2xlYXIgdGhlIGNhbGxiYWNrIHJlZmVyZW5jZSBmcm9tIFhNTEh0dHBSZXF1ZXN0Lm9ucHJvZ3Jlc3MgICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZpZXcuX3ZpZXdQaGFzZSA9PT0gXCJkaXNwb3NlZFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvL2NvbnNvbGUud2FybihcIiVzOjpfcHJlbG9hZEFsbEl0ZW1zIGFib3J0aW5nIFhIUiBbJXMgJXNdICglcylcIiwgdmlldy5jaWQsIHJlcXVlc3Quc3RhdHVzLCByZXF1ZXN0LnJlYWR5U3RhdGUsIGl0ZW0uZ2V0KFwib3JpZ2luYWxcIiksIHJlcXVlc3QpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdC5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVxdWVzdC5vbnByb2dyZXNzID0gdm9pZCAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVtLnNldChcInByb2dyZXNzXCIsIHByb2dyZXNzKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQudGhlbihcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24ocFVybCkge1xuXHRcdFx0XHRcdFx0XHRcdGl0ZW0uc2V0KHtcblx0XHRcdFx0XHRcdFx0XHRcdFwicHJvZ3Jlc3NcIjogcFVybCA/IDEgOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJwcmVmZXRjaGVkXCI6IHBVcmxcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlldztcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXRlbS5zZXQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJwcm9ncmVzc1wiOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJlcnJvclwiOiBlcnJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlldztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSwgUHJvbWlzZS5yZXNvbHZlKHZpZXcpKTtcblx0fSxcblxuXHQvLyBfcHJlbG9hZEFsbEl0ZW1zMjogZnVuY3Rpb24odmlldykge1xuXHQvLyBcdHJldHVybiB2aWV3LnNvdXJjZXMucmVkdWNlKGZ1bmN0aW9uKGxhc3RQcm9taXNlLCBpdGVtLCBpbmRleCwgc291cmNlcykge1xuXHQvLyBcdFx0cmV0dXJuIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24odmlldykge1xuXHQvLyBcdFx0XHR2YXIgaXRlbVZpZXcgPSB2aWV3Ll9nZXRJdGVtVmlldyhpdGVtKTtcblx0Ly8gXHRcdFx0cmV0dXJuIF93aGVuSW1hZ2VMb2FkcyhpdGVtVmlldy5lbCkudGhlbihmdW5jdGlvbih1cmwpe1xuXHQvLyBcdFx0XHRcdHZpZXcuX3VwZGF0ZUl0ZW1Qcm9ncmVzcygxLCBpbmRleCk7XG5cdC8vIFx0XHRcdFx0cmV0dXJuIHZpZXc7XG5cdC8vIFx0XHRcdH0sIGZ1bmN0aW9uKGVycikge1xuXHQvLyBcdFx0XHRcdHZpZXcuX3VwZGF0ZUl0ZW1Qcm9ncmVzcygwLCBpbmRleCk7XG5cdC8vIFx0XHRcdFx0aXRlbS5zZXQoXCJlcnJvclwiLCBlcnIpO1xuXHQvLyBcdFx0XHRcdHJldHVybiB2aWV3O1xuXHQvLyBcdFx0XHR9KTtcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH0sIFByb21pc2UucmVzb2x2ZSh2aWV3KSk7XG5cdC8vIH0sXG5cblx0X3VwZGF0ZUl0ZW1Qcm9ncmVzczogZnVuY3Rpb24ocHJvZ3Jlc3MsIGluZGV4KSB7XG5cdFx0dGhpcy5fc291cmNlUHJvZ3Jlc3NCeUlkeFtpbmRleF0gPSBwcm9ncmVzcztcblx0XHRpZiAodGhpcy5wcm9ncmVzc01ldGVyKSB7XG5cdFx0XHR0aGlzLnByb2dyZXNzTWV0ZXIudmFsdWVUbyhcImF2YWlsYWJsZVwiLCB0aGlzLl9zb3VyY2VQcm9ncmVzc0J5SWR4LCAzMDApO1xuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogUGxheWFibGVSZW5kZXJlciBpbXBsZW1lbnRhdGlvblxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiogQG92ZXJyaWRlIGluaXRpYWwgdmFsdWUgKi9cblx0X3BsYXliYWNrUmVxdWVzdGVkOiB0cnVlLFxuXG5cdC8qKiBAdHlwZSB7Qm9vbGVhbn0gaW50ZXJuYWwgc3RvcmUgKi9cblx0X3BhdXNlZDogdHJ1ZSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdF9pc01lZGlhUGF1c2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHR9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0X3BsYXlNZWRpYTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQpIHJldHVybjtcblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdGlmICghdGhpcy5faXNNZWRpYVdhaXRpbmcoKSkge1xuXHRcdFx0aWYgKHRoaXMudGltZXIuc3RhdHVzID09PSBUaW1lci5QQVVTRUQpIHtcblx0XHRcdFx0dGhpcy50aW1lci5zdGFydCgpOyAvLyByZXN1bWUsIGFjdHVhbGx5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRpbWVyLnN0YXJ0KHRoaXMuX3NlcXVlbmNlSW50ZXJ2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdF9wYXVzZU1lZGlhOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSByZXR1cm47XG5cdFx0dGhpcy5fcGF1c2VkID0gdHJ1ZTtcblx0XHRpZiAodGhpcy50aW1lci5zdGF0dXMgPT09IFRpbWVyLlNUQVJURUQpIHtcblx0XHRcdHRoaXMudGltZXIucGF1c2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gLyoqIEBvdmVycmlkZSAqL1xuXHQvLyBfcmVuZGVyUGxheWJhY2tTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdC8vIFx0Ly8gaWYgKCF0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic3RhcnRlZFwiKSkge1xuXHQvLyBcdC8vIFx0dGhpcy5jb250ZW50LmNsYXNzTGlzdC5hZGQoXCJzdGFydGVkXCIpO1xuXHQvLyBcdC8vIH1cblx0Ly8gXHRQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyUGxheWJhY2tTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQvLyB9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdC8qIHNlcXVlbmNlIHByaXZhdGVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uVGltZXJTdGFydDogZnVuY3Rpb24oZHVyYXRpb24pIHtcblx0XHR2YXIgaXRlbTtcblx0XHRpZiAodGhpcy5zb3VyY2VzLnNlbGVjdGVkSW5kZXggPT09IC0xKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5tb2RlbC5nZXQoXCJzb3VyY2VcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW0gPSB0aGlzLnNvdXJjZXMuZm9sbG93aW5nT3JGaXJzdCgpO1xuXHRcdH1cblx0XHR0aGlzLnNvdXJjZXMuc2VsZWN0KGl0ZW0pO1xuXHRcdHRoaXMucHJvZ3Jlc3NNZXRlci52YWx1ZVRvKFwiYW1vdW50XCIsIHRoaXMuc291cmNlcy5zZWxlY3RlZEluZGV4ICsgMSwgZHVyYXRpb24pO1xuXHRcdHRoaXMuY29udGVudC5jbGFzc0xpc3QudG9nZ2xlKFwicGxheWJhY2stZXJyb3JcIiwgaXRlbS5oYXMoXCJlcnJvclwiKSk7XG5cblx0XHQvLyB2YXIgY3VyclZpZXcgPSB0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChpdGVtKTtcblx0XHQvLyBpZiAoIWl0ZW0uaGFzKFwiZXJyb3JcIikgJiYgY3VyclZpZXcgIT09IG51bGwpIHtcblx0XHQvLyBcdHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wuc2V0SW1hZ2VTb3VyY2UoY3VyclZpZXcuZWwpO1xuXHRcdC8vIFx0Ly8gdGhpcy51cGRhdGVPdmVybGF5KGN1cnJWaWV3LmVsLCB0aGlzLnBsYXlUb2dnbGUpO1xuXHRcdC8vIH0gZWxzZSB7XG5cdFx0Ly8gXHR0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sLnNldEltYWdlU291cmNlKG51bGwpO1xuXHRcdC8vIH1cblxuXHRcdC8vIC8vIGluaXQgbmV4dCByZW5kZXJlciBub3cgdG8gaGF2ZSBzbW9vdGhlciB0cmFuc2l0aW9uc1xuXHRcdC8vIHRoaXMuX2dldEl0ZW1WaWV3KHRoaXMuc291cmNlcy5mb2xsb3dpbmdPckZpcnN0KCkpO1xuXHR9LFxuXG5cdF9vblRpbWVyUmVzdW1lOiBmdW5jdGlvbihkdXJhdGlvbikge1xuXHRcdHRoaXMucHJvZ3Jlc3NNZXRlci52YWx1ZVRvKFwiYW1vdW50XCIsIHRoaXMuc291cmNlcy5zZWxlY3RlZEluZGV4ICsgMSwgZHVyYXRpb24pO1xuXHR9LFxuXG5cdF9vblRpbWVyUGF1c2U6IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG5cdFx0dGhpcy5wcm9ncmVzc01ldGVyLnZhbHVlVG8oXCJhbW91bnRcIiwgdGhpcy5wcm9ncmVzc01ldGVyLmdldFJlbmRlcmVkVmFsdWUoXCJhbW91bnRcIiksIDApO1xuXHR9LFxuXG5cdC8qIGxhc3QgY29tcGxldGVseSBwbGF5ZWQgc2VxdWVuY2UgaW5kZXggKi9cblx0Ly8gX2xhc3RQbGF5ZWRJbmRleDogLTEsXG5cblx0X29uVGltZXJFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXh0SXRlbSwgbmV4dFZpZXc7XG5cblx0XHR2YXIgc2hvd05leHRWaWV3ID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjpzaG93TmV4dFZpZXcgJXNtcyAlc1wiLCBjb250ZXh0LmNpZCwgY29udGV4dC5fc2VxdWVuY2VJbnRlcnZhbCwgbmV4dEl0ZW0uY2lkKVxuXHRcdFx0dGhpcy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghdGhpcy5tZWRpYVBhdXNlZCkge1xuXHRcdFx0XHRcdHRoaXMudGltZXIuc3RhcnQodGhpcy5fc2VxdWVuY2VJbnRlcnZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LmJpbmQodGhpcyk7XG5cblx0XHQvLyBnZXQgbmV4dCBpdGVtIGluaXQgbmV4dCByZW5kZXJlclxuXHRcdG5leHRJdGVtID0gdGhpcy5zb3VyY2VzLmZvbGxvd2luZ09yRmlyc3QoKTtcblx0XHRuZXh0VmlldyA9IHRoaXMuX2dldEl0ZW1WaWV3KG5leHRJdGVtKTtcblxuXHRcdGlmIChuZXh0SXRlbS5oYXMoXCJlcnJvclwiKSkge1xuXHRcdFx0c2hvd05leHRWaWV3KCk7XG5cdFx0fSBlbHNlIGlmIChuZXh0SXRlbS5oYXMoXCJwcmVmZXRjaGVkXCIpKSB7XG5cdFx0XHRfd2hlbkltYWdlTG9hZHMobmV4dFZpZXcuZWwpLnRoZW4oc2hvd05leHRWaWV3LCBzaG93TmV4dFZpZXcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBUT0RPOiBhZGQgZ2EgZXZlbnQgJ21lZGlhLXdhaXRpbmcnICovXG5cdFx0XHQvLyB3aW5kb3cuZ2EoXCJzZW5kXCIsIFwiZXZlbnRcIiwgXCJzZXF1ZW5jZS1pdGVtXCIsIFwid2FpdGluZ1wiLCB0aGlzLm1vZGVsLmdldChcInRleHRcIikpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczpbd2FpdGluZ10gJXNtcyAlc1wiLCBjb250ZXh0LmNpZCwgbmV4dEl0ZW0uY2lkKTtcblx0XHRcdHRoaXMuX3RvZ2dsZVdhaXRpbmcodHJ1ZSk7XG5cdFx0XHR0aGlzLmxpc3RlblRvT25jZShuZXh0SXRlbSwgXCJjaGFuZ2U6cHJlZmV0Y2hlZCBjaGFuZ2U6ZXJyb3JcIiwgZnVuY3Rpb24obW9kZWwpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczpbcGxheWluZ10gJXNtcyAlc1wiLCBjb250ZXh0LmNpZCwgbmV4dEl0ZW0uY2lkKTtcblx0XHRcdFx0dGhpcy5fdG9nZ2xlV2FpdGluZyhmYWxzZSk7XG5cdFx0XHRcdF93aGVuSW1hZ2VMb2FkcyhuZXh0Vmlldy5lbCkudGhlbihzaG93TmV4dFZpZXcsIHNob3dOZXh0Vmlldyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X2dldEl0ZW1WaWV3OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLml0ZW1WaWV3cy5maW5kQnlNb2RlbChpdGVtKTtcblx0XHRpZiAoIXZpZXcpIHtcblx0XHRcdHZpZXcgPSBuZXcoaXRlbS5oYXMoXCJlcnJvclwiKSA/IFNvdXJjZUVycm9yUmVuZGVyZXIgOiBTZXF1ZW5jZVN0ZXBSZW5kZXJlcikoe1xuXHRcdFx0XHRtb2RlbDogaXRlbVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLml0ZW1WaWV3cy5hZGQodmlldyk7XG5cdFx0XHR0aGlzLnNlcXVlbmNlLmFwcGVuZENoaWxkKHZpZXcucmVuZGVyKCkuZWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmlldztcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQvKiBwcm9ncmVzcyBtZXRlclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBfY3JlYXRlRGVmYXVsdEl0ZW1EYXRhOiBmdW5jdGlvbigpIHtcblx0Ly8gXHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0Ly8gXHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdC8vIFx0dmFyIGltYWdlRGF0YSA9IHRoaXMuX2RyYXdNZWRpYUVsZW1lbnQoY29udGV4dCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cdC8vXG5cdC8vIFx0dmFyIG9wdHMgPSB7IHJhZGl1czogMjAgfTtcblx0Ly8gXHR2YXIgZmdDb2xvciA9IG5ldyBDb2xvcih0aGlzLm1vZGVsLmF0dHIoXCJjb2xvclwiKSk7XG5cdC8vIFx0dmFyIGJnQ29sb3IgPSBuZXcgQ29sb3IodGhpcy5tb2RlbC5hdHRyKFwiYmFja2dyb3VuZC1jb2xvclwiKSk7XG5cdC8vIFx0dmFyIGlzRmdEYXJrID0gZmdDb2xvci5sdW1pbm9zaXR5KCkgPCBiZ0NvbG9yLmx1bWlub3NpdHkoKTtcblx0Ly8gXHRvcHRzLngwMCA9IGlzRmdEYXJrPyBDb2xvcihmZ0NvbG9yKS5saWdodGVuKDAuMzMpIDogQ29sb3IoYmdDb2xvcikuZGFya2VuKDAuMzMpO1xuXHQvLyBcdG9wdHMueEZGID0gaXNGZ0Rhcms/IENvbG9yKGJnQ29sb3IpLmxpZ2h0ZW4oMC4zMykgOiBDb2xvcihmZ0NvbG9yKS5kYXJrZW4oMC4zMyk7XG5cdC8vXG5cdC8vIFx0c3RhY2tCbHVyTW9ubyhpbWFnZURhdGEsIG9wdHMpO1xuXHQvLyBcdGR1b3RvbmUoaW1hZ2VEYXRhLCBvcHRzKTtcblx0Ly8gXHQvLyBzdGFja0JsdXJSR0IoaW1hZ2VEYXRhLCBvcHRzKTtcblx0Ly9cblx0Ly8gXHRjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXHQvLyBcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG5cdC8vIH0sXG59KTtcblxuaWYgKERFQlVHKSB7XG5cdFNlcXVlbmNlUmVuZGVyZXIgPSAoZnVuY3Rpb24oU2VxdWVuY2VSZW5kZXJlcikge1xuXHRcdGlmICghU2VxdWVuY2VSZW5kZXJlci5MT0dfVE9fU0NSRUVOKSByZXR1cm4gU2VxdWVuY2VSZW5kZXJlcjtcblxuXHRcdC8vIC8qKiBAdHlwZSB7bW9kdWxlOnVuZGVyc2NvcmUuc3RyaW5ncy9scGFkfSAqL1xuXHRcdC8vIHZhciBycGFkID0gcmVxdWlyZShcInVuZGVyc2NvcmUuc3RyaW5nL3JwYWRcIik7XG5cdFx0LyoqIEB0eXBlIHttb2R1bGU6dW5kZXJzY29yZS5zdHJpbmdzL2xwYWR9ICovXG5cdFx0dmFyIGxwYWQgPSByZXF1aXJlKFwidW5kZXJzY29yZS5zdHJpbmcvbHBhZFwiKTtcblx0XHQvKiogQHR5cGUge21vZHVsZTp1bmRlcnNjb3JlLnN0cmluZ3MvY2FwaXRhbGl6ZX0gKi9cblx0XHR2YXIgY2FwcyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlLnN0cmluZy9jYXBpdGFsaXplXCIpO1xuXG5cdFx0cmV0dXJuIFNlcXVlbmNlUmVuZGVyZXIuZXh0ZW5kKHtcblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHRcdFx0dGhpcy5fX2xvZ0NvbG9ycyA9IF8uZXh0ZW5kKHtcblx0XHRcdFx0XHRcIm1lZGlhOnBsYXlcIjogXCJkYXJrcmVkXCIsXG5cdFx0XHRcdFx0XCJtZWRpYTpwYXVzZVwiOiBcImRhcmtyZWRcIixcblxuXHRcdFx0XHRcdFwidGltZXI6c3RhcnRcIjogXCJkYXJrZ3JlZW5cIixcblx0XHRcdFx0XHRcInRpbWVyOmVuZFwiOiBcImRhcmtncmVlblwiLFxuXHRcdFx0XHRcdFwidGltZXI6cmVzdW1lXCI6IFwiZ3JlZW5cIixcblx0XHRcdFx0XHRcInRpbWVyOnBhdXNlXCI6IFwiZ3JlZW5cIixcblxuXHRcdFx0XHRcdFwibG9hZDpwcm9ncmVzc1wiOiBcImJsdWVcIixcblx0XHRcdFx0XHRcImxvYWQ6Y29tcGxldGVcIjogXCJkYXJrYmx1ZVwiXG5cdFx0XHRcdH0sIHRoaXMuX19sb2dDb2xvcnMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gX19nZXRIZWFkZXJUZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIFx0dmFyIGZtdDEgPSBmdW5jdGlvbihzKSB7XG5cdFx0XHQvLyBcdFx0cmV0dXJuIGxwYWQoY2FwcyhzKSwgOCkuc3Vic3RyKDAsIDgpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHQvLyBcdH07XG5cdFx0XHQvLyBcdHZhciBmbXQyID0gZnVuY3Rpb24ocykge1xuXHRcdFx0Ly8gXHRcdHJldHVybiBscGFkKGNhcHMocyksIDgpLnN1YnN0cigwLCA4KS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0Ly8gXHR9O1xuXHRcdFx0Ly8gXHR2YXIgbyA9IHtcblx0XHRcdC8vIFx0XHRcInRzdGFtcFwiOiBmbXQxLFxuXHRcdFx0Ly8gXHRcdFwiaW5kZXhcIjogZm10Mixcblx0XHRcdC8vIFx0XHRcImR1cmF0aW9uXCI6IGZtdDEsXG5cdFx0XHQvLyBcdFx0XCJwbGF5YmFja1wiOiBmbXQxLFxuXHRcdFx0Ly8gXHRcdFwibWVkaWFcIjogZm10MSxcblx0XHRcdC8vIFx0XHRcInRpbWVyXCI6IGZtdDEsXG5cdFx0XHQvLyBcdFx0XCJuZXh0XCI6IGZtdDEsXG5cdFx0XHQvLyBcdH07XG5cdFx0XHQvLyBcdHJldHVybiBPYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24ocywgaSwgYSkge1xuXHRcdFx0Ly8gXHRcdHJldHVybiBvW3NdKHMpO1xuXHRcdFx0Ly8gXHR9KS5qb2luKFwiIFwiKTtcblx0XHRcdC8vIFx0Ly8gT2JqZWN0LmtleXMobykucmVkdWNlKGZ1bmN0aW9uKHNzLCBzLCBpLCBhKSB7XG5cdFx0XHQvLyBcdC8vIFx0cmV0dXJuIHNzICsgXCIgXCIgKyBscGFkKGNhcHMocyksIDgpLnN1YnN0cigwLCA4KS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0Ly8gXHQvLyB9LCBcIlwiKTtcblx0XHRcdC8vIH0sXG5cblx0XHRcdF9fZ2V0SGVhZGVyVGV4dDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XCJ0c3RhbXBcIixcblx0XHRcdFx0XHRcImluZGV4XCIsXG5cdFx0XHRcdFx0XCJkdXJhdGlvblwiLFxuXHRcdFx0XHRcdFwicGxheWJhY2tcIixcblx0XHRcdFx0XHRcIm1lZGlhXCIsXG5cdFx0XHRcdFx0XCJ0aW1lclwiLFxuXHRcdFx0XHRcdFwibmV4dFwiLFxuXHRcdFx0XHRdLm1hcChmdW5jdGlvbihzLCBpLCBhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxwYWQoY2FwcyhzKSwgOCkuc3Vic3RyKDAsIDgpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH0pLmpvaW4oXCIgXCIpO1xuXHRcdFx0fSxcblxuXHRcdFx0X19sb2dUaW1lckV2ZW50OiBmdW5jdGlvbihldm5hbWUsIG1zZykge1xuXHRcdFx0XHR2YXIgbG9nTXNnID0gW1xuXHRcdFx0XHRcdHRoaXMuc291cmNlcy5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdCh0aGlzLnRpbWVyLmdldER1cmF0aW9uKCkgKiAuMDAxKS50b0ZpeGVkKDMpLFxuXHRcdFx0XHRcdHRoaXMucGxheWJhY2tSZXF1ZXN0ZWQgPyBcIj4+XCIgOiBcIjo6XCIsXG5cdFx0XHRcdFx0dGhpcy5tZWRpYVBhdXNlZCA/IFwicGF1c2VkXCIgOlxuXHRcdFx0XHRcdCh0aGlzLm1lZGlhV2FpdGluZyA/IFwid2FpdGluZ1wiIDogXCJwbGF5aW5nXCIpLFxuXHRcdFx0XHRcdHRoaXMudGltZXIuZ2V0U3RhdHVzKCksXG5cdFx0XHRcdFx0dGhpcy5zb3VyY2VzLmZvbGxvd2luZ09yRmlyc3QoKS5oYXMoXCJwcmVmZXRjaGVkXCIpID8gXCJyZWFkeVwiIDogXCJwZW5kaW5nXCJcblx0XHRcdFx0XS5tYXAoZnVuY3Rpb24ocywgaSwgYSkge1xuXHRcdFx0XHRcdHJldHVybiBscGFkKHMsIDgpLnN1YnN0cigwLCA4KS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0bXNnICYmIGxvZ01zZy5wdXNoKG1zZyk7XG5cdFx0XHRcdGxvZ01zZyA9IGxvZ01zZy5qb2luKFwiIFwiKTtcblxuXHRcdFx0XHR0aGlzLl9fbG9nTWVzc2FnZShsb2dNc2csIGV2bmFtZSk7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6Olslc10gJXNcIiwgdGhpcy5jaWQsIGV2bmFtZSwgbG9nTXNnKTtcblx0XHRcdH0sXG5cdFx0XHRfcGxheU1lZGlhOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCJtZWRpYTpwbGF5XCIpO1xuXHRcdFx0XHRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fcGxheU1lZGlhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdC8vIHRoaXMuX19sb2dUaW1lckV2ZW50KFwiPCBtZWRpYTpwbGF5XCIpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjpfcGxheU1lZGlhKClcIiwgdGhpcy5jaWQpO1xuXHRcdFx0fSxcblx0XHRcdF9wYXVzZU1lZGlhOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCJtZWRpYTpwYXVzZVwiKTtcblx0XHRcdFx0U2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX3BhdXNlTWVkaWEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0Ly8gdGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCI8IG1lZGlhOnBhdXNlXCIpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjpfcGF1c2VNZWRpYSgpXCIsIHRoaXMuY2lkKTtcblx0XHRcdH0sXG5cblx0XHRcdF9vblRpbWVyU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9fbG9nVGltZXJFdmVudChcInRpbWVyOnN0YXJ0XCIpO1xuXHRcdFx0XHRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fb25UaW1lclN0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXHRcdFx0X29uVGltZXJSZXN1bWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9fbG9nVGltZXJFdmVudChcInRpbWVyOnJlc3VtZVwiKTtcblx0XHRcdFx0U2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX29uVGltZXJSZXN1bWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH0sXG5cdFx0XHRfb25UaW1lclBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCJ0aW1lcjpwYXVzZVwiKTtcblx0XHRcdFx0U2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX29uVGltZXJQYXVzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblx0XHRcdF9vblRpbWVyRW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCJ0aW1lcjplbmRcIik7XG5cdFx0XHRcdFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLl9vblRpbWVyRW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfdXBkYXRlSXRlbVByb2dyZXNzOiBmdW5jdGlvbihwcm9ncmVzcywgc3JjSWR4KSB7XG5cdFx0XHRcdGlmIChwcm9ncmVzcyA9PSAxKSB7XG5cdFx0XHRcdFx0dGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCJsb2FkOmNvbXBsZXRlXCIsIFwiaXRlbSBcIiArIHNyY0lkeCArIFwiOiBjb21wbGV0ZVwiKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdGlmIChzcmNJZHggPT09IHRoaXMuc291cmNlcy5zZWxlY3RlZEluZGV4KSB7XG5cdFx0XHRcdFx0dGhpcy5fX2xvZ1RpbWVyRXZlbnQoXCJsb2FkOnByb2dyZXNzXCIsIFwiaXRlbSBcIiArIHNyY0lkeCArIFwiOiBcIiArIHByb2dyZXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlSXRlbVByb2dyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfcHJlbG9hZEFsbEl0ZW1zOiBmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRcdHZpZXcuX19sb2dNZXNzYWdlKHZpZXcuY2lkICsgXCI6Ol9wcmVsb2FkQWxsSXRlbXNcIiwgXCJsb2FkOnN0YXJ0XCIpO1xuXHRcdFx0XHRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fcHJlbG9hZEFsbEl0ZW1zLmFwcGx5KHZpZXcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9KShTZXF1ZW5jZVJlbmRlcmVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXF1ZW5jZVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xudmFyIHBhcnRpYWwkMCA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlL3N2Zy9GdWxsc2NyZWVuU3ltYm9sLmhicycpO1xuSGFuZGxlYmFyc0NvbXBpbGVyLnJlZ2lzdGVyUGFydGlhbCgnLi4vdGVtcGxhdGUvc3ZnL0Z1bGxzY3JlZW5TeW1ib2wuaGJzJywgcGFydGlhbCQwKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlcjtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJwbGFjZWhvbGRlciBzaXppbmdcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnQgbWVkaWEtYm9yZGVyXFxcIj5cXG5cdDxkaXYgY2xhc3M9XFxcImNvbnRyb2xzIGNvbnRlbnQtc2l6ZVxcXCI+XFxuXHRcdDxjYW52YXMgY2xhc3M9XFxcInByb2dyZXNzLW1ldGVyXFxcIj48L2NhbnZhcz5cXG5cdDwvZGl2Plxcblx0PGRpdiBjbGFzcz1cXFwiY3JvcC1ib3ggbWVkaWEtc2l6ZVxcXCI+XFxuXHRcdDx2aWRlbyB3aWR0aD1cXFwiMjQwXFxcIiBoZWlnaHQ9XFxcIjE4MFxcXCIgbXV0ZWQgcGxheXNpbmxpbmU+PC92aWRlbz5cXG5cdFx0PGltZyBjbGFzcz1cXFwicG9zdGVyIGRlZmF1bHRcXFwiIGFsdD1cXFwiXCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGV4dCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGV4dCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLHtcIm5hbWVcIjpcInRleHRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiB3aWR0aD1cXFwiMjQwXFxcIiBoZWlnaHQ9XFxcIjE4MFxcXCIgLz5cXG5cdDwvZGl2Plxcblx0PGRpdiBjbGFzcz1cXFwib3ZlcmxheSBtZWRpYS1zaXplIHBsYXktdG9nZ2xlLWhpdGFyZWFcXFwiPlxcblx0XHRcdDxjYW52YXMgY2xhc3M9XFxcInBsYXktdG9nZ2xlXFxcIj48L2NhbnZhcz5cXG5cdFx0PGEgY2xhc3M9XFxcImZ1bGxzY3JlZW4tdG9nZ2xlXFxcIiBocmVmPVxcXCJqYXZhc2NyaXB0Oih2b2lkIDApXFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBjb250YWluZXIuaW52b2tlUGFydGlhbChwYXJ0aWFsc1tcIi4uL3RlbXBsYXRlL3N2Zy9GdWxsc2NyZWVuU3ltYm9sLmhic1wiXSxkZXB0aDAse1wibmFtZVwiOlwiLi4vdGVtcGxhdGUvc3ZnL0Z1bGxzY3JlZW5TeW1ib2wuaGJzXCIsXCJkYXRhXCI6ZGF0YSxcImluZGVudFwiOlwiXFx0XFx0XFx0XCIsXCJoZWxwZXJzXCI6aGVscGVycyxcInBhcnRpYWxzXCI6cGFydGlhbHMsXCJkZWNvcmF0b3JzXCI6Y29udGFpbmVyLmRlY29yYXRvcnN9KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlx0XHQ8L2E+XFxuXHQ8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbn0sXCJ1c2VQYXJ0aWFsXCI6dHJ1ZSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qZ2xvYmFsIEhUTUxNZWRpYUVsZW1lbnQsIE1lZGlhRXJyb3IqL1xuLyoqXG4gKiBAbW9kdWxlIGFwcC92aWV3L3JlbmRlci9WaWRlb1JlbmRlcmVyXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW9cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvRXZlbnRzL01lZGlhX2V2ZW50c1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9IVE1ML1VzaW5nX0hUTUw1X2F1ZGlvX2FuZF92aWRlb1xuICovXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiBJbXBvcnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG4vLyB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuY29uc3QgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL1BsYXlhYmxlUmVuZGVyZXJ9ICovXG5jb25zdCBQbGF5YWJsZVJlbmRlcmVyID0gcmVxdWlyZShcImFwcC92aWV3L3JlbmRlci9QbGF5YWJsZVJlbmRlcmVyXCIpO1xuLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L0NhbnZhc1Byb2dyZXNzTWV0ZXJ9ICovXG5jb25zdCBQcm9ncmVzc01ldGVyID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9DYW52YXNQcm9ncmVzc01ldGVyXCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvY29tcG9uZW50L1BsYXlUb2dnbGVTeW1ib2x9ICovXG5jb25zdCBQbGF5VG9nZ2xlU3ltYm9sID0gcmVxdWlyZShcImFwcC92aWV3L2NvbXBvbmVudC9QbGF5VG9nZ2xlU3ltYm9sXCIpO1xuXG4vLyB2YXIgc3RhY2tCbHVyTW9ubyA9IHJlcXVpcmUoXCJ1dGlscy9jYW52YXMvYml0bWFwL3N0YWNrQmx1ck1vbm9cIik7XG4vLyB2YXIgc3RhY2tCbHVyUkdCID0gcmVxdWlyZShcInV0aWxzL2NhbnZhcy9iaXRtYXAvc3RhY2tCbHVyUkdCXCIpO1xuXG4vLyAvKiogQHR5cGUge21vZHVsZTp1dGlscy9wcmVmaXhlZFN0eWxlTmFtZX0gKi9cbi8vIHZhciBwcmVmaXhlZFN0eWxlTmFtZSA9IHJlcXVpcmUoXCJ1dGlscy9wcmVmaXhlZFN0eWxlTmFtZVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3ByZWZpeGVkRXZlbnR9ICovXG5jb25zdCBwcmVmaXhlZEV2ZW50ID0gcmVxdWlyZShcInV0aWxzL3ByZWZpeGVkRXZlbnRcIik7XG5cbi8vIHZhciB3aGVuVmlld0lzQXR0YWNoZWQgPSByZXF1aXJlKFwiYXBwL3ZpZXcvcHJvbWlzZS93aGVuVmlld0lzQXR0YWNoZWRcIik7XG4vLyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuLy8gdmFyIHdoZW5TZWxlY3Rpb25EaXN0YW5jZUlzID0gcmVxdWlyZShcImFwcC92aWV3L3Byb21pc2Uvd2hlblNlbGVjdGlvbkRpc3RhbmNlSXNcIik7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiBwcml2YXRlIHN0YXRpY1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBmdWxsc2NyZWVuQ2hhbmdlRXZlbnQgPSBwcmVmaXhlZEV2ZW50KFwiZnVsbHNjcmVlbmNoYW5nZVwiLCBkb2N1bWVudCk7XG4vLyB2YXIgZnVsbHNjcmVlbkVycm9yRXZlbnQgPSBwcmVmaXhlZEV2ZW50KFwiZnVsbHNjcmVlbmVycm9yXCIsIGRvY3VtZW50KTtcblxudmFyIGZvcm1hdFRpbWVjb2RlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIFwiXCI7IC8vdmFsdWUgPSAwO1xuXHRpZiAodmFsdWUgPj0gMzYwMCkgcmV0dXJuICgodmFsdWUgLyAzNjAwKSB8IDApICsgXCJIXCI7XG5cdGlmICh2YWx1ZSA+PSA2MCkgcmV0dXJuICgodmFsdWUgLyA2MCkgfCAwKSArIFwiTVwiO1xuXHQvLyBpZiAodmFsdWUgPj0gMTApIHJldHVybiBcIjBcIiArICh2YWx1ZSB8IDApICsgXCJTXCI7XG5cdHJldHVybiAodmFsdWUgfCAwKSArIFwiU1wiO1xufTtcblxudmFyIFZJREVPX0NST1BfUFggPSBHbG9iYWxzLlZJREVPX0NST1BfUFg7XG52YXIgU1lOQ19USU1FT1VUX01TID0gMTIwMDtcbnZhciBTWU5DX1RIUkVTSE9MRF9NUyA9IDEwMDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL3ZpZXcvcmVuZGVyL1ZpZGVvUmVuZGVyZXJ9XG4gKi9cbnZhciBWaWRlb1JlbmRlcmVyID0gUGxheWFibGVSZW5kZXJlci5leHRlbmQoe1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRjaWRQcmVmaXg6IFwidmlkZW9SZW5kZXJlclwiLFxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Y2xhc3NOYW1lOiBQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5jbGFzc05hbWUgKyBcIiB2aWRlby1pdGVtXCIsXG5cdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovXG5cdHRlbXBsYXRlOiByZXF1aXJlKFwiLi9WaWRlb1JlbmRlcmVyLmhic1wiKSxcblxuXHQvLyBldmVudHM6IChmdW5jdGlvbigpIHtcblx0Ly8gXHR2YXIgcmV0ID0ge307XG5cdC8vIFx0cmV0W1BsYXlhYmxlUmVuZGVyZXIuQ0xJQ0tfRVZFTlQgKyBcIiAuZnVsbHNjcmVlbi10b2dnbGVcIl0gPSBcIl9vbkZ1bGxzY3JlZW5Ub2dnbGVcIjtcblx0Ly8gXHRyZXR1cm4gcmV0O1xuXHQvLyB9KCkpLFxuXG5cdC8vIGV2ZW50czogZnVuY3Rpb24oKSB7XG5cdC8vIFx0dmFyIGV2ZW50cyA9IHt9O1xuXHQvLyBcdGV2ZW50c1tQbGF5YWJsZVJlbmRlcmVyLkNMSUNLX0VWRU5UICsgXCIgLmZ1bGxzY3JlZW4tdG9nZ2xlXCJdID0gXCJfb25GdWxsc2NyZWVuVG9nZ2xlXCI7XG5cdC8vIFx0cmV0dXJuIF8uZXh0ZW5kKGV2ZW50cywgXy5yZXN1bHQodGhpcywgUGxheWFibGVSZW5kZXJlci5wcm90b3R5cGUuZXZlbnRzKSk7XG5cdC8vIH0sXG5cdC8vIGV2ZW50czoge1xuXHQvLyBcdFwiY2xpY2sgLmZ1bGxzY3JlZW4tdG9nZ2xlXCI6IFwiX29uRnVsbHNjcmVlblRvZ2dsZVwiLFxuXHQvLyB9LFxuXG5cdHByb3BlcnRpZXM6IHtcblx0XHRmdWxsc2NyZWVuVG9nZ2xlOiB7XG5cdFx0XHQvKiogQHJldHVybiB7SFRNTEVsZW1lbnR9ICovXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZnVsbHNjcmVlblRvZ2dsZSB8fCAodGhpcy5fZnVsbHNjcmVlblRvZ2dsZSA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5mdWxsc2NyZWVuLXRvZ2dsZVwiKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHRQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0Xy5iaW5kQWxsKHRoaXMsXG5cdFx0XHRcIl91cGRhdGVQbGF5YmFja1N0YXRlXCIsXG5cdFx0XHRcIl91cGRhdGVDdXJyVGltZVZhbHVlXCIsXG5cdFx0XHRcIl91cGRhdGVCdWZmZXJlZFZhbHVlXCIsXG5cdFx0XHRcIl9vbk1lZGlhRXJyb3JcIixcblx0XHRcdFwiX29uTWVkaWFFbmRlZFwiLFxuXHRcdFx0Ly8gXCJfb25NZWRpYVBsYXlpbmdPbmNlXCIsXG5cdFx0XHRcIl9vbkZ1bGxzY3JlZW5DaGFuZ2VcIixcblx0XHRcdFwiX29uRnVsbHNjcmVlblRvZ2dsZVwiXG5cdFx0KTtcblx0XHRfLmJpbmRBbGwodGhpcyxcblx0XHRcdFwiX3BsYXliYWNrVGltZW91dEZuX3BsYXlpbmdcIixcblx0XHRcdFwiX3BsYXliYWNrVGltZW91dEZuX3dhaXRpbmdcIlxuXHRcdCk7XG5cdFx0Ly8gdmFyIG9uUGVlclNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0dGhpcy5jb250ZW50LnN0eWxlLmRpc3BsYXkgPSAodGhpcy5nZXRTZWxlY3Rpb25EaXN0YW5jZSgpID4gMSk/IFwibm9uZVwiOiBcIlwiO1xuXHRcdC8vIH07XG5cdFx0Ly8gdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLmNvbGxlY3Rpb24sIFwic2VsZWN0Om9uZSBzZWxlY3Q6bm9uZVwiLCBvblBlZXJTZWxlY3QpO1xuXHRcdC8vIG9uUGVlclNlbGVjdCgpO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIGNoaWxkcmVuXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0Y3JlYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNoaWxkcmVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR0aGlzLnBsYWNlaG9sZGVyID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLnBsYWNlaG9sZGVyXCIpO1xuXHRcdC8vIHRoaXMub3ZlcmxheSA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLm92ZXJsYXlcIik7XG5cdFx0dGhpcy52aWRlbyA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwidmlkZW9cIik7XG5cdFx0Ly8gdGhpcy52aWRlby5sb29wID0gdGhpcy5tb2RlbC5hdHRycygpLmhhc093blByb3BlcnR5KFwiQHZpZGVvLWxvb3BcIik7XG5cblx0XHQvLyB0aGlzLnZpZGVvLnNldEF0dHJpYnV0ZShcIm11dGVkXCIsIFwibXV0ZWRcIik7XG5cdFx0Ly8gdGhpcy52aWRlby5zZXRBdHRyaWJ1dGUoXCJwbGF5c2lubGluZVwiLCBcInBsYXlzaW5saW5lXCIpO1xuXHRcdC8vIGlmICh0aGlzLm1vZGVsLmF0dHIoXCJAdmlkZW8tbG9vcFwiKSAhPT0gdm9pZCAwKSB7XG5cdFx0Ly8gXHR0aGlzLnZpZGVvLnNldEF0dHJpYnV0ZShcImxvb3BcIiwgXCJsb29wXCIpO1xuXHRcdC8vIH1cblx0XHR0aGlzLnZpZGVvLnNldEF0dHJpYnV0ZShcInByZWxvYWRcIiwgXCJub25lXCIpO1xuXHRcdGlmICh0aGlzLnZpZGVvLmNvbnRyb2xMaXN0KSB0aGlzLnZpZGVvLmNvbnRyb2xMaXN0LmFkZChcIm5vZG93bmxvYWRcIik7XG5cblx0XHQvLyB0aGlzLnZpZGVvLm11dGVkID0gdHJ1ZTtcblx0XHQvLyB0aGlzLnZpZGVvLnBsYXlzaW5saW5lID0gdHJ1ZTtcblx0XHQvLyB0aGlzLnZpZGVvLnByZWxvYWQgPSBcImF1dG9cIjtcblx0XHR0aGlzLnZpZGVvLmxvb3AgPSB0aGlzLm1vZGVsLmF0dHIoXCJAdmlkZW8tbG9vcFwiKSAhPT0gdm9pZCAwO1xuXHRcdHRoaXMudmlkZW8uc3JjID0gdGhpcy5maW5kUGxheWFibGVTb3VyY2UodGhpcy52aWRlbyk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogbGF5b3V0L3JlbmRlclxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRtZWFzdXJlOiBmdW5jdGlvbigpIHtcblx0XHRQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5tZWFzdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHQvLyBOT1RFOiBWZXJ0aWNhbCAxcHggdmlkZW8gY3JvcFxuXHRcdC8vIC0gQ3JvcHBlZCBpbiBDU1M6IHZpZGVvLCAucG9zdGVyIHsgbWFyZ2luLXRvcDogLTFweDsgbWFyZ2luLWJvdHRvbTogLTFweDt9XG5cdFx0Ly8gLSBDcm9wcGVkIGhlaWdodCBpcyBhZGp1c3RlZCBpbiBtZXRyaWNzIG9ialxuXHRcdC8vIC0gQ3JvcCBhbW91bnQgYWRkZWQgYmFjayB0byBhY3R1YWwgdmlkZW8gb24gcmVuZGVyKClcblx0XHR0aGlzLm1ldHJpY3MubWVkaWEuaGVpZ2h0ICs9IFZJREVPX0NST1BfUFggKiAyO1xuXHRcdHRoaXMubWV0cmljcy5jb250ZW50LmhlaWdodCArPSBWSURFT19DUk9QX1BYICogMjtcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0UGxheWFibGVSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgZWxzLCBlbCwgaSwgY3NzVywgY3NzSDtcblx0XHR2YXIgaW1nID0gdGhpcy5kZWZhdWx0SW1hZ2U7XG5cdFx0dmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG5cblx0XHQvLyBtZWRpYS1zaXplXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Y3NzVyA9IHRoaXMubWV0cmljcy5tZWRpYS53aWR0aCArIFwicHhcIjtcblx0XHRjc3NIID0gdGhpcy5tZXRyaWNzLm1lZGlhLmhlaWdodCArIFwicHhcIjtcblxuXHRcdGVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcIi5tZWRpYS1zaXplXCIpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGVsID0gZWxzLml0ZW0oaSk7XG5cdFx0XHRlbC5zdHlsZS53aWR0aCA9IGNzc1c7XG5cdFx0XHRlbC5zdHlsZS5oZWlnaHQgPSBjc3NIO1xuXHRcdH1cblxuXHRcdGNvbnRlbnQuc3R5bGUud2lkdGggPSBjc3NXO1xuXHRcdGNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gKHRoaXMubWV0cmljcy5tZWRpYS5oZWlnaHQgKyBWSURFT19DUk9QX1BYKSArIFwicHhcIjtcblxuXHRcdC8vIGNvbnRlbnQtcG9zaXRpb25cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR2YXIgY3NzWCwgY3NzWTtcblx0XHRjc3NYID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQueCArIFwicHhcIjtcblx0XHRjc3NZID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQueSArIFwicHhcIjtcblx0XHRjb250ZW50LnN0eWxlLmxlZnQgPSBjc3NYO1xuXHRcdGNvbnRlbnQuc3R5bGUudG9wID0gY3NzWTtcblxuXHRcdGVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRyb2xzXCIpO1xuXHRcdC8vIGVsLnN0eWxlLmxlZnQgPSBjc3NYO1xuXHRcdC8vIGNvbnRyb2xzLnN0eWxlLnRvcCA9IGNzc1k7XG5cdFx0ZWwuc3R5bGUud2lkdGggPSB0aGlzLm1ldHJpY3MuY29udGVudC53aWR0aCArIFwicHhcIjtcblx0XHRlbC5zdHlsZS5oZWlnaHQgPSB0aGlzLm1ldHJpY3MuY29udGVudC5oZWlnaHQgKyBcInB4XCI7XG5cblx0XHQvLyAvLyBjb250ZW50LXNpemVcblx0XHQvLyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyBjc3NXID0gdGhpcy5tZXRyaWNzLmNvbnRlbnQud2lkdGggKyBcInB4XCI7XG5cdFx0Ly8gY3NzSCA9IHRoaXMubWV0cmljcy5jb250ZW50LmhlaWdodCArIFwicHhcIjtcblx0XHQvL1xuXHRcdC8vIGVscyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcIi5jb250ZW50LXNpemVcIik7XG5cdFx0Ly8gZm9yIChpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuXHRcdC8vIFx0ZWwgPSBlbHMuaXRlbShpKTtcblx0XHQvLyBcdGVsLnN0eWxlLndpZHRoID0gY3NzVztcblx0XHQvLyBcdGVsLnN0eWxlLmhlaWdodCA9IGNzc0g7XG5cdFx0Ly8gfVxuXG5cdFx0Ly8gTk9URTogZWxlbWVudHMgYmVsb3cgbXVzdCB1c2UgdmlkZW8ncyBVTkNST1BQRUQgaGVpZ2h0LCBzbyArMnB4XG5cdFx0dGhpcy52aWRlby5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLm1ldHJpY3MubWVkaWEud2lkdGgpO1xuXHRcdHRoaXMudmlkZW8uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoaXMubWV0cmljcy5tZWRpYS5oZWlnaHQgLSBWSURFT19DUk9QX1BYICogMik7XG5cdFx0aW1nLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMubWV0cmljcy5tZWRpYS53aWR0aCk7XG5cdFx0aW1nLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLm1ldHJpY3MubWVkaWEuaGVpZ2h0IC0gVklERU9fQ1JPUF9QWCAqIDIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogaW5pdGlhbGl6ZUFzeW5jXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGluaXRpYWxpemVBc3luYzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKVxuXHRcdFx0LnRoZW4oUGxheWFibGVSZW5kZXJlci53aGVuU2VsZWN0aW9uSXNDb250aWd1b3VzKVxuXHRcdFx0LnRoZW4oUGxheWFibGVSZW5kZXJlci53aGVuU2Nyb2xsaW5nRW5kcylcblx0XHRcdC50aGVuKFBsYXlhYmxlUmVuZGVyZXIud2hlblZpZXdJc0F0dGFjaGVkKVxuXHRcdFx0LnRoZW4oXG5cdFx0XHRcdGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjppbml0aWFsaXplQXN5bmMgW2F0dGFjaGVkLCBzY3JvbGxlbmQsIHNlbGVjdGVkID4gJW8sIHByZWxvYWQ6JXNdICgnJW8nKVwiLCB2aWV3LmNpZCwgdmlldy5tb2RlbC5nZXREaXN0YW5jZVRvU2VsZWN0ZWQoKSwgdmlldy52aWRlby5wcmVsb2FkLCB2aWV3Lm1vZGVsLmdldChcIm5hbWVcIikpO1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChbXG5cdFx0XHRcdFx0XHRQbGF5YWJsZVJlbmRlcmVyLndoZW5EZWZhdWx0SW1hZ2VMb2Fkcyh2aWV3KSxcblx0XHRcdFx0XHRcdHZpZXcud2hlblZpZGVvSGFzTWV0YWRhdGEodmlldyksXG5cdFx0XHRcdFx0XSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2aWV3O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0LnRoZW4oXG5cdFx0XHRcdGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjppbml0aWFsaXplQXN5bmMgW2RlZmF1bHRJbWFnZSwgcHJlbG9hZDolc10gKCclbycpXCIsIHZpZXcuY2lkLCB2aWV3LnZpZGVvLnByZWxvYWQsIHZpZXcubW9kZWwuZ2V0KFwibmFtZVwiKSk7XG5cdFx0XHRcdFx0dmlldy5pbml0aWFsaXplUGxheWFibGUoKTtcblx0XHRcdFx0XHQvLyB2aWV3LnVwZGF0ZU92ZXJsYXkodmlldy5kZWZhdWx0SW1hZ2UsIHZpZXcucGxheVRvZ2dsZSk7IC8vdmlldy5vdmVybGF5KTtcblx0XHRcdFx0XHR2aWV3Lmxpc3RlblRvU2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0cmV0dXJuIHZpZXc7XG5cdFx0XHRcdH0pO1xuXG5cdFx0Ly8gdmlkZW9FbC5zZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIsIFwibWV0YWRhdGFcIik7XG5cdH0sXG5cblx0aW5pdGlhbGl6ZVBsYXlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHQvLyBXaGVuIHNlbGVjdGVkIGZvciB0aGUgZmlyc3QgdGltZVxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFBsYXlhYmxlUmVuZGVyZXIud2hlblNlbGVjdGlvbkRpc3RhbmNlSXModGhpcywgMClcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHZpZXcpIHtcblx0XHRcdFx0dmlldy52aWRlby5zZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIsIFwiYXV0b1wiKTtcblx0XHRcdFx0dmlldy52aWRlby5wcmVsb2FkID0gXCJhdXRvXCI7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OmluaXRpYWxpemVBc3luYyBbc2VsZWN0ZWQsIHByZWxvYWQ6JXNdICgnJW8nKVwiLCB2aWV3LmNpZCwgdmlldy52aWRlby5wcmVsb2FkLCB2aWV3Lm1vZGVsLmdldChcIm5hbWVcIikpO1xuXHRcdFx0XHRyZXR1cm4gdmlldztcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRcdGlmIChyZWFzb24gaW5zdGFuY2VvZiBQbGF5YWJsZVJlbmRlcmVyLlZpZXdFcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiJXM6OiVzXCIsIHJlYXNvbi52aWV3LmNpZCwgcmVhc29uLm1lc3NhZ2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihyZWFzb24pO1xuXHRcdFx0XHRcdC8vIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHQvLyBwbGF5LXRvZ2dsZS1zeW1ib2xcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHR0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sID0gbmV3IFBsYXlUb2dnbGVTeW1ib2woXy5leHRlbmQoe1xuXHRcdFx0ZWw6IHRoaXMuZWwucXVlcnlTZWxlY3RvcihcIi5wbGF5LXRvZ2dsZVwiKVxuXHRcdH0sIHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wgfHwge30pKTtcblxuXHRcdC8vIHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wuc2V0SW1hZ2VTb3VyY2UodGhpcy5kZWZhdWx0SW1hZ2UsIDAsIDApO1xuXHRcdC8vIHRoaXMubGlzdGVuVG9FbGVtZW50T25jZSh0aGlzLnZpZGVvLCBcInRpbWV1cGRhdGVcIiwgZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBcdHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wuc2V0SW1hZ2VTb3VyY2UodGhpcy52aWRlbyk7XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBwcm9ncmVzcy1tZXRlclxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdHRoaXMucHJvZ3Jlc3NNZXRlciA9IG5ldyBQcm9ncmVzc01ldGVyKHtcblx0XHRcdGVsOiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIucHJvZ3Jlc3MtbWV0ZXJcIiksXG5cdFx0XHRjb2xvcjogdGhpcy5tb2RlbC5hdHRyKFwiY29sb3JcIiksXG5cdFx0XHQvLyBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMubW9kZWwuYXR0cihcImJhY2tncm91bmQtY29sb3JcIiksXG5cdFx0XHRtYXhWYWx1ZXM6IHtcblx0XHRcdFx0YW1vdW50OiB0aGlzLnZpZGVvLmR1cmF0aW9uLFxuXHRcdFx0XHRhdmFpbGFibGU6IHRoaXMudmlkZW8uZHVyYXRpb24sXG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxGbjogKGZ1bmN0aW9uKHZhbHVlLCB0b3RhbCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0YXJ0ZWQgfHwgdGhpcy52aWRlby5lbmRlZCB8fCBpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZm9ybWF0VGltZWNvZGUodG90YWwpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCF0aGlzLnBsYXliYWNrUmVxdWVzdGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEdsb2JhbHMuUEFVU0VfQ0hBUjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZm9ybWF0VGltZWNvZGUodG90YWwgLSB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLmJpbmQodGhpcylcblx0XHR9KTtcblx0XHQvLyB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuY29udHJvbHNcIikuYXBwZW5kQ2hpbGQodGhpcy5wcm9ncmVzc01ldGVyLmVsKTtcblx0XHQvLyB2YXIgZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIucHJvZ3Jlc3MtbWV0ZXJcIik7XG5cdFx0Ly8gZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5wcm9ncmVzc01ldGVyLmVsLCBlbCk7XG5cdFx0Ly8gdmFyIHBhcmVudEVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRyb2xzXCIpO1xuXHRcdC8vIHBhcmVudEVsLmluc2VydEJlZm9yZSh0aGlzLnByb2dyZXNzTWV0ZXIuZWwsIHBhcmVudEVsLmZpcnN0Q2hpbGQpO1xuXG5cdFx0Ly8gdGhpcy5fc2V0UGxheVRvZ2dsZVN5bWJvbChcInBsYXktc3ltYm9sXCIpO1xuXHRcdHRoaXMuX3JlbmRlclBsYXliYWNrU3RhdGUoKTtcblxuXHRcdC8vIGxpc3RlbiB0byB2aWRlbyBldmVudHNcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyB0aGlzLnZpZGVvLnBvc3RlciA9IHRoaXMubW9kZWwuZ2V0KFwic291cmNlXCIpLmdldChcIm9yaWdpbmFsXCIpO1xuXHRcdHRoaXMuYWRkTWVkaWFMaXN0ZW5lcnMoKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiB3aGVuVmlkZW9IYXNNZXRhZGF0YSBwcm9taXNlXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHdoZW5WaWRlb0hhc01ldGFkYXRhOiBmdW5jdGlvbih2aWV3KSB7XG5cdFx0Ly8gTk9URTogbm90IHByZXR0eSAhISFcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgdmlkZW9FbCA9IHZpZXcudmlkZW87XG5cdFx0XHR2YXIgZXZlbnRIYW5kbGVycyA9IHtcblx0XHRcdFx0bG9hZGVkbWV0YWRhdGE6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdFx0aWYgKGV2KSByZW1vdmVFdmVudExpc3RlbmVycygpO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6OndoZW5WaWRlb0hhc01ldGFkYXRhIFslc10gJXNcIiwgdmlldy5jaWQsIFwicmVzb2x2ZWRcIiwgZXYgPyBldi50eXBlIDogXCJzeW5jXCIpO1xuXHRcdFx0XHRcdHJlc29sdmUodmlldyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdGlmIChldikgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblx0XHRcdFx0XHRyZWplY3QobmV3IFBsYXlhYmxlUmVuZGVyZXIuVmlld0Vycm9yKHZpZXcsIG5ldyBFcnJvcihcIndoZW5WaWRlb0hhc01ldGFkYXRhOiB2aWV3IHdhcyByZW1vdmVkXCIpKSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdGlmIChldikgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblx0XHRcdFx0XHR2YXIgZXJyO1xuXHRcdFx0XHRcdGlmICh2aWRlb0VsLmVycm9yKSB7XG5cdFx0XHRcdFx0XHRlcnIgPSBuZXcgRXJyb3IoXy5pbnZlcnQoTWVkaWFFcnJvcilbdmlkZW9FbC5lcnJvci5jb2RlXSk7XG5cdFx0XHRcdFx0XHRlcnIuaW5mb0NvZGUgPSB2aWRlb0VsLmVycm9yLmNvZGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVyciA9IG5ldyBFcnJvcihcIlVuc3BlY2lmaWVkIGVycm9yXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlcnIuaW5mb1NyYyA9IHZpZGVvRWwuc3JjO1xuXHRcdFx0XHRcdGVyci5sb2dNZXNzYWdlID0gXCJ3aGVuVmlkZW9IYXNNZXRhZGF0YTogXCIgKyBlcnIubmFtZSArIFwiIFwiICsgZXJyLmluZm9TcmM7XG5cdFx0XHRcdFx0ZXJyLmxvZ0V2ZW50ID0gZXY7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0sXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyAgKHZpZGVvRWwucHJlbG9hZCA9PSBcImF1dG9cIiAmJiB2aWRlb0VsLnJlYWR5U3RhdGUgPj0gSFRNTE1lZGlhRWxlbWVudC5IQVZFX0NVUlJFTlRfREFUQSlcblx0XHRcdC8vIFx0KHZpZGVvRWwucHJlbG9hZCA9PSBcIm1ldGFkYXRhXCIgJiYgdmlkZW9FbC5yZWFkeVN0YXRlID49IEhUTUxNZWRpYUVsZW1lbnQuSEFWRV9NRVRBREFUQSlcblxuXHRcdFx0aWYgKHZpZGVvRWwuZXJyb3IpIHtcblx0XHRcdFx0ZXZlbnRIYW5kbGVycy5lcnJvcigpO1xuXHRcdFx0fSBlbHNlIGlmICh2aWRlb0VsLnJlYWR5U3RhdGUgPj0gSFRNTE1lZGlhRWxlbWVudC5IQVZFX01FVEFEQVRBKSB7XG5cdFx0XHRcdGV2ZW50SGFuZGxlcnMubG9hZGVkbWV0YWRhdGEoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzb3VyY2VzID0gdmlkZW9FbC5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpO1xuXHRcdFx0XHR2YXIgZXJyVGFyZ2V0ID0gc291cmNlcy5sZW5ndGggPiAwID8gc291cmNlcy5pdGVtKHNvdXJjZXMubGVuZ3RoIC0gMSkgOiB2aWRlb0VsO1xuXHRcdFx0XHR2YXIgZXJyQ2FwdHVyZSA9IGVyclRhcmdldCA9PT0gdmlkZW9FbDsgLy8gdXNlIGNhcHR1cmUgd2l0aCBIVE1MTWVkaWFFbGVtZW50XG5cblx0XHRcdFx0dmFyIHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZXJyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBldmVudEhhbmRsZXJzLmVycm9yLCBlcnJDYXB0dXJlKTtcblx0XHRcdFx0XHRmb3IgKHZhciBldiBpbiBldmVudEhhbmRsZXJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXYgIT09IFwiZXJyb3JcIiAmJiBldmVudEhhbmRsZXJzLmhhc093blByb3BlcnR5KGV2KSkge1xuXHRcdFx0XHRcdFx0XHR2aWRlb0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIGV2ZW50SGFuZGxlcnNbZXZdLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRlcnJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGV2ZW50SGFuZGxlcnMuZXJyb3IsIGVyckNhcHR1cmUpO1xuXHRcdFx0XHRmb3IgKHZhciBldiBpbiBldmVudEhhbmRsZXJzKSB7XG5cdFx0XHRcdFx0aWYgKGV2ICE9PSBcImVycm9yXCIgJiYgZXZlbnRIYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldikpIHtcblx0XHRcdFx0XHRcdHZpZGVvRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgZXZlbnRIYW5kbGVyc1tldl0sIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogTk9URTogTVMgRWRnZSBpZ25vcmVzIGpzIHByb3BlcnR5LCB1c2luZyBzZXRBdHRyaWJ1dGUgKi9cblx0XHRcdFx0dmlkZW9FbC5zZXRBdHRyaWJ1dGUoXCJwcmVsb2FkXCIsIFwibWV0YWRhdGFcIik7XG5cdFx0XHRcdHZpZGVvRWwucHJlbG9hZCA9IFwibWV0YWRhdGFcIjtcblxuXHRcdFx0XHQvLyB2aWRlb0VsLnNldEF0dHJpYnV0ZShcInBvc3RlclwiLCB2aWV3LmdldChcInNvdXJjZVwiKS5nZXQoXCJvcmlnaW5hbFwiKSk7XG5cdFx0XHRcdC8vIHZpZGVvRWwuc2V0QXR0cmlidXRlKFwicHJlbG9hZFwiLCBcIm1ldGFkYXRhXCIpO1xuXHRcdFx0XHQvLyB2aWRlb0VsLnBvc3RlciA9IHZpZXcubW9kZWwuZ2V0KFwic291cmNlXCIpLmdldChcIm9yaWdpbmFsXCIpO1xuXHRcdFx0XHQvLyB2aWRlb0VsLmxvb3AgPSB2aWV3Lm1vZGVsLmF0dHIoXCJAdmlkZW8tbG9vcFwiKSAhPT0gdm9pZCAwO1xuXHRcdFx0XHQvLyB2aWRlb0VsLnNyYyA9IHZpZXcuZmluZFBsYXlhYmxlU291cmNlKHZpZGVvRWwpO1xuXHRcdFx0XHQvLyB2aWRlb0VsLmxvYWQoKTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIiVzOjp3aGVuVmlkZW9IYXNNZXRhZGF0YSBbcHJlbG9hZDolc11cIiwgdmlldy5jaWQsIHZpZGVvRWwucHJlbG9hZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0ZmluZFBsYXlhYmxlU291cmNlOiBmdW5jdGlvbih2aWRlbykge1xuXHRcdHZhciBwbGF5YWJsZSA9IHRoaXMubW9kZWwuZ2V0KFwic291cmNlc1wiKS5maW5kKGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIC9edmlkZW9cXC8vLnRlc3Qoc291cmNlLmdldChcIm1pbWVcIikpICYmIHZpZGVvLmNhblBsYXlUeXBlKHNvdXJjZS5nZXQoXCJtaW1lXCIpKSAhPSBcIlwiO1xuXHRcdH0pO1xuXHRcdHJldHVybiBwbGF5YWJsZSA/IHBsYXlhYmxlLmdldChcIm9yaWdpbmFsXCIpIDogXCJcIjtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICogUGxheWFibGVSZW5kZXJlciBpbXBsZW1lbnRhdGlvblxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyAvKiogQG92ZXJyaWRlICovXG5cdC8vIF9jYW5SZXN1bWVQbGF5YmFjazogZnVuY3Rpb24oKSB7XG5cdC8vIFx0cmV0dXJuIFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLl9jYW5SZXN1bWVQbGF5YmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA+PSBIVE1MTWVkaWFFbGVtZW50LkhBVkVfQ1VSUkVOVF9EQVRBO1xuXHQvLyB9LFxuXG5cdC8qKiBAb3ZlcnJpZGUgaW5pdGlhbCB2YWx1ZSAqL1xuXHRfcGxheWJhY2tSZXF1ZXN0ZWQ6IGZhbHNlLFxuXG5cdC8qKiBAb3ZlcnJpZGUgKi9cblx0X2lzTWVkaWFQYXVzZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZGVvLnBhdXNlZDtcblx0fSxcblxuXHQvKiogQG92ZXJyaWRlICovXG5cdF9wbGF5TWVkaWE6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPj0gSFRNTE1lZGlhRWxlbWVudC5IQVZFX0NVUlJFTlRfREFUQSAmJiB0aGlzLnZpZGVvLnNlZWthYmxlLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRjb25zb2xlLndhcm4odGhpcy5jaWQsIFwiV1RGISBnb3QgdmlkZW8gZGF0YSwgYnV0IGNhbm5vdCBzZWVrLCBjYWxsaW5nIGxvYWQoKVwiKTtcblx0XHRcdC8vIHRoaXMuX2xvZ01lc3NhZ2UoXCJjYWxsOmxvYWRcIiwgXCJnb3QgdmlkZW8gZGF0YSwgYnV0IGNhbm5vdCBzZWVrLCBjYWxsaW5nIGxvYWQoKVwiLCBcIm9yYW5nZVwiKTtcblx0XHRcdGlmIChfLmlzRnVuY3Rpb24odGhpcy52aWRlby5sb2FkKSkge1xuXHRcdFx0XHR0aGlzLnZpZGVvLmxvYWQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogTk9URTogbG9vcCBpcyBmYWxzZSwgcmVzdGFydCBmcm9tIGVuZCBvbiByZXF1ZXN0ICovXG5cdFx0ZWxzZSBpZiAodGhpcy52aWRlby5lbmRlZCkge1xuXHRcdFx0dGhpcy52aWRlby5jdXJyZW50VGltZSA9IHRoaXMudmlkZW8uc2Vla2FibGUuc3RhcnQoMCk7XG5cdFx0fVxuXG5cdFx0LyogaWYgbm90IGVub3VnaCBkYXRhICovXG5cdFx0aWYgKHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA8IEhUTUxNZWRpYUVsZW1lbnQuSEFWRV9FTk9VR0hfREFUQSkge1xuXHRcdFx0aWYgKHRoaXMudmlkZW8ubmV0d29ya1N0YXRlID09IEhUTUxNZWRpYUVsZW1lbnQuTkVUV09SS19JRExFKSB7XG5cdFx0XHRcdHRoaXMudmlkZW8ubG9hZCgpO1xuXHRcdFx0fSAvL2Vsc2Uge1xuXHRcdFx0Ly8gdmFyIF9wbGF5U3RhbXAgPSB0aGlzLl9wbGF5YmFja0NvdW50O1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCIlczo6X3BsYXlNZWRpYSAlcyB3YWl0aW5nIFsjJXNdXCIsIHRoaXMuY2lkLCB0aGlzLl9pc01lZGlhV2FpdGluZygpID8gXCJjb250aW51ZVwiIDogXCJiZWdpblwiLCBfcGxheVN0YW1wKTtcblx0XHRcdC8vXG5cdFx0XHQvLyB0aGlzLmxpc3RlblRvRWxlbWVudE9uY2UodGhpcy52aWRlbywgXCJjYW5wbGF5dGhyb3VnaFwiLCBmdW5jdGlvbihldikge1xuXHRcdFx0Ly8gXHRjb25zb2xlLmxvZyhcIiVzOjpfcGxheU1lZGlhIGVuZCB3YWl0aW5nIFsjJXNdXCIsIHRoaXMuY2lkLCBfcGxheVN0YW1wKTtcblx0XHRcdC8vXG5cdFx0XHQvLyBcdHRoaXMuX3RvZ2dsZVdhaXRpbmcoZmFsc2UpO1xuXHRcdFx0Ly8gXHQvLyB0aGlzLnBsYXliYWNrUmVxdWVzdGVkICYmIHRoaXMudmlkZW8ucGxheSgpO1xuXHRcdFx0Ly8gXHR0aGlzLl92YWxpZGF0ZVBsYXliYWNrKCk7XG5cdFx0XHQvLyB9KTtcblx0XHRcdC8vfVxuXHRcdFx0LyogTk9URTogb24gXCJjYW5wbGF5dGhyb3VnaFwiIF9wbGF5TWVkaWEoKSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBpZiBzdGlsbCByZXF1aXJlZCAqL1xuXHRcdFx0dGhpcy5fdG9nZ2xlV2FpdGluZyh0cnVlKTtcblx0XHR9XG5cdFx0LyogcGxheSAqL1xuXHRcdGVsc2Uge1xuXHRcdFx0LyogTk9URTogY3VycmVudCBicm93c2VycyByZXR1cm4gYSBwcm9taXNlICovXG5cdFx0XHR0aGlzLnZpZGVvLnBsYXkoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRfcGF1c2VNZWRpYTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gdGhpcy5fc2V0UGxheVRvZ2dsZVN5bWJvbChcInBsYXktc3ltYm9sXCIpO1xuXHRcdHRoaXMudmlkZW8ucGF1c2UoKTtcblx0XHQvLyB0aGlzLl9yZW5kZXJQbGF5YmFja1N0YXRlKCk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIERPTSBldmVudHNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X2xpc3RlbldoaWxlU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFBsYXlhYmxlUmVuZGVyZXIucHJvdG90eXBlLl9saXN0ZW5XaGlsZVNlbGVjdGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5mdWxsc2NyZWVuVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHR0aGlzLl90b2dnbGVFdmVudCwgdGhpcy5fb25GdWxsc2NyZWVuVG9nZ2xlLCBmYWxzZSk7XG5cdH0sXG5cblx0X3N0b3BMaXN0ZW5pbmdXaGlsZVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5fc3RvcExpc3RlbmluZ1doaWxlU2VsZWN0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR0aGlzLmZ1bGxzY3JlZW5Ub2dnbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcblx0XHRcdHRoaXMuX3RvZ2dsZUV2ZW50LCB0aGlzLl9vbkZ1bGxzY3JlZW5Ub2dnbGUsIGZhbHNlKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogbWVkaWEgZXZlbnRzXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdGFkZE1lZGlhTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcblx0XHQvLyBcdHRoaXMuYWRkTGlzdGVuZXJzKHRoaXMudmlkZW8sIHRoaXMucGxheWluZ09uY2VFdmVudHMsIHRoaXMuX29uTWVkaWFQbGF5aW5nT25jZSk7XG5cdFx0Ly8gfVxuXHRcdHRoaXMuYWRkTGlzdGVuZXJzKHRoaXMudmlkZW8sIHRoaXMudXBkYXRlUGxheWJhY2tFdmVudHMsIHRoaXMuX3VwZGF0ZVBsYXliYWNrU3RhdGUpO1xuXHRcdHRoaXMuYWRkTGlzdGVuZXJzKHRoaXMudmlkZW8sIHRoaXMudXBkYXRlQnVmZmVyZWRFdmVudHMsIHRoaXMuX3VwZGF0ZUJ1ZmZlcmVkVmFsdWUpO1xuXHRcdHRoaXMuYWRkTGlzdGVuZXJzKHRoaXMudmlkZW8sIHRoaXMudXBkYXRlQ3VyclRpbWVFdmVudHMsIHRoaXMuX3VwZGF0ZUN1cnJUaW1lVmFsdWUpO1xuXHRcdHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHRoaXMuX29uTWVkaWFFbmRlZCwgZmFsc2UpO1xuXHRcdHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uTWVkaWFFcnJvciwgdHJ1ZSk7XG5cblx0XHR0aGlzLm9uKFwidmlldzpyZW1vdmVkXCIsIHRoaXMucmVtb3ZlTWVkaWFMaXN0ZW5lcnMsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZU1lZGlhTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm9mZihcInZpZXc6cmVtb3ZlZFwiLCB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzLCB0aGlzKTtcblxuXHRcdC8vIGlmICghdGhpcy5fc3RhcnRlZCkge1xuXHRcdC8vIFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnModGhpcy52aWRlbywgdGhpcy5wbGF5aW5nT25jZUV2ZW50cywgdGhpcy5fb25NZWRpYVBsYXlpbmdPbmNlKTtcblx0XHQvLyB9XG5cdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnModGhpcy52aWRlbywgdGhpcy51cGRhdGVQbGF5YmFja0V2ZW50cywgdGhpcy5fdXBkYXRlUGxheWJhY2tTdGF0ZSk7XG5cdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnModGhpcy52aWRlbywgdGhpcy51cGRhdGVCdWZmZXJlZEV2ZW50cywgdGhpcy5fdXBkYXRlQnVmZmVyZWRWYWx1ZSk7XG5cdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnModGhpcy52aWRlbywgdGhpcy51cGRhdGVDdXJyVGltZUV2ZW50cywgdGhpcy5fdXBkYXRlQ3VyclRpbWVWYWx1ZSk7XG5cdFx0dGhpcy52aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgdGhpcy5fb25NZWRpYUVuZGVkLCBmYWxzZSk7XG5cdFx0dGhpcy52aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25NZWRpYUVycm9yLCB0cnVlKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogbWVkaWEgZXZlbnQgaGFuZGxlcnNcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uTWVkaWFFcnJvcjogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCk7XG5cdFx0dGhpcy5yZW1vdmVTZWxlY3Rpb25MaXN0ZW5lcnMoKTtcblxuXHRcdHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZShcInN0YXJ0ZWRcIik7XG5cblx0XHR0aGlzLm1lZGlhU3RhdGUgPSBcImVycm9yXCI7XG5cdFx0dGhpcy5wbGF5YmFja1JlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdC8vIHRoaXMuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZW5kZWRcIik7XG5cdFx0Ly8gdGhpcy5jb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJ3YWl0aW5nXCIpO1xuXHRcdHRoaXMuX2V4aXRGdWxsc2NyZWVuKCk7XG5cdH0sXG5cblx0X29uTWVkaWFFbmRlZDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnBsYXliYWNrUmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5fZXhpdEZ1bGxzY3JlZW4oKTtcblx0fSxcblxuXHRfZXhpdEZ1bGxzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdC8qIE5PVEU6IHBvbHlmaWxsIHNob3VsZCBoYW5kbGUgdGhpcyBvbiBpT1M/ICovXG5cdFx0aWYgKHRoaXMudmlkZW8ud2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4pIHtcblx0XHRcdHRoaXMudmlkZW8ud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcblx0XHR9XG5cdFx0aWYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ID09PSB0aGlzLnZpZGVvKSB7XG5cdFx0XHR0aGlzLnZpZGVvLmV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiBfb25NZWRpYVBsYXlpbmdPbmNlXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIHBsYXlpbmdPbmNlRXZlbnRzOiBcInBsYXlpbmcgd2FpdGluZ1wiLFxuXHQvL1xuXHQvLyBfb25NZWRpYVBsYXlpbmdPbmNlOiBmdW5jdGlvbihldikge1xuXHQvLyBcdHRoaXMucmVtb3ZlTGlzdGVuZXJzKHRoaXMudmlkZW8sIHRoaXMucGxheWluZ09uY2VFdmVudHMsIHRoaXMuX29uTWVkaWFQbGF5aW5nT25jZSk7XG5cdC8vIFx0aWYgKCF0aGlzLl9zdGFydGVkKSB7XG5cdC8vIFx0XHR0aGlzLl9zdGFydGVkID0gdHJ1ZTtcblx0Ly8gXHRcdHRoaXMuY29udGVudC5jbGFzc0xpc3QuYWRkKFwic3RhcnRlZFwiKTtcblx0Ly8gXHR9XG5cdC8vIH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIF91cGRhdGVDdXJyVGltZVZhbHVlXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHVwZGF0ZUN1cnJUaW1lRXZlbnRzOiBcInBsYXlpbmcgd2FpdGluZyBwYXVzZSB0aW1ldXBkYXRlIHNlZWtlZFwiLCAvLy5zcGxpdChcIiBcIiksXG5cblx0X3VwZGF0ZUN1cnJUaW1lVmFsdWU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKHRoaXMudmlkZW8ucGxheWVkLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5jb250ZW50LmNsYXNzTGlzdC5hZGQoXCJzdGFydGVkXCIpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wcm9ncmVzc01ldGVyKSB7XG5cdFx0XHR0aGlzLnByb2dyZXNzTWV0ZXIudmFsdWVUbyhcImFtb3VudFwiLCB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lLCAwKTtcblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIF91cGRhdGVQbGF5YmFja1N0YXRlXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIHVwZGF0ZVBsYXliYWNrRXZlbnRzOiBcInBsYXlpbmcgcGxheSB3YWl0aW5nIHBhdXNlIHNlZWtpbmcgc2Vla2VkIGVuZGVkXCIsXG5cdHVwZGF0ZVBsYXliYWNrRXZlbnRzOiBcInRpbWV1cGRhdGUgcGxheWluZyBwYXVzZSB3YWl0aW5nIGNhbnBsYXl0aHJvdWdoIHNlZWtlZFwiLFxuXG5cdF9pc1BsYXliYWNrV2FpdGluZzogZmFsc2UsXG5cdF9wbGF5YmFja1N0YXJ0VFM6IC0xLFxuXHRfcGxheWJhY2tTdGFydFRDOiAtMSxcblxuXHRfdXBkYXRlUGxheWJhY2tTdGF0ZTogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyB2YXIgaXNXYWl0aW5nID0gZmFsc2U7XG5cdFx0Ly8gdmFyIHN5bWJvbE5hbWUgPSBcInBsYXktc3ltYm9sXCI7XG5cblx0XHQvLyBOT1RFOiBjbGVhclRpbWVvdXQgd2lsbCBjYW5jZWwgYm90aCBzZXRUaW1lb3V0IGFuZCBzZXRJbnRlcnZhbCBJRHNcblx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3BsYXliYWNrVGltZW91dElEKTtcblx0XHR0aGlzLl9wbGF5YmFja1RpbWVvdXRJRCA9IC0xO1xuXG5cdFx0aWYgKHRoaXMucGxheWJhY2tSZXF1ZXN0ZWQpIHtcblx0XHRcdGlmIChldi50eXBlICE9PSBcInRpbWV1cGRhdGVcIikge1xuXHRcdFx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VFMgPSBldi50aW1lU3RhbXA7XG5cdFx0XHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUQyA9IHRoaXMudmlkZW8uY3VycmVudFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKGV2LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInRpbWV1cGRhdGVcIjpcblx0XHRcdFx0XHRpZiAoU1lOQ19USFJFU0hPTERfTVMgPCBNYXRoLmFicygoZXYudGltZVN0YW1wIC0gdGhpcy5fcGxheWJhY2tTdGFydFRTKSAtXG5cdFx0XHRcdFx0XHRcdCgodGhpcy52aWRlby5jdXJyZW50VGltZSAtIHRoaXMuX3BsYXliYWNrU3RhcnRUQykgKiAxMDAwKSkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUUyA9IGV2LnRpbWVTdGFtcDtcblx0XHRcdFx0XHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUQyA9IHRoaXMudmlkZW8uY3VycmVudFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLl9wbGF5YmFja1RpbWVvdXRJRCA9XG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX3BsYXliYWNrVGltZW91dEZuX3dhaXRpbmcsIFNZTkNfVElNRU9VVF9NUyk7XG5cdFx0XHRcdFx0XHR0aGlzLl90b2dnbGVXYWl0aW5nKHRydWUpO1xuXHRcdFx0XHRcdFx0Ly8gYnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX3BsYXliYWNrVGltZW91dElEID1cblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQodGhpcy5fcGxheWJhY2tUaW1lb3V0Rm5fcGxheWluZywgU1lOQ19USU1FT1VUX01TKTtcblx0XHRcdFx0XHRcdHRoaXMuX3RvZ2dsZVdhaXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwicGxheWluZ1wiOlxuXHRcdFx0XHRcdHRoaXMuX3BsYXliYWNrU3RhcnRUUyA9IGV2LnRpbWVTdGFtcDtcblx0XHRcdFx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VEMgPSB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3BsYXliYWNrVGltZW91dElEID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5fcGxheWJhY2tUaW1lb3V0Rm5fcGxheWluZywgU1lOQ19USU1FT1VUX01TKTtcblx0XHRcdFx0XHR0aGlzLl90b2dnbGVXYWl0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwicGF1c2VcIjpcblx0XHRcdFx0XHQvKiBOT1RFOiB0aGlzLnBsYXliYWNrUmVxdWVzdGVkIGlzIHRydWUsIHRoZSBwYXVzZSB3YXNuJ3QgdHJpZ2dlcmVkXG5cdFx0XHRcdFx0ICogZnJvbSBVSSwgYnV0IGJ5IHRoZSB3YWl0aW5nIGhhbmRsZXIgYmVsb3csIHNvIHdlIHRyZWF0IGl0IGFzXG5cdFx0XHRcdFx0ICogd2FpdGluZyAqL1xuXHRcdFx0XHRcdC8vIGlmICghdGhpcy5wbGF5YmFja1JlcXVlc3RlZCkge1xuXHRcdFx0XHRcdC8vIFx0dGhpcy5fdG9nZ2xlV2FpdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdHRoaXMuX3RvZ2dsZVdhaXRpbmcodGhpcy5wbGF5YmFja1JlcXVlc3RlZCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcImNhbnBsYXl0aHJvdWdoXCI6XG5cdFx0XHRcdFx0dGhpcy5fdG9nZ2xlV2FpdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0dGhpcy5fdmFsaWRhdGVQbGF5YmFjaygpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJ3YWl0aW5nXCI6XG5cdFx0XHRcdFx0LyogTk9URTogaWYgdGhlIHZpZGVvIGlzIHNlZWtpbmcsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcmVzdW1lLCBzbyBkb1xuXHRcdFx0XHRcdCAqIG5vdGhpbmcsIGFuZCBoYW5kbGUgdGhpbmdzIG9uIHNlZWtlZC9wbGF5aW5nICovXG5cdFx0XHRcdFx0aWYgKCF0aGlzLnZpZGVvLnNlZWtpbmcpIHtcblx0XHRcdFx0XHRcdC8qIGlmIG5vdCBlbm91Z2ggZGF0YSAqL1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA8IEhUTUxNZWRpYUVsZW1lbnQuSEFWRV9FTk9VR0hfREFUQSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnZpZGVvLnBhdXNlKCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gdGhpcy5saXN0ZW5Ub0VsZW1lbnRPbmNlKHRoaXMudmlkZW8sIFwiY2FucGxheXRocm91Z2hcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFx0dGhpcy5fdG9nZ2xlV2FpdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdC8vIFx0dGhpcy5fdmFsaWRhdGVQbGF5YmFjaygpO1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzLnBsYXliYWNrUmVxdWVzdGVkICYmIHRoaXMudmlkZW8ucGxheSgpO1xuXHRcdFx0XHRcdFx0XHQvLyB9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3RvZ2dsZVdhaXRpbmcodHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhpcy5fdG9nZ2xlV2FpdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RvZ2dsZVdhaXRpbmcoZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHRfcGxheWJhY2tUaW1lb3V0SUQ6IC0xLFxuXHRfcGxheWJhY2tUaW1lb3V0Rm5fcGxheWluZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGxheWJhY2tUaW1lb3V0SUQgPSAtMTtcblxuXHRcdHRoaXMuX3RvZ2dsZVdhaXRpbmcodHJ1ZSk7XG5cdFx0Ly8gdGhpcy5fcmVuZGVyUGxheWJhY2tTdGF0ZSgpO1xuXG5cdFx0Ly8gdGhpcy5fc2V0UGxheVRvZ2dsZVN5bWJvbChcIndhaXRpbmctc3ltYm9sXCIpO1xuXHRcdC8vIHRoaXMuY29udGVudC5jbGFzc0xpc3QuYWRkKFwid2FpdGluZ1wiKTtcblx0XHQvLyB0aGlzLnByb2dyZXNzTWV0ZXIuc3RhbGxlZCA9IHRydWU7XG5cdFx0Ly8gdGhpcy5faXNQbGF5YmFja1dhaXRpbmcgPSB0cnVlO1xuXHR9LFxuXG5cdF9wbGF5YmFja1RpbWVvdXRGbl93YWl0aW5nOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoU1lOQ19USFJFU0hPTERfTVMgPCAodGhpcy52aWRlby5jdXJyZW50VGltZSAtIHRoaXMuX3BsYXliYWNrU3RhcnRUQykgKiAxMDAwKSB7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1RpbWVvdXRJRCA9XG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX3BsYXliYWNrVGltZW91dEZuX3dhaXRpbmcsIFNZTkNfVElNRU9VVF9NUyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHNpbmNlIHRoZXJlIGlzIG5vIGV2ZW50LnRpbWVTdGFtcFxuXHRcdFx0Ly8gdmFyIGRlbHRhID0gdGhpcy52aWRlby5jdXJyZW50VGltZSAtIHRoaXMuX3BsYXliYWNrU3RhcnRUQztcblx0XHRcdC8vIHRoaXMuX3BsYXliYWNrU3RhcnRUUyArPSBkZWx0YSAqIDEwMDA7XG5cdFx0XHQvLyB0aGlzLl9wbGF5YmFja1N0YXJ0VFMgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHR0aGlzLl9wbGF5YmFja1N0YXJ0VFMgKz0gU1lOQ19USU1FT1VUX01TO1xuXHRcdFx0dGhpcy5fcGxheWJhY2tTdGFydFRDID0gdGhpcy52aWRlby5jdXJyZW50VGltZTtcblx0XHRcdHRoaXMuX3BsYXliYWNrVGltZW91dElEID1cblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQodGhpcy5fcGxheWJhY2tUaW1lb3V0Rm5fcGxheWluZywgU1lOQ19USU1FT1VUX01TKTtcblxuXHRcdFx0dGhpcy5fdG9nZ2xlV2FpdGluZyhmYWxzZSk7XG5cdFx0XHQvLyB0aGlzLl9yZW5kZXJQbGF5YmFja1N0YXRlKCk7XG5cblx0XHRcdC8vIHRoaXMuX3NldFBsYXlUb2dnbGVTeW1ib2woXCJwYXVzZS1zeW1ib2xcIik7XG5cdFx0XHQvLyB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZShcIndhaXRpbmdcIik7XG5cdFx0XHQvLyB0aGlzLnByb2dyZXNzTWV0ZXIuc3RhbGxlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gdGhpcy5faXNQbGF5YmFja1dhaXRpbmcgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqIEBvdmVycmlkZSAqL1xuXHRfcmVuZGVyUGxheWJhY2tTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaWYgKERFQlVHKSB7XG5cdFx0Ly8gXHR0aGlzLl9fbG9nTWVzc2FnZShbXG5cdFx0Ly8gXHRcIm1lZGlhU3RhdGU6XCIsIHRoaXMubWVkaWFTdGF0ZSxcblx0XHQvLyBcdFwicGxheWVkOlwiLCB0aGlzLnZpZGVvLnBsYXllZC5sZW5ndGgsXG5cdFx0Ly8gXHRcImVuZGVkOlwiLCB0aGlzLnZpZGVvLmVuZGVkLFxuXHRcdC8vIFx0XCJ0b2dnbGUucGF1c2VkOlwiLCB0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sLnBhdXNlZFxuXHRcdC8vIF0uam9pbihcIiBcIiksIFwiX3JlbmRlclBsYXliYWNrU3RhdGVcIik7XG5cdFx0Ly8gfVxuXHRcdC8vIGNvbnNvbGUubG9nKFwiJXM6Ol9yZW5kZXJQbGF5YmFja1N0YXRlIG1lZGlhU3RhdGU6JXMgcGxheWVkOiVvIGVuZGVkOiVvXCIsXG5cdFx0Ly8gXHR0aGlzLmNpZCwgdGhpcy5tZWRpYVN0YXRlLCB0aGlzLnZpZGVvLnBsYXllZC5sZW5ndGgsIHRoaXMudmlkZW8uZW5kZWQpO1xuXHRcdC8vXG5cdFx0Ly8gaWYgKHRoaXMubWVkaWFTdGF0ZSA9PT0gXCJyZWFkeVwiKSB7XG5cdFx0Ly8gXHR0aGlzLnVwZGF0ZU92ZXJsYXkodGhpcy52aWRlbywgdGhpcy5wbGF5VG9nZ2xlKTtcblx0XHQvLyB9XG5cblx0XHR2YXIgY2xzID0gdGhpcy5jb250ZW50LmNsYXNzTGlzdDtcblx0XHQvLyBpZiAoIXRoaXMuX3N0YXJ0ZWQgJiYgdGhpcy5wbGF5YmFja1JlcXVlc3RlZCAmJlxuXHRcdC8vIFx0XHR0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPT09IEhUTUxNZWRpYUVsZW1lbnQuSEFWRV9FTk9VR0hfREFUQSkge1xuXHRcdC8vIFx0dGhpcy5fc3RhcnRlZCA9IHRydWU7XG5cdFx0Ly8gXHRjbHMuYWRkKFwic3RhcnRlZFwiKTtcblx0XHQvLyB9XG5cdFx0Ly8gY2xzLnRvZ2dsZShcInN0YXJ0ZWRcIiwgKHRoaXMudmlkZW8ucGxheWVkLmxlbmd0aCA+IDApKTtcblx0XHRjbHMudG9nZ2xlKFwiZW5kZWRcIiwgdGhpcy52aWRlby5lbmRlZCk7XG5cblx0XHRQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyUGxheWJhY2tTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9zZXRQbGF5VG9nZ2xlU3ltYm9sOiBmdW5jdGlvbihzeW1ib2xOYW1lKSB7XG5cdFx0Ly8gaWYgKHRoaXMudmlkZW8uZW5kZWQpIHtcblx0XHQvLyBcdGNvbnNvbGUubG9nKFwiJXM6Ol9zZXRQbGF5VG9nZ2xlU3ltYm9sICVzIC0+IGVuZGVkXCIsIHRoaXMuY2lkLCBzeW1ib2xOYW1lKTtcblx0XHQvLyB9XG5cdFx0Ly8gaWYgKHRoaXMubWVkaWFTdGF0ZSA9PT0gXCJyZWFkeVwiKSB7XG5cdFx0Ly8gXHRpZiAodGhpcy5wbGF5YmFja1JlcXVlc3RlZCAmJiAhdGhpcy5faXNNZWRpYVdhaXRpbmcoKSkge1xuXHRcdC8vIFx0XHR0aGlzLl9wbGF5VG9nZ2xlU3ltYm9sLnNldEltYWdlU291cmNlKG51bGwpO1xuXHRcdC8vIFx0fSBlbHNlIHtcblx0XHQvLyBcdFx0dGhpcy5fcGxheVRvZ2dsZVN5bWJvbC5zZXRJbWFnZVNvdXJjZSh0aGlzLnZpZGVvKTtcblx0XHQvLyBcdH1cblx0XHQvLyBcdHRoaXMuX3BsYXlUb2dnbGVTeW1ib2wucmVmcmVzaEltYWdlU291cmNlKCk7XG5cdFx0Ly8gfVxuXHRcdHJldHVybiBQbGF5YWJsZVJlbmRlcmVyLnByb3RvdHlwZS5fc2V0UGxheVRvZ2dsZVN5bWJvbC5jYWxsKHRoaXMsIHRoaXMudmlkZW8uZW5kZWQgPyBcImVuZGVkXCIgOiBzeW1ib2xOYW1lKTtcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogX3VwZGF0ZUJ1ZmZlcmVkVmFsdWVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gdXBkYXRlQnVmZmVyZWRFdmVudHM6IFwicHJvZ3Jlc3MgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBwbGF5aW5nIHRpbWV1cGRhdGVcIiwvL2xvYWRlZGRhdGFcblx0dXBkYXRlQnVmZmVyZWRFdmVudHM6IFwicHJvZ3Jlc3MgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBwbGF5IHBsYXlpbmdcIixcblxuXHRfdXBkYXRlQnVmZmVyZWRWYWx1ZTogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHJldHVybjtcblx0XHR2YXIgYlJhbmdlcyA9IHRoaXMudmlkZW8uYnVmZmVyZWQ7XG5cdFx0aWYgKGJSYW5nZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5fYnVmZmVyZWRWYWx1ZSA9IGJSYW5nZXMuZW5kKGJSYW5nZXMubGVuZ3RoIC0gMSk7XG5cdFx0XHRpZiAodGhpcy5wcm9ncmVzc01ldGVyICYmICgodGhpcy52aWRlby5yZWFkeVN0YXRlID49IEhUTUxNZWRpYUVsZW1lbnQuSEFWRV9DVVJSRU5UX0RBVEEpIC8qfHwgKHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA+PSBIVE1MTWVkaWFFbGVtZW50LkhBVkVfQ1VSUkVOVF9EQVRBICYmIHRoaXMudmlkZW8ubmV0d29ya1N0YXRlID09IEhUTUxNZWRpYUVsZW1lbnQuTkVUV09SS19MT0FESU5HKSovICkpIHtcblx0XHRcdFx0dGhpcy5wcm9ncmVzc01ldGVyLnZhbHVlVG8oXCJhdmFpbGFibGVcIiwgdGhpcy5fYnVmZmVyZWRWYWx1ZSwgMzAwKTtcblx0XHRcdFx0Ly8gdGhpcy5wcm9ncmVzc01ldGVyLnZhbHVlVG8oXCJhdmFpbGFibGVcIiwgdGhpcy5fYnVmZmVyZWRWYWx1ZSwgTWF0aC5tYXgoMCwgMTAwMCAqICh0aGlzLl9idWZmZXJlZFZhbHVlIC0gKHRoaXMucHJvZ3Jlc3NNZXRlci5nZXRUYXJnZXRWYWx1ZShcImF2YWlsYWJsZVwiKSB8IDApKSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogZnVsbHNjcmVlbiBhcGlcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X29uRnVsbHNjcmVlblRvZ2dsZTogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBOT1RFOiBJZ25vcmUgaWYgTW91c2VFdmVudC5idXR0b24gaXMgMCBvciB1bmRlZmluZWQgKDA6IGxlZnQtYnV0dG9uKVxuXHRcdGlmICghZXYuZGVmYXVsdFByZXZlbnRlZCAmJiAhZXYuYnV0dG9uICYmIHRoaXMubW9kZWwuc2VsZWN0ZWQpIHtcblx0XHRcdGV2LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoZG9jdW1lbnQuaGFzT3duUHJvcGVydHkoXCJmdWxsc2NyZWVuRWxlbWVudFwiKSAmJlxuXHRcdFx0XHRcdGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ICE9PSB0aGlzLnZpZGVvKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihmdWxsc2NyZWVuQ2hhbmdlRXZlbnQsIHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuXHRcdFx0XHRcdHRoaXMudmlkZW8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdGlmICh0aGlzLnZpZGVvLndlYmtpdFN1cHBvcnRzRnVsbHNjcmVlbiAmJiAhdGhpcy52aWRlby53ZWJraXREaXNwbGF5aW5nRnVsbHNjcmVlbikge1xuXHRcdFx0XHRcdHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdGJlZ2luZnVsbHNjcmVlblwiLCB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcblx0XHRcdFx0XHR0aGlzLnZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dGhpcy52aWRlby5jb250cm9scyA9IGZhbHNlO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkZ1bGxzY3JlZW5DaGFuZ2U6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0c3dpdGNoIChldi50eXBlKSB7XG5cdFx0XHRjYXNlIGZ1bGxzY3JlZW5DaGFuZ2VFdmVudDpcblx0XHRcdFx0Ly8gdmFyIGlzT3duRnVsbHNjcmVlbiA9IE1vZGVybml6ci5wcmVmaXhlZChcImZ1bGxzY3JlZW5FbGVtZW50XCIsIGRvY3VtZW50KSA9PT0gdGhpcy52aWRlbztcblx0XHRcdFx0dmFyIGlzT3duRnVsbHNjcmVlbiA9IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50ID09PSB0aGlzLnZpZGVvO1xuXHRcdFx0XHR0aGlzLnZpZGVvLmNvbnRyb2xzID0gaXNPd25GdWxsc2NyZWVuO1xuXHRcdFx0XHRpZiAoIWlzT3duRnVsbHNjcmVlbikge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZnVsbHNjcmVlbkNoYW5nZUV2ZW50LCB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cIjpcblx0XHRcdFx0dGhpcy52aWRlby5jb250cm9scyA9IHRydWU7XG5cdFx0XHRcdHRoaXMudmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdGJlZ2luZnVsbHNjcmVlblwiLCB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcblx0XHRcdFx0dGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0ZW5kZnVsbHNjcmVlblwiLCB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwid2Via2l0ZW5kZnVsbHNjcmVlblwiOlxuXHRcdFx0XHR0aGlzLnZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRlbmRmdWxsc2NyZWVuXCIsIHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuXHRcdFx0XHR0aGlzLnZpZGVvLmNvbnRyb2xzID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1JlbmRlcmVyO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIGxvZyB0byBzY3JlZW5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuaWYgKERFQlVHKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKFZpZGVvUmVuZGVyZXIpIHtcblx0XHRpZiAoIVZpZGVvUmVuZGVyZXIuTE9HX1RPX1NDUkVFTikgcmV0dXJuIFZpZGVvUmVuZGVyZXI7XG5cblx0XHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuXHRcdHZhciBDb2xvciA9IHJlcXVpcmUoXCJjb2xvclwiKTtcblx0XHQvKiogQHR5cGUge21vZHVsZTp1bmRlcnNjb3JlLnN0cmluZ3MvbHBhZH0gKi9cblx0XHR2YXIgbHBhZCA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlLnN0cmluZy9scGFkXCIpO1xuXHRcdC8qKiBAdHlwZSB7bW9kdWxlOnVuZGVyc2NvcmUuc3RyaW5ncy9ycGFkfSAqL1xuXHRcdHZhciBycGFkID0gcmVxdWlyZShcInVuZGVyc2NvcmUuc3RyaW5nL3JwYWRcIik7XG5cblx0XHQvLyB2YXIgZnVsbHNjcmVlbkV2ZW50cyA9IFtcblx0XHQvLyBcdGZ1bGxzY3JlZW5DaGFuZ2VFdmVudCwgZnVsbHNjcmVlbkVycm9yRXZlbnQsXG5cdFx0Ly8gXHRcIndlYmtpdGJlZ2luZnVsbHNjcmVlblwiLCBcIndlYmtpdGVuZGZ1bGxzY3JlZW5cIixcblx0XHQvLyBdO1xuXG5cdFx0dmFyIG1lZGlhRXZlbnRzID0gcmVxdWlyZShcInV0aWxzL2V2ZW50L21lZGlhRXZlbnRzRW51bVwiKTtcblx0XHR2YXIgbG9nUGxheWJhY2tTdGF0ZUV2ZW50cywgbG9nQnVmZmVyZWRFdmVudHMsIGxvZ1BsYXllZEV2ZW50cztcblxuXHRcdC8vIGxvZ1BsYXliYWNrU3RhdGVFdmVudHMgPSBbXCJwbGF5aW5nXCIsIFwid2FpdGluZ1wiLCBcImVuZGVkXCIsIFwicGF1c2VcIiwgXCJzZWVraW5nXCIsIFwic2Vla2VkXCJdO1xuXHRcdC8vIGxvZ0J1ZmZlcmVkRXZlbnRzID0gW1wicHJvZ3Jlc3NcIiwgXCJkdXJhdGlvbmNoYW5nZVwiLCBcImNhbnBsYXlcIiwgXCJwbGF5XCJdO1xuXHRcdC8vIGxvZ1BsYXllZEV2ZW50cyA9IFtcInBsYXlpbmdcIiwgXCJ0aW1ldXBkYXRlXCJdO1xuXG5cdFx0bG9nUGxheWJhY2tTdGF0ZUV2ZW50cyA9IFtcblx0XHRcdFwibG9hZHN0YXJ0XCIsXG5cdFx0XHRcInByb2dyZXNzXCIsXG5cdFx0XHRcInN1c3BlbmRcIixcblx0XHRcdFwiYWJvcnRcIixcblx0XHRcdFwiZXJyb3JcIixcblx0XHRcdFwiZW1wdGllZFwiLFxuXHRcdFx0XCJzdGFsbGVkXCIsXG5cdFx0XTtcblx0XHRsb2dCdWZmZXJlZEV2ZW50cyA9IFtcblx0XHRcdFwibG9hZGVkbWV0YWRhdGFcIixcblx0XHRcdFwibG9hZGVkZGF0YVwiLFxuXHRcdFx0XCJjYW5wbGF5XCIsXG5cdFx0XHRcImNhbnBsYXl0aHJvdWdoXCIsXG5cdFx0XHRcInBsYXlpbmdcIixcblx0XHRcdFwid2FpdGluZ1wiLFxuXHRcdFx0XCJzZWVraW5nXCIsIC8vIHNlZWtpbmcgY2hhbmdlZCB0byB0cnVlXG5cdFx0XHRcInNlZWtlZFwiLCAvLyBzZWVraW5nIGNoYW5nZWQgdG8gZmFsc2Vcblx0XHRcdFwiZW5kZWRcIiwgLy8gZW5kZWQgaXMgdHJ1ZVxuXHRcdF07XG5cdFx0bG9nUGxheWVkRXZlbnRzID0gW1xuXHRcdFx0XCJwbGF5XCIsXG5cdFx0XHRcInBhdXNlXCJcblx0XHRdO1xuXG5cdFx0Ly8gRXhjbHVkZSBzb21lIGV2ZW50cyBmcm9tIGxvZ1xuXHRcdG1lZGlhRXZlbnRzID0gXy53aXRob3V0KG1lZGlhRXZlbnRzLCBcInJlc2l6ZVwiLCBcImVycm9yXCIpO1xuXHRcdC8vIE1ha2Ugc3VyZSBldmVudCBzdWJzZXRzIGV4aXN0IGluIHRoZSBtYWluIHNldFxuXHRcdGxvZ1BsYXliYWNrU3RhdGVFdmVudHMgPSBfLmludGVyc2VjdGlvbihtZWRpYUV2ZW50cywgbG9nUGxheWJhY2tTdGF0ZUV2ZW50cyk7XG5cdFx0bG9nQnVmZmVyZWRFdmVudHMgPSBfLmludGVyc2VjdGlvbihtZWRpYUV2ZW50cywgbG9nQnVmZmVyZWRFdmVudHMpO1xuXHRcdGxvZ1BsYXllZEV2ZW50cyA9IF8uaW50ZXJzZWN0aW9uKG1lZGlhRXZlbnRzLCBsb2dQbGF5ZWRFdmVudHMpO1xuXG5cdFx0dmFyIHJlYWR5U3RhdGVTeW1ib2xzID0gXy5pbnZlcnQoXy5waWNrKEhUTUxNZWRpYUVsZW1lbnQsXG5cdFx0XHRmdW5jdGlvbih2YWwsIGtleSwgb2JqKSB7XG5cdFx0XHRcdHJldHVybiAvXkhBVkVfLy50ZXN0KGtleSk7XG5cdFx0XHR9KSk7XG5cdFx0dmFyIHJlYWR5U3RhdGVUb1N0cmluZyA9IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gcmVhZHlTdGF0ZVN5bWJvbHNbZWwucmVhZHlTdGF0ZV0gKyBcIihcIiArIGVsLnJlYWR5U3RhdGUgKyBcIilcIjtcblx0XHR9O1xuXG5cdFx0dmFyIG5ldHdvcmtTdGF0ZVN5bWJvbHMgPSBfLmludmVydChfLnBpY2soSFRNTE1lZGlhRWxlbWVudCxcblx0XHRcdGZ1bmN0aW9uKHZhbCwga2V5LCBvYmopIHtcblx0XHRcdFx0cmV0dXJuIC9eTkVUV09SS18vLnRlc3Qoa2V5KTtcblx0XHRcdH0pKTtcblx0XHR2YXIgbmV0d29ya1N0YXRlVG9TdHJpbmcgPSBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIG5ldHdvcmtTdGF0ZVN5bWJvbHNbZWwubmV0d29ya1N0YXRlXSArIFwiKFwiICsgZWwubmV0d29ya1N0YXRlICsgXCIpXCI7XG5cdFx0fTtcblxuXHRcdHZhciBtZWRpYUVycm9yU3ltYm9scyA9IF8uaW52ZXJ0KE1lZGlhRXJyb3IpO1xuXHRcdHZhciBtZWRpYUVycm9yVG9TdHJpbmcgPSBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIGVsLmVycm9yID8gbWVkaWFFcnJvclN5bWJvbHNbZWwuZXJyb3IuY29kZV0gKyBcIihcIiArIGVsLmVycm9yLmNvZGUgKyBcIilcIiA6IFwiW01lZGlhRXJyb3IgbnVsbF1cIjtcblx0XHR9O1xuXG5cdFx0dmFyIGZpbmRSYW5nZUluZGV4ID0gZnVuY3Rpb24ocmFuZ2UsIGN1cnJUaW1lKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWkgPSByYW5nZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0XHRcdGlmIChyYW5nZS5zdGFydChpKSA8PSBjdXJyVGltZSAmJiBjdXJyVGltZSA8PSByYW5nZS5lbmQoaSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cblx0XHR2YXIgZm9ybWF0VmlkZW9FcnJvciA9IGZ1bmN0aW9uKHZpZGVvKSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRtZWRpYUVycm9yVG9TdHJpbmcodmlkZW8pLFxuXHRcdFx0XHRuZXR3b3JrU3RhdGVUb1N0cmluZyh2aWRlbyksXG5cdFx0XHRcdHJlYWR5U3RhdGVUb1N0cmluZyh2aWRlbyksXG5cdFx0XHRdLmpvaW4oXCIgXCIpO1xuXHRcdH07XG5cblx0XHR2YXIgZ2V0VmlkZW9TdGF0c0NvbHMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBcIjAwMDAuMDAwIFtDdXJyL1RvdGFsXSBbU2Vla2FibGVdICBbQnVmZmVyZWRdICBuZXR3b3JrU3RhdGUgcmVhZHlTdGF0ZSAgICAgIFBsYXliYWNrXCI7XG5cdFx0XHQvLyByZXR1cm4gXCIwMDAwLjYyMCBbdDogIDAuMCAgMjcuNF0gW3M6IDI3LjQgMC8xXSBbYjogIDAuNSAwLzFdIExPQURJTkcoMikgICBGVVRVUkVfREFUQSgzKSAgOjogKDo6KVwiO1xuXHRcdH1cblxuXHRcdHZhciBmb3JtYXRWaWRlb1N0YXRzID0gZnVuY3Rpb24odmlkZW8pIHtcblx0XHRcdHZhciBjdXJyVGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lLFxuXHRcdFx0XHRkdXJUaW1lID0gdmlkZW8uZHVyYXRpb24sXG5cdFx0XHRcdGJSYW5nZXMgPSB2aWRlby5idWZmZXJlZCxcblx0XHRcdFx0YlJhbmdlSWR4LFxuXHRcdFx0XHRzUmFuZ2VzID0gdmlkZW8uc2Vla2FibGUsXG5cdFx0XHRcdHNSYW5nZUlkeDtcblxuXHRcdFx0YlJhbmdlSWR4ID0gZmluZFJhbmdlSW5kZXgoYlJhbmdlcywgY3VyclRpbWUpO1xuXHRcdFx0c1JhbmdlSWR4ID0gZmluZFJhbmdlSW5kZXgoc1JhbmdlcywgY3VyclRpbWUpO1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XCJbXCIgKyBscGFkKGN1cnJUaW1lLnRvRml4ZWQoMSksIDUpICtcblx0XHRcdFx0XHRcIiBcIiArIGxwYWQoKCFpc05hTihkdXJUaW1lKSA/IGR1clRpbWUudG9GaXhlZCgxKSA6IFwiLVwiKSwgNCkgKyBcIl1cIixcblx0XHRcdFx0XCJbXCIgKyBscGFkKChzUmFuZ2VJZHggPj0gMCA/IHNSYW5nZXMuZW5kKHNSYW5nZUlkeCkudG9GaXhlZCgxKSA6IFwiLVwiKSwgNSkgK1xuXHRcdFx0XHRcdFwiIFwiICsgKHNSYW5nZUlkeCA+PSAwID8gc1JhbmdlSWR4IDogXCItXCIpICsgXCIvXCIgKyBzUmFuZ2VzLmxlbmd0aCArIFwiXVwiLFxuXHRcdFx0XHRcIltcIiArIGxwYWQoKGJSYW5nZUlkeCA+PSAwID8gYlJhbmdlcy5lbmQoYlJhbmdlSWR4KS50b0ZpeGVkKDEpIDogXCItXCIpLCA1KSArXG5cdFx0XHRcdFx0XCIgXCIgKyAoYlJhbmdlSWR4ID49IDAgPyBiUmFuZ2VJZHggOiBcIi1cIikgKyBcIi9cIiArIGJSYW5nZXMubGVuZ3RoICsgXCJdXCIsXG5cdFx0XHRcdHJwYWQobmV0d29ya1N0YXRlVG9TdHJpbmcodmlkZW8pLnN1YnN0cig4KSwgMTIpLFxuXHRcdFx0XHRycGFkKHJlYWR5U3RhdGVUb1N0cmluZyh2aWRlbykuc3Vic3RyKDUpLCAxNSksXG5cdFx0XHRcdCh2aWRlby5lbmRlZCA/IFwiPjpcIiA6ICh2aWRlby5wYXVzZWQgPyBcIjo6XCIgOiBcIj4+XCIpKVxuXHRcdFx0XHQvLyB2aWRlby5wbGF5YmFja1JhdGUudG9GaXhlZCgyKSArIFwiIChcIiArIHZpZGVvLmRlZmF1bHRQbGF5YmFja1JhdGUudG9GaXhlZCgyKSArIFwiKVwiXG5cdFx0XHRdOyAvLy5qb2luKFwiIFwiKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFZpZGVvUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRcdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFZpZGVvUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0XHRfLmJpbmRBbGwodGhpcywgXCJfX2hhbmRsZU1lZGlhRXZlbnRcIik7XG5cblx0XHRcdFx0dmFyIGZnQ29sb3IgPSB0aGlzLm1vZGVsLmF0dHIoXCJjb2xvclwiKSxcblx0XHRcdFx0XHRyZWQgPSBuZXcgQ29sb3IoXCJyZWRcIiksXG5cdFx0XHRcdFx0Ymx1ZSA9IG5ldyBDb2xvcihcImJsdWVcIiksXG5cdFx0XHRcdFx0Z3JlZW4gPSBuZXcgQ29sb3IoXCJncmVlblwiKTtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGV2ID0gbWVkaWFFdmVudHNbaV07XG5cdFx0XHRcdFx0dGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKGV2LCB0aGlzLl9faGFuZGxlTWVkaWFFdmVudCwgZmFsc2UpO1xuXG5cdFx0XHRcdFx0dmFyIGMgPSBuZXcgQ29sb3IoZmdDb2xvciksXG5cdFx0XHRcdFx0XHRjYyA9IDE7XG5cdFx0XHRcdFx0aWYgKGxvZ0J1ZmZlcmVkRXZlbnRzLmluZGV4T2YoZXYpICE9IC0xKSBjLm1peChncmVlbiwgKGNjIC89IDIpKTtcblx0XHRcdFx0XHRpZiAobG9nUGxheWVkRXZlbnRzLmluZGV4T2YoZXYpICE9IC0xKSBjLm1peChyZWQsIChjYyAvPSAyKSk7XG5cdFx0XHRcdFx0aWYgKGxvZ1BsYXliYWNrU3RhdGVFdmVudHMuaW5kZXhPZihldikgIT0gLTEpIGMubWl4KGJsdWUsIChjYyAvPSAyKSk7XG5cdFx0XHRcdFx0dGhpcy5fX2xvZ0NvbG9yc1tldl0gPSBjLnJnYigpLnN0cmluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX19oYW5kbGVNZWRpYUV2ZW50LCB0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFZpZGVvUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKG1lZGlhRXZlbnRzW2ldID09IFwiZXJyb3JcIikgY29udGludWU7XG5cdFx0XHRcdFx0dGhpcy52aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKG1lZGlhRXZlbnRzW2ldLCB0aGlzLl9faGFuZGxlTWVkaWFFdmVudCwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX19oYW5kbGVNZWRpYUV2ZW50LCB0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdC8vIF9vblZpc2liaWxpdHlDaGFuZ2U6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHQvLyBcdFZpZGVvUmVuZGVyZXIucHJvdG90eXBlLl9vblZpc2liaWxpdHlDaGFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdC8vIFx0dmFyIHN0YXRlVmFsID0gTW9kZXJuaXpyLnByZWZpeGVkKFwidmlzaWJpbGl0eVN0YXRlXCIsIGRvY3VtZW50KTtcblx0XHRcdC8vIFx0dGhpcy5fX2xvZ0V2ZW50KFwidmlzaWJpbGl0eVN0YXRlOlwiICsgc3RhdGVWYWwsIGV2LnR5cGUgKyBcIjpcIiArIHN0YXRlVmFsKTtcblx0XHRcdC8vIH0sXG5cdFx0XHQvL1xuXHRcdFx0Ly8gLyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0Ly8gX29uRnVsbHNjcmVlbkNoYW5nZTogZnVuY3Rpb24oZXYpIHtcblx0XHRcdC8vIFx0VmlkZW9SZW5kZXJlci5wcm90b3R5cGUuX29uRnVsbHNjcmVlbkNoYW5nZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gXHR2YXIgbG9ndHlwZSA9IChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCA9PT0gdGhpcy52aWRlbyA/IFwiZW50ZXI6XCIgOiBcImV4aXQ6XCIpICsgZXYudHlwZTtcblx0XHRcdC8vIFx0dGhpcy5fX2xvZ0V2ZW50KFwiZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQ6IFwiICsgdGhpcy5jaWQsIGxvZ3R5cGUpO1xuXHRcdFx0Ly8gfSxcblxuXHRcdFx0LyoqIEBvdmVycmlkZSAqL1xuXHRcdFx0X29uRnVsbHNjcmVlblRvZ2dsZTogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aWYgKCFldi5kZWZhdWx0UHJldmVudGVkICYmIHRoaXMubW9kZWwuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHR0aGlzLl9fbG9nRXZlbnQoXCJmdWxsc2NyZWVuLXRvZ2dsZVwiLCBldi50eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRWaWRlb1JlbmRlcmVyLnByb3RvdHlwZS5fb25GdWxsc2NyZWVuVG9nZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiogQG92ZXJyaWRlICovXG5cdFx0XHRfcGxheWJhY2tUaW1lb3V0Rm5fcGxheWluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFZpZGVvUmVuZGVyZXIucHJvdG90eXBlLl9wbGF5YmFja1RpbWVvdXRGbl9wbGF5aW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdC8vIHRoaXMuX19sb2dFdmVudChmb3JtYXRWaWRlb1N0YXRzKHRoaXMudmlkZW8pLmpvaW4oXCIgXCIpLCBcInRpbWVvdXQtcGxheVwiKTtcblx0XHRcdFx0dGhpcy5fX2hhbmRsZU1lZGlhRXZlbnQoe1xuXHRcdFx0XHRcdHR5cGU6IFwidGltZW91dC1wbGF5XCIsXG5cdFx0XHRcdFx0dGltZVN0YW1wOiBudWxsLFxuXHRcdFx0XHRcdGlzVGltZW91dDogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKiBAb3ZlcnJpZGUgKi9cblx0XHRcdF9wbGF5YmFja1RpbWVvdXRGbl93YWl0aW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0VmlkZW9SZW5kZXJlci5wcm90b3R5cGUuX3BsYXliYWNrVGltZW91dEZuX3dhaXRpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0Ly8gdGhpcy5fX2xvZ0V2ZW50KGZvcm1hdFZpZGVvU3RhdHModGhpcy52aWRlbykuam9pbihcIiBcIiksIFwidGltZW91dC13YWl0XCIpO1xuXHRcdFx0XHR0aGlzLl9faGFuZGxlTWVkaWFFdmVudCh7XG5cdFx0XHRcdFx0dHlwZTogXCJ0aW1lb3V0LXdhaXRcIixcblx0XHRcdFx0XHR0aW1lU3RhbXA6IG51bGwsXG5cdFx0XHRcdFx0aXNUaW1lb3V0OiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0X19oYW5kbGVNZWRpYUV2ZW50OiBmdW5jdGlvbihldikge1xuXHRcdFx0XHR2YXIgZXZtc2cgPSBmb3JtYXRWaWRlb1N0YXRzKHRoaXMudmlkZW8pO1xuXG5cdFx0XHRcdGlmICh0aGlzLnBsYXliYWNrUmVxdWVzdGVkID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0ZXZtc2cucHVzaChcIig+PilcIik7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5wbGF5YmFja1JlcXVlc3RlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRldm1zZy5wdXNoKFwiKDo6KVwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRldm1zZy5wdXNoKFwiKC0tKVwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLnBsYXliYWNrUmVxdWVzdGVkKSB7XG5cdFx0XHRcdFx0ZXZtc2cucHVzaCh0aGlzLl9wbGF5YmFja1RpbWVvdXRJRCAhPT0gLTEgPyBcIldcIiA6IFwiLVwiKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRldm1zZy5wdXNoKHRoaXMuX3BsYXliYWNrVGltZW91dElEICE9PSAtMSA/IFwiP1wiIDogXCIhXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGV2bXNnLnB1c2godGhpcy5fcGxheVRvZ2dsZVN5bWJvbC5zeW1ib2xOYW1lKTtcblxuXHRcdFx0XHR2YXIgdHMsIHRjO1xuXHRcdFx0XHRpZiAoKHRoaXMudXBkYXRlUGxheWJhY2tFdmVudHMuaW5kZXhPZihldi50eXBlKSA+IC0xKSB8fCBldi5pc1RpbWVvdXQpIHtcblx0XHRcdFx0XHQvLyBldm1zZy5wdXNoKHRoaXMuX3BsYXliYWNrU3RhcnRUUy50b0ZpeGVkKDIpKTtcblx0XHRcdFx0XHR0cyA9IGV2LnRpbWVTdGFtcCAtIHRoaXMuX3BsYXliYWNrU3RhcnRUUztcblx0XHRcdFx0XHR0YyA9IHRoaXMudmlkZW8uY3VycmVudFRpbWUgLSB0aGlzLl9wbGF5YmFja1N0YXJ0VEM7XG5cdFx0XHRcdFx0dHMgKj0gLjAwMTsgLy8gcyB0byBtc1xuXHRcdFx0XHRcdGV2bXNnLnB1c2goTWF0aC5hYnModGMgLSB0cykudG9GaXhlZCgzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZWxzZSB7XG5cdFx0XHRcdC8vIFx0dHMgPSB0aGlzLl9wbGF5YmFja1N0YXJ0VFM7XG5cdFx0XHRcdC8vIFx0dGMgPSB0aGlzLl9wbGF5YmFja1N0YXJ0VEM7XG5cdFx0XHRcdC8vIH1cblx0XHRcdFx0Ly8gdHMgKj0gLjAwMTsgLy8gcyB0byBtc1xuXHRcdFx0XHQvLyBldm1zZy5wdXNoKE1hdGguYWJzKHRjIC0gdHMpLnRvRml4ZWQoMykpO1xuXHRcdFx0XHQvLyBldm1zZy5wdXNoKFwiVEM6XCIgKyB0Yy50b0ZpeGVkKDMpKTtcblx0XHRcdFx0Ly8gZXZtc2cucHVzaChcIlRTOlwiICsgdHMudG9GaXhlZCgzKSk7XG5cblx0XHRcdFx0dGhpcy5fX2xvZ0V2ZW50KGV2bXNnLmpvaW4oXCIgXCIpLCBldi50eXBlKTtcblx0XHRcdFx0aWYgKGV2LnR5cGUgPT09IFwiZXJyb3JcIiB8fCBldi50eXBlID09PSBcImFib3J0XCIpIHtcblx0XHRcdFx0XHR0aGlzLl9fbG9nTWVzc2FnZShmb3JtYXRWaWRlb0Vycm9yKHRoaXMudmlkZW8pLCBldi50eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X19sb2dFdmVudDogZnVuY3Rpb24obXNnLCBsb2d0eXBlLCBjb2xvcikge1xuXHRcdFx0XHR2YXIgbG9nRW50cnlFbCA9IHRoaXMuX19sb2dFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdGlmICgobG9nRW50cnlFbCAmJiBsb2dFbnRyeUVsLmdldEF0dHJpYnV0ZShcImRhdGEtbG9ndHlwZVwiKSA9PSBsb2d0eXBlKSAmJlxuXHRcdFx0XHRcdCgobG9ndHlwZSA9PT0gXCJ0aW1ldXBkYXRlXCIpIHx8IChsb2d0eXBlID09PSBcInByb2dyZXNzXCIpKSkge1xuXHRcdFx0XHRcdHZhciBsb2dSZXBlYXRWYWwgPSBwYXJzZUludChsb2dFbnRyeUVsLmdldEF0dHJpYnV0ZShcImRhdGEtbG9ncmVwZWF0XCIpKTtcblx0XHRcdFx0XHRsb2dFbnRyeUVsLnRleHRDb250ZW50ID0gdGhpcy5fX2dldFRTdGFtcCgpICsgXCIgXCIgKyBtc2c7XG5cdFx0XHRcdFx0bG9nRW50cnlFbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWxvZ3JlcGVhdFwiLCBpc05hTihsb2dSZXBlYXRWYWwpID8gMiA6ICsrbG9nUmVwZWF0VmFsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9fbG9nTWVzc2FnZShtc2csIGxvZ3R5cGUsIGNvbG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X19nZXRIZWFkZXJUZXh0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGdldFZpZGVvU3RhdHNDb2xzKCk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9KShtb2R1bGUuZXhwb3J0cyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiO1xuXG4gIHJldHVybiBcIjxkaXYgaWQ9XFxcImRlc2NfYlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiBjbGFzcz1cXFwiY29udGVudCBzaXppbmcgbWRvd25cXFwiPlwiXG4gICAgKyAoKHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGVzYyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGVzYyA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiZGVzY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzcsXCI+PSA0LjAuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksIGFsaWFzMj1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCI7XG5cbiAgcmV0dXJuIFwiPGRpdiBpZD1cXFwiZGVzY19tXCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiIGNsYXNzPVxcXCJjb250ZW50IHNpemluZ1xcXCI+PHA+XCJcbiAgICArICgoc3RhY2sxID0gKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L3A+XCJcbiAgICArICgoc3RhY2sxID0gKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5zdWIgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnN1YiA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwic3ViXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2Rpdj5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlcjtcblxuICByZXR1cm4gXCJcdFx0PHA+PGNvZGU+XCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaW5mb1NyYyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaW5mb1NyYyA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLHtcIm5hbWVcIjpcImluZm9TcmNcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9jb2RlPjwvcD5cXG5cIjtcbn0sXCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiZXJyb3ItdGl0bGUgY29sb3ItZmcgY29sb3ItcmV2ZXJzZVxcXCI+XCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiZXJyb3ItbWVzc2FnZSBjb2xvci1mZ1xcXCI+XFxuXHQ8cD48c3Ryb25nPlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Ryb25nPiA8Y29kZT5cIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubWVzc2FnZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWVzc2FnZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwibWVzc2FnZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L2NvZGU+PC9wPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbXCJpZlwiXS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaW5mb1NyYyA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiPC9kaXY+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gdmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKFwiaGFuZGxlYmFyc1wiKVtcImRlZmF1bHRcIl07XG5jb25zdCBIYW5kbGViYXJzID0gcmVxdWlyZShcImhic2Z5L3J1bnRpbWVcIik7XG4vKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuY29uc3QgQ29sb3IgPSByZXF1aXJlKFwiY29sb3JcIik7XG4vKiogQHR5cGUge21vZHVsZTphcHAvY29udHJvbC9HbG9iYWxzfSAqL1xuY29uc3QgR2xvYmFscyA9IHJlcXVpcmUoXCJhcHAvY29udHJvbC9HbG9iYWxzXCIpO1xuXG4vLyAoZnVuY3Rpb24oKSB7XG52YXIgaGVscGVycyA9IHtcblx0Lypcblx0LyogQXJpdGhtZXRpYyBoZWxwZXJzXG5cdC8qL1xuXHRhZGQ6IGZ1bmN0aW9uKHZhbHVlLCBhZGRpdGlvbikge1xuXHRcdHJldHVybiB2YWx1ZSArIGFkZGl0aW9uO1xuXHR9LFxuXHRzdWJ0cmFjdDogZnVuY3Rpb24odmFsdWUsIHN1YnN0cmFjdGlvbikge1xuXHRcdHJldHVybiB2YWx1ZSAtIHN1YnN0cmFjdGlvbjtcblx0fSxcblx0ZGl2aWRlOiBmdW5jdGlvbih2YWx1ZSwgZGl2aXNvcikge1xuXHRcdHJldHVybiB2YWx1ZSAvIGRpdmlzb3I7XG5cdH0sXG5cdG11bHRpcGx5OiBmdW5jdGlvbih2YWx1ZSwgbXVsdGlwbGllcikge1xuXHRcdHJldHVybiB2YWx1ZSAqIG11bHRpcGxpZXI7XG5cdH0sXG5cdGZsb29yOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcblx0fSxcblx0Y2VpbDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHZhbHVlKTtcblx0fSxcblx0cm91bmQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuXHR9LFxuXHRnbG9iYWw6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIEdsb2JhbHNbdmFsdWVdO1xuXHR9LFxuXG5cdC8qXG5cdC8qIEZsb3cgY29udHJvbCBoZWxwZXJzXG5cdC8qL1xuXHRpczogZnVuY3Rpb24oYSwgYiwgb3B0cykge1xuXHRcdHJldHVybiAoYSA9PT0gYikgPyBvcHRzLmZuKHRoaXMpIDogb3B0cy5pbnZlcnNlKHRoaXMpO1xuXHR9LFxuXHRpc25vdDogZnVuY3Rpb24oYSwgYiwgb3B0cykge1xuXHRcdHJldHVybiAoYSAhPT0gYikgPyBvcHRzLmZuKHRoaXMpIDogb3B0cy5pbnZlcnNlKHRoaXMpO1xuXHR9LFxuXHRpc2FueTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAyLFxuXHRcdFx0b3B0cyA9IGFyZ3VtZW50c1tpaSArIDFdO1xuXHRcdGRvXG5cdFx0XHRpZiAodmFsdWUgPT09IGFyZ3VtZW50c1srK2ldKSB7XG5cdFx0XHRcdHJldHVybiBvcHRzLmZuKHRoaXMpO1xuXHRcdFx0fVxuXHRcdHdoaWxlIChpIDwgaWkpO1xuXHRcdHJldHVybiBvcHRzLmludmVyc2UodGhpcyk7XG5cdH0sXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhLCBiLCBvcHRzKSB7XG5cdFx0cmV0dXJuIChhLmluZGV4T2YoYikgIT09IC0xKSA/IG9wdHMuZm4odGhpcykgOiBvcHRzLmludmVyc2UodGhpcyk7XG5cdH0sXG5cdGlnbm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH0sXG5cblx0Lypcblx0LyogQ29sb3IgaGVscGVyc1xuXHQvKi9cblx0bWl4OiBmdW5jdGlvbihjb2xvcmEsIGNvbG9yYiwgYW1vdW50KSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihjb2xvcmEpLm1peChuZXcgQ29sb3IoY29sb3JiKSwgYW1vdW50KS5yZ2IoKS5zdHJpbmcoKTtcblx0fSxcblx0bGlnaHRlbjogZnVuY3Rpb24oY29sb3IsIGFtb3VudCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IpLmxpZ2h0ZW4oYW1vdW50KS5yZ2IoKS5zdHJpbmcoKTtcblx0fSxcblx0ZGFya2VuOiBmdW5jdGlvbihjb2xvciwgYW1vdW50KSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihjb2xvcikuZGFya2VuKGFtb3VudCkucmdiKCkuc3RyaW5nKCk7XG5cdH0sXG5cdC8vIGNvbG9yRm9ybWF0OiBmdW5jdGlvbihjb2xvciwgZm10KSB7XG5cdC8vIFx0c3dpdGNoIChmbXQpIHtcblx0Ly8gXHRcdGNhc2UgXCJyZ2JcIjpcblx0Ly8gXHRcdFx0cmV0dXJuIG5ldyBDb2xvcihjb2xvcikucmdiKCkuc3RyaW5nKCk7XG5cdC8vIFx0XHRjYXNlIFwiaHNsXCI6XG5cdC8vIFx0XHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IpLmhzbCgpLnN0cmluZygpO1xuXHQvLyBcdFx0Y2FzZSBcImhleFwiOiBkZWZhdWx0OlxuXHQvLyBcdFx0XHRyZXR1cm4gbmV3IENvbG9yKGNvbG9yKS5oZXgoKS5zdHJpbmcoKTtcblx0Ly8gXHR9XG5cdC8vIH0sXG59O1xuZm9yICh2YXIgaGVscGVyIGluIGhlbHBlcnMpIHtcblx0aWYgKGhlbHBlcnMuaGFzT3duUHJvcGVydHkoaGVscGVyKSkge1xuXHRcdEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoaGVscGVyLCBoZWxwZXJzW2hlbHBlcl0pO1xuXHR9XG59XG4vLyB9KSgpO1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls3LFwiPj0gNC4wLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8c3ZnIGNsYXNzPVxcXCJjb2ctc3ltYm9sIGljb25cXFwiIHZpZXdCb3g9XFxcIi0xMDAgLTEwMCAyMDAgMjAwXFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+XFxuXHQ8cGF0aCBkPVxcXCJNMTEuNzU0LC05OS4zMDdjLTcuODA5LC0wLjkyNCAtMTUuNjk5LC0wLjkyNCAtMjMuNTA4LDBsLTMuNzMsMjAuODJjLTYuMjU0LDEuMjM0IC0xMi4zMzgsMy4yMSAtMTguMTIzLDUuODg4bC0xNS4yNTUsLTE0LjY1MWMtNi44NjEsMy44NDIgLTEzLjI0NCw4LjQ4IC0xOS4wMTgsMTMuODE4bDkuMjIsMTkuMDM2Yy00LjMzNSw0LjY3NCAtOC4wOTUsOS44NDkgLTExLjIwMSwxNS40MTZsLTIwLjk1MywtMi44ODZjLTMuMjkyLDcuMTQxIC01LjczMSwxNC42NDUgLTcuMjY1LDIyLjM1N2wxOC42NDgsOS45ODFjLTAuNzU5LDYuMzI5IC0wLjc1OSwxMi43MjcgMCwxOS4wNTZsLTE4LjY0OCw5Ljk4MWMxLjUzNCw3LjcxMiAzLjk3MywxNS4yMTYgNy4yNjUsMjIuMzU3bDIwLjk1MywtMi44ODZjMy4xMDYsNS41NjcgNi44NjYsMTAuNzQyIDExLjIwMSwxNS40MTZsLTkuMjIsMTkuMDM2YzUuNzc0LDUuMzM4IDEyLjE1Nyw5Ljk3NiAxOS4wMTgsMTMuODE4bDE1LjI1NSwtMTQuNjUxYzUuNzg1LDIuNjc4IDExLjg2OSw0LjY1NCAxOC4xMjMsNS44ODhsMy43MywyMC44MmM3LjgwOSwwLjkyNCAxNS42OTksMC45MjQgMjMuNTA4LDBsMy43MywtMjAuODJjNi4yNTQsLTEuMjM0IDEyLjMzOCwtMy4yMSAxOC4xMjMsLTUuODg4bDE1LjI1NSwxNC42NTFjNi44NjEsLTMuODQyIDEzLjI0NCwtOC40OCAxOS4wMTgsLTEzLjgxOGwtOS4yMiwtMTkuMDM2YzQuMzM1LC00LjY3NCA4LjA5NSwtOS44NDkgMTEuMjAxLC0xNS40MTZsMjAuOTUzLDIuODg2YzMuMjkyLC03LjE0MSA1LjczMSwtMTQuNjQ1IDcuMjY1LC0yMi4zNTdsLTE4LjY0OCwtOS45ODFjMC43NTksLTYuMzI5IDAuNzU5LC0xMi43MjcgMCwtMTkuMDU2bDE4LjY0OCwtOS45ODFjLTEuNTM0LC03LjcxMiAtMy45NzMsLTE1LjIxNiAtNy4yNjUsLTIyLjM1N2wtMjAuOTUzLDIuODg2Yy0zLjEwNiwtNS41NjcgLTYuODY2LC0xMC43NDIgLTExLjIwMSwtMTUuNDE2bDkuMjIsLTE5LjAzNmMtNS43NzQsLTUuMzM4IC0xMi4xNTcsLTkuOTc2IC0xOS4wMTgsLTEzLjgxOGwtMTUuMjU1LDE0LjY1MWMtNS43ODUsLTIuNjc4IC0xMS44NjksLTQuNjU0IC0xOC4xMjMsLTUuODg4bC0zLjczLC0yMC44MlpNMCwtMzNjMTguMjEzLDAgMzMsMTQuNzg3IDMzLDMzYzAsMTguMjEzIC0xNC43ODcsMzMgLTMzLDMzYy0xOC4yMTMsMCAtMzMsLTE0Ljc4NyAtMzMsLTMzYzAsLTE4LjIxMyAxNC43ODcsLTMzIDMzLC0zM1pcXFwiIHN0eWxlPVxcXCJmaWxsOmN1cnJlbnRDb2xvcjtmaWxsLXJ1bGU6ZXZlbm9kZDtcXFwiLz5cXG48L3N2Zz5cXG5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPHN2ZyBjbGFzcz1cXFwiZnVsbHNjcmVlbi1zeW1ib2xcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCIgdmlld0JveD1cXFwiLTIxIC0yMSA0MiA0MlxcXCI+XFxuXHQ8cGF0aCBpZD1cXFwiZnVsbHNjcmVlbi1zaGFkb3dcXFwiIGQ9XFxcIk0tNSw1IEwtMjAsMjAgTS03LDIwIEwtMjAsMjAgTC0yMCw3IE01LC01IEwyMCwtMjAgTTcsLTIwIEwyMCwtMjAgTDIwLC03XFxcIiBjbGFzcz1cXFwiYmctY29sb3Itc3Ryb2tlXFxcIiBzdHlsZT1cXFwiZmlsbDpub25lXFxcIiB2ZWN0b3ItZWZmZWN0PVxcXCJub24tc2NhbGluZy1zdHJva2VcXFwiIHRyYW5zZm9ybT1cXFwidHJhbnNsYXRlKDIgMilcXFwiLz5cXG5cdDxwYXRoIGlkPVxcXCJmdWxsc2NyZWVuLXBhdGhcXFwiIGQ9XFxcIk0tNSw1IEwtMjAsMjAgTS03LDIwIEwtMjAsMjAgTC0yMCw3IE01LC01IEwyMCwtMjAgTTcsLTIwIEwyMCwtMjAgTDIwLC03XFxcIiBjbGFzcz1cXFwiY29sb3Itc3Ryb2tlXFxcIiBzdHlsZT1cXFwiZmlsbDpub25lXFxcIiB2ZWN0b3ItZWZmZWN0PVxcXCJub24tc2NhbGluZy1zdHJva2VcXFwiIC8+XFxuPC9zdmc+XFxuXCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEB0eXBlIHttb2R1bGU6YmFja2JvbmV9ICovXG5jb25zdCBFdmVudHMgPSByZXF1aXJlKFwiYmFja2JvbmVcIikuRXZlbnRzO1xuXG5cbi8vIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbi8vIFx0dGljazogMSxcbi8vIFx0b25zdGFydDogbnVsbCxcbi8vIFx0b250aWNrOiBudWxsLFxuLy8gXHRvbnBhdXNlOiBudWxsLFxuLy8gXHRvbnN0b3A6IG51bGwsXG4vLyBcdG9uZW5kOiBudWxsXG4vLyB9XG52YXIgaWRTZWVkID0gMDtcblxudmFyIFRpbWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvLyBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGltZXIpKSB7XG5cdC8vIFx0cmV0dXJuIG5ldyBUaW1lcihvcHRpb25zKTtcblx0Ly8gfVxuXHR0aGlzLl9pZCA9IGlkU2VlZCsrO1xuXHQvLyB0aGlzLl9vcHRpb25zID0ge307XG5cdHRoaXMuX2R1cmF0aW9uID0gMDtcblx0dGhpcy5fc3RhdHVzID0gXCJpbml0aWFsaXplZFwiO1xuXHR0aGlzLl9zdGFydCA9IDA7XG5cdC8vIHRoaXMuX21lYXN1cmVzID0gW107XG5cblx0Ly8gZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0T3B0aW9ucykge1xuXHQvLyBcdHRoaXMuX29wdGlvbnNbcHJvcF0gPSBkZWZhdWx0T3B0aW9uc1twcm9wXTtcblx0Ly8gfVxuXHQvLyB0aGlzLm9wdGlvbnMob3B0aW9ucyk7XG59O1xuXG5fLmV4dGVuZChUaW1lci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG5cdHN0YXJ0OiBmdW5jdGlvbihkdXJhdGlvbikge1xuXHRcdGlmICghXy5pc051bWJlcihkdXJhdGlvbikgJiYgIXRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0Ly8gZHVyYXRpb24gJiYgKGR1cmF0aW9uICo9IDEwMDApXG5cdFx0aWYgKHRoaXMuX3RpbWVvdXQgJiYgdGhpcy5fc3RhdHVzID09PSBcInN0YXJ0ZWRcIikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHZhciBldk5hbWUgPSAodGhpcy5fc3RhdHVzID09PSBcInN0b3BwZWRcIikgPyBcInN0YXJ0XCIgOiBcInJlc3VtZVwiO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgdGhpcy5fZHVyYXRpb247XG5cdFx0dGhpcy5fdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGVuZC5iaW5kKHRoaXMpLCB0aGlzLl9kdXJhdGlvbik7XG5cdFx0Ly8gaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLm9udGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0Ly8gXHR0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdC8vIFx0XHR0aGlzLnRyaWdnZXIoXCJ0aWNrXCIsIHRoaXMuZ2V0RHVyYXRpb24oKSlcblx0XHQvLyBcdH0uYmluZCh0aGlzKSwgK3RoaXMuX29wdGlvbnMudGljayAqIDEwMDApXG5cdFx0Ly8gfVxuXHRcdHRoaXMuX3N0YXJ0ID0gX25vdygpO1xuXHRcdHRoaXMuX3N0YXR1cyA9IFwic3RhcnRlZFwiO1xuXHRcdHRoaXMudHJpZ2dlcihldk5hbWUsIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9zdGF0dXMgIT09IFwic3RhcnRlZFwiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fZHVyYXRpb24gLT0gKF9ub3coKSAtIHRoaXMuX3N0YXJ0KTtcblx0XHRjbGVhci5jYWxsKHRoaXMsIGZhbHNlKTtcblx0XHR0aGlzLl9zdGF0dXMgPSBcInBhdXNlZFwiO1xuXHRcdHRoaXMudHJpZ2dlcihcInBhdXNlXCIsIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCEvc3RhcnRlZHxwYXVzZWQvLnRlc3QodGhpcy5fc3RhdHVzKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGNsZWFyLmNhbGwodGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5fc3RhdHVzID0gXCJzdG9wcGVkXCI7XG5cdFx0dGhpcy50cmlnZ2VyKFwic3RvcFwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXREdXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3N0YXR1cyA9PT0gXCJzdGFydGVkXCIpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbiAtIChfbm93KCkgLSB0aGlzLl9zdGFydCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9zdGF0dXMgPT09IFwicGF1c2VkXCIpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Z2V0U3RhdHVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhdHVzO1xuXHR9LFxufSk7XG5cbnZhciBfbm93ID0gd2luZG93LnBlcmZvcm1hbmNlID9cblx0d2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOlxuXHREYXRlLm5vdy5iaW5kKERhdGUpO1xuXG5mdW5jdGlvbiBlbmQoKSB7XG5cdGNsZWFyLmNhbGwodGhpcyk7XG5cdHRoaXMuX3N0YXR1cyA9IFwic3RvcHBlZFwiO1xuXHR0aGlzLnRyaWdnZXIoXCJlbmRcIik7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKGNsZWFyRHVyYXRpb24pIHtcblx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcblx0Ly8gd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuXHRpZiAoY2xlYXJEdXJhdGlvbiA9PT0gdHJ1ZSkge1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gMDtcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaW1lci5wcm90b3R5cGUsIHtcblx0ZHVyYXRpb246IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXREdXJhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RhdHVzOiB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U3RhdHVzKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGltZXIsIHtcblx0U1RPUFBFRDoge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0dmFsdWU6IFwic3RvcHBlZFwiXG5cdH0sXG5cdFNUQVJURUQ6IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdHZhbHVlOiBcInN0YXJ0ZWRcIlxuXHR9LFxuXHRQQVVTRUQ6IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdHZhbHVlOiBcInBhdXNlZFwiXG5cdH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogSW1wb3J0c1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqLy8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL1RyYW5zZm9ybUl0ZW19ICovXG5jb25zdCBUcmFuc2Zvcm1JdGVtID0gcmVxdWlyZShcIi4vVHJhbnNmb3JtSXRlbVwiKTtcblxudmFyIGlkU2VlZCA9IDA7XG52YXIgY2lkU2VlZCA9IDEwMDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0eXBlIHttb2R1bGU6YXBwL2hlbHBlci9UcmFuc2Zvcm1IZWxwZXJ9XG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybUhlbHBlcigpIHtcblx0dGhpcy5pZCA9IGlkU2VlZCsrO1xuXHR0aGlzLl9pdGVtcyA9IFtdO1xuXHR0aGlzLl9pdGVtc0J5SWQgPSB7fTtcbn1cblxuVHJhbnNmb3JtSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoe1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogUHJpdmF0ZVxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X2dldDogZnVuY3Rpb24oZWwpIHtcblx0XHRpZiAodGhpcy5oYXMoZWwpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faXRlbXNCeUlkW2VsLmVpZF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9hZGQoZWwpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkOiBmdW5jdGlvbihlbCkge1xuXHRcdHZhciBpdGVtLCBpZDtcblx0XHQvLyBpZCA9IGVsLmVpZCB8fCBlbC5jaWQgfHwgZWwuaWQ7XG5cdFx0Ly8gaWYgKCFpZCB8fCAodGhpcy5faXRlbXNCeUlkW2lkXSAmJiAodGhpcy5faXRlbXNCeUlkW2lkXS5lbCAhPT0gZWwpKSkge1xuXHRcdC8vIFx0aWQgPSBcImVsdFwiICsgY2lkU2VlZCsrO1xuXHRcdC8vIH1cblx0XHQvLyBpZiAoIWVsLmVpZCkge1xuXHRcdC8vIFx0aWQgPSBlbC5laWQgfHwgZWwuY2lkIHx8IChcImVsdFwiICsgY2lkU2VlZCsrKTtcblx0XHQvLyB9XG5cdFx0aWQgPSBlbC5laWQgfHwgZWwuY2lkIHx8IChcImVsdFwiICsgY2lkU2VlZCsrKTtcblx0XHRpdGVtID0gbmV3IFRyYW5zZm9ybUl0ZW0oZWwsIGlkKTtcblx0XHR0aGlzLl9pdGVtc0J5SWRbaWRdID0gaXRlbTtcblx0XHR0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0aWYgKHRoaXMuaGFzKGVsKSkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLl9pdGVtc0J5SWRbZWwuZWlkXTtcblx0XHRcdHRoaXMuX2l0ZW1zLnNwbGljZSh0aGlzLl9pdGVtcy5pbmRleE9mKG8pLCAxKTtcblx0XHRcdG8uZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2l0ZW1zQnlJZFtlbC5laWRdO1xuXHRcdH1cblx0fSxcblxuXHRfaW52b2tlOiBmdW5jdGlvbihmdW5jTmFtZSwgYXJncywgc3RhcnRJbmRleCkge1xuXHRcdHZhciBpLCBpaSwgaiwgamosIGVsLCBvLCBycjtcblx0XHR2YXIgZnVuY0FyZ3MgPSBudWxsO1xuXHRcdGlmIChzdGFydEluZGV4ICE9PSB2b2lkIDApIHtcblx0XHRcdGZ1bmNBcmdzID0gc2xpY2UuY2FsbChhcmdzLCAwLCBzdGFydEluZGV4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhcnRJbmRleCA9IDA7XG5cdFx0fVxuXHRcdGZvciAoaSA9IHN0YXJ0SW5kZXgsIGlpID0gYXJncy5sZW5ndGgsIHJyID0gW107IGkgPCBpaTsgKytpKSB7XG5cdFx0XHRlbCA9IGFyZ3NbaV07XG5cdFx0XHQvLyBpdGVyYXRlIG9uIE5vZGVMaXN0LCBBcmd1bWVudHMsIEFycmF5Li4uXG5cdFx0XHRpZiAoZWwubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAoaiA9IDAsIGpqID0gZWwubGVuZ3RoOyBqIDwgamo7ICsraikge1xuXHRcdFx0XHRcdG8gPSB0aGlzLl9nZXQoZWxbal0pO1xuXHRcdFx0XHRcdHJyLnB1c2gob1tmdW5jTmFtZV0uYXBwbHkobywgZnVuY0FyZ3MpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0byA9IHRoaXMuX2dldChlbCk7XG5cdFx0XHRcdHJyLnB1c2gob1tmdW5jTmFtZV0uYXBwbHkobywgZnVuY0FyZ3MpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJyO1xuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogUHVibGljXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRoYXM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0cmV0dXJuIGVsLmVpZCAmJiB0aGlzLl9pdGVtc0J5SWRbZWwuZWlkXSAhPT0gdm9pZCAwO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgaiwgZWwsIHJldCA9IFtdO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGVsID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZWwubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRyZXQucHVzaCh0aGlzLl9nZXQoZWxbal0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0LnB1c2godGhpcy5fZ2V0KGVsKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbihlbCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXQoZWwpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGksIGosIGVsO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGVsID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgZWwubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHR0aGlzLl9nZXQoZWxbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9nZXQoZWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpLCBqLCBlbDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRlbCA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmIChlbC5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGVsLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlKGVsW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlKGVsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0LyogcHVibGljXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyogcHVibGljOiBzaW5nbGUgYXJnXG5cdC8qIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gKi9cblxuXHRoYXNPZmZzZXQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGFzKGVsKSA/IHRoaXMuX2l0ZW1zQnlJZFtlbC5laWRdLmhhc09mZnNldCA6ICh2b2lkIDApO1xuXHR9LFxuXG5cdC8qIHB1YmxpYzogY2FwdHVyZVxuXHQvKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtICovXG5cblx0Y2FwdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faW52b2tlKFwiY2FwdHVyZVwiLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjYXB0dXJlQWxsOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0XHR0aGlzLl9pdGVtc1tpXS5jYXB0dXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsZWFyQ2FwdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faW52b2tlKFwiY2xlYXJDYXB0dXJlXCIsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGNsZWFyQWxsQ2FwdHVyZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcblx0XHRcdHRoaXMuX2l0ZW1zW2ldLmNsZWFyQ2FwdHVyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBwdWJsaWM6IG9mZnNldFxuXHQvKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtICovXG5cdG9mZnNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuX2ludm9rZShcIm9mZnNldFwiLCBhcmd1bWVudHMsIDIpO1xuXHR9LFxuXHRvZmZzZXRBbGw6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0XHR0aGlzLl9pdGVtc1tpXS5vZmZzZXQoeCwgeSk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsZWFyT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pbnZva2UoXCJjbGVhck9mZnNldFwiLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbGVhckFsbE9mZnNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcblx0XHRcdHRoaXMuX2l0ZW1zW2ldLmNsZWFyT2Zmc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIHB1YmxpYzogdHJhbnNpdGlvbnNcblx0LyogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAqL1xuXG5cdHJ1blRyYW5zaXRpb246IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcblx0XHR0aGlzLl9pbnZva2UoXCJydW5UcmFuc2l0aW9uXCIsIGFyZ3VtZW50cywgMSk7XG5cdH0sXG5cdHJ1bkFsbFRyYW5zaXRpb25zOiBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0dGhpcy5faXRlbXNbaV0ucnVuVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcblx0XHR9XG5cdH0sXG5cblx0Y2xlYXJUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pbnZva2UoXCJjbGVhclRyYW5zaXRpb25cIiwgYXJndW1lbnRzKTtcblx0fSxcblx0Y2xlYXJBbGxUcmFuc2l0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0dGhpcy5faXRlbXNbaV0uY2xlYXJUcmFuc2l0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0b3BUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pbnZva2UoXCJzdG9wVHJhbnNpdGlvblwiLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRzdG9wQWxsVHJhbnNpdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcblx0XHRcdHRoaXMuX2l0ZW1zW2ldLnN0b3BUcmFuc2l0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHdoZW5UcmFuc2l0aW9uRW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX2ludm9rZShcIndoZW5UcmFuc2l0aW9uRW5kc1wiLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZXMubGVuZ3RoICE9IDAgP1xuXHRcdFx0UHJvbWlzZS5hbGwocmVzKSA6XG5cdFx0XHRQcm9taXNlLnJlc29sdmUobnVsbCk7XG5cdH0sXG5cdHdoZW5BbGxUcmFuc2l0aW9uc0VuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9pdGVtcy5sZW5ndGggIT0gMCkgPyBQcm9taXNlLmFsbCh0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdFx0cmV0dXJuIG8ud2hlblRyYW5zaXRpb25FbmRzKCk7XG5cdFx0fSkpIDogUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuXHR9LFxuXG5cdHByb21pc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDAgP1xuXHRcdFx0dGhpcy53aGVuQWxsVHJhbnNpdGlvbnNFbmQoKSA6XG5cdFx0XHR0aGlzLndoZW5UcmFuc2l0aW9uRW5kcy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvKiB2YWxpZGF0aW9uXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHR2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5faXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdFx0dGhpcy5faXRlbXNbaV0udmFsaWRhdGUoKTtcblx0XHR9XG5cdH0sXG59LCB7XG5cdGl0ZW1zOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pdGVtcztcblx0XHR9XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybUhlbHBlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSW1wb3J0c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZWRQcm9wZXJ0eX0gKi9cbmNvbnN0IHByZWZpeGVkUHJvcGVydHkgPSByZXF1aXJlKFwidXRpbHMvcHJlZml4ZWRQcm9wZXJ0eVwiKTtcbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3ByZWZpeGVkU3R5bGVOYW1lfSAqL1xuY29uc3QgcHJlZml4ZWRTdHlsZU5hbWUgPSByZXF1aXJlKFwidXRpbHMvcHJlZml4ZWRTdHlsZU5hbWVcIik7XG4vKiogQHR5cGUge21vZHVsZTp1dGlscy9wcmVmaXhlZEV2ZW50fSAqL1xuY29uc3QgcHJlZml4ZWRFdmVudCA9IHJlcXVpcmUoXCJ1dGlscy9wcmVmaXhlZEV2ZW50XCIpO1xuLyoqIEB0eXBlIHtTdHJpbmd9ICovXG52YXIgdHJhbnNpdGlvbkVuZCA9IHByZWZpeGVkRXZlbnQoXCJ0cmFuc2l0aW9uZW5kXCIpO1xuLy92YXIgdHJhbnNpdGlvbkVuZCA9IHJlcXVpcmUoXCJ1dGlscy9ldmVudC90cmFuc2l0aW9uRW5kXCIpO1xuLy8gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbi8vIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvZGVidWcvdHJhY2VFbGVtZW50fSAqL1xuLy8gdmFyIHRyYWNlRWx0ID0gcmVxdWlyZShcIi4vZGVidWcvdHJhY2VFbGVtZW50XCIpO1xuLy8gdmFyIHRyYWNlRWx0Q2FjaGUgPSB7fTtcbi8vIHZhciBsb2cgPSBmdW5jdGlvbigpIHtcbi8vIFx0dmFyIGxvZ0ZuID0gXCJsb2dcIjtcbi8vIFx0dmFyIGFyZ3MgPSBzbGljZS5hcHBseShhcmd1bWVudHMpO1xuLy8gXHRzd2l0Y2goYXJnc1swXSkge1xuLy8gXHRcdGNhc2UgXCJlcnJvclwiOlxuLy8gXHRcdGNhc2UgXCJ3YXJuXCI6XG4vLyBcdFx0Y2FzZSBcImluZm9cIjpcbi8vIFx0XHRcdGxvZ0ZuID0gYXJncy5zaGlmdCgpO1xuLy8gXHRcdFx0YnJlYWs7XG4vLyBcdFx0ZGVmYXVsdDpcbi8vIFx0XHRcdC8vIGJyZWFrO1xuLy8gXHRcdFx0cmV0dXJuO1xuLy8gXHR9XG4vLyBcdHZhciBlbCwgdHhJZDtcbi8vIFx0aWYgKChlbCA9IGFyZ3NbMF0pICYmICh0eElkID0gZWwuZWlkKSkge1xuLy8gXHRcdGFyZ3NbMF0gPSB0cmFjZUVsdENhY2hlW3R4SWRdIHx8ICh0cmFjZUVsdENhY2hlW3R4SWRdID0gZWwpO1xuLy8gXHR9XG4vLyBcdGFyZ3NbMF0gPSBcIlxcdFwiICsgYXJnc1swXTtcbi8vIFx0Y29uc29sZVtsb2dGbl0uYXBwbHkoY29uc29sZSwgYXJncyk7XG4vLyB9O1xuXG4vKiBqc2hpbnQgLVcwNzkgKi9cbi8vIHZhciBjb25zb2xlID0gKGZ1bmN0aW9uKHRhcmdldCkge1xuLy8gXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5yZWR1Y2UoZnVuY3Rpb24ocHJveHksIHByb3ApIHtcbi8vIFx0XHRpZiAoKHR5cGVvZiB0YXJnZXRbcHJvcF0pID09IFwiZnVuY3Rpb25cIikge1xuLy8gXHRcdFx0c3dpdGNoIChwcm9wKSB7XG4vLyBcdFx0XHRcdGNhc2UgXCJlcnJvclwiOlxuLy8gXHRcdFx0XHRjYXNlIFwid2FyblwiOlxuLy8gXHRcdFx0XHRjYXNlIFwiaW5mb1wiOlxuLy8gXHRcdFx0XHRcdHByb3h5W3Byb3BdID0gZnVuY3Rpb24gKCkge1xuLy8gXHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSBzbGljZS5hcHBseShhcmd1bWVudHMpO1xuLy8gXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdID09IFwic3RyaW5nXCIpIHtcbi8vIFx0XHRcdFx0XHRcdFx0YXJnc1swXSA9IHByb3AgKyBcIjo6XCIgKyBhcmdzWzBdO1xuLy8gXHRcdFx0XHRcdFx0fVxuLy8gXHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldFtwcm9wXS5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuLy8gXHRcdFx0XHRcdH07XG4vLyBcdFx0XHRcdFx0YnJlYWs7XG4vLyBcdFx0XHRcdGNhc2UgXCJsb2dcIjpcbi8vIFx0XHRcdFx0XHRwcm94eVtwcm9wXSA9IGZ1bmN0aW9uKCkge307XG4vLyBcdFx0XHRcdFx0YnJlYWs7XG4vLyBcdFx0XHRcdGRlZmF1bHQ6XG4vLyBcdFx0XHRcdFx0cHJveHlbcHJvcF0gPSB0YXJnZXRbcHJvcF0uYmluZCh0YXJnZXQpO1xuLy8gXHRcdFx0XHRcdGJyZWFrO1xuLy8gXHRcdFx0fVxuLy8gXHRcdH0gZWxzZSB7XG4vLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksIHByb3AsIHtcbi8vIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRhcmdldFtwcm9wXTsgfSxcbi8vIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWwpIHsgdGFyZ2V0W3Byb3BdID0gdmFsOyB9XG4vLyBcdFx0XHR9KTtcbi8vIFx0XHR9XG4vLyBcdFx0cmV0dXJuIHByb3h5O1xuLy8gXHR9LCB7fSk7XG4vLyB9KSh3aW5kb3cuY29uc29sZSk7XG4vKiBqc2hpbnQgK1cwNzkgKi9cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogUHJpdmF0ZSBzdGF0aWNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIE5PX1RSQU5TSVRJT05fVkFMVUUgPSBcIm5vbmUgMHMgc3RlcC1zdGFydCAwc1wiO1xuLy8gdmFyIE5PX1RSQU5TSVRJT05fVkFMVUUgPSBcImFsbCAwLjAwMXMgc3RlcC1zdGFydCAwLjAwMXNcIjtcblxudmFyIFVOU0VUX1RSQU5TSVRJT04gPSB7XG5cdG5hbWU6IFwidW5zZXRcIixcblx0Y2xhc3NOYW1lOiBcInR4LXVuc2V0XCIsXG5cdHByb3BlcnR5OiBcIm5vbmVcIixcblx0ZWFzaW5nOiBcImVhc2VcIixcblx0ZGVsYXk6IDAsXG5cdGR1cmF0aW9uOiAwLFxuXHRjc3NUZXh0OiBcInVuc2V0XCIsXG59O1xuXG4vLyB2YXIgdHJhbnNsYXRlVGVtcGxhdGUgPSBfLnRlbXBsYXRlKFwidHJhbnNsYXRlKDwlPSBfcmVuZGVyZWRYICU+cHgsIDwlPSBfcmVuZGVyZWRZICU+cHgpXCI7XG4vLyB2YXIgdHJhbnNsYXRlM2RUZW1wbGF0ZSA9IF8udGVtcGxhdGUoXCJ0cmFuc2xhdGUzZCg8JT0gX3JlbmRlcmVkWCAlPnB4LCA8JT0gX3JlbmRlcmVkWSAlPnB4LCAwcHgpXCI7XG4vLyB2YXIgdHJhbnNpdGlvblRlbXBsYXRlID0gXy50ZW1wbGF0ZShcIjwlPSBwcm9wZXJ0eSAlPiA8JSBkdXJhdGlvbi8xMDAwICU+cyA8JT0gZWFzaW5nICU+IDwlIGRlbGF5LzEwMDAgJT5zXCIpO1xuXG52YXIgdHJhbnNsYXRlVGVtcGxhdGUgPSAoZnVuY3Rpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKG8pIHtcblx0XHRyZXR1cm4gZm4oby5fcmVuZGVyZWRYLCBvLl9yZW5kZXJlZFkpO1xuXHR9O1xufShyZXF1aXJlKFwiYXBwL2NvbnRyb2wvR2xvYmFsc1wiKS5UUkFOU0xBVEVfVEVNUExBVEUpKTtcblxudmFyIHRyYW5zaXRpb25UZW1wbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIG8ucHJvcGVydHkgKyBcIiBcIiArXG5cdFx0by5kdXJhdGlvbiAvIDEwMDAgKyBcInMgXCIgK1xuXHRcdG8uZWFzaW5nICsgXCIgXCIgK1xuXHRcdG8uZGVsYXkgLyAxMDAwICsgXCJzXCI7XG59O1xuXG52YXIgcHJvcERlZmF1bHRzID0ge1xuXHRcIm9wYWNpdHlcIjogXCIxXCIsXG5cdFwidmlzaWJpbGl0eVwiOiBcInZpc2libGVcIixcblx0XCJ0cmFuc2Zvcm1cIjogXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIixcblx0XCJ0cmFuc2Zvcm1TdHlsZVwiOiBcIlwiLFxuXHRcInRyYW5zaXRpb25cIjogXCJcIixcblx0Ly8gXCJ3aWxsQ2hhbmdlXCI6IFwiXCIsXG5cdC8vIFwidHJhbnNpdGlvbkR1cmF0aW9uXCI6IFwiMHNcIixcblx0Ly8gXCJ0cmFuc2l0aW9uRGVsYXlcIjogXCIwc1wiLFxuXHQvLyBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiOiBcIm5vbmVcIixcblx0Ly8gXCJ0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25cIjogXCJlYXNlXCJcbn07XG52YXIgcHJvcEtleXMgPSBPYmplY3Qua2V5cyhwcm9wRGVmYXVsdHMpO1xudmFyIHByb3BOYW1lcyA9IHByb3BLZXlzLnJlZHVjZShmdW5jdGlvbihvYmosIHByb3BOYW1lKSB7XG5cdG9ialtwcm9wTmFtZV0gPSBwcmVmaXhlZFByb3BlcnR5KHByb3BOYW1lKTtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxudmFyIHN0eWxlTmFtZXMgPSAoZnVuY3Rpb24oY2FtZWxUb0Rhc2hlZCkge1xuXHRyZXR1cm4gcHJvcEtleXNcblx0XHQubWFwKGNhbWVsVG9EYXNoZWQpXG5cdFx0LnJlZHVjZShmdW5jdGlvbihvYmosIHByb3BOYW1lKSB7XG5cdFx0XHRvYmpbcHJvcE5hbWVdID0gcHJlZml4ZWRTdHlsZU5hbWUocHJvcE5hbWUpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LCB7fSk7XG59KShyZXF1aXJlKFwidXRpbHMvc3RyaW5ncy9jYW1lbFRvRGFzaGVkXCIpKTtcblxudmFyIHJlc29sdmVBbGwgPSBmdW5jdGlvbihwcCwgcmVzdWx0KSB7XG5cdGlmIChwcC5sZW5ndGggIT0gMCkge1xuXHRcdHBwLmZvckVhY2goZnVuY3Rpb24ocCwgaSwgYSkge1xuXHRcdFx0cC5yZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRhW2ldID0gbnVsbDtcblx0XHR9KTtcblx0XHRwcC5sZW5ndGggPSAwO1xuXHR9XG5cdHJldHVybiBwcDtcbn07XG5cbnZhciByZWplY3RBbGwgPSBmdW5jdGlvbihwcCwgcmVhc29uKSB7XG5cdGlmIChwcC5sZW5ndGggIT0gMCkge1xuXHRcdHBwLmZvckVhY2goZnVuY3Rpb24ocCwgaSwgYSkge1xuXHRcdFx0cC5yZWplY3QocmVhc29uKTtcblx0XHRcdGFbaV0gPSBudWxsO1xuXHRcdH0pO1xuXHRcdHBwLmxlbmd0aCA9IDA7XG5cdH1cblx0cmV0dXJuIHBwO1xufTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVHJhbnNmb3JtSXRlbVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVHJhbnNmb3JtSXRlbSA9IGZ1bmN0aW9uKGVsLCBpZCkge1xuXHR0aGlzLmVsID0gZWw7XG5cdHRoaXMuaWQgPSBpZDtcblx0dGhpcy5lbC5laWQgPSBpZDtcblxuXHR0aGlzLl9vblRyYW5zaXRpb25FbmQgPSB0aGlzLl9vblRyYW5zaXRpb25FbmQuYmluZCh0aGlzKTtcblx0dGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmQsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xuXG5cdHRoaXMuX2NhcHR1cmVJbnZhbGlkID0gZmFsc2U7XG5cdHRoaXMuX2NhcHR1cmVkQ2hhbmdlZCA9IGZhbHNlO1xuXHR0aGlzLl9jYXB0dXJlZFggPSBudWxsO1xuXHR0aGlzLl9jYXB0dXJlZFkgPSBudWxsO1xuXHR0aGlzLl9jdXJyQ2FwdHVyZSA9IHt9O1xuXHR0aGlzLl9sYXN0Q2FwdHVyZSA9IHt9O1xuXG5cdHRoaXMuX2hhc09mZnNldCA9IGZhbHNlO1xuXHR0aGlzLl9vZmZzZXRJbnZhbGlkID0gZmFsc2U7XG5cdHRoaXMuX29mZnNldFggPSBudWxsO1xuXHR0aGlzLl9vZmZzZXRZID0gbnVsbDtcblxuXHR0aGlzLl9yZW5kZXJlZFggPSBudWxsO1xuXHR0aGlzLl9yZW5kZXJlZFkgPSBudWxsO1xuXG5cdHRoaXMuX2hhc1RyYW5zaXRpb24gPSBmYWxzZTtcblx0dGhpcy5fdHJhbnNpdGlvbkludmFsaWQgPSBmYWxzZTtcblx0dGhpcy5fdHJhbnNpdGlvblJ1bm5pbmcgPSBmYWxzZTtcblx0dGhpcy5fdHJhbnNpdGlvbiA9IF8uZXh0ZW5kKHt9LCBVTlNFVF9UUkFOU0lUSU9OKTsgLy97fTtcblxuXHR0aGlzLl9wcm9taXNlcyA9IFtdO1xuXHR0aGlzLl9wZW5kaW5nUHJvbWlzZXMgPSBbXTtcbn1cblxuVHJhbnNmb3JtSXRlbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIFB1YmxpY1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyogZGVzdHJveVxuXHQvKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIE5PVEU6IHN0eWxlIHByb3BlcnR5IG1heSBoYXZlIGJlZW4gbW9kaWZpZWQ7IGNsZWFyT2Zmc2V0KGVsZW1lbnQpIHNob3VsZFxuXHRcdC8vIGJlIGNhbGxlZCBleHBsaWNpdGx5IGlmIGNsZWFuIHVwIGlzIHJlcXVpcmVkLlxuXHRcdHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kLCB0aGlzLl9vblRyYW5zaXRpb25FbmQsIGZhbHNlKTtcblx0XHRyZWplY3RBbGwodGhpcy5fcGVuZGluZ1Byb21pc2VzLCB0aGlzKTtcblx0XHRyZWplY3RBbGwodGhpcy5fcHJvbWlzZXMsIHRoaXMpO1xuXHRcdC8vIGRlbGV0ZSB0aGlzLmVsLmVpZDtcblx0fSxcblxuXHQvKiBjYXB0dXJlXG5cdC8qIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gKi9cblx0Y2FwdHVyZTogZnVuY3Rpb24oZm9yY2UpIHtcblx0XHQvLyBjb25zb2xlLmxvZyhcInR4WyVzXTo6Y2FwdHVyZVwiLCB0aGlzLmlkKTtcblx0XHRpZiAoZm9yY2UpIHtcblx0XHRcdHRoaXMuY2xlYXJDYXB0dXJlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3ZhbGlkYXRlQ2FwdHVyZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyQ2FwdHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJ0eFslc106OmNsZWFyQ2FwdHVyZVwiLCB0aGlzLmlkKTtcblx0XHQvLyB0aGlzLl9oYXNPZmZzZXQgPSBmYWxzZTtcblx0XHR0aGlzLl9jYXB0dXJlSW52YWxpZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Lyogb2Zmc2V0L2NsZWFyXG5cdC8qIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gKi9cblx0b2Zmc2V0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJ0eFslc106Om9mZnNldFwiLCB0aGlzLmlkKTtcblx0XHR0aGlzLl9oYXNPZmZzZXQgPSB0cnVlO1xuXHRcdHRoaXMuX29mZnNldEludmFsaWQgPSB0cnVlO1xuXHRcdHRoaXMuX29mZnNldFggPSB4IHx8IDA7XG5cdFx0dGhpcy5fb2Zmc2V0WSA9IHkgfHwgMDtcblx0XHQvLyBpZiAodGhpcy5pbW1lZGlhdGUpIHRoaXMuX3ZhbGlkYXRlT2Zmc2V0KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xlYXJPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9oYXNPZmZzZXQpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHhbJXNdOjpjbGVhck9mZnNldFwiLCB0aGlzLmlkKTtcblx0XHRcdHRoaXMuX2hhc09mZnNldCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fb2Zmc2V0SW52YWxpZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9vZmZzZXRYID0gbnVsbDtcblx0XHRcdHRoaXMuX29mZnNldFkgPSBudWxsO1xuXHRcdFx0Ly8gaWYgKHRoaXMuaW1tZWRpYXRlKSB0aGlzLl92YWxpZGF0ZU9mZnNldCgpO1xuXHRcdH1cblx0XHQvLyBlbHNlIHtcblx0XHQvLyBcdGNvbnNvbGUubG9nKFwidHhbJXNdOjpjbGVhck9mZnNldCBubyBvZmZzZXQgdG8gY2xlYXJcIiwgdGhpcy5pZCk7XG5cdFx0Ly8gfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIHRyYW5zaXRpb25zXG5cdC8qIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gKi9cblx0cnVuVHJhbnNpdGlvbjogZnVuY3Rpb24odHJhbnNpdGlvbikge1xuXHRcdGlmICghdHJhbnNpdGlvbikgeyAvLyB8fCAodHJhbnNpdGlvbi5kdXJhdGlvbiArIHRyYW5zaXRpb24uZGVsYXkpID09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLmNsZWFyVHJhbnNpdGlvbigpO1xuXHRcdH1cblx0XHR2YXIgbGFzdFZhbHVlID0gdGhpcy5fdHJhbnNpdGlvblZhbHVlO1xuXHRcdHZhciBsYXN0TmFtZSA9IHRoaXMuX3RyYW5zaXRpb24ubmFtZTtcblx0XHR0aGlzLl90cmFuc2l0aW9uLnByb3BlcnR5ID0gc3R5bGVOYW1lc1tcInRyYW5zZm9ybVwiXTtcblx0XHR0aGlzLl90cmFuc2l0aW9uID0gXy5leHRlbmQodGhpcy5fdHJhbnNpdGlvbiwgdHJhbnNpdGlvbik7XG5cdFx0dGhpcy5fdHJhbnNpdGlvblZhbHVlID0gdHJhbnNpdGlvblRlbXBsYXRlKHRoaXMuX3RyYW5zaXRpb24pO1xuXG5cdFx0aWYgKHRoaXMuX3RyYW5zaXRpb25JbnZhbGlkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJ0eFslc106OnJ1blRyYW5zaXRpb24gc2V0IG92ZXIgKCVzOiclcycgPT4gJXM6JyVzJylcIiwgdGhpcy5pZCxcblx0XHRcdFx0bGFzdE5hbWUsIGxhc3RWYWx1ZSwgdGhpcy5fdHJhbnNpdGlvbi5uYW1lLCB0aGlzLl90cmFuc2l0aW9uVmFsdWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2hhc1RyYW5zaXRpb24gPSB0cnVlO1xuXHRcdHRoaXMuX3RyYW5zaXRpb25JbnZhbGlkID0gdHJ1ZTtcblx0XHQvLyBpZiAodGhpcy5pbW1lZGlhdGUpIHRoaXMuX3ZhbGlkYXRlVHJhbnNpdGlvbigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyVHJhbnNpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdHJhbnNpdGlvbiA9IF8uZXh0ZW5kKHRoaXMuX3RyYW5zaXRpb24sIFVOU0VUX1RSQU5TSVRJT04pO1xuXHRcdHRoaXMuX3RyYW5zaXRpb25WYWx1ZSA9IE5PX1RSQU5TSVRJT05fVkFMVUU7XG5cblx0XHR0aGlzLl9oYXNUcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5fdHJhbnNpdGlvbkludmFsaWQgPSB0cnVlO1xuXHRcdC8vIGlmICh0aGlzLmltbWVkaWF0ZSkgdGhpcy5fdmFsaWRhdGVUcmFuc2l0aW9uKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcFRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHRoaXMuX3RyYW5zaXRpb24ubmFtZSA9IFwiW25vbmVdXCI7XG5cdFx0Ly8gdGhpcy5fdHJhbnNpdGlvbi5wcm9wZXJ0eSA9IFwibm9uZVwiO1xuXHRcdHRoaXMuX3RyYW5zaXRpb24gPSBfLmV4dGVuZCh0aGlzLl90cmFuc2l0aW9uLCBVTlNFVF9UUkFOU0lUSU9OKTtcblx0XHR0aGlzLl90cmFuc2l0aW9uVmFsdWUgPSBOT19UUkFOU0lUSU9OX1ZBTFVFO1xuXG5cdFx0dGhpcy5faGFzVHJhbnNpdGlvbiA9IGZhbHNlO1xuXHRcdHRoaXMuX3RyYW5zaXRpb25JbnZhbGlkID0gdHJ1ZTtcblx0XHQvLyBpZiAodGhpcy5pbW1lZGlhdGUpIHRoaXMuX3ZhbGlkYXRlVHJhbnNpdGlvbigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoZW5UcmFuc2l0aW9uRW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGQsIHAsIHBwO1xuXHRcdGlmICh0aGlzLl90cmFuc2l0aW9uSW52YWxpZCB8fCB0aGlzLl90cmFuc2l0aW9uUnVubmluZykge1xuXHRcdFx0ZCA9IHt9O1xuXHRcdFx0cCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRkLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0XHRkLnJlamVjdCA9IHJlamVjdDtcblx0XHRcdH0pO1xuXHRcdFx0cHAgPSB0aGlzLl90cmFuc2l0aW9uSW52YWxpZCA/IHRoaXMuX3BlbmRpbmdQcm9taXNlcyA6IHRoaXMuX3Byb21pc2VzO1xuXHRcdFx0cHAucHVzaChkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cCA9IFByb21pc2UucmVzb2x2ZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cblx0LyogdmFsaWRhdGlvblxuXHQvKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtICovXG5cdHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblx0XHQvLyB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZCwgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCBmYWxzZSk7XG5cdFx0dGhpcy5faWdub3JlRXZlbnQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMuX2NhcHR1cmVJbnZhbGlkKSB7XG5cdFx0XHR2YXIgbGFzdFggPSAodGhpcy5fcmVuZGVyZWRYICE9PSBudWxsID8gdGhpcy5fcmVuZGVyZWRYIDogdGhpcy5fY2FwdHVyZWRYKSxcblx0XHRcdFx0bGFzdFkgPSAodGhpcy5fcmVuZGVyZWRZICE9PSBudWxsID8gdGhpcy5fcmVuZGVyZWRZIDogdGhpcy5fY2FwdHVyZWRZKTtcblxuXHRcdFx0Ly8gdGhpcy5fdmFsaWRhdGVUcmFuc2l0aW9uKCk7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZUNhcHR1cmUoKTtcblx0XHRcdHRoaXMuX3ZhbGlkYXRlT2Zmc2V0KCk7XG5cblx0XHRcdHZhciBjdXJyWCA9ICh0aGlzLl9yZW5kZXJlZFggIT09IG51bGwgPyB0aGlzLl9yZW5kZXJlZFggOiB0aGlzLl9jYXB0dXJlZFgpLFxuXHRcdFx0XHRjdXJyWSA9ICh0aGlzLl9yZW5kZXJlZFkgIT09IG51bGwgPyB0aGlzLl9yZW5kZXJlZFkgOiB0aGlzLl9jYXB0dXJlZFkpO1xuXG5cdFx0XHRpZiAobGFzdFggPT09IGN1cnJYICYmIGxhc3RZID09PSBjdXJyWSkge1xuXHRcdFx0XHR0aGlzLl9oYXNUcmFuc2l0aW9uICYmIGNvbnNvbGUud2FybihcInR4WyVzXTo6dmFsaWRhdGUgdW5jaGFuZ2VkOiBsYXN0OlslaSwlaV0gY3VycjpbJWksJWldXCIsIHRoaXMuZWwuaWQgfHwgdGhpcy5pZCwgbGFzdFgsIGxhc3RZLCBjdXJyWCwgY3VyclkpO1xuXHRcdFx0XHQvLyBjb25zb2xlLmluZm8oXCJ0eFslc106OnZhbGlkYXRlIHVuY2hhbmdlZDogbGFzdDpbJWYsJWZdIGN1cnI6WyVmLCVmXSByZW5kZXI6WyVmLCVmXSBjYXB0dXJlZFslZiwlZl1cIiwgdGhpcy5lbC5pZCB8fCB0aGlzLmlkLCBsYXN0WCwgbGFzdFksIGN1cnJYLCBjdXJyWSwgdGhpcy5fcmVuZGVyZWRYLCB0aGlzLl9yZW5kZXJlZFksIHRoaXMuX2NhcHR1cmVkWCwgdGhpcy5fY2FwdHVyZWRZKTtcblx0XHRcdFx0dGhpcy5jbGVhclRyYW5zaXRpb24oKTtcblx0XHRcdFx0Ly8gdGhpcy5fdmFsaWRhdGVUcmFuc2l0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl92YWxpZGF0ZVRyYW5zaXRpb24oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdGhpcy5fdmFsaWRhdGVDYXB0dXJlKCk7XG5cdFx0XHR0aGlzLl92YWxpZGF0ZVRyYW5zaXRpb24oKTtcblx0XHRcdHRoaXMuX3ZhbGlkYXRlT2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmQsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xuXHRcdHRoaXMuX2lnbm9yZUV2ZW50ID0gZmFsc2U7XG5cblx0XHQvLyBpZiAodGhpcy5fY2FwdHVyZWRDaGFuZ2VkKSB7XG5cdFx0Ly8gXHRjb25zb2xlLmVycm9yKFwidHhbJXNdOjp2YWxpZGF0ZSBjYXB0dXJlIGNoYW5nZWQ6IFslZiwlZl1cIiwgdGhpcy5pZCwgdGhpcy5fY2FwdHVyZWRYLCB0aGlzLl9jYXB0dXJlZFkpO1xuXHRcdC8vIH1cblx0XHR0aGlzLl9jYXB0dXJlZENoYW5nZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIFByaXZhdGVcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdF92YWxpZGF0ZUNhcHR1cmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY2FwdHVyZUludmFsaWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly8gdmFyIGNvbXB1dGVkLCBjYXB0dXJlZFZhbHVlcztcblx0XHR2YXIgdHJhbnNmb3JtVmFsdWUgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX2hhc09mZnNldCAmJiAhdGhpcy5fb2Zmc2V0SW52YWxpZCkge1xuXHRcdFx0Ly8gdGhpcyBpcyBhbiBleHBsaWNpdCBjYWxsIHRvIGNhcHR1cmUoKSBpbnN0ZWFkIG9mIGEgc3ViY2FsbCBmcm9tIF92YWxpZGF0ZU9mZnNldCgpXG5cdFx0XHR0cmFuc2Zvcm1WYWx1ZSA9IHRoaXMuX2dldENTU1Byb3AoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRpZiAodHJhbnNmb3JtVmFsdWUgPT09IFwiXCIpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcInR4WyVzXTo6X2NhcHR1cmUgdmFsaWQgb2Zmc2V0ICglaSwkaSkgYnV0IHRyYW5zZm9ybVZhbHVlPVxcXCJcXFwiXCIsIHRoaXMuaWQsIHRoaXMuX29mZnNldFgsIHRoaXMuX29mZnNldFkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlQ1NTUHJvcChcInRyYW5zZm9ybVwiKTtcblx0XHR9XG5cblx0XHQvLyBOT1RFOiByZXVzaW5nIG9iamVjdCwgYWxsIHByb3BzIHdpbGwgYmUgb3ZlcndyaXR0ZW5cblx0XHR0aGlzLl9sYXN0Q2FwdHVyZSA9IHRoaXMuX2N1cnJDYXB0dXJlO1xuXHRcdHRoaXMuX2N1cnJDYXB0dXJlID0gdGhpcy5fZ2V0Q29tcHV0ZWRDU1NQcm9wcygpO1xuXG5cdFx0aWYgKHRoaXMuX2N1cnJDYXB0dXJlLnRyYW5zZm9ybSAhPT0gdGhpcy5fbGFzdENhcHR1cmUudHJhbnNmb3JtKSB7XG5cdFx0XHR2YXIgbSwgbW07IC8vLCByZXQgPSB7fTtcblx0XHRcdG1tID0gdGhpcy5fY3VyckNhcHR1cmUudHJhbnNmb3JtLm1hdGNoKC8obWF0cml4fG1hdHJpeDNkKVxcKChbXlxcKV0rKVxcKS8pO1xuXHRcdFx0aWYgKG1tKSB7XG5cdFx0XHRcdG0gPSBtbVsyXS5zcGxpdChcIixcIik7XG5cdFx0XHRcdGlmIChtbVsxXSA9PT0gXCJtYXRyaXhcIikge1xuXHRcdFx0XHRcdHRoaXMuX2NhcHR1cmVkWCA9IHBhcnNlRmxvYXQobVs0XSk7XG5cdFx0XHRcdFx0dGhpcy5fY2FwdHVyZWRZID0gcGFyc2VGbG9hdChtWzVdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9jYXB0dXJlZFggPSBwYXJzZUZsb2F0KG1bMTJdKTtcblx0XHRcdFx0XHR0aGlzLl9jYXB0dXJlZFkgPSBwYXJzZUZsb2F0KG1bMTNdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fY2FwdHVyZWRYID0gMDtcblx0XHRcdFx0dGhpcy5fY2FwdHVyZWRZID0gMDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NhcHR1cmVkQ2hhbmdlZCA9IHRydWU7XG5cdFx0fVxuXHRcdGlmICh0cmFuc2Zvcm1WYWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJ0eFslc106Ol9jYXB0dXJlIHJlYXBwbHlpbmcgJyVzJ1wiLCB0aGlzLmlkLCB0cmFuc2Zvcm1WYWx1ZSk7XG5cdFx0XHR0aGlzLl9zZXRDU1NQcm9wKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybVZhbHVlKTtcblx0XHR9XG5cdFx0dGhpcy5fY2FwdHVyZUludmFsaWQgPSBmYWxzZTtcblx0fSxcblxuXHRfdmFsaWRhdGVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vZmZzZXRJbnZhbGlkKSB7XG5cdFx0XHQvLyB0aGlzLl92YWxpZGF0ZUNhcHR1cmUoKTtcblx0XHRcdHRoaXMuX29mZnNldEludmFsaWQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLl9oYXNPZmZzZXQpIHtcblx0XHRcdFx0dmFyIHR4ID0gdGhpcy5fb2Zmc2V0WCArIHRoaXMuX2NhcHR1cmVkWDtcblx0XHRcdFx0dmFyIHR5ID0gdGhpcy5fb2Zmc2V0WSArIHRoaXMuX2NhcHR1cmVkWTtcblx0XHRcdFx0aWYgKHR4ICE9PSB0aGlzLl9yZW5kZXJlZFggfHwgdHkgIT09IHRoaXMuX3JlbmRlcmVkWSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlbmRlcmVkWCA9IHR4O1xuXHRcdFx0XHRcdHRoaXMuX3JlbmRlcmVkWSA9IHR5O1xuXHRcdFx0XHRcdHRoaXMuX3NldENTU1Byb3AoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlVGVtcGxhdGUodGhpcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yZW5kZXJlZFggPSBudWxsO1xuXHRcdFx0XHR0aGlzLl9yZW5kZXJlZFkgPSBudWxsO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDU1NQcm9wKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdmFsaWRhdGVUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fdHJhbnNpdGlvbkludmFsaWQpIHtcblx0XHRcdC8vIHRoaXMuX3ZhbGlkYXRlQ2FwdHVyZSgpO1xuXHRcdFx0dGhpcy5fdHJhbnNpdGlvbkludmFsaWQgPSBmYWxzZTtcblxuXHRcdFx0Ly8gc2F2ZSBwcm9taXNlcyBtYWRlIHdoaWxlIGludmFsaWRcblx0XHRcdHZhciByZWplY3QgPSB0aGlzLl9wcm9taXNlcztcblx0XHRcdC8vIHByZXBhcmUgX3Byb21pc2VzIGFuZCBwdXNoIGluIG5ldyBvbmVzXG5cdFx0XHR0aGlzLl9wcm9taXNlcyA9IHRoaXMuX3BlbmRpbmdQcm9taXNlcztcblx0XHRcdC8vIHdoYXRldmVyIHN0aWxsIGhlcmUgaXMgdG8gYmUgcmVqZWN0ZWQuIHJldXNlIGFycmF5XG5cdFx0XHR0aGlzLl9wZW5kaW5nUHJvbWlzZXMgPSByZWplY3RBbGwocmVqZWN0LCB0aGlzKTtcblxuXHRcdFx0Ly8gU2V0IHJ1bm5pbmcgZmxhZywgaWYgdGhlcmUncyBhIHRyYW5zaXRpb24gdG8gcnVuXG5cdFx0XHR0aGlzLl90cmFuc2l0aW9uUnVubmluZyA9IHRoaXMuX2hhc1RyYW5zaXRpb247XG5cdFx0XHQvLyBTZXQgdGhlIGNzcyB2YWx1ZSAod2hpY2ggd2lsbCBiZSBlbXB0eSBzdHJpbmcgaWYgdGhlcmUncyBubyB0cmFuc2l0aW9uKVxuXHRcdFx0dGhpcy5fc2V0Q1NTUHJvcChcInRyYW5zaXRpb25cIiwgdGhpcy5fdHJhbnNpdGlvblZhbHVlKTtcblx0XHRcdGlmIChERUJVRykge1xuXHRcdFx0XHRpZiAodGhpcy5faGFzVHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdHRoaXMuZWwuc2V0QXR0cmlidXRlKFwiZGF0YS10eFwiLCB0aGlzLl90cmFuc2l0aW9uLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5faGFzVHJhbnNpdGlvbikge1xuXHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBubyB0cmFuc2l0aW9uLCByZXNvbHZlIHByb21pc2VzIG5vd1xuXHRcdFx0XHRyZXNvbHZlQWxsKHRoaXMuX3Byb21pc2VzLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X29uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAodGhpcy5faWdub3JlRXZlbnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3RyYW5zaXRpb25SdW5uaW5nICYmICh0aGlzLmVsID09PSBldi50YXJnZXQpICYmXG5cdFx0XHQodGhpcy5fdHJhbnNpdGlvbi5wcm9wZXJ0eSA9PSBldi5wcm9wZXJ0eU5hbWUpKSB7XG5cdFx0XHR0aGlzLl9oYXNUcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHR0aGlzLl90cmFuc2l0aW9uUnVubmluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ1NTUHJvcChcInRyYW5zaXRpb25cIik7XG5cdFx0XHRyZXNvbHZlQWxsKHRoaXMuX3Byb21pc2VzLCB0aGlzKTtcblxuXHRcdFx0aWYgKERFQlVHKSB7XG5cdFx0XHRcdGlmICh0aGlzLmVsLmhhc0F0dHJpYnV0ZShcImRhdGEtdHhcIikpIHtcblx0XHRcdFx0XHQvLyB0aGlzLmVsLnNldEF0dHJpYnV0ZShcImRhdGEtdHgtbGFzdFwiLCB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtdHhcIikpO1xuXHRcdFx0XHRcdHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10eFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8qIENTU1xuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0X2dldENTU1Byb3A6IGZ1bmN0aW9uKHByb3ApIHtcblx0XHRyZXR1cm4gdGhpcy5lbC5zdHlsZVtwcm9wTmFtZXNbcHJvcF1dO1xuXHRcdC8vIHJldHVybiB0aGlzLmVsLnN0eWxlW3ByZWZpeGVkUHJvcGVydHkocHJvcCldO1xuXHRcdC8vIHJldHVybiB0aGlzLmVsLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVOYW1lc1twcm9wXSk7XG5cdH0sXG5cblx0X3NldENTU1Byb3A6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG5cdFx0aWYgKHByb3AgPT09IFwidHJhbnNpdGlvblwiICYmIHZhbHVlID09IE5PX1RSQU5TSVRJT05fVkFMVUUpIHtcblx0XHRcdHZhbHVlID0gXCJcIjtcblx0XHR9XG5cdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IFwiXCIpIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNTU1Byb3AocHJvcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWwuc3R5bGVbcHJvcE5hbWVzW3Byb3BdXSA9IHZhbHVlO1xuXHRcdFx0Ly8gdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWVzW3Byb3BdLCB2YWx1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVDU1NQcm9wOiBmdW5jdGlvbihwcm9wKSB7XG5cdFx0dGhpcy5lbC5zdHlsZVtwcm9wTmFtZXNbcHJvcF1dID0gXCJcIjtcblx0XHQvLyB0aGlzLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KHN0eWxlTmFtZXNbcHJvcF0pO1xuXHR9LFxuXG5cdF9nZXRDb21wdXRlZENTU1Byb3BzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG5cdFx0Zm9yICh2YXIgcCBpbiBwcm9wTmFtZXMpIHtcblx0XHRcdHZhbHVlc1twXSA9IGNvbXB1dGVkW3Byb3BOYW1lc1twXV07XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG59LCB7XG5cdHRyYW5zaXRpb246IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RyYW5zaXRpb247XG5cdFx0fVxuXHR9LFxuXHRoYXNUcmFuc2l0aW9uOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9oYXNUcmFuc2l0aW9uO1xuXHRcdH1cblx0fSxcblx0Y2FwdHVyZWRDaGFuZ2VkOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYXB0dXJlZENoYW5nZWQ7XG5cdFx0fVxuXHR9LFxuXHRjYXB0dXJlZFg6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhcHR1cmVkWDtcblx0XHR9XG5cdH0sXG5cdGNhcHR1cmVkWToge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FwdHVyZWRZO1xuXHRcdH1cblx0fSxcblxuXHRoYXNPZmZzZXQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2hhc09mZnNldDtcblx0XHR9XG5cdH0sXG5cdG9mZnNldFg6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX29mZnNldFg7XG5cdFx0fVxuXHR9LFxuXHRvZmZzZXRZOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9vZmZzZXRZO1xuXHRcdH1cblx0fSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybUl0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYTEsIGEyLCBkZXN0KSB7XG5cdHJldHVybiBhMS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBvLCBpLCBhKSB7XG5cdFx0aWYgKGEyLmluZGV4T2YobykgPT0gLTEpIHJlcy5wdXNoKG8pO1xuXHRcdHJldHVybiByZXM7XG5cdH0sIChkZXN0ICE9PSB2b2lkIDApID8gZGVzdCA6IFtdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcblxudmFyIHNwbGljZSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG4vLyB2YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLypcbiAqXHRVc2luZyBqYXZhc2NyaXB0IHRvIGNvbnZlcnQgcmFkaWFucyB0byBkZWdyZWVzIHdpdGggcG9zaXRpdmUgYW5kXG4gKlx0bmVnYXRpdmUgdmFsdWVzIFtodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yOTU4ODQwNC9dXG4gKlx0YCgoKHIgKiAoMTgwL01hdGguUEkpKSAlIDM2MCkgKyAzNjApICUgMzYwO2BcbiAqXHRgZnVuY3Rpb24gbW9kKG4sIG0pIHtcbiAqXHRcdHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbiAqXHR9YFxuICovXG52YXIgX21vZCA9IGZ1bmN0aW9uKG4sIG0pIHtcblx0cmV0dXJuICgobiAlIG0pICsgbSkgJSBtO1xufTtcblxudmFyIHNldFN0eWxlID0gZnVuY3Rpb24oY3R4LCBzKSB7XG5cdGlmICh0eXBlb2YgcyAhPSBcIm9iamVjdFwiKSByZXR1cm47XG5cdGZvciAodmFyIHAgaW4gcykge1xuXHRcdHN3aXRjaCAodHlwZW9mIGN0eFtwXSkge1xuXHRcdFx0Y2FzZSBcInVuZGVmaW5lZFwiOlxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJmdW5jdGlvblwiOlxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzW3BdKSkge1xuXHRcdFx0XHRcdGN0eFtwXS5hcHBseShjdHgsIHNbcF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eFtwXS5jYWxsKGN0eCwgc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjdHhbcF0gPSBzW3BdO1xuXHRcdH1cblx0fVxufTtcblxudmFyIF9kcmF3U2hhcGUgPSBmdW5jdGlvbihmbiwgcywgY3R4KSB7XG5cdGN0eC5zYXZlKCk7XG5cdGlmIChzKSB7XG5cdFx0c2V0U3R5bGUoY3R4LCBzKTtcblx0fVxuXHRmbi5hcHBseShudWxsLCBzcGxpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcblx0aWYgKCdzdHJva2VTdHlsZScgaW4gcykgeyAvKiBjdHgubGluZVdpZHRoID4gMCAqL1xuXHRcdGN0eC5zdHJva2UoKTtcblx0fVxuXHRpZiAoJ2ZpbGxTdHlsZScgaW4gcykgeyAvKiBjdHguZmlsbFN0eWxlICE9PSBcInRyYW5zcGFyZW50XCIgKi9cblx0XHRjdHguZmlsbCgpO1xuXHR9XG5cdGN0eC5yZXN0b3JlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c2V0U3R5bGU6IHNldFN0eWxlLFxuXG5cdHZHdWlkZTogZnVuY3Rpb24oY3R4LCB4KSB7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5tb3ZlVG8oeCwgMCk7XG5cdFx0Y3R4LmxpbmVUbyh4LCBjdHguY2FudmFzLmhlaWdodCk7XG5cdH0sXG5cdGRyYXdWR3VpZGU6IGZ1bmN0aW9uKGN0eCwgcywgeCkge1xuXHRcdF9kcmF3U2hhcGUodGhpcy52R3VpZGUsIHMsIGN0eCwgeCk7XG5cdH0sXG5cblx0aEd1aWRlOiBmdW5jdGlvbihjdHgsIHkpIHtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbygwLCB5KTtcblx0XHRjdHgubGluZVRvKGN0eC5jYW52YXMud2lkdGgsIHkpO1xuXHR9LFxuXHRkcmF3SEd1aWRlOiBmdW5jdGlvbihjdHgsIHMsIHkpIHtcblx0XHRfZHJhd1NoYXBlKHRoaXMuaEd1aWRlLCBzLCBjdHgsIHkpO1xuXHR9LFxuXG5cdGNyb3NzaGFpcjogZnVuY3Rpb24oY3R4LCB4LCB5LCByKSB7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHgudHJhbnNsYXRlKHgsIHkpO1xuXHRcdGN0eC5yb3RhdGUoTWF0aC5QSSAvIDQpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgubW92ZVRvKDAsIC1yKTtcblx0XHRjdHgubGluZVRvKDAsIHIpO1xuXHRcdGN0eC5tb3ZlVG8oLXIsIDApO1xuXHRcdGN0eC5saW5lVG8ociwgMCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblx0ZHJhd0Nyb3NzaGFpcjogZnVuY3Rpb24oY3R4LCBzLCB4LCB5LCByKSB7XG5cdFx0X2RyYXdTaGFwZSh0aGlzLmNyb3NzaGFpciwgcywgY3R4LCB4LCB5LCByKTtcblx0fSxcblxuXHRjaXJjbGU6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgcikge1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHgsIHksIHIsIDAsIFBJMik7XG5cdH0sXG5cdGRyYXdDaXJjbGU6IGZ1bmN0aW9uKGN0eCwgcywgeCwgeSwgcikge1xuXHRcdF9kcmF3U2hhcGUodGhpcy5jaXJjbGUsIHMsIGN0eCwgeCwgeSwgcik7XG5cdH0sXG5cblx0c3F1YXJlOiBmdW5jdGlvbihjdHgsIHgsIHksIHIpIHtcblx0XHRyID0gTWF0aC5mbG9vcihyIC8gMikgKiAyO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdCh4IC0gciwgeSAtIHIsIHIgKiAyLCByICogMik7XG5cdH0sXG5cdGRyYXdTcXVhcmU6IGZ1bmN0aW9uKGN0eCwgcywgeCwgeSwgcikge1xuXHRcdF9kcmF3U2hhcGUodGhpcy5zcXVhcmUsIHMsIGN0eCwgeCwgeSwgcik7XG5cdH0sXG5cblx0YXJyb3doZWFkOiBmdW5jdGlvbihjdHgsIHgsIHksIHIsIHQpIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC50cmFuc2xhdGUoeCwgeSk7XG5cdFx0Y3R4LnJvdGF0ZShfbW9kKHQsIFBJMikpO1xuXHRcdGN0eC50cmFuc2xhdGUociAqIDAuNSwgMCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5tb3ZlVG8oMCwgMCk7XG5cdFx0Ly8gY3R4LmxpbmVUbygtciwgciAqIE1hdGguU1FSVDFfMik7XG5cdFx0Ly8gY3R4LmxpbmVUbygtciwgLXIgKiBNYXRoLlNRUlQxXzIpO1xuXHRcdGN0eC5saW5lVG8oLXIgKiBNYXRoLlNRUlQyLCByICogTWF0aC5TUVJUMV8yKTtcblx0XHRjdHguYXJjVG8oMCwgMCwgLXIgKiBNYXRoLlNRUlQyLCAtciAqIE1hdGguU1FSVDFfMiwgcik7XG5cdFx0Ly8gY3R4LnF1YWRyYXRpY0N1cnZlVG8oMCwgMCwgLXIgKiBNYXRoLlNRUlQyLCAtciAqIE1hdGguU1FSVDFfMik7XG5cdFx0Y3R4LmxpbmVUbygwLCAwKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblx0ZHJhd0Fycm93aGVhZDogZnVuY3Rpb24oY3R4LCBzLCB4LCB5LCByLCB0KSB7XG5cdFx0X2RyYXdTaGFwZSh0aGlzLmFycm93aGVhZCwgcywgY3R4LCB4LCB5LCByLCB0KTtcblx0fSxcblxuXHRhcnJvd2hlYWQyOiBmdW5jdGlvbihjdHgsIHgsIHksIHIsIHQpIHtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC50cmFuc2xhdGUoeCwgeSk7XG5cdFx0Y3R4LnJvdGF0ZShfbW9kKHQsIFBJMikpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgubW92ZVRvKC1yLCByICogTWF0aC5TUVJUMV8yKTtcblx0XHRjdHgubGluZVRvKDAsIDApO1xuXHRcdGN0eC5saW5lVG8oLXIsIC1yICogTWF0aC5TUVJUMV8yKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXHRkcmF3QXJyb3doZWFkMjogZnVuY3Rpb24oY3R4LCBzLCB4LCB5LCByLCB0KSB7XG5cdFx0X2RyYXdTaGFwZSh0aGlzLmFycm93aGVhZCwgcywgY3R4LCB4LCB5LCByLCB0KTtcblx0fSxcblxuXHRyZWN0OiBmdW5jdGlvbihjdHgsIGExLCBhMiwgYTMsIGE0KSB7XG5cdFx0aWYgKHR5cGVvZiBhMSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0YTQgPSBhMS5oZWlnaHQ7XG5cdFx0XHRhMyA9IGExLndpZHRoO1xuXHRcdFx0YTIgPSBhMS50b3A7XG5cdFx0XHRhMSA9IGExLmxlZnQ7XG5cdFx0fVxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChhMSwgYTIsIGEzLCBhNCk7XG5cdH0sXG5cdGRyYXdSZWN0OiBmdW5jdGlvbihjdHgsIHMsIGExLCBhMiwgYTMsIGE0KSB7XG5cdFx0X2RyYXdTaGFwZSh0aGlzLnJlY3QsIHMsIGN0eCwgYTEsIGEyLCBhMywgYTQpO1xuXHR9LFxuXG5cdHJvdW5kUmVjdDogZnVuY3Rpb24oY3R4LCB4LCB5LCB3LCBoLCByKSB7XG5cdFx0aWYgKHcgPCAyICogcikgciA9IHcgLyAyO1xuXHRcdGlmIChoIDwgMiAqIHIpIHIgPSBoIC8gMjtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbyh4ICsgciwgeSk7XG5cdFx0Y3R4LmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIGgsIHIpO1xuXHRcdGN0eC5hcmNUbyh4ICsgdywgeSArIGgsIHgsIHkgKyBoLCByKTtcblx0XHRjdHguYXJjVG8oeCwgeSArIGgsIHgsIHksIHIpO1xuXHRcdGN0eC5hcmNUbyh4LCB5LCB4ICsgdywgeSwgcik7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9LFxuXHRkcmF3Um91bmRSZWN0OiBmdW5jdGlvbihjdHgsIHMsIHgsIHksIHcsIGgsIHIpIHtcblx0XHRfZHJhd1NoYXBlKHRoaXMucm91bmRSZWN0LCBzLCBjdHgsIHgsIHksIGgsIHIpO1xuXHR9LFxuXG5cdHF1YWRSb3VuZFJlY3Q6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgdywgaCwgcikge1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgubW92ZVRvKHgsIHkgKyByKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgciwgeSk7XG5cdFx0Y3R4LmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3LCB5LCB4ICsgdywgeSArIHIpO1xuXHRcdGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoKTtcblx0XHRjdHgubGluZVRvKHggKyByLCB5ICsgaCk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gcik7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9LFxuXHRkcmF3UXVhZFJvdW5kUmVjdDogZnVuY3Rpb24oY3R4LCBzLCB4LCB5LCB3LCBoLCByKSB7XG5cdFx0X2RyYXdTaGFwZSh0aGlzLnF1YWRSb3VuZFJlY3QsIHMsIGN0eCwgeCwgeSwgaCwgcik7XG5cdH0sXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuXG5TdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG5WZXJzaW9uOiAgMC41XG5BdXRob3I6IE1hcmlvIEtsaW5nZW1hbm5cbkNvbnRhY3Q6ICBtYXJpb0BxdWFzaW1vbmRvLmNvbVxuV2Vic2l0ZTogaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcblR3aXR0ZXI6IEBxdWFzaW1vbmRvXG5cbkluIGNhc2UgeW91IGZpbmQgdGhpcyBjbGFzcyB1c2VmdWwgLSBlc3BlY2lhbGx5IGluIGNvbW1lcmNpYWwgcHJvamVjdHMgLVxuSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG5tYXJpb0BxdWFzaW1vbmRvLmRlXG5cbk9yIHN1cHBvcnQgbWUgb24gZmxhdHRyOiBcbmh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxub2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbmZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxucmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG5jb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5Tb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbkhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG5PVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnIgPSAwO1xuXHR0aGlzLmcgPSAwO1xuXHR0aGlzLmIgPSAwO1xuXHR0aGlzLmEgPSAwO1xuXHR0aGlzLm5leHQgPSBudWxsO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbWFnZURhdGEsIGFkaikge1xuXHR2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG5cdHZhciByLCBnLCBiLCBzO1xuXHR2YXIgaSwgaWk7XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRmb3IgKGkgPSAwLCBpaSA9IHBpeGVscy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG5cdFx0XHRwaXhlbHNbaV0gPSAocGl4ZWxzW2ldICogMjk5ICsgcGl4ZWxzW2kgKyAxXSAqIDU4NyArIHBpeGVsc1tpICsgMl0gKiAxNDQpIC8gMTAwMDtcblx0XHR9XG5cdH0gZWxzZVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuXHRcdGlmICgwID49IGFkaiA+IDEpIHtcblx0XHRcdGNvbnNvbGUud2FybihcImFyZ3VtZW50IG91dCBvZiByYW5nZSAoMS0wKVwiLCBhZGopO1xuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgaWkgPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuXHRcdFx0ciA9IHBpeGVsc1tpXTtcblx0XHRcdGcgPSBwaXhlbHNbaSArIDFdO1xuXHRcdFx0YiA9IHBpeGVsc1tpICsgMl07XG5cdFx0XHQvLyBzID0gKChyICogMjk5ICsgZyAqIDU4NyArIGIgKiAxNDQpIC8gMTAwMCkgKiAoMSAtIGFkaik7XG5cdFx0XHQvLyBwaXhlbHNbaV0gPSByICogYWRqICsgcztcblx0XHRcdC8vIHBpeGVsc1tpICsgMV0gPSBnICogYWRqICsgcztcblx0XHRcdC8vIHBpeGVsc1tpICsgMl0gPSBiICogYWRqICsgcztcblx0XHRcdHMgPSBNYXRoLm1heChyLCBnLCBiKTtcblx0XHRcdGlmIChzID09PSAwKSB7XG5cdFx0XHRcdHBpeGVsc1tpXSA9IE1hdGgucm91bmQoMjU1ICogYWRqKTtcblx0XHRcdFx0cGl4ZWxzW2kgKyAxXSA9IE1hdGgucm91bmQoMjU1ICogYWRqKTtcblx0XHRcdFx0cGl4ZWxzW2kgKyAyXSA9IE1hdGgucm91bmQoMjU1ICogYWRqKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHMgPSAyNTUgKiBhZGogLyBzO1xuXHRcdFx0XHRwaXhlbHNbaV0gPSBNYXRoLnJvdW5kKHIgKiBzKTtcblx0XHRcdFx0cGl4ZWxzW2kgKyAxXSA9IE1hdGgucm91bmQoZyAqIHMpO1xuXHRcdFx0XHRwaXhlbHNbaSArIDJdID0gTWF0aC5yb3VuZChiICogcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBpbWFnZURhdGE7XG59O1xuXG4vLyBmdW5jdGlvbiBzYXR1cmF0aW9uKHIsZyxiLCBzKSB7XG4vLyAgICAgdmFyIG1pbiA9IHJnYi5pbmRleE9mKE1hdGgubWluLmFwcGx5KG51bGwsIHJnYikpLCAvLyBpbmRleCBvZiBtaW5cbi8vICAgICAgICAgbWF4ID0gcmdiLmluZGV4T2YoTWF0aC5tYXguYXBwbHkobnVsbCwgcmdiKSksIC8vIGluZGV4IG9mIG1heFxuLy8gICAgICAgICBtaWQgPSBbMCwgMSwgMl0uZmlsdGVyKGZ1bmN0aW9uIChpKSB7cmV0dXJuIGkgIT09IG1pbiAmJiBpICE9PSBtYXg7fSlbMF0sXG4vLyAgICAgICAgIGEgPSByZ2JbbWF4XSAtIHJnYlttaW5dLFxuLy8gICAgICAgICBiID0gcmdiW21pZF0gLSByZ2JbbWluXSxcbi8vICAgICAgICAgeCA9IHJnYlttYXhdLFxuLy8gICAgICAgICBhcnIgPSBbeCwgeCwgeF07XG4vLyAgICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4vLyAgICAgICAgIG1pbiA9IDI7IC8vIGJvdGggbWF4ID0gbWluID0gMCwgPT4gbWlkID0gMSwgc28gc2V0IG1pbiA9IDJcbi8vICAgICAgICAgYSA9IDE7ICAgLy8gYWxzbyBtZWFucyBhID0gYiA9IDAsIGRvbid0IHdhbnQgZGl2aXNpb24gYnkgMCBpbiBgYiAvIGFgXG4vLyAgICAgfVxuLy9cbi8vICAgICBhcnJbbWF4XSA9IHg7XG4vLyAgICAgYXJyW21pbl0gPSBNYXRoLnJvdW5kKHggKiAoMSAtIHMpKTtcbi8vICAgICBhcnJbbWlkXSA9IE1hdGgucm91bmQoeCAqICgoMSAtIHMpICsgcyAqIGIgLyBhKSk7XG4vL1xuLy8gICAgIHJldHVybiBhcnI7XG4vLyB9XG5cblxuLy8gZnVuY3Rpb24gbnZhbHVlKHJnYiwgdikge1xuLy8gICAgIHZhciB4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgcmdiKTtcbi8vICAgICBpZiAoeCA9PT0gMClcbi8vICAgICAgICAgcmV0dXJuIFtcbi8vICAgICAgICAgICAgIE1hdGgucm91bmQoMjU1ICogdiksXG4vLyAgICAgICAgICAgICBNYXRoLnJvdW5kKDI1NSAqIHYpLFxuLy8gICAgICAgICAgICAgTWF0aC5yb3VuZCgyNTUgKiB2KVxuLy8gICAgICAgICBdO1xuLy8gICAgIHggPSAyNTUgKiB2IC8geDtcbi8vICAgICByZXR1cm4gW1xuLy8gICAgICAgICBNYXRoLnJvdW5kKHJnYlswXSAqIHgpLFxuLy8gICAgICAgICBNYXRoLnJvdW5kKHJnYlsxXSAqIHgpLFxuLy8gICAgICAgICBNYXRoLnJvdW5kKHJnYlsyXSAqIHgpXG4vLyAgICAgXTtcbi8vIH1cbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbWFnZURhdGEsIG9wdHMpIHtcblx0dmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuXHR2YXIgcGl4ZWxzTnVtID0gcGl4ZWxzLmxlbmd0aDtcblx0dmFyIHJnYkF2ZyA9IFswLCAwLCAwXTtcblx0dmFyIGk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHBpeGVsc051bTsgaSArPSA0KSB7XG5cdFx0cmdiQXZnWzBdICs9IHBpeGVsc1tpXTtcblx0XHRyZ2JBdmdbMV0gKz0gcGl4ZWxzW2kgKyAxXTtcblx0XHRyZ2JBdmdbMl0gKz0gcGl4ZWxzW2kgKyAyXTtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0cmdiQXZnW2ldID0gKHJnYkF2Z1tpXSAvIChwaXhlbHNOdW0gLyA0KSkgfCAwO1xuXHR9XG5cdHJldHVybiByZ2JBdmc7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuXG5TdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG5WZXJzaW9uOiAgMC41XG5BdXRob3I6IE1hcmlvIEtsaW5nZW1hbm5cbkNvbnRhY3Q6ICBtYXJpb0BxdWFzaW1vbmRvLmNvbVxuV2Vic2l0ZTogaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcblR3aXR0ZXI6IEBxdWFzaW1vbmRvXG5cbkluIGNhc2UgeW91IGZpbmQgdGhpcyBjbGFzcyB1c2VmdWwgLSBlc3BlY2lhbGx5IGluIGNvbW1lcmNpYWwgcHJvamVjdHMgLVxuSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG5tYXJpb0BxdWFzaW1vbmRvLmRlXG5cbk9yIHN1cHBvcnQgbWUgb24gZmxhdHRyOiBcbmh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxub2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbmZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxucmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG5jb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5Tb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbkhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG5PVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcblx0XHQ1MTIsIDUxMiwgNDU2LCA1MTIsIDMyOCwgNDU2LCAzMzUsIDUxMiwgNDA1LCAzMjgsIDI3MSwgNDU2LCAzODgsIDMzNSwgMjkyLCA1MTIsXG5cdFx0NDU0LCA0MDUsIDM2NCwgMzI4LCAyOTgsIDI3MSwgNDk2LCA0NTYsIDQyMCwgMzg4LCAzNjAsIDMzNSwgMzEyLCAyOTIsIDI3MywgNTEyLFxuXHRcdDQ4MiwgNDU0LCA0MjgsIDQwNSwgMzgzLCAzNjQsIDM0NSwgMzI4LCAzMTIsIDI5OCwgMjg0LCAyNzEsIDI1OSwgNDk2LCA0NzUsIDQ1Nixcblx0XHQ0MzcsIDQyMCwgNDA0LCAzODgsIDM3NCwgMzYwLCAzNDcsIDMzNSwgMzIzLCAzMTIsIDMwMiwgMjkyLCAyODIsIDI3MywgMjY1LCA1MTIsXG5cdFx0NDk3LCA0ODIsIDQ2OCwgNDU0LCA0NDEsIDQyOCwgNDE3LCA0MDUsIDM5NCwgMzgzLCAzNzMsIDM2NCwgMzU0LCAzNDUsIDMzNywgMzI4LFxuXHRcdDMyMCwgMzEyLCAzMDUsIDI5OCwgMjkxLCAyODQsIDI3OCwgMjcxLCAyNjUsIDI1OSwgNTA3LCA0OTYsIDQ4NSwgNDc1LCA0NjUsIDQ1Nixcblx0XHQ0NDYsIDQzNywgNDI4LCA0MjAsIDQxMiwgNDA0LCAzOTYsIDM4OCwgMzgxLCAzNzQsIDM2NywgMzYwLCAzNTQsIDM0NywgMzQxLCAzMzUsXG5cdFx0MzI5LCAzMjMsIDMxOCwgMzEyLCAzMDcsIDMwMiwgMjk3LCAyOTIsIDI4NywgMjgyLCAyNzgsIDI3MywgMjY5LCAyNjUsIDI2MSwgNTEyLFxuXHRcdDUwNSwgNDk3LCA0ODksIDQ4MiwgNDc1LCA0NjgsIDQ2MSwgNDU0LCA0NDcsIDQ0MSwgNDM1LCA0MjgsIDQyMiwgNDE3LCA0MTEsIDQwNSxcblx0XHQzOTksIDM5NCwgMzg5LCAzODMsIDM3OCwgMzczLCAzNjgsIDM2NCwgMzU5LCAzNTQsIDM1MCwgMzQ1LCAzNDEsIDMzNywgMzMyLCAzMjgsXG5cdFx0MzI0LCAzMjAsIDMxNiwgMzEyLCAzMDksIDMwNSwgMzAxLCAyOTgsIDI5NCwgMjkxLCAyODcsIDI4NCwgMjgxLCAyNzgsIDI3NCwgMjcxLFxuXHRcdDI2OCwgMjY1LCAyNjIsIDI1OSwgMjU3LCA1MDcsIDUwMSwgNDk2LCA0OTEsIDQ4NSwgNDgwLCA0NzUsIDQ3MCwgNDY1LCA0NjAsIDQ1Nixcblx0XHQ0NTEsIDQ0NiwgNDQyLCA0MzcsIDQzMywgNDI4LCA0MjQsIDQyMCwgNDE2LCA0MTIsIDQwOCwgNDA0LCA0MDAsIDM5NiwgMzkyLCAzODgsXG5cdFx0Mzg1LCAzODEsIDM3NywgMzc0LCAzNzAsIDM2NywgMzYzLCAzNjAsIDM1NywgMzU0LCAzNTAsIDM0NywgMzQ0LCAzNDEsIDMzOCwgMzM1LFxuXHRcdDMzMiwgMzI5LCAzMjYsIDMyMywgMzIwLCAzMTgsIDMxNSwgMzEyLCAzMTAsIDMwNywgMzA0LCAzMDIsIDI5OSwgMjk3LCAyOTQsIDI5Mixcblx0XHQyODksIDI4NywgMjg1LCAyODIsIDI4MCwgMjc4LCAyNzUsIDI3MywgMjcxLCAyNjksIDI2NywgMjY1LCAyNjMsIDI2MSwgMjU5XTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwaXhlbHMsIGFkanVzdG1lbnQpIHtcblx0dmFyIGQgPSBwaXhlbHMuZGF0YTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSArPSA0KSB7XG5cdFx0ZFtpXSAqPSBhZGp1c3RtZW50O1xuXHRcdGRbaSArIDFdICo9IGFkanVzdG1lbnQ7XG5cdFx0ZFtpICsgMl0gKj0gYWRqdXN0bWVudDtcblx0fVxuXHRyZXR1cm4gcGl4ZWxzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLypcblxuU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuVmVyc2lvbjogIDAuNVxuQXV0aG9yOiBNYXJpbyBLbGluZ2VtYW5uXG5Db250YWN0OiAgbWFyaW9AcXVhc2ltb25kby5jb21cbldlYnNpdGU6IGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXG5Ud2l0dGVyOiBAcXVhc2ltb25kb1xuXG5JbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbkkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxubWFyaW9AcXVhc2ltb25kby5kZVxuXG5PciBzdXBwb3J0IG1lIG9uIGZsYXR0cjogXG5odHRwczovL2ZsYXR0ci5jb20vdGhpbmcvNzI3OTEvU3RhY2tCbHVyLWEtZmFzdC1hbG1vc3QtR2F1c3NpYW4tQmx1ci1FZmZlY3QtZm9yLUNhbnZhc0phdmFzY3JpcHRcblxuQ29weXJpZ2h0IChjKSAyMDEwIE1hcmlvIEtsaW5nZW1hbm5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbm9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG5maWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbnJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbmNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG5IT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbldIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSBbXG5cdFx0OSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNyxcblx0XHQxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOSxcblx0XHQxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCxcblx0XHQyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSxcblx0XHQyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSxcblx0XHQyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcblx0XHQyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcblx0XHQyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMyxcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcblx0XHQyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0XTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuLypcblxuU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuVmVyc2lvbjogIDAuNVxuQXV0aG9yOiBNYXJpbyBLbGluZ2VtYW5uXG5Db250YWN0OiAgbWFyaW9AcXVhc2ltb25kby5jb21cbldlYnNpdGU6IGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXG5Ud2l0dGVyOiBAcXVhc2ltb25kb1xuXG5JbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbkkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxubWFyaW9AcXVhc2ltb25kby5kZVxuXG5PciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbmh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxub2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbmZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxucmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG5jb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5Tb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbkhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG5PVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBtdWxfdGFibGUgPSByZXF1aXJlKFwiLi9tdWxfdGFibGVcIik7XG5jb25zdCBzaGdfdGFibGUgPSByZXF1aXJlKFwiLi9zaGdfdGFibGVcIik7XG5jb25zdCBCbHVyU3RhY2sgPSByZXF1aXJlKFwiLi9CbHVyU3RhY2tcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW1hZ2VEYXRhLCBvcHRzKSB7XG5cdGlmICgodHlwZW9mIG9wdHMgPT09IFwib2JqZWN0XCIpICYmIG9wdHMuaGFzT3duUHJvcGVydHkoXCJyYWRpdXNcIikpIHtcblx0XHRvcHRzID0gb3B0cy5yYWRpdXM7XG5cdH1cblx0aWYgKCh0eXBlb2Ygb3B0cyAhPT0gXCJudW1iZXJcIikgfHwgaXNOYU4ob3B0cykgfHwgKDEgPiBvcHRzKSkge1xuXHRcdC8vIG5vIHZhbGlkIGFyZ3VtZW50IHZhbHVlIGRvIG5vdGhpbmdcblx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXHR9XG5cdHZhciByYWRpdXMgPSBvcHRzIHwgMDtcblx0dmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhLFxuXHRcdHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuXHRcdGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XG5cblx0dmFyIHgsIHksIGksIHAsIHlwLCB5aSwgeXcsIHJfc3VtLCBnX3N1bSwgYl9zdW0sXG5cdFx0cl9vdXRfc3VtLCBnX291dF9zdW0sIGJfb3V0X3N1bSxcblx0XHRyX2luX3N1bSwgZ19pbl9zdW0sIGJfaW5fc3VtLFxuXHRcdHByLCBwZywgcGIsIHJicztcblxuXHR2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMTtcblx0dmFyIHc0ID0gd2lkdGggPDwgMjtcblx0dmFyIHdpZHRoTWludXMxID0gd2lkdGggLSAxO1xuXHR2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcblx0dmFyIHJhZGl1c1BsdXMxID0gcmFkaXVzICsgMTtcblx0dmFyIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKHJhZGl1c1BsdXMxICsgMSkgLyAyO1xuXG5cdHZhciBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpO1xuXHR2YXIgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXHRmb3IgKGkgPSAxOyBpIDwgZGl2OyBpKyspIHtcblx0XHRzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG5cdFx0aWYgKGkgPT0gcmFkaXVzUGx1czEpIHZhciBzdGFja0VuZCA9IHN0YWNrO1xuXHR9XG5cdHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuXHR2YXIgc3RhY2tJbiA9IG51bGw7XG5cdHZhciBzdGFja091dCA9IG51bGw7XG5cblx0eXcgPSB5aSA9IDA7XG5cblx0dmFyIG11bF9zdW0gPSBtdWxfdGFibGVbcmFkaXVzXTtcblx0dmFyIHNoZ19zdW0gPSBzaGdfdGFibGVbcmFkaXVzXTtcblxuXHRmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcblx0XHRyX2luX3N1bSA9IGdfaW5fc3VtID0gYl9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSAwO1xuXG5cdFx0cl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocHIgPSBwaXhlbHNbeWldKTtcblx0XHRnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwZyA9IHBpeGVsc1t5aSArIDFdKTtcblx0XHRiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYiA9IHBpeGVsc1t5aSArIDJdKTtcblxuXHRcdHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuXHRcdGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuXHRcdGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuXG5cdFx0c3RhY2sgPSBzdGFja1N0YXJ0O1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKyspIHtcblx0XHRcdHN0YWNrLnIgPSBwcjtcblx0XHRcdHN0YWNrLmcgPSBwZztcblx0XHRcdHN0YWNrLmIgPSBwYjtcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAxOyBpIDwgcmFkaXVzUGx1czE7IGkrKykge1xuXHRcdFx0cCA9IHlpICsgKCh3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkpIDw8IDIpO1xuXHRcdFx0cl9zdW0gKz0gKHN0YWNrLnIgPSAocHIgPSBwaXhlbHNbcF0pKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuXHRcdFx0Z19zdW0gKz0gKHN0YWNrLmcgPSAocGcgPSBwaXhlbHNbcCArIDFdKSkgKiByYnM7XG5cdFx0XHRiX3N1bSArPSAoc3RhY2suYiA9IChwYiA9IHBpeGVsc1twICsgMl0pKSAqIHJicztcblxuXHRcdFx0cl9pbl9zdW0gKz0gcHI7XG5cdFx0XHRnX2luX3N1bSArPSBwZztcblx0XHRcdGJfaW5fc3VtICs9IHBiO1xuXG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cdFx0fVxuXG5cdFx0c3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG5cdFx0c3RhY2tPdXQgPSBzdGFja0VuZDtcblx0XHRmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuXHRcdFx0cGl4ZWxzW3lpXSA9IChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRwaXhlbHNbeWkgKyAxXSA9IChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRwaXhlbHNbeWkgKyAyXSA9IChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cblx0XHRcdHJfc3VtIC09IHJfb3V0X3N1bTtcblx0XHRcdGdfc3VtIC09IGdfb3V0X3N1bTtcblx0XHRcdGJfc3VtIC09IGJfb3V0X3N1bTtcblxuXHRcdFx0cl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcblx0XHRcdGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG5cdFx0XHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuXG5cdFx0XHRwID0gKHl3ICsgKChwID0geCArIHJhZGl1cyArIDEpIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEpKSA8PCAyO1xuXG5cdFx0XHRyX2luX3N1bSArPSAoc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcblx0XHRcdGdfaW5fc3VtICs9IChzdGFja0luLmcgPSBwaXhlbHNbcCArIDFdKTtcblx0XHRcdGJfaW5fc3VtICs9IChzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdKTtcblxuXHRcdFx0cl9zdW0gKz0gcl9pbl9zdW07XG5cdFx0XHRnX3N1bSArPSBnX2luX3N1bTtcblx0XHRcdGJfc3VtICs9IGJfaW5fc3VtO1xuXG5cdFx0XHRzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXG5cdFx0XHRyX291dF9zdW0gKz0gKHByID0gc3RhY2tPdXQucik7XG5cdFx0XHRnX291dF9zdW0gKz0gKHBnID0gc3RhY2tPdXQuZyk7XG5cdFx0XHRiX291dF9zdW0gKz0gKHBiID0gc3RhY2tPdXQuYik7XG5cblx0XHRcdHJfaW5fc3VtIC09IHByO1xuXHRcdFx0Z19pbl9zdW0gLT0gcGc7XG5cdFx0XHRiX2luX3N1bSAtPSBwYjtcblxuXHRcdFx0c3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG5cdFx0XHR5aSArPSA0O1xuXHRcdH1cblx0XHR5dyArPSB3aWR0aDtcblx0fVxuXG5cdGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG5cdFx0Z19pbl9zdW0gPSBiX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IHJfc3VtID0gMDtcblxuXHRcdHlpID0geCA8PCAyO1xuXHRcdHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHByID0gcGl4ZWxzW3lpXSk7XG5cdFx0Z19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkgKyAxXSk7XG5cdFx0Yl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGIgPSBwaXhlbHNbeWkgKyAyXSk7XG5cblx0XHRyX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcblx0XHRnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcblx0XHRiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcblxuXHRcdHN0YWNrID0gc3RhY2tTdGFydDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XG5cdFx0XHRzdGFjay5yID0gcHI7XG5cdFx0XHRzdGFjay5nID0gcGc7XG5cdFx0XHRzdGFjay5iID0gcGI7XG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cdFx0fVxuXG5cdFx0eXAgPSB3aWR0aDtcblxuXHRcdGZvciAoaSA9IDE7IGkgPD0gcmFkaXVzOyBpKyspIHtcblx0XHRcdHlpID0gKHlwICsgeCkgPDwgMjtcblxuXHRcdFx0cl9zdW0gKz0gKHN0YWNrLnIgPSAocHIgPSBwaXhlbHNbeWldKSkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcblx0XHRcdGdfc3VtICs9IChzdGFjay5nID0gKHBnID0gcGl4ZWxzW3lpICsgMV0pKSAqIHJicztcblx0XHRcdGJfc3VtICs9IChzdGFjay5iID0gKHBiID0gcGl4ZWxzW3lpICsgMl0pKSAqIHJicztcblxuXHRcdFx0cl9pbl9zdW0gKz0gcHI7XG5cdFx0XHRnX2luX3N1bSArPSBwZztcblx0XHRcdGJfaW5fc3VtICs9IHBiO1xuXG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cblx0XHRcdGlmIChpIDwgaGVpZ2h0TWludXMxKSB7XG5cdFx0XHRcdHlwICs9IHdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHlpID0geDtcblx0XHRzdGFja0luID0gc3RhY2tTdGFydDtcblx0XHRzdGFja091dCA9IHN0YWNrRW5kO1xuXHRcdGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuXHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRwaXhlbHNbcF0gPSAocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuXHRcdFx0cGl4ZWxzW3AgKyAxXSA9IChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRwaXhlbHNbcCArIDJdID0gKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcblxuXHRcdFx0cl9zdW0gLT0gcl9vdXRfc3VtO1xuXHRcdFx0Z19zdW0gLT0gZ19vdXRfc3VtO1xuXHRcdFx0Yl9zdW0gLT0gYl9vdXRfc3VtO1xuXG5cdFx0XHRyX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuXHRcdFx0Z19vdXRfc3VtIC09IHN0YWNrSW4uZztcblx0XHRcdGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG5cblx0XHRcdHAgPSAoeCArICgoKHAgPSB5ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSkgKiB3aWR0aCkpIDw8IDI7XG5cblx0XHRcdHJfc3VtICs9IChyX2luX3N1bSArPSAoc3RhY2tJbi5yID0gcGl4ZWxzW3BdKSk7XG5cdFx0XHRnX3N1bSArPSAoZ19pbl9zdW0gKz0gKHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV0pKTtcblx0XHRcdGJfc3VtICs9IChiX2luX3N1bSArPSAoc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXSkpO1xuXG5cdFx0XHRzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXG5cdFx0XHRyX291dF9zdW0gKz0gKHByID0gc3RhY2tPdXQucik7XG5cdFx0XHRnX291dF9zdW0gKz0gKHBnID0gc3RhY2tPdXQuZyk7XG5cdFx0XHRiX291dF9zdW0gKz0gKHBiID0gc3RhY2tPdXQuYik7XG5cblx0XHRcdHJfaW5fc3VtIC09IHByO1xuXHRcdFx0Z19pbl9zdW0gLT0gcGc7XG5cdFx0XHRiX2luX3N1bSAtPSBwYjtcblxuXHRcdFx0c3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG5cdFx0XHR5aSArPSB3aWR0aDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGltYWdlRGF0YTtcbn07XG5cbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSB1dGlscy9jYW52YXMvY2FsY0FyY0hDb25uZWN0b3JcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIsIHJvKSB7XG5cdHZhciBxeCA9IHgyID4geDEgPyAxIDogLTE7XG5cdHZhciBxeSA9IHkyID4geTEgPyAxIDogLTE7XG5cdHZhciBkeSA9IE1hdGguYWJzKHkyIC0geTEpO1xuXHR2YXIgZHggPSBNYXRoLmFicyh4MiAtIHgxKTtcblx0dmFyIHJyID0gcjEgKyByMjtcblx0dmFyIHR4MSwgdHgyLCBjLCB0eCwgdHk7XG5cblx0aWYgKGR5IDwgMSkge1xuXHRcdC8vIHBvaW50cyBhcmUgYWxpZ25lZCBob3Jpem9udGFsbHksIG5vIGFyY3MgbmVlZGVkXG5cdFx0dHgxID0gMDtcblx0XHR0eDIgPSBkeFxuXHRcdC8vIHJldHVybiBbeDEsIHgyXTtcblx0fVxuXG5cdGlmIChkeSA+PSByciAmJiBkeCA+PSBycikge1xuXHRcdC8vIGFyY3MgZml0IGhvcml6b250YWxseTpcblx0XHQvLyBzZWNvbmQgY2lyY2xlIGNlbnRlciBpcyByMStyMiwgdGFuZ2VudCBpbnRlcnNlY3QgYXQgeD1yMVxuXHRcdGMgPSBycjtcblx0XHR0eDEgPSByMTtcblx0XHR0eDIgPSByMTtcblx0fSBlbHNlIHtcblx0XHQvLyBhcmNzIG92ZXJsYXAgaG9yaXpvbnRhbGx5OlxuXHRcdC8vIGZpbmQgc2Vjb25kIGNpcmNsZSBjZW50ZXJcblx0XHRjID0gTWF0aC5zcXJ0KGR5ICogcjIgKiAyICsgZHkgKiByMSAqIDIgLSBkeSAqIGR5KTtcblxuXHRcdC8vIGNpcmNsZXMgdGFuZ2VudCBwb2ludFxuXHRcdHR4ID0gKGMgKiByMSkgLyBycjtcblx0XHR0eSA9IChkeSAqIHIxKSAvIHJyO1xuXG5cdFx0aWYgKHIxIDwgdHkgfHwgYyA+IGR4KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gdGFuZ2VudCBwZXJwZW5kaWN1bGFyIHNsb3BlXG5cdFx0dmFyIHNsb3BlID0gKHJyIC0gZHkpIC8gYztcblx0XHQvLyB0YW5nZW50IGludGVyc2VjdGlvbnNcblx0XHR0eDEgPSB0eCAtICh0eSAqIHNsb3BlKTtcblx0XHR0eDIgPSAoZHkgKiBzbG9wZSkgKyB0eDE7XG5cblx0XHQvKlxuXHRcdC8vIGNpcmNsZSBjZW50ZXJzXG5cdFx0dmFyIGNjeDEsIGNjeTEsIGNjeDIsIGNjeTI7XG5cdFx0Y2N4MSA9IDA7XG5cdFx0Y2N5MSA9IHIxO1xuXHRcdGNjeDIgPSBjO1xuXHRcdGNjeTIgPSBkeSAtIHIyO1xuXHRcdC8vIHRhbmdlbnQgcGVycGVuZGljdWxhciBzbG9wZVxuXHRcdHZhciBzbG9wZSA9IChjY3kxIC0gY2N5MikgLyAoY2N4MiAtIGNjeDEpO1xuXHRcdHZhciB4U2VjID0gdHggLSAodHkgKiBzbG9wZSk7XG5cdFx0Ly8gdGFuZ2VudCBpbnRlcnNlY3Rpb25zXG5cdFx0dHgxID0geFNlYztcblx0XHR0eDIgPSAoZHkgKiBzbG9wZSkgKyB4U2VjO1xuXHRcdCovXG5cdH1cblxuXHQvLyBvZmZzZXQgYXJjVG8ncyBpbiB4LWF4aXNcblx0aWYgKHJvID4gMCkge1xuXHRcdGlmIChybyA+IDEpIHtcblx0XHRcdHJvID0gTWF0aC5taW4oZHggLSByciwgcm8pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRybyAqPSBkeCAtIHJyO1xuXHRcdH1cblx0XHR0eDEgKz0gcm87XG5cdFx0dHgyICs9IHJvO1xuXHR9XG5cblx0cmV0dXJuIFt0eDEgKiBxeCArIHgxLCB0eDIgKiBxeCArIHgxLCB0eDEsIHR4Ml07XG59O1xuXG4vKlxudmFyIGRyYXdBcmNDb25uZWN0b3IgPSBmdW5jdGlvbihjdHgsIHgxLCB5MSwgeDIsIHkyLCByKSB7XG5cdHZhciBkeCwgZHksIGh4LCBoeSwgZ3gsIGd5O1xuXG5cdGh4ID0gMDtcblx0aHkgPSAwO1xuXHRneCA9ICh4MSArIHgyKSAvIDI7XG5cdGd5ID0gKHkxICsgeTIpIC8gMjtcblx0ZHggPSBNYXRoLmFicyh4MSAtIGd4KTtcblx0ZHkgPSBNYXRoLmFicyh5MSAtIGd5KTtcblxuXHRpZiAoZHggPCByICYmIGR5IDwgcikge1xuXHRcdHIgPSBNYXRoLm1pbihkeCAqIE1hdGguU1FSVDFfMiwgZHkgKiBNYXRoLlNRUlQxXzIpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChkeCA8IHIpIHtcblx0XHRcdGh5ID0gTWF0aC5hY29zKGR4IC8gcikgKiByICogMC41O1xuXHRcdFx0aWYgKHkxID4geTIpIGh5ICo9IC0xO1xuXHRcdH1cblx0XHRpZiAoZHkgPCByKSB7XG5cdFx0XHRoeCA9IE1hdGguYWNvcyhkeSAvIHIpICogciAqIDAuNTtcblx0XHRcdGlmICh4MSA+IHgyKSBoeCAqPSAtMTtcblx0XHR9XG5cdH1cblx0Y3R4LmFyY1RvKGd4IC0gaHgsIHkxLCBneCArIGh4LCB5Miwgcik7XG5cdGN0eC5hcmNUbyhneCArIGh4LCB5MiwgeDIsIHkyLCByKTtcbn07XG5cbnZhciBkcmF3QXJjQ29ubmVjdG9yMiA9IGZ1bmN0aW9uKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHIpIHtcblx0dmFyIGR4LCBkeSwgaHgsIGh5LCBjeDEsIGN4MjtcblxuXHRoeCA9IDA7XG5cdGh5ID0gMDtcblx0ZHggPSBNYXRoLmFicyh4MiAtIHgxKSAvIDI7XG5cdGR5ID0gTWF0aC5hYnMoeTEgLSB5MikgLyAyO1xuXG5cdGlmIChkeCA8IHIgJiYgZHkgPCByKSB7XG5cdFx0ciA9IE1hdGgubWluKGR4ICogTWF0aC5TUVJUMV8yLCBkeSAqIE1hdGguU1FSVDFfMik7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGR4IDwgcikge1xuXHRcdFx0aHkgPSBNYXRoLmFjb3MoZHggLyByKSAqIHI7XG5cdFx0fVxuXHRcdGlmIChkeSA8IHIpIHtcblx0XHRcdGh4ID0gTWF0aC5hY29zKGR5IC8gcikgKiByO1xuXHRcdH1cblx0fVxuXHRjeDEgPSB4MSArIGR4O1xuXHRjeDIgPSB4MiAtIChkeCAtIGh4IC8gMik7XG5cdGN0eC5hcmNUbyhjeDEsIHkxLCBjeDIsIHkyLCByKTtcblx0Y3R4LmFyY1RvKGN4MiwgeTIsIHgyLCB5Miwgcik7XG59O1xuXG52YXIgZHJhd0FyY0Nvbm5lY3RvcjEgPSBmdW5jdGlvbihjdHgsIHgxLCB5MSwgeDIsIHkyLCByKSB7XG5cdHZhciBkeCwgZHksIGN4O1xuXG5cdGR4ID0gTWF0aC5hYnMoeDIgLSB4MSkgLyAyO1xuXHRkeSA9IE1hdGguYWJzKHkxIC0geTIpIC8gMjtcblx0ciA9IE1hdGgubWluKHIsIGR5ICogTWF0aC5TUVJUMV8yKTtcblx0aWYgKHgxIDwgeDIpIHtcblx0XHRjeCA9IHgxICsgZHggKyByO1xuXHR9IGVsc2Uge1xuXHRcdGN4ID0geDIgLSBkeCAtIHI7XG5cdH1cblx0Ly8gY3ggPSAoeDIgKyB4MSkgLyAyO1xuXHQvLyBjeCArPSB4MSA8IHgyID8gciA6IC1yO1xuXG5cdGN0eC5hcmNUbyhjeCwgeTEsIGN4LCB5Miwgcik7XG5cdGN0eC5hcmNUbyhjeCwgeTIsIHgyLCB5Miwgcik7XG59O1xuKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIEhUTUxFbGVtZW50LCBDU1NTdHlsZURlY2xhcmF0aW9uICovXG5cbi8vIHZhciBwYXJzZVNpemUgPSByZXF1aXJlKFwiLi9wYXJzZVNpemVcIik7XG5cbnZhciBDU1NfQk9YX1BST1BTID0gW1xuXHRcImJveFNpemluZ1wiLCBcInBvc2l0aW9uXCIsIFwib2JqZWN0Rml0XCJcbl07XG52YXIgQ1NTX0VER0VfUFJPUFMgPSBbXG5cdFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsXG5cdFwiYm9yZGVyVG9wV2lkdGhcIiwgXCJib3JkZXJCb3R0b21XaWR0aFwiLCBcImJvcmRlckxlZnRXaWR0aFwiLCBcImJvcmRlclJpZ2h0V2lkdGhcIixcblx0XCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIsXG5dO1xudmFyIENTU19QT1NfUFJPUFMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl07XG52YXIgQ1NTX1NJWkVfUFJPUFMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcIm1pbldpZHRoXCIsIFwibWluSGVpZ2h0XCIsIFwibWF4V2lkdGhcIiwgXCJtYXhIZWlnaHRcIl07XG52YXIgQ1NTX0FMTF9QUk9QUyA9IENTU19FREdFX1BST1BTLmNvbmNhdChDU1NfU0laRV9QUk9QUywgQ1NTX1BPU19QUk9QUyk7XG5cbi8vIHZhciBDT01QVVRFRF9QUk9QUyA9IFtcbi8vIFx0XCJjbGllbnRMZWZ0XCIsIFwiY2xpZW50VG9wXCIsIFwiY2xpZW50V2lkdGhcIiwgXCJjbGllbnRIZWlnaHRcIixcbi8vIFx0XCJvZmZzZXRMZWZ0XCIsIFwib2Zmc2V0VG9wXCIsIFwib2Zmc2V0V2lkdGhcIiwgXCJvZmZzZXRIZWlnaHRcIlxuLy8gXTtcbi8vIHZhciBvID0gXy5waWNrKGVsZW1lbnQsIGZ1bmN0aW9uKHZhbCkge1xuLy8gXHRyZXR1cm4gL14ob2Zmc2V0fGNsaWVudCkoTGVmdHxUb3B8V2lkdGh8SGVpZ2h0KS8udGVzdCh2YWwpO1xuLy8gfSk7XG5cbnZhciBjc3NEaW1lbnNpb25SRSA9IC9eKC0/W1xcZFxcLl0rKShweHxlbXxyZW0pJC87XG4vLyB2YXIgY3NzRGltUmUgPSAvXihbLVxcLjAtOV0rKShbcmVtXSspJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocywgbSwgaW5jbHVkZVNpemVQb3MpIHtcblx0aWYgKHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHRcdHMgPSBnZXRDb21wdXRlZFN0eWxlKHMpO1xuXHR9XG5cdGlmIChERUJVRykge1xuXHRcdGlmICghKHMgaW5zdGFuY2VvZiBDU1NTdHlsZURlY2xhcmF0aW9uKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGEgQ1NTU3R5bGVEZWNsYXJhdGlvbiBub3IgSFRNTEVsZW1lbnRcIik7XG5cdFx0fVxuXHR9XG5cdHZhciB2LCBwLCBpLCBpaSwgZW1QeCwgcmVtUHg7XG5cdG0gfHwgKG0gPSB7fSk7XG5cblx0ZW1QeCA9IG0uZm9udFNpemUgPSBwYXJzZUZsb2F0KHMuZm9udFNpemUpO1xuXG5cdGZvciAoaSA9IDAsIGlpID0gQ1NTX0JPWF9QUk9QUy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0cCA9IENTU19CT1hfUFJPUFNbaV07XG5cdFx0aWYgKHAgaW4gcykge1xuXHRcdFx0bVtwXSA9IHNbcF07XG5cdFx0fVxuXHR9XG5cdHZhciBjc3NQcm9wcyA9IGluY2x1ZGVTaXplUG9zID8gQ1NTX0VER0VfUFJPUFMgOiBDU1NfQUxMX1BST1BTO1xuXHRmb3IgKGkgPSAwLCBpaSA9IGNzc1Byb3BzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcblx0XHRwID0gY3NzUHJvcHNbaV07XG5cdFx0bVtcIl9cIiArIHBdID0gc1twXTtcblx0XHRpZiAoc1twXSAmJiAodiA9IGNzc0RpbWVuc2lvblJFLmV4ZWMoc1twXSkpKSB7XG5cdFx0XHRpZiAodlsyXSA9PT0gXCJweFwiKSB7XG5cdFx0XHRcdG1bcF0gPSBwYXJzZUZsb2F0KHZbMV0pO1xuXHRcdFx0fSBlbHNlIGlmICh2WzJdID09PSBcImVtXCIpIHtcblx0XHRcdFx0bVtwXSA9IHBhcnNlRmxvYXQodlsxXSkgKiBlbVB4O1xuXHRcdFx0fSBlbHNlIGlmICh2WzJdID09PSBcInJlbVwiKSB7XG5cdFx0XHRcdHJlbVB4IHx8IChyZW1QeCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplKSk7XG5cdFx0XHRcdG1bcF0gPSBwYXJzZUZsb2F0KHZbMV0pICogcmVtUHg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJJZ25vcmluZyB2YWx1ZVwiLCBwLCB2WzFdLCB2WzJdKTtcblx0XHRcdFx0bVtwXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSAvLyBlbHNlIHtcblx0XHQvL1x0Y29uc29sZS53YXJuKFwiSWdub3JpbmcgdW5pdGxlc3MgdmFsdWVcIiwgcCwgdik7XG5cdFx0Ly99XG5cdH1cblx0cmV0dXJuIG07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlYXNlSW5RdWFkICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgsIHQsIGIsIGMsIGQpIHtcblx0cmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogZWFzZU91dFF1YWQgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odCwgYiwgYywgZCkge1xuXHRyZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaSBjdXJyZW50IGl0ZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHMgc3RhcnQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkIGNoYW5nZSBpbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHQgdG90YWwgaXRlcmF0aW9uc1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG52YXIgbGluZWFyID0gZnVuY3Rpb24oaSwgcywgZCwgdCkge1xuXHRyZXR1cm4gZCAqIGkgLyB0ICsgcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbGluZWFyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9tZWRpYS5odG1sI2V2ZW50LW1lZGlhLWNhbnBsYXlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBbXG5cdC8vIG5ldHdvcmtTdGF0ZVxuXHRcImxvYWRzdGFydFwiLFxuXHRcInByb2dyZXNzXCIsXG5cdFwic3VzcGVuZFwiLFxuXHRcImFib3J0XCIsXG5cdFwiZXJyb3JcIixcblx0XCJlbXB0aWVkXCIsXG5cdFwic3RhbGxlZFwiLFxuXHQvLyByZWFkeVN0YXRlXG5cdFwibG9hZGVkbWV0YWRhdGFcIixcblx0XCJsb2FkZWRkYXRhXCIsXG5cdFwiY2FucGxheVwiLFxuXHRcImNhbnBsYXl0aHJvdWdoXCIsXG5cdFwicGxheWluZ1wiLFxuXHRcIndhaXRpbmdcIixcblx0Ly9cblx0XCJzZWVraW5nXCIsIC8vIHNlZWtpbmcgY2hhbmdlZCB0byB0cnVlXG5cdFwic2Vla2VkXCIsIC8vIHNlZWtpbmcgY2hhbmdlZCB0byBmYWxzZVxuXHRcImVuZGVkXCIsIC8vIGVuZGVkIGlzIHRydWVcblx0Ly9cblx0XCJkdXJhdGlvbmNoYW5nZVwiLCAvLyBkdXJhdGlvbiB1cGRhdGVkXG5cdFwidGltZXVwZGF0ZVwiLCAvLyBjdXJyZW50VGltZSB1cGRhdGVkXG5cdFwicGxheVwiLCAvLyBwYXVzZWQgaXMgZmFsc2Vcblx0XCJwYXVzZVwiLCAvLyBwYXVzZWQgaXMgZmFsc2Vcblx0XCJwYXVzZWRcIiwgLy8gPz9cblx0XCJyYXRlY2hhbmdlXCIsXG5cdC8vXG5cdFwicmVzaXplXCIsXG5cdFwidm9sdW1lY2hhbmdlXCIsXG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgYXBwL3ZpZXcvY29tcG9uZW50L0dyYXBoVmlld1xuICovbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWN0LCBkeCwgZHkpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuXHRcdGR5ID0gZHg7XG5cdH1cblx0dmFyIHIgPSB7XG5cdFx0d2lkdGg6IHJlY3Qud2lkdGggKyBkeCAqIDIsXG5cdFx0aGVpZ2h0OiByZWN0LmhlaWdodCArIGR5ICogMlxuXHR9O1xuXHRpZiAoci53aWR0aCA+PSAwKSB7XG5cdFx0ci5sZWZ0ID0gcmVjdC5sZWZ0IC0gZHg7XG5cdFx0ci5yaWdodCA9IHIubGVmdCArIHIud2lkdGg7XG5cdFx0ci54ID0gci5sZWZ0O1xuXHR9IGVsc2Uge1xuXHRcdHIucmlnaHQgPSByZWN0LnJpZ2h0ICsgZHg7XG5cdFx0ci5sZWZ0ID0gcmVjdC5yaWdodCAtIHIud2lkdGg7XG5cdFx0ci55ID0gci5yaWdodDtcblx0fVxuXHRpZiAoci5oZWlnaHQgPj0gMCkge1xuXHRcdHIudG9wID0gcmVjdC50b3AgLSBkeTtcblx0XHRyLmJvdHRvbSA9IHIudG9wICsgci5oZWlnaHQ7XG5cdFx0ci55ID0gci50b3A7XG5cdH0gZWxzZSB7XG5cdFx0ci5ib3R0b20gPSByZWN0LmJvdHRvbSArIGR5O1xuXHRcdHIudG9wID0gcmVjdC5ib3R0b20gLSByLmhlaWdodDtcblx0XHRyLnkgPSByLmJvdHRvbTtcblx0fVxuXG5cdHJldHVybiByO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEB0eXBlIHtBcnJheX0gbG93ZXJjYXNlIHByZWZpeGVzICovXG52YXIgbGNQcmVmaXhlcyA9IFtcIlwiXS5jb25jYXQocmVxdWlyZShcIi4vcHJlZml4ZXNcIikpO1xuXG4vKiogQHR5cGUge0FycmF5fSBjYXBpdGFsaXplZCBwcmVmaXhlcyAqL1xudmFyIHVjUHJlZml4ZXMgPSBsY1ByZWZpeGVzLm1hcChmdW5jdGlvbihzKSB7XG5cdHJldHVybiAocyA9PT0gXCJcIikgPyBzIDogcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc3Vic3RyKDEpO1xufSk7XG5cbi8qKiBAdHlwZSB7T2JqZWN0fSBzcGVjaWZpYyBldmVudCBzb2x2ZXJzICovXG52YXIgX3NvbHZlcnMgPSB7fTtcblxuLyoqIEB0eXBlIHtPYmplY3R9IGNhY2hlZCB2YWx1ZXMgKi9cbnZhciBfY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBVbnByZWZpeGVkIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7P09iamVjdH0gb2JqIFByZWZpeCB0ZXN0IHRhcmdldFxuICogQHBhcmFtIHs/U3RyaW5nfSB0ZXN0UHJvcCBQcm94eSBwcm9wZXJ0eSB0byB0ZXN0IHByZWZpeGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFyIF9wcmVmaXhlZEV2ZW50ID0gZnVuY3Rpb24obmFtZSwgb2JqLCB0ZXN0UHJvcCkge1xuXHR2YXIgcHJlZml4ZXMgPSAvXltBLVpdLy50ZXN0KG5hbWUpID8gdWNQcmVmaXhlcyA6IGxjUHJlZml4ZXM7XG5cdG9iaiB8fCAob2JqID0gZG9jdW1lbnQpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHRlc3RQcm9wKSB7XG5cdFx0XHRpZiAoKHByZWZpeGVzW2ldICsgdGVzdFByb3ApIGluIG9iaikge1xuXHRcdFx0XHRyZXR1cm4gcHJlZml4ZXNbaV0gKyBuYW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoKFwib25cIiArIHByZWZpeGVzW2ldICsgbmFtZSkgaW4gb2JqKSB7XG5cdFx0XHRyZXR1cm4gcHJlZml4ZXNbaV0gKyBuYW1lO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbi8vIHRyYW5zaXRpb25lbmRcbl9zb2x2ZXJzW1widHJhbnNpdGlvbmVuZFwiXSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcHJvcCwgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlLFxuXHRcdG1hcCA9IHtcblx0XHRcdFwidHJhbnNpdGlvblwiOiBcInRyYW5zaXRpb25lbmRcIixcblx0XHRcdFwiV2Via2l0VHJhbnNpdGlvblwiOiBcIndlYmtpdFRyYW5zaXRpb25FbmRcIixcblx0XHRcdFwiTW96VHJhbnNpdGlvblwiOiBcInRyYW5zaXRpb25lbmRcIixcblx0XHRcdC8vIFwibXNUcmFuc2l0aW9uXCIgOiBcIk1TVHJhbnNpdGlvbkVuZFwiLFxuXHRcdFx0XCJPVHJhbnNpdGlvblwiOiBcIm9UcmFuc2l0aW9uRW5kXCJcblx0XHR9O1xuXHRmb3IgKHByb3AgaW4gbWFwKSB7XG5cdFx0aWYgKHByb3AgaW4gc3R5bGUpIHtcblx0XHRcdHJldHVybiBtYXBbcHJvcF07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGxvb2stdXAgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IHByZWZpeGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXZOYW1lKSB7XG5cdGlmICghX2NhY2hlLmhhc093blByb3BlcnR5KGV2TmFtZSkpIHtcblx0XHRfY2FjaGVbZXZOYW1lXSA9IF9zb2x2ZXJzLmhhc093blByb3BlcnR5KGV2TmFtZSkgPyBfc29sdmVyc1tldk5hbWVdKCkgOiBfcHJlZml4ZWRFdmVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdGlmIChfY2FjaGVbZXZOYW1lXSA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiRXZlbnQgJyVzJyBub3QgZm91bmRcIiwgZXZOYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coXCJFdmVudCAnJXMnIGZvdW5kIGFzICclcydcIiwgZXZOYW1lLCBfY2FjaGVbZXZOYW1lXSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBfY2FjaGVbZXZOYW1lXTtcblx0Ly8gcmV0dXJuIF9jYWNoZVtldk5hbWVdIHx8IChfY2FjaGVbZXZOYW1lXSA9IF9zb2x2ZXJzW2V2TmFtZV0/IF9zb2x2ZXJzW2V2TmFtZV0uY2FsbCgpIDogX3ByZWZpeGVkUHJvcGVydHkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG59O1xuXG4vKlxudmFyIGRlZmF1bHRUZXN0ID0gZnVuY3Rpb24obmFtZSwgb2JqKSB7XG5cdHZhciBwcmVmaXhlcyA9IC9eW0EtWl0vLnRlc3QobmFtZSk/IHVjUHJlZml4ZXMgOiBsY1ByZWZpeGVzO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKChcIm9uXCIgKyBwcmVmaXhlc1tpXSArIG5hbWUpIGluIG9iaikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJFdmVudCAnJXMnIGZvdW5kIGFzICclcydcIiwgbmFtZSwgcHJlZml4ZXNbaV0gKyBuYW1lKTtcblx0XHRcdHJldHVybiBwcmVmaXhlc1tpXSArIG5hbWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxudmFyIHByb3h5VGVzdCA9IGZ1bmN0aW9uKG5hbWUsIG9iaiwgdGVzdFByb3ApIHtcblx0dmFyIHByZWZpeGVzID0gL15bQS1aXS8udGVzdChuYW1lKT8gdWNQcmVmaXhlcyA6IGxjUHJlZml4ZXM7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoKHByZWZpeGVzW2ldICsgdGVzdFByb3ApIGluIG9iaikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJFdmVudCAlcyBpbmZlcnJlZCBhcyAnJXMnIGZyb20gcHJvcGVydHkgJyVzJ1wiLCBuYW1lLCBwcmVmaXhlc1tpXSArIG5hbWUsIHRlc3RQcm9wKTtcblx0XHRcdHJldHVybiBwcmVmaXhlc1tpXSArIG5hbWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufTtcbiovXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuLyogQG1vZHVsZSB1dGlscy9wcmVmaXhlZFByb3BlcnR5XG4vKi9cblxuLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvcHJlZml4ZXN9ICovXG5jb25zdCBwcmVmaXhlcyA9IHJlcXVpcmUoXCIuL3ByZWZpeGVzXCIpO1xuLyoqIEB0eXBlIHtOdW1iZXJ9IHByZWZpeCBjb3VudCAqL1xudmFyIF9wcmVmaXhOdW0gPSBwcmVmaXhlcy5sZW5ndGg7XG4vKiogQHR5cGUge0FycmF5fSBjYWNoZWQgdmFsdWVzICovXG52YXIgX2NhY2hlID0ge307XG5cbnZhciBfcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikge1xuXHR2YXIgcHJlZml4ZWRQcm9wLCBjYW1lbFByb3A7XG5cblx0aWYgKHByb3AgaW4gb2JqKSB7XG5cdFx0Y29uc29sZS5sb2coXCJQcm9wZXJ0eSAnJXMnIGZvdW5kIHVucHJlZml4ZWRcIiwgcHJvcCk7XG5cdFx0cmV0dXJuIHByb3A7XG5cdH1cblx0Y2FtZWxQcm9wID0gcHJvcFswXS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfcHJlZml4TnVtOyBpKyspIHtcblx0XHRwcmVmaXhlZFByb3AgPSBwcmVmaXhlc1tpXSArIGNhbWVsUHJvcDtcblx0XHRpZiAocHJlZml4ZWRQcm9wIGluIG9iaikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJQcm9wZXJ0eSAnJXMnIGZvdW5kIGFzICclcydcIiwgcHJvcCwgcHJlZml4ZWRQcm9wKTtcblx0XHRcdHJldHVybiBwcmVmaXhlZFByb3A7XG5cdFx0fVxuXHR9XG5cdGNvbnNvbGUuZXJyb3IoXCJQcm9wZXJ0eSAnJXMnIG5vdCBmb3VuZFwiLCBwcm9wKTtcblx0cmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gbG9vay11cCBvYmplY3RcbiAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gcHJlZml4ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm9wLCBvYmopIHtcblx0cmV0dXJuIF9jYWNoZVtwcm9wXSB8fCAoX2NhY2hlW3Byb3BdID0gX3ByZWZpeGVkUHJvcGVydHkocHJvcCwgb2JqIHx8IGRvY3VtZW50LmJvZHkuc3R5bGUpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuLyogQG1vZHVsZSB1dGlscy9wcmVmaXhlZFN0eWxlTmFtZVxuLyovXG5cbi8qKiBAdHlwZSB7bW9kdWxlOnV0aWxzL3ByZWZpeGVzfSAqL1xuY29uc3QgcHJlZml4ZXMgPSByZXF1aXJlKFwiLi9wcmVmaXhlc1wiKTsgLy8ubWFwKGZ1bmN0aW9uKHByZWZpeCkgeyByZXR1cm4gXCItXCIgKyBwcmVmaXggKyBcIi1cIjsgfSk7XG4vKiogQHR5cGUge051bWJlcn0gcHJlZml4IGNvdW50ICovXG52YXIgX3ByZWZpeE51bSA9IHByZWZpeGVzLmxlbmd0aDtcbi8qKiBAdHlwZSB7QXJyYXl9IGNhY2hlZCB2YWx1ZXMgKi9cbnZhciBfY2FjaGUgPSB7fTtcblxudmFyIF9wcmVmaXhlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uKHN0eWxlLCBzdHlsZU9iaikge1xuXHR2YXIgcHJlZml4ZWRTdHlsZTtcblxuXHRpZiAoc3R5bGUgaW4gc3R5bGVPYmopIHtcblx0XHRjb25zb2xlLmxvZyhcIkNTUyBzdHlsZSAnJXMnIGZvdW5kIHVucHJlZml4ZWRcIiwgc3R5bGUpO1xuXHRcdHJldHVybiBzdHlsZTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IF9wcmVmaXhOdW07IGkrKykge1xuXHRcdHByZWZpeGVkU3R5bGUgPSBcIi1cIiArIHByZWZpeGVzW2ldICsgXCItXCIgKyBzdHlsZTtcblx0XHQvLyBwcmVmaXhlZFN0eWxlID0gcHJlZml4ZXNbaV0gKyBzdHlsZTtcblx0XHRpZiAocHJlZml4ZWRTdHlsZSBpbiBzdHlsZU9iaikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJDU1Mgc3R5bGUgJyVzJyBmb3VuZCBhcyAnJXMnXCIsIHN0eWxlLCBwcmVmaXhlZFN0eWxlKTtcblx0XHRcdHJldHVybiBwcmVmaXhlZFN0eWxlO1xuXHRcdH1cblx0fVxuXHRjb25zb2xlLndhcm4oXCJDU1Mgc3R5bGUgJyVzJyBub3QgZm91bmRcIiwgc3R5bGUpO1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogZ2V0IHRoZSBwcmVmaXhlZCBzdHlsZSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGxvb2stdXAgc3R5bGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSwgc3R5bGVPYmopIHtcblx0Ly8gcmV0dXJuIF9jYWNoZVtzdHlsZV0gfHwgKF9jYWNoZVtzdHlsZV0gPSBfcHJlZml4ZWRTdHlsZU5hbWVfcmV2ZXJzZShzdHlsZSwgc3R5bGVPYmogfHwgZG9jdW1lbnQuYm9keS5zdHlsZSkpO1xuXHRyZXR1cm4gX2NhY2hlW3N0eWxlXSB8fCAoX2NhY2hlW3N0eWxlXSA9IF9wcmVmaXhlZFN0eWxlTmFtZShzdHlsZSwgc3R5bGVPYmogfHwgZG9jdW1lbnQuYm9keS5zdHlsZSkpO1xufTtcblxuLy8gLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvc3RyaW5ncy9jYW1lbFRvRGFzaGVkfSAqL1xuLy8gdmFyIGNhbWVsVG9EYXNoZWQgPSByZXF1aXJlKFwiLi9zdHJpbmdzL2NhbWVsVG9EYXNoZWRcIik7XG4vLyAvKiogQHR5cGUge21vZHVsZTp1dGlscy9wcmVmaXhlZFByb3BlcnR5fSAqL1xuLy8gdmFyIHByZWZpeGVkUHJvcGVydHkgPSByZXF1aXJlKFwiLi9wcmVmaXhlZFByb3BlcnR5XCIpO1xuLy8gLyoqIEB0eXBlIHttb2R1bGU6dXRpbHMvc3RyaW5ncy9kYXNoZWRUb0NhbWVsfSAqL1xuLy8gdmFyIGRhc2hlZFRvQ2FtZWwgPSByZXF1aXJlKFwiLi9zdHJpbmdzL2Rhc2hlZFRvQ2FtZWxcIik7XG4vL1xuLy8gdmFyIF9wcmVmaXhlZFN0eWxlTmFtZV9yZXZlcnNlID0gZnVuY3Rpb24gKHN0eWxlLCBzdHlsZU9iaikge1xuLy8gXHR2YXIgY2FtZWxQcm9wLCBwcmVmaXhlZFByb3A7XG4vLyBcdGNhbWVsUHJvcCA9IGRhc2hlZFRvQ2FtZWwoc3R5bGUpO1xuLy8gXHRwcmVmaXhlZFByb3AgPSBwcmVmaXhlZFByb3BlcnR5KGNhbWVsUHJvcCwgc3R5bGVPYmopO1xuLy8gXHRyZXR1cm4gcHJlZml4ZWRQcm9wPyAoY2FtZWxQcm9wID09PSBwcmVmaXhlZFByb3A/IFwiXCIgOiBcIi1cIikgKyBjYW1lbFRvRGFzaGVkKHByZWZpeGVkUHJvcCkgOiBudWxsO1xuLy8gfTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXCJ3ZWJraXRcIiwgXCJtb3pcIiwgXCJtc1wiLCBcIm9cIl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHAsIHJlYXNvbikge1xuXHRpZiAocHAubGVuZ3RoID4gMCkge1xuXHRcdHBwLmZvckVhY2goZnVuY3Rpb24ocCwgaSwgYSkge1xuXHRcdFx0cC5yZWplY3QocmVhc29uKTtcblx0XHRcdGFbaV0gPSBudWxsO1xuXHRcdH0pO1xuXHRcdHBwLmxlbmd0aCA9IDA7XG5cdH1cblx0cmV0dXJuIHBwO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcCwgcmVzdWx0KSB7XG5cdGlmIChwcC5sZW5ndGggIT0gMCkge1xuXHRcdHBwLmZvckVhY2goZnVuY3Rpb24ocCwgaSwgYSkge1xuXHRcdFx0cC5yZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRhW2ldID0gbnVsbDtcblx0XHR9KTtcblx0XHRwcC5sZW5ndGggPSAwO1xuXHR9XG5cdHJldHVybiBwcDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24oJDApIHtcblx0XHRyZXR1cm4gXCItXCIgKyAkMC50b0xvd2VyQ2FzZSgpO1xuXHR9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocykge1xuXHRyZXR1cm4gcy5yZXBsYWNlKC88W14+XSs+L2csIFwiXCIpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEB0eXBlIHttb2R1bGU6aGFtbWVyanN9ICovXG5jb25zdCBIYW1tZXIgPSByZXF1aXJlKFwiaGFtbWVyanNcIik7XG5cbi8vIC8qKlxuLy8gICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4vLyAgKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuLy8gICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbi8vICAqL1xuLy8gZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbi8vIFx0aWYgKHN0YXRlICYgSGFtbWVyLlNUQVRFX0NBTkNFTExFRCkge1xuLy8gXHRcdHJldHVybiBcImNhbmNlbFwiO1xuLy8gXHR9IGVsc2UgaWYgKHN0YXRlICYgSGFtbWVyLlNUQVRFX0VOREVEKSB7XG4vLyBcdFx0cmV0dXJuIFwiZW5kXCI7XG4vLyBcdH0gZWxzZSBpZiAoc3RhdGUgJiBIYW1tZXIuU1RBVEVfQ0hBTkdFRCkge1xuLy8gXHRcdHJldHVybiBcIm1vdmVcIjtcbi8vIFx0fSBlbHNlIGlmIChzdGF0ZSAmIEhhbW1lci5TVEFURV9CRUdBTikge1xuLy8gXHRcdHJldHVybiBcInN0YXJ0XCI7XG4vLyBcdH1cbi8vIFx0cmV0dXJuIFwiXCI7XG4vLyB9XG5cbi8qKlxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge0NvbnN0fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRpclN0cihkaXJlY3Rpb24pIHtcblx0aWYgKGRpcmVjdGlvbiA9PSBIYW1tZXIuRElSRUNUSU9OX0RPV04pIHtcblx0XHRyZXR1cm4gXCJkb3duXCI7XG5cdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IEhhbW1lci5ESVJFQ1RJT05fVVApIHtcblx0XHRyZXR1cm4gXCJ1cFwiO1xuXHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBIYW1tZXIuRElSRUNUSU9OX0xFRlQpIHtcblx0XHRyZXR1cm4gXCJsZWZ0XCI7XG5cdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IEhhbW1lci5ESVJFQ1RJT05fUklHSFQpIHtcblx0XHRyZXR1cm4gXCJyaWdodFwiO1xuXHR9XG5cdHJldHVybiBcIlwiO1xufVxuXG4vLy8qKlxuLy8gKiBQYW5cbi8vICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbi8vICogQGNvbnN0cnVjdG9yXG4vLyAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4vLyAqL1xuLy9mdW5jdGlvbiBQYW5SZWNvZ25pemVyKCkge1xuLy9cdEhhbW1lci5BdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuLy9cbi8vXHR0aGlzLnBYID0gbnVsbDtcbi8vXHR0aGlzLnBZID0gbnVsbDtcbi8vfVxuLy9cbi8vaW5oZXJpdChQYW5SZWNvZ25pemVyLCBIYW1tZXIuQXR0clJlY29nbml6ZXIsIHtcbi8vXHQvKipcbi8vXHQvKiBAbmFtZXNwYWNlXG4vL1x0LyogQG1lbWJlcm9mIFBhblJlY29nbml6ZXJcbi8vXHQvKi9cbi8vXHRkZWZhdWx0czoge1xuLy9cdFx0ZXZlbnQ6IFwicGFuXCIsXG4vL1x0XHR0aHJlc2hvbGQ6IDEwLFxuLy9cdFx0cG9pbnRlcnM6IDEsXG4vL1x0XHRkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbi8vXHR9LFxuLy9cbi8vXHRnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4vL1x0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbi8vXHRcdHZhciBhY3Rpb25zID0gW107XG4vL1x0XHRpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbi8vXHRcdFx0YWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4vL1x0XHR9XG4vL1x0XHRpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4vL1x0XHRcdGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuLy9cdFx0fVxuLy9cdFx0cmV0dXJuIGFjdGlvbnM7XG4vL1x0fSxcbi8vXG4vL1x0ZGlyZWN0aW9uVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbi8vXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuLy9cdFx0dmFyIGhhc01vdmVkID0gdHJ1ZTtcbi8vXHRcdHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuLy9cdFx0dmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbi8vXHRcdHZhciB4ID0gaW5wdXQuZGVsdGFYO1xuLy9cdFx0dmFyIHkgPSBpbnB1dC5kZWx0YVk7XG4vL1xuLy9cdFx0Ly8gbG9jayB0byBheGlzP1xuLy9cdFx0aWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4vL1x0XHRcdGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4vL1x0XHRcdFx0ZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4vL1x0XHRcdFx0aGFzTW92ZWQgPSB4ICE9IHRoaXMucFg7XG4vL1x0XHRcdFx0ZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuLy9cdFx0XHR9IGVsc2Uge1xuLy9cdFx0XHRcdGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuLy9cdFx0XHRcdGhhc01vdmVkID0geSAhPSB0aGlzLnBZO1xuLy9cdFx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbi8vXHRcdFx0fVxuLy9cdFx0fVxuLy9cdFx0aW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuLy9cdFx0cmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4vL1x0fSxcbi8vXG4vL1x0YXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4vL1x0XHRyZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4vL1x0XHRcdCh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4vL1x0fSxcbi8vXG4vL1x0ZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbi8vXHRcdHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4vL1x0XHR0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuLy9cbi8vXHRcdHZhciBkaXJlY3Rpb24gPSBkaXJTdHIoaW5wdXQuZGlyZWN0aW9uKTtcbi8vXHRcdGlmIChkaXJlY3Rpb24pIHtcbi8vXHRcdFx0dGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4vL1x0XHR9XG4vL1xuLy9cdFx0dGhpcy5fc3VwZXIuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbi8vXHR9XG4vL30pO1xuXG4vKipcbiAqIFNtb290aFBhblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBIYW1tZXIuUGFuXG4gKi9cbmZ1bmN0aW9uIFNtb290aFBhbigpIHtcblx0dmFyIHJldCA9IEhhbW1lci5QYW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0dGhpcy50aHJlc2hvbGRPZmZzZXRYID0gbnVsbDtcblx0dGhpcy50aHJlc2hvbGRPZmZzZXRZID0gbnVsbDtcblx0dGhpcy50aHJlc2hvbGRPZmZzZXQgPSBudWxsO1xuXHRyZXR1cm4gcmV0O1xufVxuXG5IYW1tZXIuaW5oZXJpdChTbW9vdGhQYW4sIEhhbW1lci5QYW4sIHtcblx0ZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHQvLyBJbmhlcml0YW5jZSBicmVha3MsIHNvIHRoaXMgY29kZSBpcyB0YWtlbiBmcm9tIFBhblJlY29nbml6ZXIuZW1pdFxuXHRcdC8vXHR0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpOyAvLyBUcmlnZ2VycyBpbmZpbml0ZSByZWN1cnNpb25cblx0XHQvL1x0SGFtbWVyLlBhbi5wcm90b3R5cGUuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGlzIGJyZWFrcyB0b29cblxuXHRcdHZhciB0aHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMudGhyZXNob2xkO1xuXHRcdHZhciBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG5cblx0XHRpZiAodGhpcy5zdGF0ZSA9PSBIYW1tZXIuU1RBVEVfQkVHQU4pIHtcblx0XHRcdHRoaXMudGhyZXNob2xkT2Zmc2V0WCA9IChkaXJlY3Rpb24gJiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwpID8gKChkaXJlY3Rpb24gJiBIYW1tZXIuRElSRUNUSU9OX0xFRlQpID8gdGhyZXNob2xkIDogLXRocmVzaG9sZCkgOiAwO1xuXHRcdFx0dGhpcy50aHJlc2hvbGRPZmZzZXRZID0gKGRpcmVjdGlvbiAmIEhhbW1lci5ESVJFQ1RJT05fVkVSVElDQUwpID8gKChkaXJlY3Rpb24gJiBIYW1tZXIuRElSRUNUSU9OX1VQKSA/IHRocmVzaG9sZCA6IC10aHJlc2hvbGQpIDogMDtcblx0XHRcdC8vIHRoaXMudGhyZXNob2xkT2Zmc2V0ID0gKGRpcmVjdGlvbiAmIEhhbW1lci5ESVJFQ1RJT05fSE9SSVpPTlRBTCk/IGlucHV0LnRocmVzaG9sZE9mZnNldFggOiBpbnB1dC50aHJlc2hvbGRPZmZzZXRZO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJSRUNPR05JWkVSIFNUQVRFXCIsIGRpclN0cihkaXJlY3Rpb24pLCBzdGF0ZVN0cih0aGlzLnN0YXRlKSwgdGhpcy50aHJlc2hvbGRPZmZzZXRYKTtcblx0XHR9XG5cdFx0aW5wdXQudGhyZXNob2xkT2Zmc2V0WCA9IHRoaXMudGhyZXNob2xkT2Zmc2V0WDtcblx0XHRpbnB1dC50aHJlc2hvbGRPZmZzZXRZID0gdGhpcy50aHJlc2hvbGRPZmZzZXRZO1xuXHRcdGlucHV0LnRocmVzaG9sZERlbHRhWCA9IGlucHV0LmRlbHRhWCArIHRoaXMudGhyZXNob2xkT2Zmc2V0WDtcblx0XHRpbnB1dC50aHJlc2hvbGREZWx0YVkgPSBpbnB1dC5kZWx0YVkgKyB0aGlzLnRocmVzaG9sZE9mZnNldFk7XG5cblx0XHR0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuXHRcdHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cblx0XHRkaXJlY3Rpb24gPSBkaXJTdHIoZGlyZWN0aW9uKTtcblx0XHRpZiAoZGlyZWN0aW9uKSB7XG5cdFx0XHR0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcblx0XHR9XG5cdFx0cmV0dXJuIEhhbW1lci5SZWNvZ25pemVyLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNtb290aFBhbjtcbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJ2aWRlb19jcm9wX3B4XCI6IFwiMFwiLFxuXHRcInRyYW5zZm9ybV90eXBlXCI6IFwiM2RcIixcblx0XCJ0cmFuc2l0aW9uc1wiOiB7XG5cdFx0XCJlYXNlXCI6IFwiZWFzZS1pbi1vdXRcIixcblx0XHRcImR1cmF0aW9uX21zXCI6IFwiMzUwXCIsXG5cdFx0XCJkZWxheV9pbnRlcnZhbF9tc1wiOiBcIjM0XCIsXG5cdFx0XCJtaW5fZGVsYXlfbXNcIjogXCIzNFwiXG5cdH0sXG5cdFwiYnJlYWtwb2ludHNcIjoge1xuXHRcdFwibGFuZHNjYXBlXCI6IFwiJyhvcmllbnRhdGlvbjogbGFuZHNjYXBlKSdcIixcblx0XHRcInBvcnRyYWl0XCI6IFwiJyhvcmllbnRhdGlvbjogcG9ydHJhaXQpJ1wiLFxuXHRcdFwieHNtYWxsLXN0cmV0Y2hcIjogXCInbm90IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDYwcHgpLCBub3Qgc2NyZWVuIGFuZCAobWluLWhlaWdodDogNDIwcHgpJ1wiLFxuXHRcdFwic21hbGwtc3RyZXRjaFwiOiBcIidub3Qgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3MDRweCksIG5vdCBzY3JlZW4gYW5kIChtaW4taGVpZ2h0OiA1NDBweCknXCIsXG5cdFx0XCJkZWZhdWx0XCI6XCInb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDcwNHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDU0MHB4KSdcIixcblx0XHRcIm1lZGl1bS13aWRlXCI6IFwiJ29ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxMDI0cHgpIGFuZCAobWluLWhlaWdodDogNTQwcHgpJ1wiLFxuXHRcdFwibGFyZ2Utd2lkZVwiOiBcIidvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTIyNHB4KSBhbmQgKG1pbi1oZWlnaHQ6IDcwNHB4KSdcIixcblx0XHRcInhsYXJnZS13aWRlXCI6IFwiJ29ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxODI0cHgpIGFuZCAobWluLWhlaWdodDogMTAyNHB4KSdcIlxuXHR9LFxuXHRcImRlZmF1bHRfY29sb3JzXCI6IHtcblx0XHRcImNvbG9yXCI6IFwiaHNsKDQ3LCA1JSwgMTUlKVwiLFxuXHRcdFwiYmFja2dyb3VuZC1jb2xvclwiOiBcImhzbCg0NywgNSUsIDk1JSlcIixcblx0XHRcImxpbmstY29sb3JcIjogXCJoc2woMTAsIDgwJSwgNTAlKVwiXG5cdH0sXG5cdFwidGVtcFwiOiB7XG5cdFx0XCJjb2xsYXBzZV9vZmZzZXRcIjogXCIzNjBcIlxuXHR9LFxuXHRcIl9pZ25vcmVcIjoge1xuXHRcdFwidHJhbnNpdGlvbnNcIjoge1xuXHRcdFx0XCJlYXNlXCI6IFwiY3ViaWMtYmV6aWVyKDAuNDIsIDAuMCwgMC41OCwgMS4wKVwiLFxuXHRcdFx0XCJkdXJhdGlvbl9tc1wiOiBcIjQwMFwiLFxuXHRcdFx0XCJkZWxheV9pbnRlcnZhbF9tc1wiOiBcIjEzNFwiLFxuXHRcdFx0XCJtaW5fZGVsYXlfbXNcIjogXCIzNFwiXG5cdFx0fSxcblx0XHRcImRlZmF1bHRfY29sb3JzXCI6IHtcblx0XHRcdFwiLS1saW5rLWNvbG9yXCI6IFwiaHNsKDEwLCA4MCUsIDUwJSlcIixcblx0XHRcdFwiLS1hbHQtYmFja2dyb3VuZC1jb2xvclwiOiBcInVuc2V0XCJcblx0XHR9LFxuXHRcdFwidW5pdHNcIjoge1xuXHRcdFx0XCJodV9weFwiOiBcIjIwXCIsXG5cdFx0XHRcInZ1X3B4XCI6IFwiMTJcIlxuXHRcdH0sXG5cdFx0XCJicmVha3BvaW50c1wiOiB7XG5cdFx0XHRcIm1vYmlsZVwiOiBcIidub3Qgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3MDRweCksIG5vdCBzY3JlZW4gYW5kIChtaW4taGVpZ2h0OiA1NDBweCknXCIsXG5cdFx0XHRcInVuc3VwcG9ydGVkXCI6IFwiJ25vdCBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDcwNHB4KSdcIixcblx0XHRcdFwidW5xdW90ZWRcIjogXCJvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTgyNHB4KVwiLFxuXHRcdFx0XCJ1bnF1b3RlZF9uZWdcIjogXCJub3Qgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3MDRweClcIixcblx0XHRcdFwicXVvdGVkX2NvbWJpbmVkXCI6IFwiJ25vdCBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDcwNHB4KSwgbm90IHNjcmVlbiBhbmQgKG1pbi1oZWlnaHQ6IDU0MHB4KSdcIixcblx0XHRcdFwiYXJyYXlcIjogW1xuXHRcdFx0XHRcIm9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3MDRweClcIixcblx0XHRcdFx0XCJub3Qgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3MDRweClcIixcblx0XHRcdFx0XCJub3Qgc2NyZWVuIGFuZCAobWluLWhlaWdodDogNTQwcHgpXCJcblx0XHRcdF1cblx0XHR9XG5cdH1cbn1cbiJdfQ==
